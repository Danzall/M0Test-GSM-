
M0_Test.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000000c0  08009000  08009000  00009000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         0000c800  080090c0  080090c0  000090c0  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       000005b8  080158c0  080158c0  000158c0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  08015e78  08015e78  00020340  2**0
                  CONTENTS
  4 .ARM          00000000  08015e78  08015e78  00020340  2**0
                  CONTENTS
  5 .preinit_array 00000000  08015e78  08015e78  00020340  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  08015e78  08015e78  00015e78  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000004  08015e7c  08015e7c  00015e7c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         00000280  200000c0  08015e80  000200c0  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          0000343c  20000340  08016100  00020340  2**2
                  ALLOC
 10 ._user_heap_stack 00000604  2000377c  08016100  0002377c  2**0
                  ALLOC
 11 .ARM.attributes 00000028  00000000  00000000  00020340  2**0
                  CONTENTS, READONLY
 12 .debug_info   00024faa  00000000  00000000  00020368  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_abbrev 00005250  00000000  00000000  00045312  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_aranges 00001690  00000000  00000000  0004a568  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_ranges 000014b0  00000000  00000000  0004bbf8  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_macro  000068f8  00000000  00000000  0004d0a8  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_line   0001dbaf  00000000  00000000  000539a0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_str    000a19d5  00000000  00000000  0007154f  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .comment      00000053  00000000  00000000  00112f24  2**0
                  CONTENTS, READONLY
 20 .debug_frame  0000524c  00000000  00000000  00112f78  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

080090c0 <__do_global_dtors_aux>:
 80090c0:	b510      	push	{r4, lr}
 80090c2:	4c06      	ldr	r4, [pc, #24]	; (80090dc <__do_global_dtors_aux+0x1c>)
 80090c4:	7823      	ldrb	r3, [r4, #0]
 80090c6:	2b00      	cmp	r3, #0
 80090c8:	d107      	bne.n	80090da <__do_global_dtors_aux+0x1a>
 80090ca:	4b05      	ldr	r3, [pc, #20]	; (80090e0 <__do_global_dtors_aux+0x20>)
 80090cc:	2b00      	cmp	r3, #0
 80090ce:	d002      	beq.n	80090d6 <__do_global_dtors_aux+0x16>
 80090d0:	4804      	ldr	r0, [pc, #16]	; (80090e4 <__do_global_dtors_aux+0x24>)
 80090d2:	e000      	b.n	80090d6 <__do_global_dtors_aux+0x16>
 80090d4:	bf00      	nop
 80090d6:	2301      	movs	r3, #1
 80090d8:	7023      	strb	r3, [r4, #0]
 80090da:	bd10      	pop	{r4, pc}
 80090dc:	20000340 	.word	0x20000340
 80090e0:	00000000 	.word	0x00000000
 80090e4:	080158a8 	.word	0x080158a8

080090e8 <frame_dummy>:
 80090e8:	4b04      	ldr	r3, [pc, #16]	; (80090fc <frame_dummy+0x14>)
 80090ea:	b510      	push	{r4, lr}
 80090ec:	2b00      	cmp	r3, #0
 80090ee:	d003      	beq.n	80090f8 <frame_dummy+0x10>
 80090f0:	4903      	ldr	r1, [pc, #12]	; (8009100 <frame_dummy+0x18>)
 80090f2:	4804      	ldr	r0, [pc, #16]	; (8009104 <frame_dummy+0x1c>)
 80090f4:	e000      	b.n	80090f8 <frame_dummy+0x10>
 80090f6:	bf00      	nop
 80090f8:	bd10      	pop	{r4, pc}
 80090fa:	46c0      	nop			; (mov r8, r8)
 80090fc:	00000000 	.word	0x00000000
 8009100:	20000344 	.word	0x20000344
 8009104:	080158a8 	.word	0x080158a8

08009108 <strlen>:
 8009108:	2300      	movs	r3, #0
 800910a:	5cc2      	ldrb	r2, [r0, r3]
 800910c:	3301      	adds	r3, #1
 800910e:	2a00      	cmp	r2, #0
 8009110:	d1fb      	bne.n	800910a <strlen+0x2>
 8009112:	1e58      	subs	r0, r3, #1
 8009114:	4770      	bx	lr
	...

08009118 <__gnu_thumb1_case_shi>:
 8009118:	b403      	push	{r0, r1}
 800911a:	4671      	mov	r1, lr
 800911c:	0849      	lsrs	r1, r1, #1
 800911e:	0040      	lsls	r0, r0, #1
 8009120:	0049      	lsls	r1, r1, #1
 8009122:	5e09      	ldrsh	r1, [r1, r0]
 8009124:	0049      	lsls	r1, r1, #1
 8009126:	448e      	add	lr, r1
 8009128:	bc03      	pop	{r0, r1}
 800912a:	4770      	bx	lr

0800912c <__udivsi3>:
 800912c:	2200      	movs	r2, #0
 800912e:	0843      	lsrs	r3, r0, #1
 8009130:	428b      	cmp	r3, r1
 8009132:	d374      	bcc.n	800921e <__udivsi3+0xf2>
 8009134:	0903      	lsrs	r3, r0, #4
 8009136:	428b      	cmp	r3, r1
 8009138:	d35f      	bcc.n	80091fa <__udivsi3+0xce>
 800913a:	0a03      	lsrs	r3, r0, #8
 800913c:	428b      	cmp	r3, r1
 800913e:	d344      	bcc.n	80091ca <__udivsi3+0x9e>
 8009140:	0b03      	lsrs	r3, r0, #12
 8009142:	428b      	cmp	r3, r1
 8009144:	d328      	bcc.n	8009198 <__udivsi3+0x6c>
 8009146:	0c03      	lsrs	r3, r0, #16
 8009148:	428b      	cmp	r3, r1
 800914a:	d30d      	bcc.n	8009168 <__udivsi3+0x3c>
 800914c:	22ff      	movs	r2, #255	; 0xff
 800914e:	0209      	lsls	r1, r1, #8
 8009150:	ba12      	rev	r2, r2
 8009152:	0c03      	lsrs	r3, r0, #16
 8009154:	428b      	cmp	r3, r1
 8009156:	d302      	bcc.n	800915e <__udivsi3+0x32>
 8009158:	1212      	asrs	r2, r2, #8
 800915a:	0209      	lsls	r1, r1, #8
 800915c:	d065      	beq.n	800922a <__udivsi3+0xfe>
 800915e:	0b03      	lsrs	r3, r0, #12
 8009160:	428b      	cmp	r3, r1
 8009162:	d319      	bcc.n	8009198 <__udivsi3+0x6c>
 8009164:	e000      	b.n	8009168 <__udivsi3+0x3c>
 8009166:	0a09      	lsrs	r1, r1, #8
 8009168:	0bc3      	lsrs	r3, r0, #15
 800916a:	428b      	cmp	r3, r1
 800916c:	d301      	bcc.n	8009172 <__udivsi3+0x46>
 800916e:	03cb      	lsls	r3, r1, #15
 8009170:	1ac0      	subs	r0, r0, r3
 8009172:	4152      	adcs	r2, r2
 8009174:	0b83      	lsrs	r3, r0, #14
 8009176:	428b      	cmp	r3, r1
 8009178:	d301      	bcc.n	800917e <__udivsi3+0x52>
 800917a:	038b      	lsls	r3, r1, #14
 800917c:	1ac0      	subs	r0, r0, r3
 800917e:	4152      	adcs	r2, r2
 8009180:	0b43      	lsrs	r3, r0, #13
 8009182:	428b      	cmp	r3, r1
 8009184:	d301      	bcc.n	800918a <__udivsi3+0x5e>
 8009186:	034b      	lsls	r3, r1, #13
 8009188:	1ac0      	subs	r0, r0, r3
 800918a:	4152      	adcs	r2, r2
 800918c:	0b03      	lsrs	r3, r0, #12
 800918e:	428b      	cmp	r3, r1
 8009190:	d301      	bcc.n	8009196 <__udivsi3+0x6a>
 8009192:	030b      	lsls	r3, r1, #12
 8009194:	1ac0      	subs	r0, r0, r3
 8009196:	4152      	adcs	r2, r2
 8009198:	0ac3      	lsrs	r3, r0, #11
 800919a:	428b      	cmp	r3, r1
 800919c:	d301      	bcc.n	80091a2 <__udivsi3+0x76>
 800919e:	02cb      	lsls	r3, r1, #11
 80091a0:	1ac0      	subs	r0, r0, r3
 80091a2:	4152      	adcs	r2, r2
 80091a4:	0a83      	lsrs	r3, r0, #10
 80091a6:	428b      	cmp	r3, r1
 80091a8:	d301      	bcc.n	80091ae <__udivsi3+0x82>
 80091aa:	028b      	lsls	r3, r1, #10
 80091ac:	1ac0      	subs	r0, r0, r3
 80091ae:	4152      	adcs	r2, r2
 80091b0:	0a43      	lsrs	r3, r0, #9
 80091b2:	428b      	cmp	r3, r1
 80091b4:	d301      	bcc.n	80091ba <__udivsi3+0x8e>
 80091b6:	024b      	lsls	r3, r1, #9
 80091b8:	1ac0      	subs	r0, r0, r3
 80091ba:	4152      	adcs	r2, r2
 80091bc:	0a03      	lsrs	r3, r0, #8
 80091be:	428b      	cmp	r3, r1
 80091c0:	d301      	bcc.n	80091c6 <__udivsi3+0x9a>
 80091c2:	020b      	lsls	r3, r1, #8
 80091c4:	1ac0      	subs	r0, r0, r3
 80091c6:	4152      	adcs	r2, r2
 80091c8:	d2cd      	bcs.n	8009166 <__udivsi3+0x3a>
 80091ca:	09c3      	lsrs	r3, r0, #7
 80091cc:	428b      	cmp	r3, r1
 80091ce:	d301      	bcc.n	80091d4 <__udivsi3+0xa8>
 80091d0:	01cb      	lsls	r3, r1, #7
 80091d2:	1ac0      	subs	r0, r0, r3
 80091d4:	4152      	adcs	r2, r2
 80091d6:	0983      	lsrs	r3, r0, #6
 80091d8:	428b      	cmp	r3, r1
 80091da:	d301      	bcc.n	80091e0 <__udivsi3+0xb4>
 80091dc:	018b      	lsls	r3, r1, #6
 80091de:	1ac0      	subs	r0, r0, r3
 80091e0:	4152      	adcs	r2, r2
 80091e2:	0943      	lsrs	r3, r0, #5
 80091e4:	428b      	cmp	r3, r1
 80091e6:	d301      	bcc.n	80091ec <__udivsi3+0xc0>
 80091e8:	014b      	lsls	r3, r1, #5
 80091ea:	1ac0      	subs	r0, r0, r3
 80091ec:	4152      	adcs	r2, r2
 80091ee:	0903      	lsrs	r3, r0, #4
 80091f0:	428b      	cmp	r3, r1
 80091f2:	d301      	bcc.n	80091f8 <__udivsi3+0xcc>
 80091f4:	010b      	lsls	r3, r1, #4
 80091f6:	1ac0      	subs	r0, r0, r3
 80091f8:	4152      	adcs	r2, r2
 80091fa:	08c3      	lsrs	r3, r0, #3
 80091fc:	428b      	cmp	r3, r1
 80091fe:	d301      	bcc.n	8009204 <__udivsi3+0xd8>
 8009200:	00cb      	lsls	r3, r1, #3
 8009202:	1ac0      	subs	r0, r0, r3
 8009204:	4152      	adcs	r2, r2
 8009206:	0883      	lsrs	r3, r0, #2
 8009208:	428b      	cmp	r3, r1
 800920a:	d301      	bcc.n	8009210 <__udivsi3+0xe4>
 800920c:	008b      	lsls	r3, r1, #2
 800920e:	1ac0      	subs	r0, r0, r3
 8009210:	4152      	adcs	r2, r2
 8009212:	0843      	lsrs	r3, r0, #1
 8009214:	428b      	cmp	r3, r1
 8009216:	d301      	bcc.n	800921c <__udivsi3+0xf0>
 8009218:	004b      	lsls	r3, r1, #1
 800921a:	1ac0      	subs	r0, r0, r3
 800921c:	4152      	adcs	r2, r2
 800921e:	1a41      	subs	r1, r0, r1
 8009220:	d200      	bcs.n	8009224 <__udivsi3+0xf8>
 8009222:	4601      	mov	r1, r0
 8009224:	4152      	adcs	r2, r2
 8009226:	4610      	mov	r0, r2
 8009228:	4770      	bx	lr
 800922a:	e7ff      	b.n	800922c <__udivsi3+0x100>
 800922c:	b501      	push	{r0, lr}
 800922e:	2000      	movs	r0, #0
 8009230:	f000 f806 	bl	8009240 <__aeabi_idiv0>
 8009234:	bd02      	pop	{r1, pc}
 8009236:	46c0      	nop			; (mov r8, r8)

08009238 <__aeabi_uidivmod>:
 8009238:	2900      	cmp	r1, #0
 800923a:	d0f7      	beq.n	800922c <__udivsi3+0x100>
 800923c:	e776      	b.n	800912c <__udivsi3>
 800923e:	4770      	bx	lr

08009240 <__aeabi_idiv0>:
 8009240:	4770      	bx	lr
 8009242:	46c0      	nop			; (mov r8, r8)

08009244 <GSM_Send_Bin>:
	HAL_UART_Receive_IT(&huart2, (uint8_t *) dummy, 50);
	gsmTimeout = 0;
	gsmSend = 1;
}

void GSM_Send_Bin(char* data, int size){
 8009244:	b580      	push	{r7, lr}
 8009246:	b084      	sub	sp, #16
 8009248:	af00      	add	r7, sp, #0
 800924a:	6078      	str	r0, [r7, #4]
 800924c:	6039      	str	r1, [r7, #0]
	//int size;
	int timeout = 5;
 800924e:	2305      	movs	r3, #5
 8009250:	60fb      	str	r3, [r7, #12]
	//size = strlen(data);
	//HAL_UART_Transmit(&huart2, (uint8_t*)data, size, timeout);

	HAL_UART_Transmit_IT(&huart2, data, size);
 8009252:	683b      	ldr	r3, [r7, #0]
 8009254:	b29a      	uxth	r2, r3
 8009256:	6879      	ldr	r1, [r7, #4]
 8009258:	4b09      	ldr	r3, [pc, #36]	; (8009280 <GSM_Send_Bin+0x3c>)
 800925a:	0018      	movs	r0, r3
 800925c:	f005 f8ee 	bl	800e43c <HAL_UART_Transmit_IT>
	HAL_UART_Receive_IT(&huart2, (uint8_t *) dummy, 50);
 8009260:	4908      	ldr	r1, [pc, #32]	; (8009284 <GSM_Send_Bin+0x40>)
 8009262:	4b07      	ldr	r3, [pc, #28]	; (8009280 <GSM_Send_Bin+0x3c>)
 8009264:	2232      	movs	r2, #50	; 0x32
 8009266:	0018      	movs	r0, r3
 8009268:	f005 f968 	bl	800e53c <HAL_UART_Receive_IT>
	gsmTimeout = 0;
 800926c:	4b06      	ldr	r3, [pc, #24]	; (8009288 <GSM_Send_Bin+0x44>)
 800926e:	2200      	movs	r2, #0
 8009270:	601a      	str	r2, [r3, #0]
	gsmSend = 1;
 8009272:	4b06      	ldr	r3, [pc, #24]	; (800928c <GSM_Send_Bin+0x48>)
 8009274:	2201      	movs	r2, #1
 8009276:	601a      	str	r2, [r3, #0]
}
 8009278:	46c0      	nop			; (mov r8, r8)
 800927a:	46bd      	mov	sp, r7
 800927c:	b004      	add	sp, #16
 800927e:	bd80      	pop	{r7, pc}
 8009280:	2000275c 	.word	0x2000275c
 8009284:	20001cb0 	.word	0x20001cb0
 8009288:	20000360 	.word	0x20000360
 800928c:	20000364 	.word	0x20000364

08009290 <Debug_Send>:

void Debug_Send(char* data){
 8009290:	b580      	push	{r7, lr}
 8009292:	b084      	sub	sp, #16
 8009294:	af00      	add	r7, sp, #0
 8009296:	6078      	str	r0, [r7, #4]
	int size;
	int timeout = 25;
 8009298:	2319      	movs	r3, #25
 800929a:	60fb      	str	r3, [r7, #12]
	size = strlen(data);
 800929c:	687b      	ldr	r3, [r7, #4]
 800929e:	0018      	movs	r0, r3
 80092a0:	f7ff ff32 	bl	8009108 <strlen>
 80092a4:	0003      	movs	r3, r0
 80092a6:	60bb      	str	r3, [r7, #8]
	HAL_UART_Transmit(&huart1, (uint8_t*)data, size, timeout);
 80092a8:	68bb      	ldr	r3, [r7, #8]
 80092aa:	b29a      	uxth	r2, r3
 80092ac:	68fb      	ldr	r3, [r7, #12]
 80092ae:	6879      	ldr	r1, [r7, #4]
 80092b0:	4803      	ldr	r0, [pc, #12]	; (80092c0 <Debug_Send+0x30>)
 80092b2:	f005 f819 	bl	800e2e8 <HAL_UART_Transmit>
	//HAL_UART_Transmit_IT(&huart1, data, size);
}
 80092b6:	46c0      	nop			; (mov r8, r8)
 80092b8:	46bd      	mov	sp, r7
 80092ba:	b004      	add	sp, #16
 80092bc:	bd80      	pop	{r7, pc}
 80092be:	46c0      	nop			; (mov r8, r8)
 80092c0:	200026d4 	.word	0x200026d4

080092c4 <GSM_Receive>:
	 //sendData(testS,UART0);
	return count;
}


void GSM_Receive(char in){
 80092c4:	b580      	push	{r7, lr}
 80092c6:	b082      	sub	sp, #8
 80092c8:	af00      	add	r7, sp, #0
 80092ca:	0002      	movs	r2, r0
 80092cc:	1dfb      	adds	r3, r7, #7
 80092ce:	701a      	strb	r2, [r3, #0]
	HAL_GPIO_TogglePin(LED1_GPIO_Port, LED1_Pin);
 80092d0:	2380      	movs	r3, #128	; 0x80
 80092d2:	01db      	lsls	r3, r3, #7
 80092d4:	4a20      	ldr	r2, [pc, #128]	; (8009358 <GSM_Receive+0x94>)
 80092d6:	0019      	movs	r1, r3
 80092d8:	0010      	movs	r0, r2
 80092da:	f002 fa6e 	bl	800b7ba <HAL_GPIO_TogglePin>
	gsmInfo.Timeout = 0;
 80092de:	4a1f      	ldr	r2, [pc, #124]	; (800935c <GSM_Receive+0x98>)
 80092e0:	23b0      	movs	r3, #176	; 0xb0
 80092e2:	005b      	lsls	r3, r3, #1
 80092e4:	2100      	movs	r1, #0
 80092e6:	50d1      	str	r1, [r2, r3]
	//HAL_UART_Receive_IT(&huart2, temp, 50);

	if (ftpinc < 60){
 80092e8:	4b1d      	ldr	r3, [pc, #116]	; (8009360 <GSM_Receive+0x9c>)
 80092ea:	681b      	ldr	r3, [r3, #0]
 80092ec:	2b3b      	cmp	r3, #59	; 0x3b
 80092ee:	dc11      	bgt.n	8009314 <GSM_Receive+0x50>
	//if (gsmInfo.FTP_Data > 0){
		ftpReceived[ftpinc] = in;
 80092f0:	4b1b      	ldr	r3, [pc, #108]	; (8009360 <GSM_Receive+0x9c>)
 80092f2:	681b      	ldr	r3, [r3, #0]
 80092f4:	4a1b      	ldr	r2, [pc, #108]	; (8009364 <GSM_Receive+0xa0>)
 80092f6:	1df9      	adds	r1, r7, #7
 80092f8:	7809      	ldrb	r1, [r1, #0]
 80092fa:	54d1      	strb	r1, [r2, r3]
		//HAL_UART_Transmit(&huart1, ftpReceived[ftpinc], 1, 10);
		ftpinc++;
 80092fc:	4b18      	ldr	r3, [pc, #96]	; (8009360 <GSM_Receive+0x9c>)
 80092fe:	681b      	ldr	r3, [r3, #0]
 8009300:	1c5a      	adds	r2, r3, #1
 8009302:	4b17      	ldr	r3, [pc, #92]	; (8009360 <GSM_Receive+0x9c>)
 8009304:	601a      	str	r2, [r3, #0]
		HAL_GPIO_TogglePin(LED4_GPIO_Port, LED4_Pin);
 8009306:	2380      	movs	r3, #128	; 0x80
 8009308:	005b      	lsls	r3, r3, #1
 800930a:	4a17      	ldr	r2, [pc, #92]	; (8009368 <GSM_Receive+0xa4>)
 800930c:	0019      	movs	r1, r3
 800930e:	0010      	movs	r0, r2
 8009310:	f002 fa53 	bl	800b7ba <HAL_GPIO_TogglePin>
	}
	//else{
		if (in == '>') gsmInfo.Prompt = 1;
 8009314:	1dfb      	adds	r3, r7, #7
 8009316:	781b      	ldrb	r3, [r3, #0]
 8009318:	2b3e      	cmp	r3, #62	; 0x3e
 800931a:	d104      	bne.n	8009326 <GSM_Receive+0x62>
 800931c:	4a0f      	ldr	r2, [pc, #60]	; (800935c <GSM_Receive+0x98>)
 800931e:	23ae      	movs	r3, #174	; 0xae
 8009320:	005b      	lsls	r3, r3, #1
 8009322:	2101      	movs	r1, #1
 8009324:	50d1      	str	r1, [r2, r3]
		//if (in != 0x0A){
			recBuffDebug[recBuffPointerWrite] = in;
 8009326:	4b11      	ldr	r3, [pc, #68]	; (800936c <GSM_Receive+0xa8>)
 8009328:	681b      	ldr	r3, [r3, #0]
 800932a:	4a11      	ldr	r2, [pc, #68]	; (8009370 <GSM_Receive+0xac>)
 800932c:	1df9      	adds	r1, r7, #7
 800932e:	7809      	ldrb	r1, [r1, #0]
 8009330:	54d1      	strb	r1, [r2, r3]
			//HAL_UART_Transmit(&huart1, recBuff[recBuffPointerWrite], 2, 10);
			//huart1.Instance->TDR = in;
			recBuffPointerWrite++;
 8009332:	4b0e      	ldr	r3, [pc, #56]	; (800936c <GSM_Receive+0xa8>)
 8009334:	681b      	ldr	r3, [r3, #0]
 8009336:	1c5a      	adds	r2, r3, #1
 8009338:	4b0c      	ldr	r3, [pc, #48]	; (800936c <GSM_Receive+0xa8>)
 800933a:	601a      	str	r2, [r3, #0]
			if (recBuffPointerWrite > recBuffSize) recBuffPointerWrite = 0;
 800933c:	4b0b      	ldr	r3, [pc, #44]	; (800936c <GSM_Receive+0xa8>)
 800933e:	681a      	ldr	r2, [r3, #0]
 8009340:	2396      	movs	r3, #150	; 0x96
 8009342:	005b      	lsls	r3, r3, #1
 8009344:	429a      	cmp	r2, r3
 8009346:	dd02      	ble.n	800934e <GSM_Receive+0x8a>
 8009348:	4b08      	ldr	r3, [pc, #32]	; (800936c <GSM_Receive+0xa8>)
 800934a:	2200      	movs	r2, #0
 800934c:	601a      	str	r2, [r3, #0]
		//}
	//}

}
 800934e:	46c0      	nop			; (mov r8, r8)
 8009350:	46bd      	mov	sp, r7
 8009352:	b002      	add	sp, #8
 8009354:	bd80      	pop	{r7, pc}
 8009356:	46c0      	nop			; (mov r8, r8)
 8009358:	48000800 	.word	0x48000800
 800935c:	20001b24 	.word	0x20001b24
 8009360:	200000c0 	.word	0x200000c0
 8009364:	20001ce4 	.word	0x20001ce4
 8009368:	48000400 	.word	0x48000400
 800936c:	2000035c 	.word	0x2000035c
 8009370:	2000156c 	.word	0x2000156c

08009374 <Wifi_Init>:
uint8_t temp1[300];
uint8_t ConnID[4];
uint8_t mqttReceived[30];


void Wifi_Init(){
 8009374:	b580      	push	{r7, lr}
 8009376:	af00      	add	r7, sp, #0
	HAL_GPIO_WritePin(GPIOB, LED3_Pin, GPIO_PIN_RESET);
 8009378:	2380      	movs	r3, #128	; 0x80
 800937a:	009b      	lsls	r3, r3, #2
 800937c:	481e      	ldr	r0, [pc, #120]	; (80093f8 <Wifi_Init+0x84>)
 800937e:	2200      	movs	r2, #0
 8009380:	0019      	movs	r1, r3
 8009382:	f002 f9fd 	bl	800b780 <HAL_GPIO_WritePin>
	HAL_GPIO_WritePin(LED5_GPIO_Port, LED5_Pin, GPIO_PIN_SET);
 8009386:	4b1c      	ldr	r3, [pc, #112]	; (80093f8 <Wifi_Init+0x84>)
 8009388:	2201      	movs	r2, #1
 800938a:	2108      	movs	r1, #8
 800938c:	0018      	movs	r0, r3
 800938e:	f002 f9f7 	bl	800b780 <HAL_GPIO_WritePin>
	Debug_Send("Wifi init\r\n");
 8009392:	4b1a      	ldr	r3, [pc, #104]	; (80093fc <Wifi_Init+0x88>)
 8009394:	0018      	movs	r0, r3
 8009396:	f7ff ff7b 	bl	8009290 <Debug_Send>
	HAL_UART_Receive_IT(&huart2, (uint8_t *) dummy, 40);
 800939a:	4919      	ldr	r1, [pc, #100]	; (8009400 <Wifi_Init+0x8c>)
 800939c:	4b19      	ldr	r3, [pc, #100]	; (8009404 <Wifi_Init+0x90>)
 800939e:	2228      	movs	r2, #40	; 0x28
 80093a0:	0018      	movs	r0, r3
 80093a2:	f005 f8cb 	bl	800e53c <HAL_UART_Receive_IT>
	//HAL_UART_Receive_IT(&huart1, (uint8_t *) dummy, 40);
	//__HAL_UART_ENABLE_IT(&huart3, UART_IT_RXNE);

	//HAL_UART_Receive(&huart3, dummy, 50, 5);
	//strcpy(quality,"N/A");
	HAL_Delay(2000);
 80093a6:	23fa      	movs	r3, #250	; 0xfa
 80093a8:	00db      	lsls	r3, r3, #3
 80093aa:	0018      	movs	r0, r3
 80093ac:	f001 fef0 	bl	800b190 <HAL_Delay>
	wifiFlag.connect = 0;
 80093b0:	4b15      	ldr	r3, [pc, #84]	; (8009408 <Wifi_Init+0x94>)
 80093b2:	2200      	movs	r2, #0
 80093b4:	701a      	strb	r2, [r3, #0]
	wifiFlag.list = 0;
 80093b6:	4b14      	ldr	r3, [pc, #80]	; (8009408 <Wifi_Init+0x94>)
 80093b8:	2200      	movs	r2, #0
 80093ba:	705a      	strb	r2, [r3, #1]
	wifiFlag.ip = 0;
 80093bc:	4b12      	ldr	r3, [pc, #72]	; (8009408 <Wifi_Init+0x94>)
 80093be:	2200      	movs	r2, #0
 80093c0:	709a      	strb	r2, [r3, #2]
	wifiFlag.print = 1;
 80093c2:	4b11      	ldr	r3, [pc, #68]	; (8009408 <Wifi_Init+0x94>)
 80093c4:	2201      	movs	r2, #1
 80093c6:	70da      	strb	r2, [r3, #3]
	wifiFlag.server = 0;
 80093c8:	4b0f      	ldr	r3, [pc, #60]	; (8009408 <Wifi_Init+0x94>)
 80093ca:	2200      	movs	r2, #0
 80093cc:	711a      	strb	r2, [r3, #4]
	//WifiState = GetIP;
	Debug_Send("Done\r\n");
 80093ce:	4b0f      	ldr	r3, [pc, #60]	; (800940c <Wifi_Init+0x98>)
 80093d0:	0018      	movs	r0, r3
 80093d2:	f7ff ff5d 	bl	8009290 <Debug_Send>
	HAL_GPIO_WritePin(GPIOB, LED3_Pin, GPIO_PIN_SET);
 80093d6:	2380      	movs	r3, #128	; 0x80
 80093d8:	009b      	lsls	r3, r3, #2
 80093da:	4807      	ldr	r0, [pc, #28]	; (80093f8 <Wifi_Init+0x84>)
 80093dc:	2201      	movs	r2, #1
 80093de:	0019      	movs	r1, r3
 80093e0:	f002 f9ce 	bl	800b780 <HAL_GPIO_WritePin>
	//HAL_Delay(4000);
	//WifiState = CPMUX;
	mqttFlag.active = 1;
 80093e4:	4b0a      	ldr	r3, [pc, #40]	; (8009410 <Wifi_Init+0x9c>)
 80093e6:	2201      	movs	r2, #1
 80093e8:	709a      	strb	r2, [r3, #2]
	mqttInfo.timer = 0;
 80093ea:	4b0a      	ldr	r3, [pc, #40]	; (8009414 <Wifi_Init+0xa0>)
 80093ec:	2200      	movs	r2, #0
 80093ee:	661a      	str	r2, [r3, #96]	; 0x60
}
 80093f0:	46c0      	nop			; (mov r8, r8)
 80093f2:	46bd      	mov	sp, r7
 80093f4:	bd80      	pop	{r7, pc}
 80093f6:	46c0      	nop			; (mov r8, r8)
 80093f8:	48000400 	.word	0x48000400
 80093fc:	080158c0 	.word	0x080158c0
 8009400:	20001cb0 	.word	0x20001cb0
 8009404:	2000275c 	.word	0x2000275c
 8009408:	20002660 	.word	0x20002660
 800940c:	080158cc 	.word	0x080158cc
 8009410:	20001b1c 	.word	0x20001b1c
 8009414:	20001698 	.word	0x20001698

08009418 <Wifi_Service>:

void Wifi_Service(){
 8009418:	b580      	push	{r7, lr}
 800941a:	af00      	add	r7, sp, #0
	//Wifi_Send("AT\r\n");
	//sprintf(temp, "Wifi service state-%i\r\n", WifiState);
	//GSM_Send(temp);
	//GSM_Send("Wifi service\r\n");
	switch(WifiState){
 800941c:	4bd2      	ldr	r3, [pc, #840]	; (8009768 <Wifi_Service+0x350>)
 800941e:	781b      	ldrb	r3, [r3, #0]
 8009420:	2b11      	cmp	r3, #17
 8009422:	d900      	bls.n	8009426 <Wifi_Service+0xe>
 8009424:	e205      	b.n	8009832 <Wifi_Service+0x41a>
 8009426:	009a      	lsls	r2, r3, #2
 8009428:	4bd0      	ldr	r3, [pc, #832]	; (800976c <Wifi_Service+0x354>)
 800942a:	18d3      	adds	r3, r2, r3
 800942c:	681b      	ldr	r3, [r3, #0]
 800942e:	469f      	mov	pc, r3
	case Wifi_ver:
		Wifi_Send("AT+GMR\r\n");
 8009430:	4bcf      	ldr	r3, [pc, #828]	; (8009770 <Wifi_Service+0x358>)
 8009432:	0018      	movs	r0, r3
 8009434:	f000 fa20 	bl	8009878 <Wifi_Send>
		WifiState = Wifi_AT;
 8009438:	4bcb      	ldr	r3, [pc, #812]	; (8009768 <Wifi_Service+0x350>)
 800943a:	2202      	movs	r2, #2
 800943c:	701a      	strb	r2, [r3, #0]
		WifiState = 0;
 800943e:	4bca      	ldr	r3, [pc, #808]	; (8009768 <Wifi_Service+0x350>)
 8009440:	2200      	movs	r2, #0
 8009442:	701a      	strb	r2, [r3, #0]
		break;
 8009444:	e1f5      	b.n	8009832 <Wifi_Service+0x41a>
	case Wifi_AT:
		Wifi_Send("AT\r\n");
 8009446:	4bcb      	ldr	r3, [pc, #812]	; (8009774 <Wifi_Service+0x35c>)
 8009448:	0018      	movs	r0, r3
 800944a:	f000 fa15 	bl	8009878 <Wifi_Send>
		WifiState = ListAP;
 800944e:	4bc6      	ldr	r3, [pc, #792]	; (8009768 <Wifi_Service+0x350>)
 8009450:	2203      	movs	r2, #3
 8009452:	701a      	strb	r2, [r3, #0]
		WifiState = CheckConnect;
 8009454:	4bc4      	ldr	r3, [pc, #784]	; (8009768 <Wifi_Service+0x350>)
 8009456:	2205      	movs	r2, #5
 8009458:	701a      	strb	r2, [r3, #0]
		WifiState = Mode;
 800945a:	4bc3      	ldr	r3, [pc, #780]	; (8009768 <Wifi_Service+0x350>)
 800945c:	220a      	movs	r2, #10
 800945e:	701a      	strb	r2, [r3, #0]
		WifiState = 0;
 8009460:	4bc1      	ldr	r3, [pc, #772]	; (8009768 <Wifi_Service+0x350>)
 8009462:	2200      	movs	r2, #0
 8009464:	701a      	strb	r2, [r3, #0]
		break;
 8009466:	e1e4      	b.n	8009832 <Wifi_Service+0x41a>
	case Mode:
		Wifi_Send("AT+CWMODE=1\r\n");
 8009468:	4bc3      	ldr	r3, [pc, #780]	; (8009778 <Wifi_Service+0x360>)
 800946a:	0018      	movs	r0, r3
 800946c:	f000 fa04 	bl	8009878 <Wifi_Send>
		WifiState = CheckConnect;
 8009470:	4bbd      	ldr	r3, [pc, #756]	; (8009768 <Wifi_Service+0x350>)
 8009472:	2205      	movs	r2, #5
 8009474:	701a      	strb	r2, [r3, #0]
		break;
 8009476:	e1dc      	b.n	8009832 <Wifi_Service+0x41a>
	case ListAP:
		Wifi_Send("AT+CWLAP\r\n");
 8009478:	4bc0      	ldr	r3, [pc, #768]	; (800977c <Wifi_Service+0x364>)
 800947a:	0018      	movs	r0, r3
 800947c:	f000 f9fc 	bl	8009878 <Wifi_Send>
		//WifiState = GetIP;
		wifiFlag.list = 1;
 8009480:	4bbf      	ldr	r3, [pc, #764]	; (8009780 <Wifi_Service+0x368>)
 8009482:	2201      	movs	r2, #1
 8009484:	705a      	strb	r2, [r3, #1]

		break;
 8009486:	e1d4      	b.n	8009832 <Wifi_Service+0x41a>
	case GetIP:
		Wifi_Send("AT+CIFSR\r\n");
 8009488:	4bbe      	ldr	r3, [pc, #760]	; (8009784 <Wifi_Service+0x36c>)
 800948a:	0018      	movs	r0, r3
 800948c:	f000 f9f4 	bl	8009878 <Wifi_Send>
		//WifiState = AT;
		//WifiState = ListAP;
		wifiFlag.print = 0;
 8009490:	4bbb      	ldr	r3, [pc, #748]	; (8009780 <Wifi_Service+0x368>)
 8009492:	2200      	movs	r2, #0
 8009494:	70da      	strb	r2, [r3, #3]
		//WifiState = CPMUX;
		WifiState = 0;
 8009496:	4bb4      	ldr	r3, [pc, #720]	; (8009768 <Wifi_Service+0x350>)
 8009498:	2200      	movs	r2, #0
 800949a:	701a      	strb	r2, [r3, #0]
		break;
 800949c:	e1c9      	b.n	8009832 <Wifi_Service+0x41a>
	case CheckConnect:
		Wifi_Send("AT+CWJAP?\r\n");
 800949e:	4bba      	ldr	r3, [pc, #744]	; (8009788 <Wifi_Service+0x370>)
 80094a0:	0018      	movs	r0, r3
 80094a2:	f000 f9e9 	bl	8009878 <Wifi_Send>
		WifiState = 0;
 80094a6:	4bb0      	ldr	r3, [pc, #704]	; (8009768 <Wifi_Service+0x350>)
 80094a8:	2200      	movs	r2, #0
 80094aa:	701a      	strb	r2, [r3, #0]
		//WifiState = ListAP;
		break;
 80094ac:	e1c1      	b.n	8009832 <Wifi_Service+0x41a>

	case WifiConnect:
		strcpy(temp,"AT+CWJAP=");
 80094ae:	4ab7      	ldr	r2, [pc, #732]	; (800978c <Wifi_Service+0x374>)
 80094b0:	4bb7      	ldr	r3, [pc, #732]	; (8009790 <Wifi_Service+0x378>)
 80094b2:	0010      	movs	r0, r2
 80094b4:	0019      	movs	r1, r3
 80094b6:	230a      	movs	r3, #10
 80094b8:	001a      	movs	r2, r3
 80094ba:	f00b fda1 	bl	8015000 <memcpy>
		strcat(temp,"\"");
 80094be:	4bb3      	ldr	r3, [pc, #716]	; (800978c <Wifi_Service+0x374>)
 80094c0:	0018      	movs	r0, r3
 80094c2:	f7ff fe21 	bl	8009108 <strlen>
 80094c6:	0003      	movs	r3, r0
 80094c8:	001a      	movs	r2, r3
 80094ca:	4bb0      	ldr	r3, [pc, #704]	; (800978c <Wifi_Service+0x374>)
 80094cc:	18d2      	adds	r2, r2, r3
 80094ce:	4bb1      	ldr	r3, [pc, #708]	; (8009794 <Wifi_Service+0x37c>)
 80094d0:	0010      	movs	r0, r2
 80094d2:	0019      	movs	r1, r3
 80094d4:	2302      	movs	r3, #2
 80094d6:	001a      	movs	r2, r3
 80094d8:	f00b fd92 	bl	8015000 <memcpy>
		strcat(temp,ssid);
 80094dc:	4aae      	ldr	r2, [pc, #696]	; (8009798 <Wifi_Service+0x380>)
 80094de:	4bab      	ldr	r3, [pc, #684]	; (800978c <Wifi_Service+0x374>)
 80094e0:	0011      	movs	r1, r2
 80094e2:	0018      	movs	r0, r3
 80094e4:	f00b fdbe 	bl	8015064 <strcat>
		strcat(temp,"\",\"");
 80094e8:	4ba8      	ldr	r3, [pc, #672]	; (800978c <Wifi_Service+0x374>)
 80094ea:	0018      	movs	r0, r3
 80094ec:	f7ff fe0c 	bl	8009108 <strlen>
 80094f0:	0003      	movs	r3, r0
 80094f2:	001a      	movs	r2, r3
 80094f4:	4ba5      	ldr	r3, [pc, #660]	; (800978c <Wifi_Service+0x374>)
 80094f6:	18d2      	adds	r2, r2, r3
 80094f8:	4ba8      	ldr	r3, [pc, #672]	; (800979c <Wifi_Service+0x384>)
 80094fa:	0010      	movs	r0, r2
 80094fc:	0019      	movs	r1, r3
 80094fe:	2304      	movs	r3, #4
 8009500:	001a      	movs	r2, r3
 8009502:	f00b fd7d 	bl	8015000 <memcpy>
		strcat(temp,passwrd);
 8009506:	4aa6      	ldr	r2, [pc, #664]	; (80097a0 <Wifi_Service+0x388>)
 8009508:	4ba0      	ldr	r3, [pc, #640]	; (800978c <Wifi_Service+0x374>)
 800950a:	0011      	movs	r1, r2
 800950c:	0018      	movs	r0, r3
 800950e:	f00b fda9 	bl	8015064 <strcat>
		strcat(temp,"\"");
 8009512:	4b9e      	ldr	r3, [pc, #632]	; (800978c <Wifi_Service+0x374>)
 8009514:	0018      	movs	r0, r3
 8009516:	f7ff fdf7 	bl	8009108 <strlen>
 800951a:	0003      	movs	r3, r0
 800951c:	001a      	movs	r2, r3
 800951e:	4b9b      	ldr	r3, [pc, #620]	; (800978c <Wifi_Service+0x374>)
 8009520:	18d2      	adds	r2, r2, r3
 8009522:	4b9c      	ldr	r3, [pc, #624]	; (8009794 <Wifi_Service+0x37c>)
 8009524:	0010      	movs	r0, r2
 8009526:	0019      	movs	r1, r3
 8009528:	2302      	movs	r3, #2
 800952a:	001a      	movs	r2, r3
 800952c:	f00b fd68 	bl	8015000 <memcpy>
		strcat(temp,"\r\n");
 8009530:	4b96      	ldr	r3, [pc, #600]	; (800978c <Wifi_Service+0x374>)
 8009532:	0018      	movs	r0, r3
 8009534:	f7ff fde8 	bl	8009108 <strlen>
 8009538:	0003      	movs	r3, r0
 800953a:	001a      	movs	r2, r3
 800953c:	4b93      	ldr	r3, [pc, #588]	; (800978c <Wifi_Service+0x374>)
 800953e:	18d2      	adds	r2, r2, r3
 8009540:	4b98      	ldr	r3, [pc, #608]	; (80097a4 <Wifi_Service+0x38c>)
 8009542:	0010      	movs	r0, r2
 8009544:	0019      	movs	r1, r3
 8009546:	2303      	movs	r3, #3
 8009548:	001a      	movs	r2, r3
 800954a:	f00b fd59 	bl	8015000 <memcpy>
		Wifi_Send(temp);
 800954e:	4b8f      	ldr	r3, [pc, #572]	; (800978c <Wifi_Service+0x374>)
 8009550:	0018      	movs	r0, r3
 8009552:	f000 f991 	bl	8009878 <Wifi_Send>
		WifiState = 0;
 8009556:	4b84      	ldr	r3, [pc, #528]	; (8009768 <Wifi_Service+0x350>)
 8009558:	2200      	movs	r2, #0
 800955a:	701a      	strb	r2, [r3, #0]

		break;
 800955c:	e169      	b.n	8009832 <Wifi_Service+0x41a>
	case WifiAT:
		Wifi_Send("AT\r\n");
 800955e:	4b85      	ldr	r3, [pc, #532]	; (8009774 <Wifi_Service+0x35c>)
 8009560:	0018      	movs	r0, r3
 8009562:	f000 f989 	bl	8009878 <Wifi_Send>
		WifiState = 0;
 8009566:	4b80      	ldr	r3, [pc, #512]	; (8009768 <Wifi_Service+0x350>)
 8009568:	2200      	movs	r2, #0
 800956a:	701a      	strb	r2, [r3, #0]
		break;
 800956c:	e161      	b.n	8009832 <Wifi_Service+0x41a>
	case IP_Stat:
		Wifi_Send("AT+CIPSTATUS\r\n");
 800956e:	4b8e      	ldr	r3, [pc, #568]	; (80097a8 <Wifi_Service+0x390>)
 8009570:	0018      	movs	r0, r3
 8009572:	f000 f981 	bl	8009878 <Wifi_Send>

		break;
 8009576:	e15c      	b.n	8009832 <Wifi_Service+0x41a>
	case CPMUX:
		Wifi_Send("AT+CIPMUX=1\r\n");
 8009578:	4b8c      	ldr	r3, [pc, #560]	; (80097ac <Wifi_Service+0x394>)
 800957a:	0018      	movs	r0, r3
 800957c:	f000 f97c 	bl	8009878 <Wifi_Send>
		WifiState = ServerOn;
 8009580:	4b79      	ldr	r3, [pc, #484]	; (8009768 <Wifi_Service+0x350>)
 8009582:	220b      	movs	r2, #11
 8009584:	701a      	strb	r2, [r3, #0]
		WifiState = Dial;
 8009586:	4b78      	ldr	r3, [pc, #480]	; (8009768 <Wifi_Service+0x350>)
 8009588:	220d      	movs	r2, #13
 800958a:	701a      	strb	r2, [r3, #0]
		if (wifiFlag.server == 0) WifiState = Dial;
 800958c:	4b7c      	ldr	r3, [pc, #496]	; (8009780 <Wifi_Service+0x368>)
 800958e:	791b      	ldrb	r3, [r3, #4]
 8009590:	2b00      	cmp	r3, #0
 8009592:	d103      	bne.n	800959c <Wifi_Service+0x184>
 8009594:	4b74      	ldr	r3, [pc, #464]	; (8009768 <Wifi_Service+0x350>)
 8009596:	220d      	movs	r2, #13
 8009598:	701a      	strb	r2, [r3, #0]
		else WifiState = ServerOn;
		break;
 800959a:	e14a      	b.n	8009832 <Wifi_Service+0x41a>
		else WifiState = ServerOn;
 800959c:	4b72      	ldr	r3, [pc, #456]	; (8009768 <Wifi_Service+0x350>)
 800959e:	220b      	movs	r2, #11
 80095a0:	701a      	strb	r2, [r3, #0]
		break;
 80095a2:	e146      	b.n	8009832 <Wifi_Service+0x41a>

	case ServerOn:
		Wifi_Send("AT+CIPSERVER=1,5008\r\n");
 80095a4:	4b82      	ldr	r3, [pc, #520]	; (80097b0 <Wifi_Service+0x398>)
 80095a6:	0018      	movs	r0, r3
 80095a8:	f000 f966 	bl	8009878 <Wifi_Send>
		HAL_GPIO_WritePin(LED5_GPIO_Port, LED5_Pin, GPIO_PIN_RESET);
 80095ac:	4b81      	ldr	r3, [pc, #516]	; (80097b4 <Wifi_Service+0x39c>)
 80095ae:	2200      	movs	r2, #0
 80095b0:	2108      	movs	r1, #8
 80095b2:	0018      	movs	r0, r3
 80095b4:	f002 f8e4 	bl	800b780 <HAL_GPIO_WritePin>
		WifiState = 0;
 80095b8:	4b6b      	ldr	r3, [pc, #428]	; (8009768 <Wifi_Service+0x350>)
 80095ba:	2200      	movs	r2, #0
 80095bc:	701a      	strb	r2, [r3, #0]
		break;
 80095be:	e138      	b.n	8009832 <Wifi_Service+0x41a>
	case ServerOff:
		Wifi_Send("AT+CIPSERVER=0\r\n");
 80095c0:	4b7d      	ldr	r3, [pc, #500]	; (80097b8 <Wifi_Service+0x3a0>)
 80095c2:	0018      	movs	r0, r3
 80095c4:	f000 f958 	bl	8009878 <Wifi_Send>
		WifiState = 0;
 80095c8:	4b67      	ldr	r3, [pc, #412]	; (8009768 <Wifi_Service+0x350>)
 80095ca:	2200      	movs	r2, #0
 80095cc:	701a      	strb	r2, [r3, #0]
		break;
 80095ce:	e130      	b.n	8009832 <Wifi_Service+0x41a>
	case Dial:
		//Wifi_Send("AT+CIPSTART=\"TCP\",\"iot.espressif.cn\",8000\r\n");
		Wifi_Send("AT+CIPSTART=0,\"TCP\",\"196.40.108.169\",1883\r\n");
 80095d0:	4b7a      	ldr	r3, [pc, #488]	; (80097bc <Wifi_Service+0x3a4>)
 80095d2:	0018      	movs	r0, r3
 80095d4:	f000 f950 	bl	8009878 <Wifi_Send>
		//Wifi_Send("AT+CIPSTART=0,\"TCP\",\"196.40.108.169\",5010\r\n");
		//Wifi_Send("AT+CIPSTART=0,\"TCP\",\"192.168.1.35\",5010\r\n");
		WifiState = 0;
 80095d8:	4b63      	ldr	r3, [pc, #396]	; (8009768 <Wifi_Service+0x350>)
 80095da:	2200      	movs	r2, #0
 80095dc:	701a      	strb	r2, [r3, #0]
		break;
 80095de:	e128      	b.n	8009832 <Wifi_Service+0x41a>
	case IP_Send:
		//strcpy(temp1,HTML2);
		len = strlen(HTML5);
 80095e0:	4b77      	ldr	r3, [pc, #476]	; (80097c0 <Wifi_Service+0x3a8>)
 80095e2:	0018      	movs	r0, r3
 80095e4:	f7ff fd90 	bl	8009108 <strlen>
 80095e8:	0003      	movs	r3, r0
 80095ea:	001a      	movs	r2, r3
 80095ec:	4b75      	ldr	r3, [pc, #468]	; (80097c4 <Wifi_Service+0x3ac>)
 80095ee:	601a      	str	r2, [r3, #0]
		if(mqttFlag.active == 1) len = mqttInfo.length;
 80095f0:	4b75      	ldr	r3, [pc, #468]	; (80097c8 <Wifi_Service+0x3b0>)
 80095f2:	789b      	ldrb	r3, [r3, #2]
 80095f4:	2b01      	cmp	r3, #1
 80095f6:	d103      	bne.n	8009600 <Wifi_Service+0x1e8>
 80095f8:	4b74      	ldr	r3, [pc, #464]	; (80097cc <Wifi_Service+0x3b4>)
 80095fa:	689a      	ldr	r2, [r3, #8]
 80095fc:	4b71      	ldr	r3, [pc, #452]	; (80097c4 <Wifi_Service+0x3ac>)
 80095fe:	601a      	str	r2, [r3, #0]
		myLongStr(len , temp,10, 10);
 8009600:	4b70      	ldr	r3, [pc, #448]	; (80097c4 <Wifi_Service+0x3ac>)
 8009602:	6818      	ldr	r0, [r3, #0]
 8009604:	4961      	ldr	r1, [pc, #388]	; (800978c <Wifi_Service+0x374>)
 8009606:	230a      	movs	r3, #10
 8009608:	220a      	movs	r2, #10
 800960a:	f001 fa41 	bl	800aa90 <myLongStr>
		//len = 70;
		//Debug_Send("Packet length: ");
		//Debug_Send(temp);
		//Debug_Send("\r\n");
		//Wifi_Send("AT+CIPSEND=<");
		strcpy((char*)temp,"AT+CIPSENDEX=");
 800960e:	4a5f      	ldr	r2, [pc, #380]	; (800978c <Wifi_Service+0x374>)
 8009610:	4b6f      	ldr	r3, [pc, #444]	; (80097d0 <Wifi_Service+0x3b8>)
 8009612:	0010      	movs	r0, r2
 8009614:	0019      	movs	r1, r3
 8009616:	230e      	movs	r3, #14
 8009618:	001a      	movs	r2, r3
 800961a:	f00b fcf1 	bl	8015000 <memcpy>
		strcat((char*)temp,ConnID);
 800961e:	4a6d      	ldr	r2, [pc, #436]	; (80097d4 <Wifi_Service+0x3bc>)
 8009620:	4b5a      	ldr	r3, [pc, #360]	; (800978c <Wifi_Service+0x374>)
 8009622:	0011      	movs	r1, r2
 8009624:	0018      	movs	r0, r3
 8009626:	f00b fd1d 	bl	8015064 <strcat>
		strcat((char*)temp,",");
 800962a:	4b58      	ldr	r3, [pc, #352]	; (800978c <Wifi_Service+0x374>)
 800962c:	0018      	movs	r0, r3
 800962e:	f7ff fd6b 	bl	8009108 <strlen>
 8009632:	0003      	movs	r3, r0
 8009634:	001a      	movs	r2, r3
 8009636:	4b55      	ldr	r3, [pc, #340]	; (800978c <Wifi_Service+0x374>)
 8009638:	18d2      	adds	r2, r2, r3
 800963a:	4b67      	ldr	r3, [pc, #412]	; (80097d8 <Wifi_Service+0x3c0>)
 800963c:	0010      	movs	r0, r2
 800963e:	0019      	movs	r1, r3
 8009640:	2302      	movs	r3, #2
 8009642:	001a      	movs	r2, r3
 8009644:	f00b fcdc 	bl	8015000 <memcpy>
		myLongStr(len,dummy,10,10);
 8009648:	4b5e      	ldr	r3, [pc, #376]	; (80097c4 <Wifi_Service+0x3ac>)
 800964a:	6818      	ldr	r0, [r3, #0]
 800964c:	4963      	ldr	r1, [pc, #396]	; (80097dc <Wifi_Service+0x3c4>)
 800964e:	230a      	movs	r3, #10
 8009650:	220a      	movs	r2, #10
 8009652:	f001 fa1d 	bl	800aa90 <myLongStr>
		strcat((char*)temp,dummy);
 8009656:	4a61      	ldr	r2, [pc, #388]	; (80097dc <Wifi_Service+0x3c4>)
 8009658:	4b4c      	ldr	r3, [pc, #304]	; (800978c <Wifi_Service+0x374>)
 800965a:	0011      	movs	r1, r2
 800965c:	0018      	movs	r0, r3
 800965e:	f00b fd01 	bl	8015064 <strcat>
		strcat((char*)temp,"\r\n");
 8009662:	4b4a      	ldr	r3, [pc, #296]	; (800978c <Wifi_Service+0x374>)
 8009664:	0018      	movs	r0, r3
 8009666:	f7ff fd4f 	bl	8009108 <strlen>
 800966a:	0003      	movs	r3, r0
 800966c:	001a      	movs	r2, r3
 800966e:	4b47      	ldr	r3, [pc, #284]	; (800978c <Wifi_Service+0x374>)
 8009670:	18d2      	adds	r2, r2, r3
 8009672:	4b4c      	ldr	r3, [pc, #304]	; (80097a4 <Wifi_Service+0x38c>)
 8009674:	0010      	movs	r0, r2
 8009676:	0019      	movs	r1, r3
 8009678:	2303      	movs	r3, #3
 800967a:	001a      	movs	r2, r3
 800967c:	f00b fcc0 	bl	8015000 <memcpy>
		Wifi_Send((char*)temp);
 8009680:	4b42      	ldr	r3, [pc, #264]	; (800978c <Wifi_Service+0x374>)
 8009682:	0018      	movs	r0, r3
 8009684:	f000 f8f8 	bl	8009878 <Wifi_Send>
		//Wifi_Send(">\r\n");
		//Wifi_Send("AT+CIPSEND=<length>\r\n");
		WifiState = 0;
 8009688:	4b37      	ldr	r3, [pc, #220]	; (8009768 <Wifi_Service+0x350>)
 800968a:	2200      	movs	r2, #0
 800968c:	701a      	strb	r2, [r3, #0]
		break;
 800968e:	e0d0      	b.n	8009832 <Wifi_Service+0x41a>
	case IP_Data:
		//Debug_Send("Send data\r\n");

		if(mqttFlag.active == 1) GSM_Send_Bin(temp1, mqttInfo.length);
 8009690:	4b4d      	ldr	r3, [pc, #308]	; (80097c8 <Wifi_Service+0x3b0>)
 8009692:	789b      	ldrb	r3, [r3, #2]
 8009694:	2b01      	cmp	r3, #1
 8009696:	d107      	bne.n	80096a8 <Wifi_Service+0x290>
 8009698:	4b4c      	ldr	r3, [pc, #304]	; (80097cc <Wifi_Service+0x3b4>)
 800969a:	689a      	ldr	r2, [r3, #8]
 800969c:	4b50      	ldr	r3, [pc, #320]	; (80097e0 <Wifi_Service+0x3c8>)
 800969e:	0011      	movs	r1, r2
 80096a0:	0018      	movs	r0, r3
 80096a2:	f7ff fdcf 	bl	8009244 <GSM_Send_Bin>
 80096a6:	e01c      	b.n	80096e2 <Wifi_Service+0x2ca>
		else{
			strcpy((char*)temp1,HTML5);
 80096a8:	4a45      	ldr	r2, [pc, #276]	; (80097c0 <Wifi_Service+0x3a8>)
 80096aa:	4b4d      	ldr	r3, [pc, #308]	; (80097e0 <Wifi_Service+0x3c8>)
 80096ac:	0011      	movs	r1, r2
 80096ae:	0018      	movs	r0, r3
 80096b0:	f00b fce5 	bl	801507e <strcpy>
			strcat((char*)temp1,"\r\n");
 80096b4:	4b4a      	ldr	r3, [pc, #296]	; (80097e0 <Wifi_Service+0x3c8>)
 80096b6:	0018      	movs	r0, r3
 80096b8:	f7ff fd26 	bl	8009108 <strlen>
 80096bc:	0003      	movs	r3, r0
 80096be:	001a      	movs	r2, r3
 80096c0:	4b47      	ldr	r3, [pc, #284]	; (80097e0 <Wifi_Service+0x3c8>)
 80096c2:	18d2      	adds	r2, r2, r3
 80096c4:	4b37      	ldr	r3, [pc, #220]	; (80097a4 <Wifi_Service+0x38c>)
 80096c6:	0010      	movs	r0, r2
 80096c8:	0019      	movs	r1, r3
 80096ca:	2303      	movs	r3, #3
 80096cc:	001a      	movs	r2, r3
 80096ce:	f00b fc97 	bl	8015000 <memcpy>
			Debug_Send((char*)temp1);
 80096d2:	4b43      	ldr	r3, [pc, #268]	; (80097e0 <Wifi_Service+0x3c8>)
 80096d4:	0018      	movs	r0, r3
 80096d6:	f7ff fddb 	bl	8009290 <Debug_Send>
			Wifi_Send((char*)temp1);
 80096da:	4b41      	ldr	r3, [pc, #260]	; (80097e0 <Wifi_Service+0x3c8>)
 80096dc:	0018      	movs	r0, r3
 80096de:	f000 f8cb 	bl	8009878 <Wifi_Send>
		}

		//Debug_Send("Send data done\r\n");
		WifiState = 0;
 80096e2:	4b21      	ldr	r3, [pc, #132]	; (8009768 <Wifi_Service+0x350>)
 80096e4:	2200      	movs	r2, #0
 80096e6:	701a      	strb	r2, [r3, #0]
		break;
 80096e8:	e0a3      	b.n	8009832 <Wifi_Service+0x41a>
	case IP_Buffer:
		strcpy((char*)temp,"AT+CIPSENDBUF=");
 80096ea:	4a28      	ldr	r2, [pc, #160]	; (800978c <Wifi_Service+0x374>)
 80096ec:	4b3d      	ldr	r3, [pc, #244]	; (80097e4 <Wifi_Service+0x3cc>)
 80096ee:	0010      	movs	r0, r2
 80096f0:	0019      	movs	r1, r3
 80096f2:	230f      	movs	r3, #15
 80096f4:	001a      	movs	r2, r3
 80096f6:	f00b fc83 	bl	8015000 <memcpy>
		strcat((char*)temp,ConnID);
 80096fa:	4a36      	ldr	r2, [pc, #216]	; (80097d4 <Wifi_Service+0x3bc>)
 80096fc:	4b23      	ldr	r3, [pc, #140]	; (800978c <Wifi_Service+0x374>)
 80096fe:	0011      	movs	r1, r2
 8009700:	0018      	movs	r0, r3
 8009702:	f00b fcaf 	bl	8015064 <strcat>
		strcat((char*)temp,",");
 8009706:	4b21      	ldr	r3, [pc, #132]	; (800978c <Wifi_Service+0x374>)
 8009708:	0018      	movs	r0, r3
 800970a:	f7ff fcfd 	bl	8009108 <strlen>
 800970e:	0003      	movs	r3, r0
 8009710:	001a      	movs	r2, r3
 8009712:	4b1e      	ldr	r3, [pc, #120]	; (800978c <Wifi_Service+0x374>)
 8009714:	18d2      	adds	r2, r2, r3
 8009716:	4b30      	ldr	r3, [pc, #192]	; (80097d8 <Wifi_Service+0x3c0>)
 8009718:	0010      	movs	r0, r2
 800971a:	0019      	movs	r1, r3
 800971c:	2302      	movs	r3, #2
 800971e:	001a      	movs	r2, r3
 8009720:	f00b fc6e 	bl	8015000 <memcpy>
		myLongStr(len,temp1,10,10);
 8009724:	4b27      	ldr	r3, [pc, #156]	; (80097c4 <Wifi_Service+0x3ac>)
 8009726:	6818      	ldr	r0, [r3, #0]
 8009728:	492d      	ldr	r1, [pc, #180]	; (80097e0 <Wifi_Service+0x3c8>)
 800972a:	230a      	movs	r3, #10
 800972c:	220a      	movs	r2, #10
 800972e:	f001 f9af 	bl	800aa90 <myLongStr>
		strcat((char*)temp,temp1);
 8009732:	4a2b      	ldr	r2, [pc, #172]	; (80097e0 <Wifi_Service+0x3c8>)
 8009734:	4b15      	ldr	r3, [pc, #84]	; (800978c <Wifi_Service+0x374>)
 8009736:	0011      	movs	r1, r2
 8009738:	0018      	movs	r0, r3
 800973a:	f00b fc93 	bl	8015064 <strcat>
		strcat((char*)temp,"\r\n");
 800973e:	4b13      	ldr	r3, [pc, #76]	; (800978c <Wifi_Service+0x374>)
 8009740:	0018      	movs	r0, r3
 8009742:	f7ff fce1 	bl	8009108 <strlen>
 8009746:	0003      	movs	r3, r0
 8009748:	001a      	movs	r2, r3
 800974a:	4b10      	ldr	r3, [pc, #64]	; (800978c <Wifi_Service+0x374>)
 800974c:	18d2      	adds	r2, r2, r3
 800974e:	4b15      	ldr	r3, [pc, #84]	; (80097a4 <Wifi_Service+0x38c>)
 8009750:	0010      	movs	r0, r2
 8009752:	0019      	movs	r1, r3
 8009754:	2303      	movs	r3, #3
 8009756:	001a      	movs	r2, r3
 8009758:	f00b fc52 	bl	8015000 <memcpy>
		Wifi_Send((char*)temp);
 800975c:	4b0b      	ldr	r3, [pc, #44]	; (800978c <Wifi_Service+0x374>)
 800975e:	0018      	movs	r0, r3
 8009760:	f000 f88a 	bl	8009878 <Wifi_Send>

		break;
 8009764:	e065      	b.n	8009832 <Wifi_Service+0x41a>
 8009766:	46c0      	nop			; (mov r8, r8)
 8009768:	200000c4 	.word	0x200000c4
 800976c:	08015cf4 	.word	0x08015cf4
 8009770:	080158d4 	.word	0x080158d4
 8009774:	080158e0 	.word	0x080158e0
 8009778:	080158e8 	.word	0x080158e8
 800977c:	080158f8 	.word	0x080158f8
 8009780:	20002660 	.word	0x20002660
 8009784:	08015904 	.word	0x08015904
 8009788:	08015910 	.word	0x08015910
 800978c:	2000231c 	.word	0x2000231c
 8009790:	0801591c 	.word	0x0801591c
 8009794:	08015928 	.word	0x08015928
 8009798:	200000c8 	.word	0x200000c8
 800979c:	0801592c 	.word	0x0801592c
 80097a0:	200000e8 	.word	0x200000e8
 80097a4:	08015930 	.word	0x08015930
 80097a8:	08015934 	.word	0x08015934
 80097ac:	08015944 	.word	0x08015944
 80097b0:	08015954 	.word	0x08015954
 80097b4:	48000400 	.word	0x48000400
 80097b8:	0801596c 	.word	0x0801596c
 80097bc:	08015980 	.word	0x08015980
 80097c0:	20000108 	.word	0x20000108
 80097c4:	20002668 	.word	0x20002668
 80097c8:	20001b1c 	.word	0x20001b1c
 80097cc:	20001698 	.word	0x20001698
 80097d0:	080159ac 	.word	0x080159ac
 80097d4:	20002594 	.word	0x20002594
 80097d8:	080159bc 	.word	0x080159bc
 80097dc:	20001cb0 	.word	0x20001cb0
 80097e0:	200023a0 	.word	0x200023a0
 80097e4:	080159c0 	.word	0x080159c0
	case Close_Socket:
		//Wifi_Send("AT+CLOSE\r\n");
		strcpy((char*)temp,"AT+CIPCLOSE=");
 80097e8:	4a1c      	ldr	r2, [pc, #112]	; (800985c <Wifi_Service+0x444>)
 80097ea:	4b1d      	ldr	r3, [pc, #116]	; (8009860 <Wifi_Service+0x448>)
 80097ec:	0010      	movs	r0, r2
 80097ee:	0019      	movs	r1, r3
 80097f0:	230d      	movs	r3, #13
 80097f2:	001a      	movs	r2, r3
 80097f4:	f00b fc04 	bl	8015000 <memcpy>
		strcat((char*)temp,ConnID);
 80097f8:	4a1a      	ldr	r2, [pc, #104]	; (8009864 <Wifi_Service+0x44c>)
 80097fa:	4b18      	ldr	r3, [pc, #96]	; (800985c <Wifi_Service+0x444>)
 80097fc:	0011      	movs	r1, r2
 80097fe:	0018      	movs	r0, r3
 8009800:	f00b fc30 	bl	8015064 <strcat>
		strcat((char*)temp,"\r\n");
 8009804:	4b15      	ldr	r3, [pc, #84]	; (800985c <Wifi_Service+0x444>)
 8009806:	0018      	movs	r0, r3
 8009808:	f7ff fc7e 	bl	8009108 <strlen>
 800980c:	0003      	movs	r3, r0
 800980e:	001a      	movs	r2, r3
 8009810:	4b12      	ldr	r3, [pc, #72]	; (800985c <Wifi_Service+0x444>)
 8009812:	18d2      	adds	r2, r2, r3
 8009814:	4b14      	ldr	r3, [pc, #80]	; (8009868 <Wifi_Service+0x450>)
 8009816:	0010      	movs	r0, r2
 8009818:	0019      	movs	r1, r3
 800981a:	2303      	movs	r3, #3
 800981c:	001a      	movs	r2, r3
 800981e:	f00b fbef 	bl	8015000 <memcpy>
		Wifi_Send((char*)temp);
 8009822:	4b0e      	ldr	r3, [pc, #56]	; (800985c <Wifi_Service+0x444>)
 8009824:	0018      	movs	r0, r3
 8009826:	f000 f827 	bl	8009878 <Wifi_Send>
		WifiState = 0;
 800982a:	4b10      	ldr	r3, [pc, #64]	; (800986c <Wifi_Service+0x454>)
 800982c:	2200      	movs	r2, #0
 800982e:	701a      	strb	r2, [r3, #0]
		break;
 8009830:	46c0      	nop			; (mov r8, r8)
	}
	if (mqttFlag.subscribe == 2) mqttInfo.timer++;
 8009832:	4b0f      	ldr	r3, [pc, #60]	; (8009870 <Wifi_Service+0x458>)
 8009834:	785b      	ldrb	r3, [r3, #1]
 8009836:	2b02      	cmp	r3, #2
 8009838:	d104      	bne.n	8009844 <Wifi_Service+0x42c>
 800983a:	4b0e      	ldr	r3, [pc, #56]	; (8009874 <Wifi_Service+0x45c>)
 800983c:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 800983e:	1c5a      	adds	r2, r3, #1
 8009840:	4b0c      	ldr	r3, [pc, #48]	; (8009874 <Wifi_Service+0x45c>)
 8009842:	661a      	str	r2, [r3, #96]	; 0x60
	if (mqttInfo.timer == 90){
 8009844:	4b0b      	ldr	r3, [pc, #44]	; (8009874 <Wifi_Service+0x45c>)
 8009846:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8009848:	2b5a      	cmp	r3, #90	; 0x5a
 800984a:	d104      	bne.n	8009856 <Wifi_Service+0x43e>
		MQTT_Publish_F1();
 800984c:	f000 fb1e 	bl	8009e8c <MQTT_Publish_F1>
		//MQTT_Ping_F1();
		mqttInfo.timer = 0;
 8009850:	4b08      	ldr	r3, [pc, #32]	; (8009874 <Wifi_Service+0x45c>)
 8009852:	2200      	movs	r2, #0
 8009854:	661a      	str	r2, [r3, #96]	; 0x60
	}
}
 8009856:	46c0      	nop			; (mov r8, r8)
 8009858:	46bd      	mov	sp, r7
 800985a:	bd80      	pop	{r7, pc}
 800985c:	2000231c 	.word	0x2000231c
 8009860:	080159d0 	.word	0x080159d0
 8009864:	20002594 	.word	0x20002594
 8009868:	08015930 	.word	0x08015930
 800986c:	200000c4 	.word	0x200000c4
 8009870:	20001b1c 	.word	0x20001b1c
 8009874:	20001698 	.word	0x20001698

08009878 <Wifi_Send>:

void Wifi_Send(char* data){
 8009878:	b580      	push	{r7, lr}
 800987a:	b084      	sub	sp, #16
 800987c:	af00      	add	r7, sp, #0
 800987e:	6078      	str	r0, [r7, #4]
	int size;
	int timeout = 25;
 8009880:	2319      	movs	r3, #25
 8009882:	60fb      	str	r3, [r7, #12]
	size = strlen(data);
 8009884:	687b      	ldr	r3, [r7, #4]
 8009886:	0018      	movs	r0, r3
 8009888:	f7ff fc3e 	bl	8009108 <strlen>
 800988c:	0003      	movs	r3, r0
 800988e:	60bb      	str	r3, [r7, #8]
	HAL_UART_Transmit(&huart2, data, size, timeout);
 8009890:	68bb      	ldr	r3, [r7, #8]
 8009892:	b29a      	uxth	r2, r3
 8009894:	68fb      	ldr	r3, [r7, #12]
 8009896:	6879      	ldr	r1, [r7, #4]
 8009898:	4806      	ldr	r0, [pc, #24]	; (80098b4 <Wifi_Send+0x3c>)
 800989a:	f004 fd25 	bl	800e2e8 <HAL_UART_Transmit>
	HAL_UART_Receive_IT(&huart2, (uint8_t *) dummy, 140);
 800989e:	4906      	ldr	r1, [pc, #24]	; (80098b8 <Wifi_Send+0x40>)
 80098a0:	4b04      	ldr	r3, [pc, #16]	; (80098b4 <Wifi_Send+0x3c>)
 80098a2:	228c      	movs	r2, #140	; 0x8c
 80098a4:	0018      	movs	r0, r3
 80098a6:	f004 fe49 	bl	800e53c <HAL_UART_Receive_IT>
	//HAL_UART_Transmit_IT(&huart3, data, size);
	//HAL_UART_Receive_IT(&huart1, data, size);
}
 80098aa:	46c0      	nop			; (mov r8, r8)
 80098ac:	46bd      	mov	sp, r7
 80098ae:	b004      	add	sp, #16
 80098b0:	bd80      	pop	{r7, pc}
 80098b2:	46c0      	nop			; (mov r8, r8)
 80098b4:	2000275c 	.word	0x2000275c
 80098b8:	20001cb0 	.word	0x20001cb0

080098bc <WifirecData>:


void WifirecData(){
 80098bc:	b580      	push	{r7, lr}
 80098be:	af00      	add	r7, sp, #0
	//HAL_GPIO_TogglePin(LED2B0_GPIO_Port, LED2B0_Pin);
	HAL_GPIO_TogglePin(LED2_GPIO_Port, LED2_Pin);
 80098c0:	2380      	movs	r3, #128	; 0x80
 80098c2:	019b      	lsls	r3, r3, #6
 80098c4:	4a7d      	ldr	r2, [pc, #500]	; (8009abc <WifirecData+0x200>)
 80098c6:	0019      	movs	r1, r3
 80098c8:	0010      	movs	r0, r2
 80098ca:	f001 ff76 	bl	800b7ba <HAL_GPIO_TogglePin>
	//while (WrecBuffPointerWrite != WrecBuffPointerRead){
		if (WrecBuffPointerWrite != WrecBuffPointerRead){
 80098ce:	4b7c      	ldr	r3, [pc, #496]	; (8009ac0 <WifirecData+0x204>)
 80098d0:	681a      	ldr	r2, [r3, #0]
 80098d2:	4b7c      	ldr	r3, [pc, #496]	; (8009ac4 <WifirecData+0x208>)
 80098d4:	681b      	ldr	r3, [r3, #0]
 80098d6:	429a      	cmp	r2, r3
 80098d8:	d100      	bne.n	80098dc <WifirecData+0x20>
 80098da:	e0ec      	b.n	8009ab6 <WifirecData+0x1fa>

			WprocBuff[WprocBuffpointer] = WrecBuff[WrecBuffPointerRead];
 80098dc:	4b79      	ldr	r3, [pc, #484]	; (8009ac4 <WifirecData+0x208>)
 80098de:	681a      	ldr	r2, [r3, #0]
 80098e0:	4b79      	ldr	r3, [pc, #484]	; (8009ac8 <WifirecData+0x20c>)
 80098e2:	681b      	ldr	r3, [r3, #0]
 80098e4:	4979      	ldr	r1, [pc, #484]	; (8009acc <WifirecData+0x210>)
 80098e6:	5c89      	ldrb	r1, [r1, r2]
 80098e8:	4a79      	ldr	r2, [pc, #484]	; (8009ad0 <WifirecData+0x214>)
 80098ea:	54d1      	strb	r1, [r2, r3]
			WrecBuffPointerRead++;
 80098ec:	4b75      	ldr	r3, [pc, #468]	; (8009ac4 <WifirecData+0x208>)
 80098ee:	681b      	ldr	r3, [r3, #0]
 80098f0:	1c5a      	adds	r2, r3, #1
 80098f2:	4b74      	ldr	r3, [pc, #464]	; (8009ac4 <WifirecData+0x208>)
 80098f4:	601a      	str	r2, [r3, #0]
			if (WrecBuffPointerRead > WrecBuffSize) WrecBuffPointerRead = 0;
 80098f6:	4b73      	ldr	r3, [pc, #460]	; (8009ac4 <WifirecData+0x208>)
 80098f8:	681b      	ldr	r3, [r3, #0]
 80098fa:	4a76      	ldr	r2, [pc, #472]	; (8009ad4 <WifirecData+0x218>)
 80098fc:	4293      	cmp	r3, r2
 80098fe:	dd02      	ble.n	8009906 <WifirecData+0x4a>
 8009900:	4b70      	ldr	r3, [pc, #448]	; (8009ac4 <WifirecData+0x208>)
 8009902:	2200      	movs	r2, #0
 8009904:	601a      	str	r2, [r3, #0]

			WprocBuffpointer++;
 8009906:	4b70      	ldr	r3, [pc, #448]	; (8009ac8 <WifirecData+0x20c>)
 8009908:	681b      	ldr	r3, [r3, #0]
 800990a:	1c5a      	adds	r2, r3, #1
 800990c:	4b6e      	ldr	r3, [pc, #440]	; (8009ac8 <WifirecData+0x20c>)
 800990e:	601a      	str	r2, [r3, #0]
			if (WprocBuffpointer > WprocBuffSize) WprocBuffpointer = 0;
 8009910:	4b6d      	ldr	r3, [pc, #436]	; (8009ac8 <WifirecData+0x20c>)
 8009912:	681b      	ldr	r3, [r3, #0]
 8009914:	2bc8      	cmp	r3, #200	; 0xc8
 8009916:	dd02      	ble.n	800991e <WifirecData+0x62>
 8009918:	4b6b      	ldr	r3, [pc, #428]	; (8009ac8 <WifirecData+0x20c>)
 800991a:	2200      	movs	r2, #0
 800991c:	601a      	str	r2, [r3, #0]

			mqttReceived[mqttInfo.Buffpointer] = WprocBuff[WprocBuffpointer - 1];
 800991e:	4b6a      	ldr	r3, [pc, #424]	; (8009ac8 <WifirecData+0x20c>)
 8009920:	681b      	ldr	r3, [r3, #0]
 8009922:	1e5a      	subs	r2, r3, #1
 8009924:	4b6c      	ldr	r3, [pc, #432]	; (8009ad8 <WifirecData+0x21c>)
 8009926:	685b      	ldr	r3, [r3, #4]
 8009928:	4969      	ldr	r1, [pc, #420]	; (8009ad0 <WifirecData+0x214>)
 800992a:	5c89      	ldrb	r1, [r1, r2]
 800992c:	4a6b      	ldr	r2, [pc, #428]	; (8009adc <WifirecData+0x220>)
 800992e:	54d1      	strb	r1, [r2, r3]
			if((mqttFlag.connect == 1) && (mqttReceived[mqttInfo.Buffpointer] == 2)){		//check connect response
 8009930:	4b6b      	ldr	r3, [pc, #428]	; (8009ae0 <WifirecData+0x224>)
 8009932:	78db      	ldrb	r3, [r3, #3]
 8009934:	2b01      	cmp	r3, #1
 8009936:	d10e      	bne.n	8009956 <WifirecData+0x9a>
 8009938:	4b67      	ldr	r3, [pc, #412]	; (8009ad8 <WifirecData+0x21c>)
 800993a:	685b      	ldr	r3, [r3, #4]
 800993c:	4a67      	ldr	r2, [pc, #412]	; (8009adc <WifirecData+0x220>)
 800993e:	5cd3      	ldrb	r3, [r2, r3]
 8009940:	2b02      	cmp	r3, #2
 8009942:	d108      	bne.n	8009956 <WifirecData+0x9a>
				Debug_Send("Got connect\r\n");
 8009944:	4b67      	ldr	r3, [pc, #412]	; (8009ae4 <WifirecData+0x228>)
 8009946:	0018      	movs	r0, r3
 8009948:	f7ff fca2 	bl	8009290 <Debug_Send>
				mqttFlag.connect = 2;
 800994c:	4b64      	ldr	r3, [pc, #400]	; (8009ae0 <WifirecData+0x224>)
 800994e:	2202      	movs	r2, #2
 8009950:	70da      	strb	r2, [r3, #3]
				MQTT_SuscribeF1();
 8009952:	f000 fa55 	bl	8009e00 <MQTT_SuscribeF1>
			}
			if((mqttFlag.subscribe == 1) && (mqttReceived[mqttInfo.Buffpointer] == 0x90)){		//check subscribe response
 8009956:	4b62      	ldr	r3, [pc, #392]	; (8009ae0 <WifirecData+0x224>)
 8009958:	785b      	ldrb	r3, [r3, #1]
 800995a:	2b01      	cmp	r3, #1
 800995c:	d113      	bne.n	8009986 <WifirecData+0xca>
 800995e:	4b5e      	ldr	r3, [pc, #376]	; (8009ad8 <WifirecData+0x21c>)
 8009960:	685b      	ldr	r3, [r3, #4]
 8009962:	4a5e      	ldr	r2, [pc, #376]	; (8009adc <WifirecData+0x220>)
 8009964:	5cd3      	ldrb	r3, [r2, r3]
 8009966:	2b90      	cmp	r3, #144	; 0x90
 8009968:	d10d      	bne.n	8009986 <WifirecData+0xca>
				Debug_Send("Got subscribe\r\n");
 800996a:	4b5f      	ldr	r3, [pc, #380]	; (8009ae8 <WifirecData+0x22c>)
 800996c:	0018      	movs	r0, r3
 800996e:	f7ff fc8f 	bl	8009290 <Debug_Send>
				mqttFlag.subscribe = 2;
 8009972:	4b5b      	ldr	r3, [pc, #364]	; (8009ae0 <WifirecData+0x224>)
 8009974:	2202      	movs	r2, #2
 8009976:	705a      	strb	r2, [r3, #1]
				//MQTT_Publish_F1();
				MQTT_Publish_F2("func2");
 8009978:	4b5c      	ldr	r3, [pc, #368]	; (8009aec <WifirecData+0x230>)
 800997a:	0018      	movs	r0, r3
 800997c:	f000 facc 	bl	8009f18 <MQTT_Publish_F2>
				mqttFlag.Data = 1;
 8009980:	4b57      	ldr	r3, [pc, #348]	; (8009ae0 <WifirecData+0x224>)
 8009982:	2201      	movs	r2, #1
 8009984:	701a      	strb	r2, [r3, #0]
				//MQTT_Ping_F1();
			}
			if((mqttFlag.subscribe == 2) && (mqttReceived[mqttInfo.Buffpointer] == 0x30)){
 8009986:	4b56      	ldr	r3, [pc, #344]	; (8009ae0 <WifirecData+0x224>)
 8009988:	785b      	ldrb	r3, [r3, #1]
 800998a:	2b02      	cmp	r3, #2
 800998c:	d108      	bne.n	80099a0 <WifirecData+0xe4>
 800998e:	4b52      	ldr	r3, [pc, #328]	; (8009ad8 <WifirecData+0x21c>)
 8009990:	685b      	ldr	r3, [r3, #4]
 8009992:	4a52      	ldr	r2, [pc, #328]	; (8009adc <WifirecData+0x220>)
 8009994:	5cd3      	ldrb	r3, [r2, r3]
 8009996:	2b30      	cmp	r3, #48	; 0x30
 8009998:	d102      	bne.n	80099a0 <WifirecData+0xe4>
				//Debug_Send("Got publish\r\n");
				//WifiState =  Wifi_AT;
				mqttFlag.Data = 1;
 800999a:	4b51      	ldr	r3, [pc, #324]	; (8009ae0 <WifirecData+0x224>)
 800999c:	2201      	movs	r2, #1
 800999e:	701a      	strb	r2, [r3, #0]
			}

			if((mqttFlag.subscribe == 2) && (mqttReceived[mqttInfo.Buffpointer] == 0x31)){
 80099a0:	4b4f      	ldr	r3, [pc, #316]	; (8009ae0 <WifirecData+0x224>)
 80099a2:	785b      	ldrb	r3, [r3, #1]
 80099a4:	2b02      	cmp	r3, #2
 80099a6:	d108      	bne.n	80099ba <WifirecData+0xfe>
 80099a8:	4b4b      	ldr	r3, [pc, #300]	; (8009ad8 <WifirecData+0x21c>)
 80099aa:	685b      	ldr	r3, [r3, #4]
 80099ac:	4a4b      	ldr	r2, [pc, #300]	; (8009adc <WifirecData+0x220>)
 80099ae:	5cd3      	ldrb	r3, [r2, r3]
 80099b0:	2b31      	cmp	r3, #49	; 0x31
 80099b2:	d102      	bne.n	80099ba <WifirecData+0xfe>
				//Debug_Send("Got publish r\r\n");
				//WifiState =  Wifi_AT;
				mqttFlag.Data = 1;
 80099b4:	4b4a      	ldr	r3, [pc, #296]	; (8009ae0 <WifirecData+0x224>)
 80099b6:	2201      	movs	r2, #1
 80099b8:	701a      	strb	r2, [r3, #0]
			}

			if (mqttReceived[mqttInfo.Buffpointer] < 10){
 80099ba:	4b47      	ldr	r3, [pc, #284]	; (8009ad8 <WifirecData+0x21c>)
 80099bc:	685b      	ldr	r3, [r3, #4]
 80099be:	4a47      	ldr	r2, [pc, #284]	; (8009adc <WifirecData+0x220>)
 80099c0:	5cd3      	ldrb	r3, [r2, r3]
 80099c2:	2b09      	cmp	r3, #9
 80099c4:	d810      	bhi.n	80099e8 <WifirecData+0x12c>
				//if ((WprocBuff[WprocBuffpointer - 1] != 0x10)||(WprocBuff[WprocBuffpointer - 1] != 0x13)){
				if (WprocBuff[WprocBuffpointer - 1] != 0x10){
 80099c6:	4b40      	ldr	r3, [pc, #256]	; (8009ac8 <WifirecData+0x20c>)
 80099c8:	681b      	ldr	r3, [r3, #0]
 80099ca:	3b01      	subs	r3, #1
 80099cc:	4a40      	ldr	r2, [pc, #256]	; (8009ad0 <WifirecData+0x214>)
 80099ce:	5cd3      	ldrb	r3, [r2, r3]
 80099d0:	2b10      	cmp	r3, #16
 80099d2:	d009      	beq.n	80099e8 <WifirecData+0x12c>
					myLongStr(mqttReceived[mqttInfo.Buffpointer],temp,10,16);
 80099d4:	4b40      	ldr	r3, [pc, #256]	; (8009ad8 <WifirecData+0x21c>)
 80099d6:	685b      	ldr	r3, [r3, #4]
 80099d8:	4a40      	ldr	r2, [pc, #256]	; (8009adc <WifirecData+0x220>)
 80099da:	5cd3      	ldrb	r3, [r2, r3]
 80099dc:	0018      	movs	r0, r3
 80099de:	4944      	ldr	r1, [pc, #272]	; (8009af0 <WifirecData+0x234>)
 80099e0:	2310      	movs	r3, #16
 80099e2:	220a      	movs	r2, #10
 80099e4:	f001 f854 	bl	800aa90 <myLongStr>
					//Debug_Send(temp);
					//Debug_Send("\r\n");
				}
			}

			if (mqttFlag.Data == 1){
 80099e8:	4b3d      	ldr	r3, [pc, #244]	; (8009ae0 <WifirecData+0x224>)
 80099ea:	781b      	ldrb	r3, [r3, #0]
 80099ec:	2b01      	cmp	r3, #1
 80099ee:	d145      	bne.n	8009a7c <WifirecData+0x1c0>
				mqttReceived[mqttInfo.Buffpointer] = WprocBuff[WprocBuffpointer - 1];
 80099f0:	4b35      	ldr	r3, [pc, #212]	; (8009ac8 <WifirecData+0x20c>)
 80099f2:	681b      	ldr	r3, [r3, #0]
 80099f4:	1e5a      	subs	r2, r3, #1
 80099f6:	4b38      	ldr	r3, [pc, #224]	; (8009ad8 <WifirecData+0x21c>)
 80099f8:	685b      	ldr	r3, [r3, #4]
 80099fa:	4935      	ldr	r1, [pc, #212]	; (8009ad0 <WifirecData+0x214>)
 80099fc:	5c89      	ldrb	r1, [r1, r2]
 80099fe:	4a37      	ldr	r2, [pc, #220]	; (8009adc <WifirecData+0x220>)
 8009a00:	54d1      	strb	r1, [r2, r3]
				Debug_Send(" - ");
				myLongStr(mqttReceived[mqttInfo.Buffpointer],temp,10,10);
				//Debug_Send("byte: ");
				Debug_Send(temp);
				Debug_Send("\r\n");*/
				if (mqttReceived[mqttInfo.Buffpointer] == 0x02){
 8009a02:	4b35      	ldr	r3, [pc, #212]	; (8009ad8 <WifirecData+0x21c>)
 8009a04:	685b      	ldr	r3, [r3, #4]
 8009a06:	4a35      	ldr	r2, [pc, #212]	; (8009adc <WifirecData+0x220>)
 8009a08:	5cd3      	ldrb	r3, [r2, r3]
 8009a0a:	2b02      	cmp	r3, #2
 8009a0c:	d103      	bne.n	8009a16 <WifirecData+0x15a>
					Debug_Send("Connected\r\n");
 8009a0e:	4b39      	ldr	r3, [pc, #228]	; (8009af4 <WifirecData+0x238>)
 8009a10:	0018      	movs	r0, r3
 8009a12:	f7ff fc3d 	bl	8009290 <Debug_Send>
					//mqttState = Subscribe;
					//gsmState = GPRS_Send;
				}
				mqttInfo.Buffpointer++;
 8009a16:	4b30      	ldr	r3, [pc, #192]	; (8009ad8 <WifirecData+0x21c>)
 8009a18:	685b      	ldr	r3, [r3, #4]
 8009a1a:	1c5a      	adds	r2, r3, #1
 8009a1c:	4b2e      	ldr	r3, [pc, #184]	; (8009ad8 <WifirecData+0x21c>)
 8009a1e:	605a      	str	r2, [r3, #4]
				if (mqttInfo.Buffpointer == 2){	//check byte [1]
 8009a20:	4b2d      	ldr	r3, [pc, #180]	; (8009ad8 <WifirecData+0x21c>)
 8009a22:	685b      	ldr	r3, [r3, #4]
 8009a24:	2b02      	cmp	r3, #2
 8009a26:	d106      	bne.n	8009a36 <WifirecData+0x17a>
					mqttInfo.Size = mqttReceived[mqttInfo.Buffpointer - 1];
 8009a28:	4b2b      	ldr	r3, [pc, #172]	; (8009ad8 <WifirecData+0x21c>)
 8009a2a:	685b      	ldr	r3, [r3, #4]
 8009a2c:	3b01      	subs	r3, #1
 8009a2e:	4a2b      	ldr	r2, [pc, #172]	; (8009adc <WifirecData+0x220>)
 8009a30:	5cd2      	ldrb	r2, [r2, r3]
 8009a32:	4b29      	ldr	r3, [pc, #164]	; (8009ad8 <WifirecData+0x21c>)
 8009a34:	701a      	strb	r2, [r3, #0]
						mqttFlag.Data = 0;
						mqttInfo.Buffpointer = 0;
					}*/
					//if (mqttInfo.Size > 10){
				}
				if (mqttInfo.Buffpointer == 4){	//check when byte 3 arrives
 8009a36:	4b28      	ldr	r3, [pc, #160]	; (8009ad8 <WifirecData+0x21c>)
 8009a38:	685b      	ldr	r3, [r3, #4]
 8009a3a:	2b04      	cmp	r3, #4
 8009a3c:	d10d      	bne.n	8009a5a <WifirecData+0x19e>
					if((mqttReceived[1] > 30)||(mqttReceived[3] > 30)){
 8009a3e:	4b27      	ldr	r3, [pc, #156]	; (8009adc <WifirecData+0x220>)
 8009a40:	785b      	ldrb	r3, [r3, #1]
 8009a42:	2b1e      	cmp	r3, #30
 8009a44:	d803      	bhi.n	8009a4e <WifirecData+0x192>
 8009a46:	4b25      	ldr	r3, [pc, #148]	; (8009adc <WifirecData+0x220>)
 8009a48:	78db      	ldrb	r3, [r3, #3]
 8009a4a:	2b1e      	cmp	r3, #30
 8009a4c:	d905      	bls.n	8009a5a <WifirecData+0x19e>
						//Debug_Send("packet invalid,topic or packet size 2 large\r\n");
						mqttFlag.Data = 0;
 8009a4e:	4b24      	ldr	r3, [pc, #144]	; (8009ae0 <WifirecData+0x224>)
 8009a50:	2200      	movs	r2, #0
 8009a52:	701a      	strb	r2, [r3, #0]
						mqttInfo.Buffpointer = 0;
 8009a54:	4b20      	ldr	r3, [pc, #128]	; (8009ad8 <WifirecData+0x21c>)
 8009a56:	2200      	movs	r2, #0
 8009a58:	605a      	str	r2, [r3, #4]
					}
				}

				if(mqttInfo.Buffpointer>mqttInfo.Size+1){
 8009a5a:	4b1f      	ldr	r3, [pc, #124]	; (8009ad8 <WifirecData+0x21c>)
 8009a5c:	685a      	ldr	r2, [r3, #4]
 8009a5e:	4b1e      	ldr	r3, [pc, #120]	; (8009ad8 <WifirecData+0x21c>)
 8009a60:	781b      	ldrb	r3, [r3, #0]
 8009a62:	3301      	adds	r3, #1
 8009a64:	429a      	cmp	r2, r3
 8009a66:	dd09      	ble.n	8009a7c <WifirecData+0x1c0>
					mqttFlag.Data = 0;
 8009a68:	4b1d      	ldr	r3, [pc, #116]	; (8009ae0 <WifirecData+0x224>)
 8009a6a:	2200      	movs	r2, #0
 8009a6c:	701a      	strb	r2, [r3, #0]
					mqttInfo.Buffpointer = 0;
 8009a6e:	4b1a      	ldr	r3, [pc, #104]	; (8009ad8 <WifirecData+0x21c>)
 8009a70:	2200      	movs	r2, #0
 8009a72:	605a      	str	r2, [r3, #4]
					//Debug_Send("mqtt stop\r\n");
					MQTT_ProcessF(mqttReceived);
 8009a74:	4b19      	ldr	r3, [pc, #100]	; (8009adc <WifirecData+0x220>)
 8009a76:	0018      	movs	r0, r3
 8009a78:	f000 f840 	bl	8009afc <MQTT_ProcessF>
				}
				//if ((MQTTBuffpointer > gsmInfo.MQTT_Size + 2)||(gsmInfo.MQTT_Size == 0)) MQTT_Process();
			}

			if (WprocBuff[WprocBuffpointer - 1] == '>'){
 8009a7c:	4b12      	ldr	r3, [pc, #72]	; (8009ac8 <WifirecData+0x20c>)
 8009a7e:	681b      	ldr	r3, [r3, #0]
 8009a80:	3b01      	subs	r3, #1
 8009a82:	4a13      	ldr	r2, [pc, #76]	; (8009ad0 <WifirecData+0x214>)
 8009a84:	5cd3      	ldrb	r3, [r2, r3]
 8009a86:	2b3e      	cmp	r3, #62	; 0x3e
 8009a88:	d102      	bne.n	8009a90 <WifirecData+0x1d4>
				WifiState = IP_Data;
 8009a8a:	4b1b      	ldr	r3, [pc, #108]	; (8009af8 <WifirecData+0x23c>)
 8009a8c:	220f      	movs	r2, #15
 8009a8e:	701a      	strb	r2, [r3, #0]
				/*if (gsmInfo.socket == 1) gsmState = GPRS_Write;
				if (gsmInfo.dataFlag == 1)gsmState = GPRS_Write;
				else gsmState = SMS_Text;*/
			}
			if (WprocBuff[WprocBuffpointer - 1] == 0x0A){
 8009a90:	4b0d      	ldr	r3, [pc, #52]	; (8009ac8 <WifirecData+0x20c>)
 8009a92:	681b      	ldr	r3, [r3, #0]
 8009a94:	3b01      	subs	r3, #1
 8009a96:	4a0e      	ldr	r2, [pc, #56]	; (8009ad0 <WifirecData+0x214>)
 8009a98:	5cd3      	ldrb	r3, [r2, r3]
 8009a9a:	2b0a      	cmp	r3, #10
 8009a9c:	d10b      	bne.n	8009ab6 <WifirecData+0x1fa>
				/*if (mqttFlag.active == 0)*/
				//WprocBuff[WprocBuffpointer - 1] = 0;
				WprocBuff[WprocBuffpointer] = 0;
 8009a9e:	4b0a      	ldr	r3, [pc, #40]	; (8009ac8 <WifirecData+0x20c>)
 8009aa0:	681b      	ldr	r3, [r3, #0]
 8009aa2:	4a0b      	ldr	r2, [pc, #44]	; (8009ad0 <WifirecData+0x214>)
 8009aa4:	2100      	movs	r1, #0
 8009aa6:	54d1      	strb	r1, [r2, r3]
				WprocBuffpointer = 0;
 8009aa8:	4b07      	ldr	r3, [pc, #28]	; (8009ac8 <WifirecData+0x20c>)
 8009aaa:	2200      	movs	r2, #0
 8009aac:	601a      	str	r2, [r3, #0]
				//GSM_Send(WprocBuff);
				//GSM_Send("\r\n");
				//GSM_Send("0x0A\r\n");
				//GSM_Send("1");
				//Debug_Send("A\r\n");
				WifiprocData(WprocBuff);
 8009aae:	4b08      	ldr	r3, [pc, #32]	; (8009ad0 <WifirecData+0x214>)
 8009ab0:	0018      	movs	r0, r3
 8009ab2:	f000 faaf 	bl	800a014 <WifiprocData>
				//GSM_Send("0x0D\r\n");
				//GSM_Send("2");
			}
		}
	//}
}
 8009ab6:	46c0      	nop			; (mov r8, r8)
 8009ab8:	46bd      	mov	sp, r7
 8009aba:	bd80      	pop	{r7, pc}
 8009abc:	48000800 	.word	0x48000800
 8009ac0:	20000368 	.word	0x20000368
 8009ac4:	2000036c 	.word	0x2000036c
 8009ac8:	20000370 	.word	0x20000370
 8009acc:	20001e08 	.word	0x20001e08
 8009ad0:	20002598 	.word	0x20002598
 8009ad4:	00000514 	.word	0x00000514
 8009ad8:	20001698 	.word	0x20001698
 8009adc:	20001a84 	.word	0x20001a84
 8009ae0:	20001b1c 	.word	0x20001b1c
 8009ae4:	080159e0 	.word	0x080159e0
 8009ae8:	080159f0 	.word	0x080159f0
 8009aec:	08015a00 	.word	0x08015a00
 8009af0:	2000231c 	.word	0x2000231c
 8009af4:	08015a08 	.word	0x08015a08
 8009af8:	200000c4 	.word	0x200000c4

08009afc <MQTT_ProcessF>:
void MQTT_ProcessF(uint8_t *data){
 8009afc:	b590      	push	{r4, r7, lr}
 8009afe:	b089      	sub	sp, #36	; 0x24
 8009b00:	af02      	add	r7, sp, #8
 8009b02:	6078      	str	r0, [r7, #4]
	Debug_Send("MQTT process\r\n");
 8009b04:	4b81      	ldr	r3, [pc, #516]	; (8009d0c <MQTT_ProcessF+0x210>)
 8009b06:	0018      	movs	r0, r3
 8009b08:	f7ff fbc2 	bl	8009290 <Debug_Send>
	if (mqttInfo.Size > 4){
		Debug_Send("Valid packet size\r\n");
	}*/
	char cnt[10];
	int counter;
	for (counter = 0; counter < mqttInfo.Size + 2; counter++){
 8009b0c:	2300      	movs	r3, #0
 8009b0e:	617b      	str	r3, [r7, #20]
 8009b10:	e023      	b.n	8009b5a <MQTT_ProcessF+0x5e>
		myLongStr(counter,cnt,10,10);
 8009b12:	2408      	movs	r4, #8
 8009b14:	1939      	adds	r1, r7, r4
 8009b16:	6978      	ldr	r0, [r7, #20]
 8009b18:	230a      	movs	r3, #10
 8009b1a:	220a      	movs	r2, #10
 8009b1c:	f000 ffb8 	bl	800aa90 <myLongStr>

		//myLongStr(mqttReceived[counter],dummy,10,10);
		myLongStr(*data++,dummy,10,10);
 8009b20:	687b      	ldr	r3, [r7, #4]
 8009b22:	1c5a      	adds	r2, r3, #1
 8009b24:	607a      	str	r2, [r7, #4]
 8009b26:	781b      	ldrb	r3, [r3, #0]
 8009b28:	0018      	movs	r0, r3
 8009b2a:	4979      	ldr	r1, [pc, #484]	; (8009d10 <MQTT_ProcessF+0x214>)
 8009b2c:	230a      	movs	r3, #10
 8009b2e:	220a      	movs	r2, #10
 8009b30:	f000 ffae 	bl	800aa90 <myLongStr>
		Debug_Send(cnt);
 8009b34:	193b      	adds	r3, r7, r4
 8009b36:	0018      	movs	r0, r3
 8009b38:	f7ff fbaa 	bl	8009290 <Debug_Send>
		Debug_Send(":");
 8009b3c:	4b75      	ldr	r3, [pc, #468]	; (8009d14 <MQTT_ProcessF+0x218>)
 8009b3e:	0018      	movs	r0, r3
 8009b40:	f7ff fba6 	bl	8009290 <Debug_Send>
		Debug_Send(dummy);
 8009b44:	4b72      	ldr	r3, [pc, #456]	; (8009d10 <MQTT_ProcessF+0x214>)
 8009b46:	0018      	movs	r0, r3
 8009b48:	f7ff fba2 	bl	8009290 <Debug_Send>
		//Debug_Send("\r\n");
		Debug_Send("| ");
 8009b4c:	4b72      	ldr	r3, [pc, #456]	; (8009d18 <MQTT_ProcessF+0x21c>)
 8009b4e:	0018      	movs	r0, r3
 8009b50:	f7ff fb9e 	bl	8009290 <Debug_Send>
	for (counter = 0; counter < mqttInfo.Size + 2; counter++){
 8009b54:	697b      	ldr	r3, [r7, #20]
 8009b56:	3301      	adds	r3, #1
 8009b58:	617b      	str	r3, [r7, #20]
 8009b5a:	4b70      	ldr	r3, [pc, #448]	; (8009d1c <MQTT_ProcessF+0x220>)
 8009b5c:	781b      	ldrb	r3, [r3, #0]
 8009b5e:	3301      	adds	r3, #1
 8009b60:	697a      	ldr	r2, [r7, #20]
 8009b62:	429a      	cmp	r2, r3
 8009b64:	ddd5      	ble.n	8009b12 <MQTT_ProcessF+0x16>
	}
	mqttInfo.packetLength = mqttReceived[1] ;
 8009b66:	4b6e      	ldr	r3, [pc, #440]	; (8009d20 <MQTT_ProcessF+0x224>)
 8009b68:	785b      	ldrb	r3, [r3, #1]
 8009b6a:	001a      	movs	r2, r3
 8009b6c:	4b6b      	ldr	r3, [pc, #428]	; (8009d1c <MQTT_ProcessF+0x220>)
 8009b6e:	60da      	str	r2, [r3, #12]
	myLongStr(mqttInfo.packetLength,dummy,10,10);
 8009b70:	4b6a      	ldr	r3, [pc, #424]	; (8009d1c <MQTT_ProcessF+0x220>)
 8009b72:	68d8      	ldr	r0, [r3, #12]
 8009b74:	4966      	ldr	r1, [pc, #408]	; (8009d10 <MQTT_ProcessF+0x214>)
 8009b76:	230a      	movs	r3, #10
 8009b78:	220a      	movs	r2, #10
 8009b7a:	f000 ff89 	bl	800aa90 <myLongStr>
	Debug_Send("\r\npacket size ");
 8009b7e:	4b69      	ldr	r3, [pc, #420]	; (8009d24 <MQTT_ProcessF+0x228>)
 8009b80:	0018      	movs	r0, r3
 8009b82:	f7ff fb85 	bl	8009290 <Debug_Send>
	Debug_Send(dummy);
 8009b86:	4b62      	ldr	r3, [pc, #392]	; (8009d10 <MQTT_ProcessF+0x214>)
 8009b88:	0018      	movs	r0, r3
 8009b8a:	f7ff fb81 	bl	8009290 <Debug_Send>
	Debug_Send("\r\n");
 8009b8e:	4b66      	ldr	r3, [pc, #408]	; (8009d28 <MQTT_ProcessF+0x22c>)
 8009b90:	0018      	movs	r0, r3
 8009b92:	f7ff fb7d 	bl	8009290 <Debug_Send>
	mqttInfo.topicLength = mqttReceived[3];
 8009b96:	4b62      	ldr	r3, [pc, #392]	; (8009d20 <MQTT_ProcessF+0x224>)
 8009b98:	78db      	ldrb	r3, [r3, #3]
 8009b9a:	001a      	movs	r2, r3
 8009b9c:	4b5f      	ldr	r3, [pc, #380]	; (8009d1c <MQTT_ProcessF+0x220>)
 8009b9e:	611a      	str	r2, [r3, #16]
	myLongStr(mqttInfo.topicLength,dummy,10,10);
 8009ba0:	4b5e      	ldr	r3, [pc, #376]	; (8009d1c <MQTT_ProcessF+0x220>)
 8009ba2:	6918      	ldr	r0, [r3, #16]
 8009ba4:	495a      	ldr	r1, [pc, #360]	; (8009d10 <MQTT_ProcessF+0x214>)
 8009ba6:	230a      	movs	r3, #10
 8009ba8:	220a      	movs	r2, #10
 8009baa:	f000 ff71 	bl	800aa90 <myLongStr>
	Debug_Send("topic size ");
 8009bae:	4b5f      	ldr	r3, [pc, #380]	; (8009d2c <MQTT_ProcessF+0x230>)
 8009bb0:	0018      	movs	r0, r3
 8009bb2:	f7ff fb6d 	bl	8009290 <Debug_Send>
	Debug_Send(dummy);
 8009bb6:	4b56      	ldr	r3, [pc, #344]	; (8009d10 <MQTT_ProcessF+0x214>)
 8009bb8:	0018      	movs	r0, r3
 8009bba:	f7ff fb69 	bl	8009290 <Debug_Send>
	Debug_Send("\r\n");
 8009bbe:	4b5a      	ldr	r3, [pc, #360]	; (8009d28 <MQTT_ProcessF+0x22c>)
 8009bc0:	0018      	movs	r0, r3
 8009bc2:	f7ff fb65 	bl	8009290 <Debug_Send>
	mqttInfo.payloadLength = mqttInfo.packetLength - mqttInfo.topicLength - 2;
 8009bc6:	4b55      	ldr	r3, [pc, #340]	; (8009d1c <MQTT_ProcessF+0x220>)
 8009bc8:	68da      	ldr	r2, [r3, #12]
 8009bca:	4b54      	ldr	r3, [pc, #336]	; (8009d1c <MQTT_ProcessF+0x220>)
 8009bcc:	691b      	ldr	r3, [r3, #16]
 8009bce:	1ad3      	subs	r3, r2, r3
 8009bd0:	1e9a      	subs	r2, r3, #2
 8009bd2:	4b52      	ldr	r3, [pc, #328]	; (8009d1c <MQTT_ProcessF+0x220>)
 8009bd4:	615a      	str	r2, [r3, #20]
	myLongStr(mqttInfo.payloadLength,dummy,10,10);
 8009bd6:	4b51      	ldr	r3, [pc, #324]	; (8009d1c <MQTT_ProcessF+0x220>)
 8009bd8:	6958      	ldr	r0, [r3, #20]
 8009bda:	494d      	ldr	r1, [pc, #308]	; (8009d10 <MQTT_ProcessF+0x214>)
 8009bdc:	230a      	movs	r3, #10
 8009bde:	220a      	movs	r2, #10
 8009be0:	f000 ff56 	bl	800aa90 <myLongStr>
	Debug_Send("payload size ");
 8009be4:	4b52      	ldr	r3, [pc, #328]	; (8009d30 <MQTT_ProcessF+0x234>)
 8009be6:	0018      	movs	r0, r3
 8009be8:	f7ff fb52 	bl	8009290 <Debug_Send>
	Debug_Send(dummy);
 8009bec:	4b48      	ldr	r3, [pc, #288]	; (8009d10 <MQTT_ProcessF+0x214>)
 8009bee:	0018      	movs	r0, r3
 8009bf0:	f7ff fb4e 	bl	8009290 <Debug_Send>
	Debug_Send("\r\n");
 8009bf4:	4b4c      	ldr	r3, [pc, #304]	; (8009d28 <MQTT_ProcessF+0x22c>)
 8009bf6:	0018      	movs	r0, r3
 8009bf8:	f7ff fb4a 	bl	8009290 <Debug_Send>
	mqttInfo.packet[0] = 0;
 8009bfc:	4b47      	ldr	r3, [pc, #284]	; (8009d1c <MQTT_ProcessF+0x220>)
 8009bfe:	2200      	movs	r2, #0
 8009c00:	761a      	strb	r2, [r3, #24]
	mqttInfo.topic[0] = 0;
 8009c02:	4b46      	ldr	r3, [pc, #280]	; (8009d1c <MQTT_ProcessF+0x220>)
 8009c04:	2236      	movs	r2, #54	; 0x36
 8009c06:	2100      	movs	r1, #0
 8009c08:	5499      	strb	r1, [r3, r2]
	mqttInfo.data[0] = 0;
 8009c0a:	4b44      	ldr	r3, [pc, #272]	; (8009d1c <MQTT_ProcessF+0x220>)
 8009c0c:	224a      	movs	r2, #74	; 0x4a
 8009c0e:	2100      	movs	r1, #0
 8009c10:	5499      	strb	r1, [r3, r2]
	if ((mqttFlag.subscribe == 2)&&(mqttInfo.topicLength > 3)){	//3 to test
 8009c12:	4b48      	ldr	r3, [pc, #288]	; (8009d34 <MQTT_ProcessF+0x238>)
 8009c14:	785b      	ldrb	r3, [r3, #1]
 8009c16:	2b02      	cmp	r3, #2
 8009c18:	d13d      	bne.n	8009c96 <MQTT_ProcessF+0x19a>
 8009c1a:	4b40      	ldr	r3, [pc, #256]	; (8009d1c <MQTT_ProcessF+0x220>)
 8009c1c:	691b      	ldr	r3, [r3, #16]
 8009c1e:	2b03      	cmp	r3, #3
 8009c20:	dd39      	ble.n	8009c96 <MQTT_ProcessF+0x19a>
		byteCopy(mqttReceived, mqttInfo.packet, 4, 1 + mqttInfo.packetLength);
 8009c22:	4b3e      	ldr	r3, [pc, #248]	; (8009d1c <MQTT_ProcessF+0x220>)
 8009c24:	68db      	ldr	r3, [r3, #12]
 8009c26:	b2db      	uxtb	r3, r3
 8009c28:	3301      	adds	r3, #1
 8009c2a:	b2db      	uxtb	r3, r3
 8009c2c:	4942      	ldr	r1, [pc, #264]	; (8009d38 <MQTT_ProcessF+0x23c>)
 8009c2e:	483c      	ldr	r0, [pc, #240]	; (8009d20 <MQTT_ProcessF+0x224>)
 8009c30:	2204      	movs	r2, #4
 8009c32:	f000 fb6b 	bl	800a30c <byteCopy>
		byteCopy(mqttReceived, mqttInfo.topic, 4, mqttInfo.topicLength + 3);
 8009c36:	4b39      	ldr	r3, [pc, #228]	; (8009d1c <MQTT_ProcessF+0x220>)
 8009c38:	691b      	ldr	r3, [r3, #16]
 8009c3a:	b2db      	uxtb	r3, r3
 8009c3c:	3303      	adds	r3, #3
 8009c3e:	b2db      	uxtb	r3, r3
 8009c40:	493e      	ldr	r1, [pc, #248]	; (8009d3c <MQTT_ProcessF+0x240>)
 8009c42:	4837      	ldr	r0, [pc, #220]	; (8009d20 <MQTT_ProcessF+0x224>)
 8009c44:	2204      	movs	r2, #4
 8009c46:	f000 fb61 	bl	800a30c <byteCopy>
		byteCopy(mqttReceived, mqttInfo.data, 4 + mqttInfo.topicLength, 1 + mqttInfo.packetLength);
 8009c4a:	4b34      	ldr	r3, [pc, #208]	; (8009d1c <MQTT_ProcessF+0x220>)
 8009c4c:	691b      	ldr	r3, [r3, #16]
 8009c4e:	b2db      	uxtb	r3, r3
 8009c50:	3304      	adds	r3, #4
 8009c52:	b2da      	uxtb	r2, r3
 8009c54:	4b31      	ldr	r3, [pc, #196]	; (8009d1c <MQTT_ProcessF+0x220>)
 8009c56:	68db      	ldr	r3, [r3, #12]
 8009c58:	b2db      	uxtb	r3, r3
 8009c5a:	3301      	adds	r3, #1
 8009c5c:	b2db      	uxtb	r3, r3
 8009c5e:	4938      	ldr	r1, [pc, #224]	; (8009d40 <MQTT_ProcessF+0x244>)
 8009c60:	482f      	ldr	r0, [pc, #188]	; (8009d20 <MQTT_ProcessF+0x224>)
 8009c62:	f000 fb53 	bl	800a30c <byteCopy>
		Debug_Send(mqttInfo.packet);
 8009c66:	4b34      	ldr	r3, [pc, #208]	; (8009d38 <MQTT_ProcessF+0x23c>)
 8009c68:	0018      	movs	r0, r3
 8009c6a:	f7ff fb11 	bl	8009290 <Debug_Send>
		Debug_Send(" ^ ");
 8009c6e:	4b35      	ldr	r3, [pc, #212]	; (8009d44 <MQTT_ProcessF+0x248>)
 8009c70:	0018      	movs	r0, r3
 8009c72:	f7ff fb0d 	bl	8009290 <Debug_Send>
		Debug_Send(mqttInfo.topic);
 8009c76:	4b31      	ldr	r3, [pc, #196]	; (8009d3c <MQTT_ProcessF+0x240>)
 8009c78:	0018      	movs	r0, r3
 8009c7a:	f7ff fb09 	bl	8009290 <Debug_Send>
		Debug_Send(" ^ ");
 8009c7e:	4b31      	ldr	r3, [pc, #196]	; (8009d44 <MQTT_ProcessF+0x248>)
 8009c80:	0018      	movs	r0, r3
 8009c82:	f7ff fb05 	bl	8009290 <Debug_Send>
		Debug_Send(mqttInfo.data);
 8009c86:	4b2e      	ldr	r3, [pc, #184]	; (8009d40 <MQTT_ProcessF+0x244>)
 8009c88:	0018      	movs	r0, r3
 8009c8a:	f7ff fb01 	bl	8009290 <Debug_Send>
		Debug_Send("\r\n");
 8009c8e:	4b26      	ldr	r3, [pc, #152]	; (8009d28 <MQTT_ProcessF+0x22c>)
 8009c90:	0018      	movs	r0, r3
 8009c92:	f7ff fafd 	bl	8009290 <Debug_Send>
	}
	if(strncmp(mqttInfo.data,"l1",2) == 0){
 8009c96:	492c      	ldr	r1, [pc, #176]	; (8009d48 <MQTT_ProcessF+0x24c>)
 8009c98:	4b29      	ldr	r3, [pc, #164]	; (8009d40 <MQTT_ProcessF+0x244>)
 8009c9a:	2202      	movs	r2, #2
 8009c9c:	0018      	movs	r0, r3
 8009c9e:	f00b f9f6 	bl	801508e <strncmp>
 8009ca2:	1e03      	subs	r3, r0, #0
 8009ca4:	d12d      	bne.n	8009d02 <MQTT_ProcessF+0x206>
		myStrSection(mqttInfo.data, temp,30,',',1);	//get parameter
 8009ca6:	4929      	ldr	r1, [pc, #164]	; (8009d4c <MQTT_ProcessF+0x250>)
 8009ca8:	4825      	ldr	r0, [pc, #148]	; (8009d40 <MQTT_ProcessF+0x244>)
 8009caa:	2301      	movs	r3, #1
 8009cac:	9300      	str	r3, [sp, #0]
 8009cae:	232c      	movs	r3, #44	; 0x2c
 8009cb0:	221e      	movs	r2, #30
 8009cb2:	f000 fe58 	bl	800a966 <myStrSection>
		if(strncmp(temp,"off",3) == 0){
 8009cb6:	4926      	ldr	r1, [pc, #152]	; (8009d50 <MQTT_ProcessF+0x254>)
 8009cb8:	4b24      	ldr	r3, [pc, #144]	; (8009d4c <MQTT_ProcessF+0x250>)
 8009cba:	2203      	movs	r2, #3
 8009cbc:	0018      	movs	r0, r3
 8009cbe:	f00b f9e6 	bl	801508e <strncmp>
 8009cc2:	1e03      	subs	r3, r0, #0
 8009cc4:	d10a      	bne.n	8009cdc <MQTT_ProcessF+0x1e0>
			HAL_GPIO_WritePin(LED4_GPIO_Port, LED4_Pin, GPIO_PIN_SET);
 8009cc6:	2380      	movs	r3, #128	; 0x80
 8009cc8:	005b      	lsls	r3, r3, #1
 8009cca:	4822      	ldr	r0, [pc, #136]	; (8009d54 <MQTT_ProcessF+0x258>)
 8009ccc:	2201      	movs	r2, #1
 8009cce:	0019      	movs	r1, r3
 8009cd0:	f001 fd56 	bl	800b780 <HAL_GPIO_WritePin>
			Debug_Send("Light off\r\n");
 8009cd4:	4b20      	ldr	r3, [pc, #128]	; (8009d58 <MQTT_ProcessF+0x25c>)
 8009cd6:	0018      	movs	r0, r3
 8009cd8:	f7ff fada 	bl	8009290 <Debug_Send>
		}
		if(strncmp(temp,"on",2) == 0){
 8009cdc:	491f      	ldr	r1, [pc, #124]	; (8009d5c <MQTT_ProcessF+0x260>)
 8009cde:	4b1b      	ldr	r3, [pc, #108]	; (8009d4c <MQTT_ProcessF+0x250>)
 8009ce0:	2202      	movs	r2, #2
 8009ce2:	0018      	movs	r0, r3
 8009ce4:	f00b f9d3 	bl	801508e <strncmp>
 8009ce8:	1e03      	subs	r3, r0, #0
 8009cea:	d10a      	bne.n	8009d02 <MQTT_ProcessF+0x206>
			HAL_GPIO_WritePin(LED4_GPIO_Port, LED4_Pin, GPIO_PIN_RESET);
 8009cec:	2380      	movs	r3, #128	; 0x80
 8009cee:	005b      	lsls	r3, r3, #1
 8009cf0:	4818      	ldr	r0, [pc, #96]	; (8009d54 <MQTT_ProcessF+0x258>)
 8009cf2:	2200      	movs	r2, #0
 8009cf4:	0019      	movs	r1, r3
 8009cf6:	f001 fd43 	bl	800b780 <HAL_GPIO_WritePin>
			Debug_Send("Light off\r\n");
 8009cfa:	4b17      	ldr	r3, [pc, #92]	; (8009d58 <MQTT_ProcessF+0x25c>)
 8009cfc:	0018      	movs	r0, r3
 8009cfe:	f7ff fac7 	bl	8009290 <Debug_Send>
		}
	}
}
 8009d02:	46c0      	nop			; (mov r8, r8)
 8009d04:	46bd      	mov	sp, r7
 8009d06:	b007      	add	sp, #28
 8009d08:	bd90      	pop	{r4, r7, pc}
 8009d0a:	46c0      	nop			; (mov r8, r8)
 8009d0c:	08015a14 	.word	0x08015a14
 8009d10:	20001cb0 	.word	0x20001cb0
 8009d14:	08015a24 	.word	0x08015a24
 8009d18:	08015a28 	.word	0x08015a28
 8009d1c:	20001698 	.word	0x20001698
 8009d20:	20001a84 	.word	0x20001a84
 8009d24:	08015a2c 	.word	0x08015a2c
 8009d28:	08015930 	.word	0x08015930
 8009d2c:	08015a3c 	.word	0x08015a3c
 8009d30:	08015a48 	.word	0x08015a48
 8009d34:	20001b1c 	.word	0x20001b1c
 8009d38:	200016b0 	.word	0x200016b0
 8009d3c:	200016ce 	.word	0x200016ce
 8009d40:	200016e2 	.word	0x200016e2
 8009d44:	08015a58 	.word	0x08015a58
 8009d48:	08015a5c 	.word	0x08015a5c
 8009d4c:	2000231c 	.word	0x2000231c
 8009d50:	08015a60 	.word	0x08015a60
 8009d54:	48000400 	.word	0x48000400
 8009d58:	08015a64 	.word	0x08015a64
 8009d5c:	08015a70 	.word	0x08015a70

08009d60 <MQTT_ConnectF1>:

void MQTT_ConnectF1(){
 8009d60:	b580      	push	{r7, lr}
 8009d62:	af00      	add	r7, sp, #0
	Debug_Send("Build connect msg\r\n");
 8009d64:	4b21      	ldr	r3, [pc, #132]	; (8009dec <MQTT_ConnectF1+0x8c>)
 8009d66:	0018      	movs	r0, r3
 8009d68:	f7ff fa92 	bl	8009290 <Debug_Send>
	temp1[0] = 0x10;
 8009d6c:	4b20      	ldr	r3, [pc, #128]	; (8009df0 <MQTT_ConnectF1+0x90>)
 8009d6e:	2210      	movs	r2, #16
 8009d70:	701a      	strb	r2, [r3, #0]
	temp1[1] = 0x0E;
 8009d72:	4b1f      	ldr	r3, [pc, #124]	; (8009df0 <MQTT_ConnectF1+0x90>)
 8009d74:	220e      	movs	r2, #14
 8009d76:	705a      	strb	r2, [r3, #1]
	temp1[2] = 0x00;
 8009d78:	4b1d      	ldr	r3, [pc, #116]	; (8009df0 <MQTT_ConnectF1+0x90>)
 8009d7a:	2200      	movs	r2, #0
 8009d7c:	709a      	strb	r2, [r3, #2]
	temp1[3] = 0x04;
 8009d7e:	4b1c      	ldr	r3, [pc, #112]	; (8009df0 <MQTT_ConnectF1+0x90>)
 8009d80:	2204      	movs	r2, #4
 8009d82:	70da      	strb	r2, [r3, #3]
	temp1[4] = 'M';
 8009d84:	4b1a      	ldr	r3, [pc, #104]	; (8009df0 <MQTT_ConnectF1+0x90>)
 8009d86:	224d      	movs	r2, #77	; 0x4d
 8009d88:	711a      	strb	r2, [r3, #4]
	temp1[5] = 'Q';
 8009d8a:	4b19      	ldr	r3, [pc, #100]	; (8009df0 <MQTT_ConnectF1+0x90>)
 8009d8c:	2251      	movs	r2, #81	; 0x51
 8009d8e:	715a      	strb	r2, [r3, #5]
	temp1[6] = 'T';
 8009d90:	4b17      	ldr	r3, [pc, #92]	; (8009df0 <MQTT_ConnectF1+0x90>)
 8009d92:	2254      	movs	r2, #84	; 0x54
 8009d94:	719a      	strb	r2, [r3, #6]
	temp1[7] = 'T';
 8009d96:	4b16      	ldr	r3, [pc, #88]	; (8009df0 <MQTT_ConnectF1+0x90>)
 8009d98:	2254      	movs	r2, #84	; 0x54
 8009d9a:	71da      	strb	r2, [r3, #7]
	temp1[8] = 0x04;
 8009d9c:	4b14      	ldr	r3, [pc, #80]	; (8009df0 <MQTT_ConnectF1+0x90>)
 8009d9e:	2204      	movs	r2, #4
 8009da0:	721a      	strb	r2, [r3, #8]
	temp1[9] = 0x02;
 8009da2:	4b13      	ldr	r3, [pc, #76]	; (8009df0 <MQTT_ConnectF1+0x90>)
 8009da4:	2202      	movs	r2, #2
 8009da6:	725a      	strb	r2, [r3, #9]
	temp1[10] = 0x00;
 8009da8:	4b11      	ldr	r3, [pc, #68]	; (8009df0 <MQTT_ConnectF1+0x90>)
 8009daa:	2200      	movs	r2, #0
 8009dac:	729a      	strb	r2, [r3, #10]
	temp1[11] = 0x78;
 8009dae:	4b10      	ldr	r3, [pc, #64]	; (8009df0 <MQTT_ConnectF1+0x90>)
 8009db0:	2278      	movs	r2, #120	; 0x78
 8009db2:	72da      	strb	r2, [r3, #11]
	temp1[12] = 0x00;
 8009db4:	4b0e      	ldr	r3, [pc, #56]	; (8009df0 <MQTT_ConnectF1+0x90>)
 8009db6:	2200      	movs	r2, #0
 8009db8:	731a      	strb	r2, [r3, #12]
	temp1[13] = 0x02;
 8009dba:	4b0d      	ldr	r3, [pc, #52]	; (8009df0 <MQTT_ConnectF1+0x90>)
 8009dbc:	2202      	movs	r2, #2
 8009dbe:	735a      	strb	r2, [r3, #13]

	temp1[14] = 'P';
 8009dc0:	4b0b      	ldr	r3, [pc, #44]	; (8009df0 <MQTT_ConnectF1+0x90>)
 8009dc2:	2250      	movs	r2, #80	; 0x50
 8009dc4:	739a      	strb	r2, [r3, #14]
	temp1[15] = '2';
 8009dc6:	4b0a      	ldr	r3, [pc, #40]	; (8009df0 <MQTT_ConnectF1+0x90>)
 8009dc8:	2232      	movs	r2, #50	; 0x32
 8009dca:	73da      	strb	r2, [r3, #15]

	mqttInfo.length = 16;
 8009dcc:	4b09      	ldr	r3, [pc, #36]	; (8009df4 <MQTT_ConnectF1+0x94>)
 8009dce:	2210      	movs	r2, #16
 8009dd0:	609a      	str	r2, [r3, #8]
	WifiState = IP_Send;
 8009dd2:	4b09      	ldr	r3, [pc, #36]	; (8009df8 <MQTT_ConnectF1+0x98>)
 8009dd4:	220e      	movs	r2, #14
 8009dd6:	701a      	strb	r2, [r3, #0]
	mqttFlag.connect = 1;
 8009dd8:	4b08      	ldr	r3, [pc, #32]	; (8009dfc <MQTT_ConnectF1+0x9c>)
 8009dda:	2201      	movs	r2, #1
 8009ddc:	70da      	strb	r2, [r3, #3]
	mqttFlag.send = 1;
 8009dde:	4b07      	ldr	r3, [pc, #28]	; (8009dfc <MQTT_ConnectF1+0x9c>)
 8009de0:	2201      	movs	r2, #1
 8009de2:	711a      	strb	r2, [r3, #4]
	//GSM_Send_Bin(temp1, 16);
}
 8009de4:	46c0      	nop			; (mov r8, r8)
 8009de6:	46bd      	mov	sp, r7
 8009de8:	bd80      	pop	{r7, pc}
 8009dea:	46c0      	nop			; (mov r8, r8)
 8009dec:	08015a74 	.word	0x08015a74
 8009df0:	200023a0 	.word	0x200023a0
 8009df4:	20001698 	.word	0x20001698
 8009df8:	200000c4 	.word	0x200000c4
 8009dfc:	20001b1c 	.word	0x20001b1c

08009e00 <MQTT_SuscribeF1>:

void MQTT_SuscribeF1(){
 8009e00:	b580      	push	{r7, lr}
 8009e02:	af00      	add	r7, sp, #0
	Debug_Send("Build subscribe msg\r\n");
 8009e04:	4b1c      	ldr	r3, [pc, #112]	; (8009e78 <MQTT_SuscribeF1+0x78>)
 8009e06:	0018      	movs	r0, r3
 8009e08:	f7ff fa42 	bl	8009290 <Debug_Send>
	temp1[0] = 0x82;
 8009e0c:	4b1b      	ldr	r3, [pc, #108]	; (8009e7c <MQTT_SuscribeF1+0x7c>)
 8009e0e:	2282      	movs	r2, #130	; 0x82
 8009e10:	701a      	strb	r2, [r3, #0]
	temp1[1] = 0x0A;
 8009e12:	4b1a      	ldr	r3, [pc, #104]	; (8009e7c <MQTT_SuscribeF1+0x7c>)
 8009e14:	220a      	movs	r2, #10
 8009e16:	705a      	strb	r2, [r3, #1]
	temp1[2] = 0x00;
 8009e18:	4b18      	ldr	r3, [pc, #96]	; (8009e7c <MQTT_SuscribeF1+0x7c>)
 8009e1a:	2200      	movs	r2, #0
 8009e1c:	709a      	strb	r2, [r3, #2]
	temp1[3] = 0x00;
 8009e1e:	4b17      	ldr	r3, [pc, #92]	; (8009e7c <MQTT_SuscribeF1+0x7c>)
 8009e20:	2200      	movs	r2, #0
 8009e22:	70da      	strb	r2, [r3, #3]
	temp1[4] = 0x00;
 8009e24:	4b15      	ldr	r3, [pc, #84]	; (8009e7c <MQTT_SuscribeF1+0x7c>)
 8009e26:	2200      	movs	r2, #0
 8009e28:	711a      	strb	r2, [r3, #4]
	temp1[5] = 0x05;
 8009e2a:	4b14      	ldr	r3, [pc, #80]	; (8009e7c <MQTT_SuscribeF1+0x7c>)
 8009e2c:	2205      	movs	r2, #5
 8009e2e:	715a      	strb	r2, [r3, #5]
	temp1[6] = 'h';
 8009e30:	4b12      	ldr	r3, [pc, #72]	; (8009e7c <MQTT_SuscribeF1+0x7c>)
 8009e32:	2268      	movs	r2, #104	; 0x68
 8009e34:	719a      	strb	r2, [r3, #6]
	temp1[7] = 'o';
 8009e36:	4b11      	ldr	r3, [pc, #68]	; (8009e7c <MQTT_SuscribeF1+0x7c>)
 8009e38:	226f      	movs	r2, #111	; 0x6f
 8009e3a:	71da      	strb	r2, [r3, #7]
	temp1[8] = 'u';
 8009e3c:	4b0f      	ldr	r3, [pc, #60]	; (8009e7c <MQTT_SuscribeF1+0x7c>)
 8009e3e:	2275      	movs	r2, #117	; 0x75
 8009e40:	721a      	strb	r2, [r3, #8]
	temp1[9] = 's';
 8009e42:	4b0e      	ldr	r3, [pc, #56]	; (8009e7c <MQTT_SuscribeF1+0x7c>)
 8009e44:	2273      	movs	r2, #115	; 0x73
 8009e46:	725a      	strb	r2, [r3, #9]
	temp1[10] = 'e';
 8009e48:	4b0c      	ldr	r3, [pc, #48]	; (8009e7c <MQTT_SuscribeF1+0x7c>)
 8009e4a:	2265      	movs	r2, #101	; 0x65
 8009e4c:	729a      	strb	r2, [r3, #10]
	temp1[11] = 0x00;
 8009e4e:	4b0b      	ldr	r3, [pc, #44]	; (8009e7c <MQTT_SuscribeF1+0x7c>)
 8009e50:	2200      	movs	r2, #0
 8009e52:	72da      	strb	r2, [r3, #11]
	temp1[12] = 0x00;
 8009e54:	4b09      	ldr	r3, [pc, #36]	; (8009e7c <MQTT_SuscribeF1+0x7c>)
 8009e56:	2200      	movs	r2, #0
 8009e58:	731a      	strb	r2, [r3, #12]

	mqttInfo.length = 13;
 8009e5a:	4b09      	ldr	r3, [pc, #36]	; (8009e80 <MQTT_SuscribeF1+0x80>)
 8009e5c:	220d      	movs	r2, #13
 8009e5e:	609a      	str	r2, [r3, #8]
	WifiState = IP_Send;
 8009e60:	4b08      	ldr	r3, [pc, #32]	; (8009e84 <MQTT_SuscribeF1+0x84>)
 8009e62:	220e      	movs	r2, #14
 8009e64:	701a      	strb	r2, [r3, #0]
	mqttFlag.subscribe = 1;
 8009e66:	4b08      	ldr	r3, [pc, #32]	; (8009e88 <MQTT_SuscribeF1+0x88>)
 8009e68:	2201      	movs	r2, #1
 8009e6a:	705a      	strb	r2, [r3, #1]
	mqttFlag.send = 1;
 8009e6c:	4b06      	ldr	r3, [pc, #24]	; (8009e88 <MQTT_SuscribeF1+0x88>)
 8009e6e:	2201      	movs	r2, #1
 8009e70:	711a      	strb	r2, [r3, #4]
	//GSM_Send_Bin(tempGPRS, 13);
}
 8009e72:	46c0      	nop			; (mov r8, r8)
 8009e74:	46bd      	mov	sp, r7
 8009e76:	bd80      	pop	{r7, pc}
 8009e78:	08015a88 	.word	0x08015a88
 8009e7c:	200023a0 	.word	0x200023a0
 8009e80:	20001698 	.word	0x20001698
 8009e84:	200000c4 	.word	0x200000c4
 8009e88:	20001b1c 	.word	0x20001b1c

08009e8c <MQTT_Publish_F1>:

void MQTT_Publish_F1(){
 8009e8c:	b580      	push	{r7, lr}
 8009e8e:	af00      	add	r7, sp, #0
	Debug_Send("Build publish msg\r\n");
 8009e90:	4b1c      	ldr	r3, [pc, #112]	; (8009f04 <MQTT_Publish_F1+0x78>)
 8009e92:	0018      	movs	r0, r3
 8009e94:	f7ff f9fc 	bl	8009290 <Debug_Send>
	temp1[0] = 0x30;
 8009e98:	4b1b      	ldr	r3, [pc, #108]	; (8009f08 <MQTT_Publish_F1+0x7c>)
 8009e9a:	2230      	movs	r2, #48	; 0x30
 8009e9c:	701a      	strb	r2, [r3, #0]
	temp1[1] = 0x0B;
 8009e9e:	4b1a      	ldr	r3, [pc, #104]	; (8009f08 <MQTT_Publish_F1+0x7c>)
 8009ea0:	220b      	movs	r2, #11
 8009ea2:	705a      	strb	r2, [r3, #1]
	temp1[2] = 0x00;
 8009ea4:	4b18      	ldr	r3, [pc, #96]	; (8009f08 <MQTT_Publish_F1+0x7c>)
 8009ea6:	2200      	movs	r2, #0
 8009ea8:	709a      	strb	r2, [r3, #2]
	temp1[3] = 0x05;
 8009eaa:	4b17      	ldr	r3, [pc, #92]	; (8009f08 <MQTT_Publish_F1+0x7c>)
 8009eac:	2205      	movs	r2, #5
 8009eae:	70da      	strb	r2, [r3, #3]
	temp1[4] = 'h';
 8009eb0:	4b15      	ldr	r3, [pc, #84]	; (8009f08 <MQTT_Publish_F1+0x7c>)
 8009eb2:	2268      	movs	r2, #104	; 0x68
 8009eb4:	711a      	strb	r2, [r3, #4]
	temp1[5] = 'o';
 8009eb6:	4b14      	ldr	r3, [pc, #80]	; (8009f08 <MQTT_Publish_F1+0x7c>)
 8009eb8:	226f      	movs	r2, #111	; 0x6f
 8009eba:	715a      	strb	r2, [r3, #5]
	temp1[6] = 'u';
 8009ebc:	4b12      	ldr	r3, [pc, #72]	; (8009f08 <MQTT_Publish_F1+0x7c>)
 8009ebe:	2275      	movs	r2, #117	; 0x75
 8009ec0:	719a      	strb	r2, [r3, #6]
	temp1[7] = 's';
 8009ec2:	4b11      	ldr	r3, [pc, #68]	; (8009f08 <MQTT_Publish_F1+0x7c>)
 8009ec4:	2273      	movs	r2, #115	; 0x73
 8009ec6:	71da      	strb	r2, [r3, #7]
	temp1[8] = 'e';
 8009ec8:	4b0f      	ldr	r3, [pc, #60]	; (8009f08 <MQTT_Publish_F1+0x7c>)
 8009eca:	2265      	movs	r2, #101	; 0x65
 8009ecc:	721a      	strb	r2, [r3, #8]
	temp1[9] = 'o';
 8009ece:	4b0e      	ldr	r3, [pc, #56]	; (8009f08 <MQTT_Publish_F1+0x7c>)
 8009ed0:	226f      	movs	r2, #111	; 0x6f
 8009ed2:	725a      	strb	r2, [r3, #9]
	temp1[10] = 'f';
 8009ed4:	4b0c      	ldr	r3, [pc, #48]	; (8009f08 <MQTT_Publish_F1+0x7c>)
 8009ed6:	2266      	movs	r2, #102	; 0x66
 8009ed8:	729a      	strb	r2, [r3, #10]
	temp1[11] = 'f';
 8009eda:	4b0b      	ldr	r3, [pc, #44]	; (8009f08 <MQTT_Publish_F1+0x7c>)
 8009edc:	2266      	movs	r2, #102	; 0x66
 8009ede:	72da      	strb	r2, [r3, #11]
	temp1[12] = '1';
 8009ee0:	4b09      	ldr	r3, [pc, #36]	; (8009f08 <MQTT_Publish_F1+0x7c>)
 8009ee2:	2231      	movs	r2, #49	; 0x31
 8009ee4:	731a      	strb	r2, [r3, #12]

	mqttInfo.length = 13;
 8009ee6:	4b09      	ldr	r3, [pc, #36]	; (8009f0c <MQTT_Publish_F1+0x80>)
 8009ee8:	220d      	movs	r2, #13
 8009eea:	609a      	str	r2, [r3, #8]
	WifiState = IP_Send;
 8009eec:	4b08      	ldr	r3, [pc, #32]	; (8009f10 <MQTT_Publish_F1+0x84>)
 8009eee:	220e      	movs	r2, #14
 8009ef0:	701a      	strb	r2, [r3, #0]
	mqttFlag.publish = 1;
 8009ef2:	4b08      	ldr	r3, [pc, #32]	; (8009f14 <MQTT_Publish_F1+0x88>)
 8009ef4:	2201      	movs	r2, #1
 8009ef6:	719a      	strb	r2, [r3, #6]
	mqttFlag.send = 1;
 8009ef8:	4b06      	ldr	r3, [pc, #24]	; (8009f14 <MQTT_Publish_F1+0x88>)
 8009efa:	2201      	movs	r2, #1
 8009efc:	711a      	strb	r2, [r3, #4]
	//GSM_Send_Bin(temp1, 14);
}
 8009efe:	46c0      	nop			; (mov r8, r8)
 8009f00:	46bd      	mov	sp, r7
 8009f02:	bd80      	pop	{r7, pc}
 8009f04:	08015aa0 	.word	0x08015aa0
 8009f08:	200023a0 	.word	0x200023a0
 8009f0c:	20001698 	.word	0x20001698
 8009f10:	200000c4 	.word	0x200000c4
 8009f14:	20001b1c 	.word	0x20001b1c

08009f18 <MQTT_Publish_F2>:

void MQTT_Publish_F2(uint8_t *data){
 8009f18:	b580      	push	{r7, lr}
 8009f1a:	b084      	sub	sp, #16
 8009f1c:	af00      	add	r7, sp, #0
 8009f1e:	6078      	str	r0, [r7, #4]
	Debug_Send("Publish Func\n");
 8009f20:	4b33      	ldr	r3, [pc, #204]	; (8009ff0 <MQTT_Publish_F2+0xd8>)
 8009f22:	0018      	movs	r0, r3
 8009f24:	f7ff f9b4 	bl	8009290 <Debug_Send>
	temp1[0] = 0x30;
 8009f28:	4b32      	ldr	r3, [pc, #200]	; (8009ff4 <MQTT_Publish_F2+0xdc>)
 8009f2a:	2230      	movs	r2, #48	; 0x30
 8009f2c:	701a      	strb	r2, [r3, #0]
	temp1[1] = 0x0A;
 8009f2e:	4b31      	ldr	r3, [pc, #196]	; (8009ff4 <MQTT_Publish_F2+0xdc>)
 8009f30:	220a      	movs	r2, #10
 8009f32:	705a      	strb	r2, [r3, #1]
	temp1[2] = 0x00;
 8009f34:	4b2f      	ldr	r3, [pc, #188]	; (8009ff4 <MQTT_Publish_F2+0xdc>)
 8009f36:	2200      	movs	r2, #0
 8009f38:	709a      	strb	r2, [r3, #2]
	temp1[3] = 0x05;
 8009f3a:	4b2e      	ldr	r3, [pc, #184]	; (8009ff4 <MQTT_Publish_F2+0xdc>)
 8009f3c:	2205      	movs	r2, #5
 8009f3e:	70da      	strb	r2, [r3, #3]
	temp1[4] = 'h';
 8009f40:	4b2c      	ldr	r3, [pc, #176]	; (8009ff4 <MQTT_Publish_F2+0xdc>)
 8009f42:	2268      	movs	r2, #104	; 0x68
 8009f44:	711a      	strb	r2, [r3, #4]
	temp1[5] = 'o';
 8009f46:	4b2b      	ldr	r3, [pc, #172]	; (8009ff4 <MQTT_Publish_F2+0xdc>)
 8009f48:	226f      	movs	r2, #111	; 0x6f
 8009f4a:	715a      	strb	r2, [r3, #5]
	temp1[6] = 'u';
 8009f4c:	4b29      	ldr	r3, [pc, #164]	; (8009ff4 <MQTT_Publish_F2+0xdc>)
 8009f4e:	2275      	movs	r2, #117	; 0x75
 8009f50:	719a      	strb	r2, [r3, #6]
	temp1[7] = 's';
 8009f52:	4b28      	ldr	r3, [pc, #160]	; (8009ff4 <MQTT_Publish_F2+0xdc>)
 8009f54:	2273      	movs	r2, #115	; 0x73
 8009f56:	71da      	strb	r2, [r3, #7]
	temp1[8] = 'e';
 8009f58:	4b26      	ldr	r3, [pc, #152]	; (8009ff4 <MQTT_Publish_F2+0xdc>)
 8009f5a:	2265      	movs	r2, #101	; 0x65
 8009f5c:	721a      	strb	r2, [r3, #8]
	temp1[9] = 'o';
 8009f5e:	4b25      	ldr	r3, [pc, #148]	; (8009ff4 <MQTT_Publish_F2+0xdc>)
 8009f60:	226f      	movs	r2, #111	; 0x6f
 8009f62:	725a      	strb	r2, [r3, #9]
	temp1[10] = 'f';
 8009f64:	4b23      	ldr	r3, [pc, #140]	; (8009ff4 <MQTT_Publish_F2+0xdc>)
 8009f66:	2266      	movs	r2, #102	; 0x66
 8009f68:	729a      	strb	r2, [r3, #10]
	temp1[11] = 'f';
 8009f6a:	4b22      	ldr	r3, [pc, #136]	; (8009ff4 <MQTT_Publish_F2+0xdc>)
 8009f6c:	2266      	movs	r2, #102	; 0x66
 8009f6e:	72da      	strb	r2, [r3, #11]

	int counter;
	counter = 9;
 8009f70:	2309      	movs	r3, #9
 8009f72:	60fb      	str	r3, [r7, #12]
	while(*data != 0){
 8009f74:	e00b      	b.n	8009f8e <MQTT_Publish_F2+0x76>
		temp1[counter] = *data++;
 8009f76:	687b      	ldr	r3, [r7, #4]
 8009f78:	1c5a      	adds	r2, r3, #1
 8009f7a:	607a      	str	r2, [r7, #4]
 8009f7c:	7819      	ldrb	r1, [r3, #0]
 8009f7e:	4a1d      	ldr	r2, [pc, #116]	; (8009ff4 <MQTT_Publish_F2+0xdc>)
 8009f80:	68fb      	ldr	r3, [r7, #12]
 8009f82:	18d3      	adds	r3, r2, r3
 8009f84:	1c0a      	adds	r2, r1, #0
 8009f86:	701a      	strb	r2, [r3, #0]
		counter++;
 8009f88:	68fb      	ldr	r3, [r7, #12]
 8009f8a:	3301      	adds	r3, #1
 8009f8c:	60fb      	str	r3, [r7, #12]
	while(*data != 0){
 8009f8e:	687b      	ldr	r3, [r7, #4]
 8009f90:	781b      	ldrb	r3, [r3, #0]
 8009f92:	2b00      	cmp	r3, #0
 8009f94:	d1ef      	bne.n	8009f76 <MQTT_Publish_F2+0x5e>
	}

	myLongStr(counter,temp,10,10);
 8009f96:	4918      	ldr	r1, [pc, #96]	; (8009ff8 <MQTT_Publish_F2+0xe0>)
 8009f98:	68f8      	ldr	r0, [r7, #12]
 8009f9a:	230a      	movs	r3, #10
 8009f9c:	220a      	movs	r2, #10
 8009f9e:	f000 fd77 	bl	800aa90 <myLongStr>
	Debug_Send("Chars added:");
 8009fa2:	4b16      	ldr	r3, [pc, #88]	; (8009ffc <MQTT_Publish_F2+0xe4>)
 8009fa4:	0018      	movs	r0, r3
 8009fa6:	f7ff f973 	bl	8009290 <Debug_Send>
	Debug_Send(temp);
 8009faa:	4b13      	ldr	r3, [pc, #76]	; (8009ff8 <MQTT_Publish_F2+0xe0>)
 8009fac:	0018      	movs	r0, r3
 8009fae:	f7ff f96f 	bl	8009290 <Debug_Send>
	Debug_Send("\r\n");
 8009fb2:	4b13      	ldr	r3, [pc, #76]	; (800a000 <MQTT_Publish_F2+0xe8>)
 8009fb4:	0018      	movs	r0, r3
 8009fb6:	f7ff f96b 	bl	8009290 <Debug_Send>

	mqttInfo.length = counter;
 8009fba:	4b12      	ldr	r3, [pc, #72]	; (800a004 <MQTT_Publish_F2+0xec>)
 8009fbc:	68fa      	ldr	r2, [r7, #12]
 8009fbe:	609a      	str	r2, [r3, #8]
	/*tempGPRS[counter] = 0x1A;
	counter++;
	tempGPRS[counter] = 0x0D;
	counter++;*/
	WifiState = IP_Send;
 8009fc0:	4b11      	ldr	r3, [pc, #68]	; (800a008 <MQTT_Publish_F2+0xf0>)
 8009fc2:	220e      	movs	r2, #14
 8009fc4:	701a      	strb	r2, [r3, #0]
	mqttFlag.publish = 1;
 8009fc6:	4b11      	ldr	r3, [pc, #68]	; (800a00c <MQTT_Publish_F2+0xf4>)
 8009fc8:	2201      	movs	r2, #1
 8009fca:	719a      	strb	r2, [r3, #6]
	mqttFlag.send = 1;
 8009fcc:	4b0f      	ldr	r3, [pc, #60]	; (800a00c <MQTT_Publish_F2+0xf4>)
 8009fce:	2201      	movs	r2, #1
 8009fd0:	711a      	strb	r2, [r3, #4]
	//GSM_Send_Bin(tempGPRS, 14);
	//mqttInfo.length = 14;
	//mqttInfo.length = counter;
	temp1[1] = counter - 2;
 8009fd2:	68fb      	ldr	r3, [r7, #12]
 8009fd4:	b2db      	uxtb	r3, r3
 8009fd6:	3b02      	subs	r3, #2
 8009fd8:	b2da      	uxtb	r2, r3
 8009fda:	4b06      	ldr	r3, [pc, #24]	; (8009ff4 <MQTT_Publish_F2+0xdc>)
 8009fdc:	705a      	strb	r2, [r3, #1]
	Debug_Send("Publish sent\r\n");
 8009fde:	4b0c      	ldr	r3, [pc, #48]	; (800a010 <MQTT_Publish_F2+0xf8>)
 8009fe0:	0018      	movs	r0, r3
 8009fe2:	f7ff f955 	bl	8009290 <Debug_Send>
	/*myLongStr(mqttInfo.length,temp1,10,10);
	Debug_Send("Length:");
	Debug_Send(temp1);
	Debug_Send("\r\n");*/
}
 8009fe6:	46c0      	nop			; (mov r8, r8)
 8009fe8:	46bd      	mov	sp, r7
 8009fea:	b004      	add	sp, #16
 8009fec:	bd80      	pop	{r7, pc}
 8009fee:	46c0      	nop			; (mov r8, r8)
 8009ff0:	08015ab4 	.word	0x08015ab4
 8009ff4:	200023a0 	.word	0x200023a0
 8009ff8:	2000231c 	.word	0x2000231c
 8009ffc:	08015ac4 	.word	0x08015ac4
 800a000:	08015930 	.word	0x08015930
 800a004:	20001698 	.word	0x20001698
 800a008:	200000c4 	.word	0x200000c4
 800a00c:	20001b1c 	.word	0x20001b1c
 800a010:	08015ad4 	.word	0x08015ad4

0800a014 <WifiprocData>:

void SendData(char * data){

}

void WifiprocData(char* data){
 800a014:	b590      	push	{r4, r7, lr}
 800a016:	b08b      	sub	sp, #44	; 0x2c
 800a018:	af02      	add	r7, sp, #8
 800a01a:	6078      	str	r0, [r7, #4]
	//Debug_Send("Process Wifi msg\r\n");
	strcpy(temp,"Rx:");
 800a01c:	4aa1      	ldr	r2, [pc, #644]	; (800a2a4 <WifiprocData+0x290>)
 800a01e:	4ba2      	ldr	r3, [pc, #648]	; (800a2a8 <WifiprocData+0x294>)
 800a020:	0010      	movs	r0, r2
 800a022:	0019      	movs	r1, r3
 800a024:	2304      	movs	r3, #4
 800a026:	001a      	movs	r2, r3
 800a028:	f00a ffea 	bl	8015000 <memcpy>
	strcat(temp,data);
 800a02c:	687a      	ldr	r2, [r7, #4]
 800a02e:	4b9d      	ldr	r3, [pc, #628]	; (800a2a4 <WifiprocData+0x290>)
 800a030:	0011      	movs	r1, r2
 800a032:	0018      	movs	r0, r3
 800a034:	f00b f816 	bl	8015064 <strcat>
	//strcat(temp,"\r\n");
	Debug_Send(temp);
 800a038:	4b9a      	ldr	r3, [pc, #616]	; (800a2a4 <WifiprocData+0x290>)
 800a03a:	0018      	movs	r0, r3
 800a03c:	f7ff f928 	bl	8009290 <Debug_Send>

	myStrSection(WprocBuff, temp,30,',',1);
 800a040:	4998      	ldr	r1, [pc, #608]	; (800a2a4 <WifiprocData+0x290>)
 800a042:	489a      	ldr	r0, [pc, #616]	; (800a2ac <WifiprocData+0x298>)
 800a044:	2301      	movs	r3, #1
 800a046:	9300      	str	r3, [sp, #0]
 800a048:	232c      	movs	r3, #44	; 0x2c
 800a04a:	221e      	movs	r2, #30
 800a04c:	f000 fc8b 	bl	800a966 <myStrSection>
	if(strncmp((char*)temp,"CONNECT",7)==0){			//socket connected
 800a050:	4997      	ldr	r1, [pc, #604]	; (800a2b0 <WifiprocData+0x29c>)
 800a052:	4b94      	ldr	r3, [pc, #592]	; (800a2a4 <WifiprocData+0x290>)
 800a054:	2207      	movs	r2, #7
 800a056:	0018      	movs	r0, r3
 800a058:	f00b f819 	bl	801508e <strncmp>
 800a05c:	1e03      	subs	r3, r0, #0
 800a05e:	d11a      	bne.n	800a096 <WifiprocData+0x82>
		myStrSection(WprocBuff, ConnID,30,',',0);
 800a060:	4994      	ldr	r1, [pc, #592]	; (800a2b4 <WifiprocData+0x2a0>)
 800a062:	4892      	ldr	r0, [pc, #584]	; (800a2ac <WifiprocData+0x298>)
 800a064:	2300      	movs	r3, #0
 800a066:	9300      	str	r3, [sp, #0]
 800a068:	232c      	movs	r3, #44	; 0x2c
 800a06a:	221e      	movs	r2, #30
 800a06c:	f000 fc7b 	bl	800a966 <myStrSection>
		sprintf(temp, "Conn %s connected\r\n",ConnID);
 800a070:	4a90      	ldr	r2, [pc, #576]	; (800a2b4 <WifiprocData+0x2a0>)
 800a072:	4991      	ldr	r1, [pc, #580]	; (800a2b8 <WifiprocData+0x2a4>)
 800a074:	4b8b      	ldr	r3, [pc, #556]	; (800a2a4 <WifiprocData+0x290>)
 800a076:	0018      	movs	r0, r3
 800a078:	f00a ffd4 	bl	8015024 <siprintf>
		Debug_Send(temp);
 800a07c:	4b89      	ldr	r3, [pc, #548]	; (800a2a4 <WifiprocData+0x290>)
 800a07e:	0018      	movs	r0, r3
 800a080:	f7ff f906 	bl	8009290 <Debug_Send>
		wifiFlag.connect = 1;
 800a084:	4b8d      	ldr	r3, [pc, #564]	; (800a2bc <WifiprocData+0x2a8>)
 800a086:	2201      	movs	r2, #1
 800a088:	701a      	strb	r2, [r3, #0]
		if (wifiFlag.server == 0){
 800a08a:	4b8c      	ldr	r3, [pc, #560]	; (800a2bc <WifiprocData+0x2a8>)
 800a08c:	791b      	ldrb	r3, [r3, #4]
 800a08e:	2b00      	cmp	r3, #0
 800a090:	d101      	bne.n	800a096 <WifiprocData+0x82>
			MQTT_ConnectF1();
 800a092:	f7ff fe65 	bl	8009d60 <MQTT_ConnectF1>
		}
	}
	if(strncmp((char*)temp,"CLOSED",6)==0){			//socket closed
 800a096:	498a      	ldr	r1, [pc, #552]	; (800a2c0 <WifiprocData+0x2ac>)
 800a098:	4b82      	ldr	r3, [pc, #520]	; (800a2a4 <WifiprocData+0x290>)
 800a09a:	2206      	movs	r2, #6
 800a09c:	0018      	movs	r0, r3
 800a09e:	f00a fff6 	bl	801508e <strncmp>
 800a0a2:	1e03      	subs	r3, r0, #0
 800a0a4:	d11a      	bne.n	800a0dc <WifiprocData+0xc8>
		myStrSection(WprocBuff, ConnID,30,',',0);
 800a0a6:	4983      	ldr	r1, [pc, #524]	; (800a2b4 <WifiprocData+0x2a0>)
 800a0a8:	4880      	ldr	r0, [pc, #512]	; (800a2ac <WifiprocData+0x298>)
 800a0aa:	2300      	movs	r3, #0
 800a0ac:	9300      	str	r3, [sp, #0]
 800a0ae:	232c      	movs	r3, #44	; 0x2c
 800a0b0:	221e      	movs	r2, #30
 800a0b2:	f000 fc58 	bl	800a966 <myStrSection>
		sprintf(temp, "Conn %s closed\r\n",ConnID);
 800a0b6:	4a7f      	ldr	r2, [pc, #508]	; (800a2b4 <WifiprocData+0x2a0>)
 800a0b8:	4982      	ldr	r1, [pc, #520]	; (800a2c4 <WifiprocData+0x2b0>)
 800a0ba:	4b7a      	ldr	r3, [pc, #488]	; (800a2a4 <WifiprocData+0x290>)
 800a0bc:	0018      	movs	r0, r3
 800a0be:	f00a ffb1 	bl	8015024 <siprintf>
		Debug_Send(temp);
 800a0c2:	4b78      	ldr	r3, [pc, #480]	; (800a2a4 <WifiprocData+0x290>)
 800a0c4:	0018      	movs	r0, r3
 800a0c6:	f7ff f8e3 	bl	8009290 <Debug_Send>
		wifiFlag.connect = 0;
 800a0ca:	4b7c      	ldr	r3, [pc, #496]	; (800a2bc <WifiprocData+0x2a8>)
 800a0cc:	2200      	movs	r2, #0
 800a0ce:	701a      	strb	r2, [r3, #0]
		mqttFlag.subscribe = 0;
 800a0d0:	4b7d      	ldr	r3, [pc, #500]	; (800a2c8 <WifiprocData+0x2b4>)
 800a0d2:	2200      	movs	r2, #0
 800a0d4:	705a      	strb	r2, [r3, #1]
		WifiState = Dial;
 800a0d6:	4b7d      	ldr	r3, [pc, #500]	; (800a2cc <WifiprocData+0x2b8>)
 800a0d8:	220d      	movs	r2, #13
 800a0da:	701a      	strb	r2, [r3, #0]
			//MQTT_ConnectF1();
		}
	}
	//GSM_Send(WprocBuff);
	//GSM_Send("\r\n");
	if(strncmp((char*)WprocBuff,"+CREG: 0,1",10)==0)HAL_GPIO_TogglePin(LED1_GPIO_Port, LED1_Pin);
 800a0dc:	497c      	ldr	r1, [pc, #496]	; (800a2d0 <WifiprocData+0x2bc>)
 800a0de:	4b73      	ldr	r3, [pc, #460]	; (800a2ac <WifiprocData+0x298>)
 800a0e0:	220a      	movs	r2, #10
 800a0e2:	0018      	movs	r0, r3
 800a0e4:	f00a ffd3 	bl	801508e <strncmp>
 800a0e8:	1e03      	subs	r3, r0, #0
 800a0ea:	d106      	bne.n	800a0fa <WifiprocData+0xe6>
 800a0ec:	2380      	movs	r3, #128	; 0x80
 800a0ee:	01db      	lsls	r3, r3, #7
 800a0f0:	4a78      	ldr	r2, [pc, #480]	; (800a2d4 <WifiprocData+0x2c0>)
 800a0f2:	0019      	movs	r1, r3
 800a0f4:	0010      	movs	r0, r2
 800a0f6:	f001 fb60 	bl	800b7ba <HAL_GPIO_TogglePin>
	if(strncmp((char*)WprocBuff,"OK",2)==0) WifiOK();
 800a0fa:	4977      	ldr	r1, [pc, #476]	; (800a2d8 <WifiprocData+0x2c4>)
 800a0fc:	4b6b      	ldr	r3, [pc, #428]	; (800a2ac <WifiprocData+0x298>)
 800a0fe:	2202      	movs	r2, #2
 800a100:	0018      	movs	r0, r3
 800a102:	f00a ffc4 	bl	801508e <strncmp>
 800a106:	1e03      	subs	r3, r0, #0
 800a108:	d101      	bne.n	800a10e <WifiprocData+0xfa>
 800a10a:	f000 f95d 	bl	800a3c8 <WifiOK>
	//if(strncmp((char*)WprocBuff,"Ai",2)==0) WifiState = Wifi_version;
	//if(strncmp((char*)WprocBuff,"No AP",5)==0) WifiState = Connect;

	//if(strncmp((char*)WprocBuff,"WIFI CONNECTED",14)==0) WifiState = Connect;	//connected to AP
	if(strncmp((char*)WprocBuff,"WIFI GOT IP",10)==0) WifiState = GetIP;		//connected to AP
 800a10e:	4973      	ldr	r1, [pc, #460]	; (800a2dc <WifiprocData+0x2c8>)
 800a110:	4b66      	ldr	r3, [pc, #408]	; (800a2ac <WifiprocData+0x298>)
 800a112:	220a      	movs	r2, #10
 800a114:	0018      	movs	r0, r3
 800a116:	f00a ffba 	bl	801508e <strncmp>
 800a11a:	1e03      	subs	r3, r0, #0
 800a11c:	d102      	bne.n	800a124 <WifiprocData+0x110>
 800a11e:	4b6b      	ldr	r3, [pc, #428]	; (800a2cc <WifiprocData+0x2b8>)
 800a120:	2204      	movs	r2, #4
 800a122:	701a      	strb	r2, [r3, #0]
	if(strncmp((char*)WprocBuff,"no change",9)==0) WifiState = 0;		//server running
 800a124:	496e      	ldr	r1, [pc, #440]	; (800a2e0 <WifiprocData+0x2cc>)
 800a126:	4b61      	ldr	r3, [pc, #388]	; (800a2ac <WifiprocData+0x298>)
 800a128:	2209      	movs	r2, #9
 800a12a:	0018      	movs	r0, r3
 800a12c:	f00a ffaf 	bl	801508e <strncmp>
 800a130:	1e03      	subs	r3, r0, #0
 800a132:	d102      	bne.n	800a13a <WifiprocData+0x126>
 800a134:	4b65      	ldr	r3, [pc, #404]	; (800a2cc <WifiprocData+0x2b8>)
 800a136:	2200      	movs	r2, #0
 800a138:	701a      	strb	r2, [r3, #0]

	if(strncmp((char*)WprocBuff,"+CWJAP:",7)==0){
 800a13a:	496a      	ldr	r1, [pc, #424]	; (800a2e4 <WifiprocData+0x2d0>)
 800a13c:	4b5b      	ldr	r3, [pc, #364]	; (800a2ac <WifiprocData+0x298>)
 800a13e:	2207      	movs	r2, #7
 800a140:	0018      	movs	r0, r3
 800a142:	f00a ffa4 	bl	801508e <strncmp>
 800a146:	1e03      	subs	r3, r0, #0
 800a148:	d112      	bne.n	800a170 <WifiprocData+0x15c>
		myStrSection(WprocBuff, temp,30,'"',1);
 800a14a:	4956      	ldr	r1, [pc, #344]	; (800a2a4 <WifiprocData+0x290>)
 800a14c:	4857      	ldr	r0, [pc, #348]	; (800a2ac <WifiprocData+0x298>)
 800a14e:	2301      	movs	r3, #1
 800a150:	9300      	str	r3, [sp, #0]
 800a152:	2322      	movs	r3, #34	; 0x22
 800a154:	221e      	movs	r2, #30
 800a156:	f000 fc06 	bl	800a966 <myStrSection>
		if(strncmp(temp,ssid,5)==0) WifiState = GetIP;
 800a15a:	4963      	ldr	r1, [pc, #396]	; (800a2e8 <WifiprocData+0x2d4>)
 800a15c:	4b51      	ldr	r3, [pc, #324]	; (800a2a4 <WifiprocData+0x290>)
 800a15e:	2205      	movs	r2, #5
 800a160:	0018      	movs	r0, r3
 800a162:	f00a ff94 	bl	801508e <strncmp>
 800a166:	1e03      	subs	r3, r0, #0
 800a168:	d102      	bne.n	800a170 <WifiprocData+0x15c>
 800a16a:	4b58      	ldr	r3, [pc, #352]	; (800a2cc <WifiprocData+0x2b8>)
 800a16c:	2204      	movs	r2, #4
 800a16e:	701a      	strb	r2, [r3, #0]

	}
	if(strncmp((char*)WprocBuff,"+CIFSR:STAIP",12)==0){
 800a170:	495e      	ldr	r1, [pc, #376]	; (800a2ec <WifiprocData+0x2d8>)
 800a172:	4b4e      	ldr	r3, [pc, #312]	; (800a2ac <WifiprocData+0x298>)
 800a174:	220c      	movs	r2, #12
 800a176:	0018      	movs	r0, r3
 800a178:	f00a ff89 	bl	801508e <strncmp>
 800a17c:	1e03      	subs	r3, r0, #0
 800a17e:	d10d      	bne.n	800a19c <WifiprocData+0x188>
		//GSM_Send(WprocBuff);
		//GSM_Send("\r\n");
		myStrSection(WprocBuff, IP1,30,'"',1);
 800a180:	495b      	ldr	r1, [pc, #364]	; (800a2f0 <WifiprocData+0x2dc>)
 800a182:	484a      	ldr	r0, [pc, #296]	; (800a2ac <WifiprocData+0x298>)
 800a184:	2301      	movs	r3, #1
 800a186:	9300      	str	r3, [sp, #0]
 800a188:	2322      	movs	r3, #34	; 0x22
 800a18a:	221e      	movs	r2, #30
 800a18c:	f000 fbeb 	bl	800a966 <myStrSection>
		wifiFlag.print = 1;
 800a190:	4b4a      	ldr	r3, [pc, #296]	; (800a2bc <WifiprocData+0x2a8>)
 800a192:	2201      	movs	r2, #1
 800a194:	70da      	strb	r2, [r3, #3]
		if (wifiFlag.ip == 3){
			GSM_Send("Copy4\r\n");
			strcpy(IP4,WprocBuff);
			//
		}*/
		wifiFlag.ip = 1;
 800a196:	4b49      	ldr	r3, [pc, #292]	; (800a2bc <WifiprocData+0x2a8>)
 800a198:	2201      	movs	r2, #1
 800a19a:	709a      	strb	r2, [r3, #2]
	}
	if(strncmp((char*)WprocBuff,"+IPD",3)==0){
 800a19c:	4955      	ldr	r1, [pc, #340]	; (800a2f4 <WifiprocData+0x2e0>)
 800a19e:	4b43      	ldr	r3, [pc, #268]	; (800a2ac <WifiprocData+0x298>)
 800a1a0:	2203      	movs	r2, #3
 800a1a2:	0018      	movs	r0, r3
 800a1a4:	f00a ff73 	bl	801508e <strncmp>
 800a1a8:	1e03      	subs	r3, r0, #0
 800a1aa:	d151      	bne.n	800a250 <WifiprocData+0x23c>
		Debug_Send("Got IPD\r\n");
 800a1ac:	4b52      	ldr	r3, [pc, #328]	; (800a2f8 <WifiprocData+0x2e4>)
 800a1ae:	0018      	movs	r0, r3
 800a1b0:	f7ff f86e 	bl	8009290 <Debug_Send>
		char len[10];
		int ln1;
		int start = 9;
 800a1b4:	2309      	movs	r3, #9
 800a1b6:	61fb      	str	r3, [r7, #28]
		int counter;
		myStrSection(WprocBuff, len,30,',',2);		//returned length
 800a1b8:	240c      	movs	r4, #12
 800a1ba:	1939      	adds	r1, r7, r4
 800a1bc:	483b      	ldr	r0, [pc, #236]	; (800a2ac <WifiprocData+0x298>)
 800a1be:	2302      	movs	r3, #2
 800a1c0:	9300      	str	r3, [sp, #0]
 800a1c2:	232c      	movs	r3, #44	; 0x2c
 800a1c4:	221e      	movs	r2, #30
 800a1c6:	f000 fbce 	bl	800a966 <myStrSection>
		if (len[1] == ':') len[1] = 0;
 800a1ca:	0022      	movs	r2, r4
 800a1cc:	18bb      	adds	r3, r7, r2
 800a1ce:	785b      	ldrb	r3, [r3, #1]
 800a1d0:	2b3a      	cmp	r3, #58	; 0x3a
 800a1d2:	d103      	bne.n	800a1dc <WifiprocData+0x1c8>
 800a1d4:	18bb      	adds	r3, r7, r2
 800a1d6:	2200      	movs	r2, #0
 800a1d8:	705a      	strb	r2, [r3, #1]
 800a1da:	e005      	b.n	800a1e8 <WifiprocData+0x1d4>
		else{
			len[2] = 0;
 800a1dc:	230c      	movs	r3, #12
 800a1de:	18fb      	adds	r3, r7, r3
 800a1e0:	2200      	movs	r2, #0
 800a1e2:	709a      	strb	r2, [r3, #2]
			start = 10;
 800a1e4:	230a      	movs	r3, #10
 800a1e6:	61fb      	str	r3, [r7, #28]
		}
		//mqttInfo.length = atoi(temp);
		ln1 =  myStrLong(len,10);
 800a1e8:	230c      	movs	r3, #12
 800a1ea:	18fb      	adds	r3, r7, r3
 800a1ec:	210a      	movs	r1, #10
 800a1ee:	0018      	movs	r0, r3
 800a1f0:	f000 fd46 	bl	800ac80 <myStrLong>
 800a1f4:	0003      	movs	r3, r0
 800a1f6:	61bb      	str	r3, [r7, #24]
		if(mqttFlag.active == 0) myStrSection(WprocBuff, temp,30,':',1);
 800a1f8:	4b33      	ldr	r3, [pc, #204]	; (800a2c8 <WifiprocData+0x2b4>)
 800a1fa:	789b      	ldrb	r3, [r3, #2]
 800a1fc:	2b00      	cmp	r3, #0
 800a1fe:	d108      	bne.n	800a212 <WifiprocData+0x1fe>
 800a200:	4928      	ldr	r1, [pc, #160]	; (800a2a4 <WifiprocData+0x290>)
 800a202:	482a      	ldr	r0, [pc, #168]	; (800a2ac <WifiprocData+0x298>)
 800a204:	2301      	movs	r3, #1
 800a206:	9300      	str	r3, [sp, #0]
 800a208:	233a      	movs	r3, #58	; 0x3a
 800a20a:	221e      	movs	r2, #30
 800a20c:	f000 fbab 	bl	800a966 <myStrSection>
 800a210:	e00c      	b.n	800a22c <WifiprocData+0x218>
		else{
			byteCopy(WprocBuff, temp, start, start + ln1);
 800a212:	69fb      	ldr	r3, [r7, #28]
 800a214:	b2dc      	uxtb	r4, r3
 800a216:	69fb      	ldr	r3, [r7, #28]
 800a218:	b2da      	uxtb	r2, r3
 800a21a:	69bb      	ldr	r3, [r7, #24]
 800a21c:	b2db      	uxtb	r3, r3
 800a21e:	18d3      	adds	r3, r2, r3
 800a220:	b2db      	uxtb	r3, r3
 800a222:	4920      	ldr	r1, [pc, #128]	; (800a2a4 <WifiprocData+0x290>)
 800a224:	4821      	ldr	r0, [pc, #132]	; (800a2ac <WifiprocData+0x298>)
 800a226:	0022      	movs	r2, r4
 800a228:	f000 f870 	bl	800a30c <byteCopy>
		}
		myStrSection(WprocBuff, ConnID,30,',',1);
 800a22c:	4921      	ldr	r1, [pc, #132]	; (800a2b4 <WifiprocData+0x2a0>)
 800a22e:	481f      	ldr	r0, [pc, #124]	; (800a2ac <WifiprocData+0x298>)
 800a230:	2301      	movs	r3, #1
 800a232:	9300      	str	r3, [sp, #0]
 800a234:	232c      	movs	r3, #44	; 0x2c
 800a236:	221e      	movs	r2, #30
 800a238:	f000 fb95 	bl	800a966 <myStrSection>
			if(strncmp(temp,"on",2) == 0){
				HAL_GPIO_WritePin(LED4_GPIO_Port, LED4_Pin, GPIO_PIN_RESET);
				Debug_Send("Light off\r\n");
			}
		}*/
		Debug_Send("Processed IPD\r\n");
 800a23c:	4b2f      	ldr	r3, [pc, #188]	; (800a2fc <WifiprocData+0x2e8>)
 800a23e:	0018      	movs	r0, r3
 800a240:	f7ff f826 	bl	8009290 <Debug_Send>
		//int hlen;
		//hlen = strlen(HTML);
		//sprintf(temp, "Conn %s received:%s\r\n",ConnID, temp1);
		//GSM_Send(temp);
		wifiFlag.print = 0;
 800a244:	4b1d      	ldr	r3, [pc, #116]	; (800a2bc <WifiprocData+0x2a8>)
 800a246:	2200      	movs	r2, #0
 800a248:	70da      	strb	r2, [r3, #3]
		mqttFlag.receive = 0;
 800a24a:	4b1f      	ldr	r3, [pc, #124]	; (800a2c8 <WifiprocData+0x2b4>)
 800a24c:	2200      	movs	r2, #0
 800a24e:	715a      	strb	r2, [r3, #5]
	}
	if (wifiFlag.print == 1){
		//sprintf(temp, "%s,%i,%i\r\n",WprocBuff, WrecBuffPointerWrite, WrecBuffPointerRead);
		//GSM_Send(temp);
	}
	if(strncmp((char*)WprocBuff,"Accept",6)==0){
 800a250:	492b      	ldr	r1, [pc, #172]	; (800a300 <WifiprocData+0x2ec>)
 800a252:	4b16      	ldr	r3, [pc, #88]	; (800a2ac <WifiprocData+0x298>)
 800a254:	2206      	movs	r2, #6
 800a256:	0018      	movs	r0, r3
 800a258:	f00a ff19 	bl	801508e <strncmp>
		//Debug_Send("Processed IPD\r\n");
		//WifiState = IP_Send;
	}
	wifiFlag.print = 1;
 800a25c:	4b17      	ldr	r3, [pc, #92]	; (800a2bc <WifiprocData+0x2a8>)
 800a25e:	2201      	movs	r2, #1
 800a260:	70da      	strb	r2, [r3, #3]
	//if(strncmp((char*)WprocBuff,"busy s...",9)==0) wifiFlag.print = 1;	//BUSY SENDING DATA
	//if(strncmp((char*)WprocBuff,"Recv 5 bytes",4)==0) wifiFlag.print = 1;	//DATA SENT
	if(strncmp((char*)WprocBuff,"SEND OK",7)==0){
 800a262:	4928      	ldr	r1, [pc, #160]	; (800a304 <WifiprocData+0x2f0>)
 800a264:	4b11      	ldr	r3, [pc, #68]	; (800a2ac <WifiprocData+0x298>)
 800a266:	2207      	movs	r2, #7
 800a268:	0018      	movs	r0, r3
 800a26a:	f00a ff10 	bl	801508e <strncmp>
 800a26e:	1e03      	subs	r3, r0, #0
 800a270:	d113      	bne.n	800a29a <WifiprocData+0x286>
		Debug_Send("SUCCESSFULLY SENT DATA\r\n");
 800a272:	4b25      	ldr	r3, [pc, #148]	; (800a308 <WifiprocData+0x2f4>)
 800a274:	0018      	movs	r0, r3
 800a276:	f7ff f80b 	bl	8009290 <Debug_Send>
		//wifiFlag.print = 1;	//SEND DONE
		//Debug_Send("Close socket\r\n");
		//mqttFlag.Data = 1;
		if (mqttFlag.send == 1){
 800a27a:	4b13      	ldr	r3, [pc, #76]	; (800a2c8 <WifiprocData+0x2b4>)
 800a27c:	791b      	ldrb	r3, [r3, #4]
 800a27e:	2b01      	cmp	r3, #1
 800a280:	d10b      	bne.n	800a29a <WifiprocData+0x286>
			//Debug_Send("Flush data\r\n");
			WifiState =  Wifi_AT;
 800a282:	4b12      	ldr	r3, [pc, #72]	; (800a2cc <WifiprocData+0x2b8>)
 800a284:	2202      	movs	r2, #2
 800a286:	701a      	strb	r2, [r3, #0]
			mqttFlag.send = 0;
 800a288:	4b0f      	ldr	r3, [pc, #60]	; (800a2c8 <WifiprocData+0x2b4>)
 800a28a:	2200      	movs	r2, #0
 800a28c:	711a      	strb	r2, [r3, #4]
			mqttFlag.receive = 1;
 800a28e:	4b0e      	ldr	r3, [pc, #56]	; (800a2c8 <WifiprocData+0x2b4>)
 800a290:	2201      	movs	r2, #1
 800a292:	715a      	strb	r2, [r3, #5]
			WifiState =  0;
 800a294:	4b0d      	ldr	r3, [pc, #52]	; (800a2cc <WifiprocData+0x2b8>)
 800a296:	2200      	movs	r2, #0
 800a298:	701a      	strb	r2, [r3, #0]
		}
		//if (mqttFlag.active == 0) WifiState =  Close_Socket;
	}
}
 800a29a:	46c0      	nop			; (mov r8, r8)
 800a29c:	46bd      	mov	sp, r7
 800a29e:	b009      	add	sp, #36	; 0x24
 800a2a0:	bd90      	pop	{r4, r7, pc}
 800a2a2:	46c0      	nop			; (mov r8, r8)
 800a2a4:	2000231c 	.word	0x2000231c
 800a2a8:	08015af8 	.word	0x08015af8
 800a2ac:	20002598 	.word	0x20002598
 800a2b0:	08015afc 	.word	0x08015afc
 800a2b4:	20002594 	.word	0x20002594
 800a2b8:	08015b04 	.word	0x08015b04
 800a2bc:	20002660 	.word	0x20002660
 800a2c0:	08015b18 	.word	0x08015b18
 800a2c4:	08015b20 	.word	0x08015b20
 800a2c8:	20001b1c 	.word	0x20001b1c
 800a2cc:	200000c4 	.word	0x200000c4
 800a2d0:	08015b34 	.word	0x08015b34
 800a2d4:	48000800 	.word	0x48000800
 800a2d8:	08015b40 	.word	0x08015b40
 800a2dc:	08015b44 	.word	0x08015b44
 800a2e0:	08015b50 	.word	0x08015b50
 800a2e4:	08015b5c 	.word	0x08015b5c
 800a2e8:	200000c8 	.word	0x200000c8
 800a2ec:	08015b64 	.word	0x08015b64
 800a2f0:	20001da4 	.word	0x20001da4
 800a2f4:	08015b74 	.word	0x08015b74
 800a2f8:	08015b7c 	.word	0x08015b7c
 800a2fc:	08015b88 	.word	0x08015b88
 800a300:	08015b98 	.word	0x08015b98
 800a304:	08015ba0 	.word	0x08015ba0
 800a308:	08015ba8 	.word	0x08015ba8

0800a30c <byteCopy>:

int byteCopy(uint8_t *source, uint8_t *dest, uint8_t start, uint8_t stop){
 800a30c:	b580      	push	{r7, lr}
 800a30e:	b088      	sub	sp, #32
 800a310:	af00      	add	r7, sp, #0
 800a312:	60f8      	str	r0, [r7, #12]
 800a314:	60b9      	str	r1, [r7, #8]
 800a316:	0019      	movs	r1, r3
 800a318:	1dfb      	adds	r3, r7, #7
 800a31a:	701a      	strb	r2, [r3, #0]
 800a31c:	1dbb      	adds	r3, r7, #6
 800a31e:	1c0a      	adds	r2, r1, #0
 800a320:	701a      	strb	r2, [r3, #0]
	 int val;
	 val = -1;
 800a322:	2301      	movs	r3, #1
 800a324:	425b      	negs	r3, r3
 800a326:	61bb      	str	r3, [r7, #24]
	 if (start > stop){
 800a328:	1dfa      	adds	r2, r7, #7
 800a32a:	1dbb      	adds	r3, r7, #6
 800a32c:	7812      	ldrb	r2, [r2, #0]
 800a32e:	781b      	ldrb	r3, [r3, #0]
 800a330:	429a      	cmp	r2, r3
 800a332:	d906      	bls.n	800a342 <byteCopy+0x36>
		 Debug_Send("Index error\r\n");
 800a334:	4b23      	ldr	r3, [pc, #140]	; (800a3c4 <byteCopy+0xb8>)
 800a336:	0018      	movs	r0, r3
 800a338:	f7fe ffaa 	bl	8009290 <Debug_Send>
		 return -1;
 800a33c:	2301      	movs	r3, #1
 800a33e:	425b      	negs	r3, r3
 800a340:	e03b      	b.n	800a3ba <byteCopy+0xae>
	 }
	 uint8_t difference;
	 uint8_t count;
	 uint8_t* source1;
	 difference = stop - start + 1;
 800a342:	1dba      	adds	r2, r7, #6
 800a344:	1dfb      	adds	r3, r7, #7
 800a346:	7812      	ldrb	r2, [r2, #0]
 800a348:	781b      	ldrb	r3, [r3, #0]
 800a34a:	1ad3      	subs	r3, r2, r3
 800a34c:	b2da      	uxtb	r2, r3
 800a34e:	2317      	movs	r3, #23
 800a350:	18fb      	adds	r3, r7, r3
 800a352:	3201      	adds	r2, #1
 800a354:	701a      	strb	r2, [r3, #0]
	 source += start;
 800a356:	1dfb      	adds	r3, r7, #7
 800a358:	781b      	ldrb	r3, [r3, #0]
 800a35a:	68fa      	ldr	r2, [r7, #12]
 800a35c:	18d3      	adds	r3, r2, r3
 800a35e:	60fb      	str	r3, [r7, #12]
	 source1 = source;
 800a360:	68fb      	ldr	r3, [r7, #12]
 800a362:	613b      	str	r3, [r7, #16]
	 source1 += start;
 800a364:	1dfb      	adds	r3, r7, #7
 800a366:	781b      	ldrb	r3, [r3, #0]
 800a368:	693a      	ldr	r2, [r7, #16]
 800a36a:	18d3      	adds	r3, r2, r3
 800a36c:	613b      	str	r3, [r7, #16]
	 for (count = 0; count < difference; count++){
 800a36e:	231f      	movs	r3, #31
 800a370:	18fb      	adds	r3, r7, r3
 800a372:	2200      	movs	r2, #0
 800a374:	701a      	strb	r2, [r3, #0]
 800a376:	e00f      	b.n	800a398 <byteCopy+0x8c>
		 *dest = *source;
 800a378:	68fb      	ldr	r3, [r7, #12]
 800a37a:	781a      	ldrb	r2, [r3, #0]
 800a37c:	68bb      	ldr	r3, [r7, #8]
 800a37e:	701a      	strb	r2, [r3, #0]
		 dest++;
 800a380:	68bb      	ldr	r3, [r7, #8]
 800a382:	3301      	adds	r3, #1
 800a384:	60bb      	str	r3, [r7, #8]
		 source++;
 800a386:	68fb      	ldr	r3, [r7, #12]
 800a388:	3301      	adds	r3, #1
 800a38a:	60fb      	str	r3, [r7, #12]
	 for (count = 0; count < difference; count++){
 800a38c:	211f      	movs	r1, #31
 800a38e:	187b      	adds	r3, r7, r1
 800a390:	781a      	ldrb	r2, [r3, #0]
 800a392:	187b      	adds	r3, r7, r1
 800a394:	3201      	adds	r2, #1
 800a396:	701a      	strb	r2, [r3, #0]
 800a398:	231f      	movs	r3, #31
 800a39a:	18fa      	adds	r2, r7, r3
 800a39c:	2317      	movs	r3, #23
 800a39e:	18fb      	adds	r3, r7, r3
 800a3a0:	7812      	ldrb	r2, [r2, #0]
 800a3a2:	781b      	ldrb	r3, [r3, #0]
 800a3a4:	429a      	cmp	r2, r3
 800a3a6:	d3e7      	bcc.n	800a378 <byteCopy+0x6c>
	 }
	 dest++;
 800a3a8:	68bb      	ldr	r3, [r7, #8]
 800a3aa:	3301      	adds	r3, #1
 800a3ac:	60bb      	str	r3, [r7, #8]
	 *dest = 0;
 800a3ae:	68bb      	ldr	r3, [r7, #8]
 800a3b0:	2200      	movs	r2, #0
 800a3b2:	701a      	strb	r2, [r3, #0]
	 //Debug_Send(dest);
	 //Debug_Send("\r\n");
	 val = 1;
 800a3b4:	2301      	movs	r3, #1
 800a3b6:	61bb      	str	r3, [r7, #24]
	 return val;
 800a3b8:	69bb      	ldr	r3, [r7, #24]
}
 800a3ba:	0018      	movs	r0, r3
 800a3bc:	46bd      	mov	sp, r7
 800a3be:	b008      	add	sp, #32
 800a3c0:	bd80      	pop	{r7, pc}
 800a3c2:	46c0      	nop			; (mov r8, r8)
 800a3c4:	08015bc4 	.word	0x08015bc4

0800a3c8 <WifiOK>:

void WifiOK(){
 800a3c8:	b580      	push	{r7, lr}
 800a3ca:	b082      	sub	sp, #8
 800a3cc:	af02      	add	r7, sp, #8
	//sprintf(temp, "%s,%i,%i,%i\r\n",WprocBuff, WrecBuffPointerWrite, WrecBuffPointerRead,wifiFlag.ip);
	//GSM_Send(temp);
	if(wifiFlag.list == 1){
 800a3ce:	4b1c      	ldr	r3, [pc, #112]	; (800a440 <WifiOK+0x78>)
 800a3d0:	785b      	ldrb	r3, [r3, #1]
 800a3d2:	2b01      	cmp	r3, #1
 800a3d4:	d105      	bne.n	800a3e2 <WifiOK+0x1a>
		wifiFlag.list = 0;
 800a3d6:	4b1a      	ldr	r3, [pc, #104]	; (800a440 <WifiOK+0x78>)
 800a3d8:	2200      	movs	r2, #0
 800a3da:	705a      	strb	r2, [r3, #1]
		WifiState = GetIP;
 800a3dc:	4b19      	ldr	r3, [pc, #100]	; (800a444 <WifiOK+0x7c>)
 800a3de:	2204      	movs	r2, #4
 800a3e0:	701a      	strb	r2, [r3, #0]
	}
	if (wifiFlag.ip == 1){
 800a3e2:	4b17      	ldr	r3, [pc, #92]	; (800a440 <WifiOK+0x78>)
 800a3e4:	789b      	ldrb	r3, [r3, #2]
 800a3e6:	2b01      	cmp	r3, #1
 800a3e8:	d127      	bne.n	800a43a <WifiOK+0x72>
		wifiFlag.ip = 0;
 800a3ea:	4b15      	ldr	r3, [pc, #84]	; (800a440 <WifiOK+0x78>)
 800a3ec:	2200      	movs	r2, #0
 800a3ee:	709a      	strb	r2, [r3, #2]
		Debug_Send(IP1);
 800a3f0:	4b15      	ldr	r3, [pc, #84]	; (800a448 <WifiOK+0x80>)
 800a3f2:	0018      	movs	r0, r3
 800a3f4:	f7fe ff4c 	bl	8009290 <Debug_Send>
		Debug_Send("\r\n");
 800a3f8:	4b14      	ldr	r3, [pc, #80]	; (800a44c <WifiOK+0x84>)
 800a3fa:	0018      	movs	r0, r3
 800a3fc:	f7fe ff48 	bl	8009290 <Debug_Send>
		myStrSection(IP1, temp,30,'.',0);
 800a400:	4913      	ldr	r1, [pc, #76]	; (800a450 <WifiOK+0x88>)
 800a402:	4811      	ldr	r0, [pc, #68]	; (800a448 <WifiOK+0x80>)
 800a404:	2300      	movs	r3, #0
 800a406:	9300      	str	r3, [sp, #0]
 800a408:	232e      	movs	r3, #46	; 0x2e
 800a40a:	221e      	movs	r2, #30
 800a40c:	f000 faab 	bl	800a966 <myStrSection>
		if (strncmp(temp,"0",1) != 0){
 800a410:	4b0f      	ldr	r3, [pc, #60]	; (800a450 <WifiOK+0x88>)
 800a412:	781a      	ldrb	r2, [r3, #0]
 800a414:	4b0f      	ldr	r3, [pc, #60]	; (800a454 <WifiOK+0x8c>)
 800a416:	781b      	ldrb	r3, [r3, #0]
 800a418:	1ad3      	subs	r3, r2, r3
 800a41a:	d00a      	beq.n	800a432 <WifiOK+0x6a>
			wifiFlag.ip = 2;
 800a41c:	4b08      	ldr	r3, [pc, #32]	; (800a440 <WifiOK+0x78>)
 800a41e:	2202      	movs	r2, #2
 800a420:	709a      	strb	r2, [r3, #2]
			WifiState = CPMUX;
 800a422:	4b08      	ldr	r3, [pc, #32]	; (800a444 <WifiOK+0x7c>)
 800a424:	2209      	movs	r2, #9
 800a426:	701a      	strb	r2, [r3, #0]
			Debug_Send("IP found\r\n");
 800a428:	4b0b      	ldr	r3, [pc, #44]	; (800a458 <WifiOK+0x90>)
 800a42a:	0018      	movs	r0, r3
 800a42c:	f7fe ff30 	bl	8009290 <Debug_Send>
		GSM_Send("\r\n");
		GSM_Send(IP4);
		GSM_Send("\r\n");*/
	}
	//Debug_Send("Got OK\r\n");
}
 800a430:	e003      	b.n	800a43a <WifiOK+0x72>
			Debug_Send("IP not found\r\n");
 800a432:	4b0a      	ldr	r3, [pc, #40]	; (800a45c <WifiOK+0x94>)
 800a434:	0018      	movs	r0, r3
 800a436:	f7fe ff2b 	bl	8009290 <Debug_Send>
}
 800a43a:	46c0      	nop			; (mov r8, r8)
 800a43c:	46bd      	mov	sp, r7
 800a43e:	bd80      	pop	{r7, pc}
 800a440:	20002660 	.word	0x20002660
 800a444:	200000c4 	.word	0x200000c4
 800a448:	20001da4 	.word	0x20001da4
 800a44c:	08015930 	.word	0x08015930
 800a450:	2000231c 	.word	0x2000231c
 800a454:	08015bd4 	.word	0x08015bd4
 800a458:	08015bd8 	.word	0x08015bd8
 800a45c:	08015be4 	.word	0x08015be4

0800a460 <Wifi_Receive>:
void Wifi_Receive(char in){
 800a460:	b580      	push	{r7, lr}
 800a462:	b082      	sub	sp, #8
 800a464:	af00      	add	r7, sp, #0
 800a466:	0002      	movs	r2, r0
 800a468:	1dfb      	adds	r3, r7, #7
 800a46a:	701a      	strb	r2, [r3, #0]
	//
	WrecBuff[WrecBuffPointerWrite] = (char)in;
 800a46c:	4b0b      	ldr	r3, [pc, #44]	; (800a49c <Wifi_Receive+0x3c>)
 800a46e:	681b      	ldr	r3, [r3, #0]
 800a470:	4a0b      	ldr	r2, [pc, #44]	; (800a4a0 <Wifi_Receive+0x40>)
 800a472:	1df9      	adds	r1, r7, #7
 800a474:	7809      	ldrb	r1, [r1, #0]
 800a476:	54d1      	strb	r1, [r2, r3]
	//HAL_UART_Transmit(&huart1, recBuff[recBuffPointerWrite], 2, 10);
	//huart1.Instance->TDR = in;
	WrecBuffPointerWrite++;
 800a478:	4b08      	ldr	r3, [pc, #32]	; (800a49c <Wifi_Receive+0x3c>)
 800a47a:	681b      	ldr	r3, [r3, #0]
 800a47c:	1c5a      	adds	r2, r3, #1
 800a47e:	4b07      	ldr	r3, [pc, #28]	; (800a49c <Wifi_Receive+0x3c>)
 800a480:	601a      	str	r2, [r3, #0]
	if (WrecBuffPointerWrite > WrecBuffSize) WrecBuffPointerWrite = 0;
 800a482:	4b06      	ldr	r3, [pc, #24]	; (800a49c <Wifi_Receive+0x3c>)
 800a484:	681b      	ldr	r3, [r3, #0]
 800a486:	4a07      	ldr	r2, [pc, #28]	; (800a4a4 <Wifi_Receive+0x44>)
 800a488:	4293      	cmp	r3, r2
 800a48a:	dd02      	ble.n	800a492 <Wifi_Receive+0x32>
 800a48c:	4b03      	ldr	r3, [pc, #12]	; (800a49c <Wifi_Receive+0x3c>)
 800a48e:	2200      	movs	r2, #0
 800a490:	601a      	str	r2, [r3, #0]

}
 800a492:	46c0      	nop			; (mov r8, r8)
 800a494:	46bd      	mov	sp, r7
 800a496:	b002      	add	sp, #8
 800a498:	bd80      	pop	{r7, pc}
 800a49a:	46c0      	nop			; (mov r8, r8)
 800a49c:	20000368 	.word	0x20000368
 800a4a0:	20001e08 	.word	0x20001e08
 800a4a4:	00000514 	.word	0x00000514

0800a4a8 <vApplicationGetIdleTaskMemory>:
/* USER CODE BEGIN GET_IDLE_TASK_MEMORY */
static StaticTask_t xIdleTaskTCBBuffer;
static StackType_t xIdleStack[configMINIMAL_STACK_SIZE];

void vApplicationGetIdleTaskMemory( StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, uint32_t *pulIdleTaskStackSize )
{
 800a4a8:	b580      	push	{r7, lr}
 800a4aa:	b084      	sub	sp, #16
 800a4ac:	af00      	add	r7, sp, #0
 800a4ae:	60f8      	str	r0, [r7, #12]
 800a4b0:	60b9      	str	r1, [r7, #8]
 800a4b2:	607a      	str	r2, [r7, #4]
  *ppxIdleTaskTCBBuffer = &xIdleTaskTCBBuffer;
 800a4b4:	68fb      	ldr	r3, [r7, #12]
 800a4b6:	4a06      	ldr	r2, [pc, #24]	; (800a4d0 <vApplicationGetIdleTaskMemory+0x28>)
 800a4b8:	601a      	str	r2, [r3, #0]
  *ppxIdleTaskStackBuffer = &xIdleStack[0];
 800a4ba:	68bb      	ldr	r3, [r7, #8]
 800a4bc:	4a05      	ldr	r2, [pc, #20]	; (800a4d4 <vApplicationGetIdleTaskMemory+0x2c>)
 800a4be:	601a      	str	r2, [r3, #0]
  *pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;
 800a4c0:	687b      	ldr	r3, [r7, #4]
 800a4c2:	2280      	movs	r2, #128	; 0x80
 800a4c4:	601a      	str	r2, [r3, #0]
  /* place for user code */
}
 800a4c6:	46c0      	nop			; (mov r8, r8)
 800a4c8:	46bd      	mov	sp, r7
 800a4ca:	b004      	add	sp, #16
 800a4cc:	bd80      	pop	{r7, pc}
 800a4ce:	46c0      	nop			; (mov r8, r8)
 800a4d0:	20000374 	.word	0x20000374
 800a4d4:	200003c8 	.word	0x200003c8

0800a4d8 <main>:
/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
 800a4d8:	b5b0      	push	{r4, r5, r7, lr}
 800a4da:	b08e      	sub	sp, #56	; 0x38
 800a4dc:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN 1 */
	remap();
 800a4de:	f000 f9d7 	bl	800a890 <remap>
  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();
 800a4e2:	f000 fdf1 	bl	800b0c8 <HAL_Init>
  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();
 800a4e6:	f000 f847 	bl	800a578 <SystemClock_Config>
  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
 800a4ea:	f000 f93f 	bl	800a76c <MX_GPIO_Init>
  MX_SPI2_Init();
 800a4ee:	f000 f89f 	bl	800a630 <MX_SPI2_Init>
  MX_USART1_UART_Init();
 800a4f2:	f000 f8db 	bl	800a6ac <MX_USART1_UART_Init>
  MX_USART2_UART_Init();
 800a4f6:	f000 f909 	bl	800a70c <MX_USART2_UART_Init>
  /* USER CODE BEGIN 2 */
  HAL_GPIO_WritePin(CS_GPIO_Port, CS_Pin,GPIO_PIN_SET);
 800a4fa:	2380      	movs	r3, #128	; 0x80
 800a4fc:	0059      	lsls	r1, r3, #1
 800a4fe:	2390      	movs	r3, #144	; 0x90
 800a500:	05db      	lsls	r3, r3, #23
 800a502:	2201      	movs	r2, #1
 800a504:	0018      	movs	r0, r3
 800a506:	f001 f93b 	bl	800b780 <HAL_GPIO_WritePin>
  //GSM_Init();
  Wifi_Init();
 800a50a:	f7fe ff33 	bl	8009374 <Wifi_Init>
  HAL_GPIO_WritePin(LED1_GPIO_Port, LED1_Pin,GPIO_PIN_SET);		//wifi enable
 800a50e:	2380      	movs	r3, #128	; 0x80
 800a510:	01db      	lsls	r3, r3, #7
 800a512:	4814      	ldr	r0, [pc, #80]	; (800a564 <main+0x8c>)
 800a514:	2201      	movs	r2, #1
 800a516:	0019      	movs	r1, r3
 800a518:	f001 f932 	bl	800b780 <HAL_GPIO_WritePin>
  /* add queues, ... */
  /* USER CODE END RTOS_QUEUES */

  /* Create the thread(s) */
  /* definition and creation of defaultTask */
  osThreadDef(defaultTask, StartDefaultTask, osPriorityNormal, 0, 128);
 800a51c:	211c      	movs	r1, #28
 800a51e:	187b      	adds	r3, r7, r1
 800a520:	4a11      	ldr	r2, [pc, #68]	; (800a568 <main+0x90>)
 800a522:	ca31      	ldmia	r2!, {r0, r4, r5}
 800a524:	c331      	stmia	r3!, {r0, r4, r5}
 800a526:	ca31      	ldmia	r2!, {r0, r4, r5}
 800a528:	c331      	stmia	r3!, {r0, r4, r5}
 800a52a:	6812      	ldr	r2, [r2, #0]
 800a52c:	601a      	str	r2, [r3, #0]
  defaultTaskHandle = osThreadCreate(osThread(defaultTask), NULL);
 800a52e:	187b      	adds	r3, r7, r1
 800a530:	2100      	movs	r1, #0
 800a532:	0018      	movs	r0, r3
 800a534:	f008 ff8b 	bl	801344e <osThreadCreate>
 800a538:	0002      	movs	r2, r0
 800a53a:	4b0c      	ldr	r3, [pc, #48]	; (800a56c <main+0x94>)
 800a53c:	601a      	str	r2, [r3, #0]

  /* definition and creation of myTask02 */
  osThreadDef(myTask02, StartTask02, osPriorityIdle, 0, 128);
 800a53e:	003b      	movs	r3, r7
 800a540:	4a0b      	ldr	r2, [pc, #44]	; (800a570 <main+0x98>)
 800a542:	ca13      	ldmia	r2!, {r0, r1, r4}
 800a544:	c313      	stmia	r3!, {r0, r1, r4}
 800a546:	ca13      	ldmia	r2!, {r0, r1, r4}
 800a548:	c313      	stmia	r3!, {r0, r1, r4}
 800a54a:	6812      	ldr	r2, [r2, #0]
 800a54c:	601a      	str	r2, [r3, #0]
  myTask02Handle = osThreadCreate(osThread(myTask02), NULL);
 800a54e:	003b      	movs	r3, r7
 800a550:	2100      	movs	r1, #0
 800a552:	0018      	movs	r0, r3
 800a554:	f008 ff7b 	bl	801344e <osThreadCreate>
 800a558:	0002      	movs	r2, r0
 800a55a:	4b06      	ldr	r3, [pc, #24]	; (800a574 <main+0x9c>)
 800a55c:	601a      	str	r2, [r3, #0]
  /* USER CODE BEGIN RTOS_THREADS */
  /* add threads, ... */
  /* USER CODE END RTOS_THREADS */

  /* Start scheduler */
  osKernelStart();
 800a55e:	f008 ff6e 	bl	801343e <osKernelStart>

  /* We should never get here as control is now taken by the scheduler */
  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
 800a562:	e7fe      	b.n	800a562 <main+0x8a>
 800a564:	48000800 	.word	0x48000800
 800a568:	08015c0c 	.word	0x08015c0c
 800a56c:	2000266c 	.word	0x2000266c
 800a570:	08015c28 	.word	0x08015c28
 800a574:	20002758 	.word	0x20002758

0800a578 <SystemClock_Config>:
/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
 800a578:	b590      	push	{r4, r7, lr}
 800a57a:	b099      	sub	sp, #100	; 0x64
 800a57c:	af00      	add	r7, sp, #0
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 800a57e:	242c      	movs	r4, #44	; 0x2c
 800a580:	193b      	adds	r3, r7, r4
 800a582:	0018      	movs	r0, r3
 800a584:	2334      	movs	r3, #52	; 0x34
 800a586:	001a      	movs	r2, r3
 800a588:	2100      	movs	r1, #0
 800a58a:	f00a fd42 	bl	8015012 <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 800a58e:	231c      	movs	r3, #28
 800a590:	18fb      	adds	r3, r7, r3
 800a592:	0018      	movs	r0, r3
 800a594:	2310      	movs	r3, #16
 800a596:	001a      	movs	r2, r3
 800a598:	2100      	movs	r1, #0
 800a59a:	f00a fd3a 	bl	8015012 <memset>
  RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
 800a59e:	003b      	movs	r3, r7
 800a5a0:	0018      	movs	r0, r3
 800a5a2:	231c      	movs	r3, #28
 800a5a4:	001a      	movs	r2, r3
 800a5a6:	2100      	movs	r1, #0
 800a5a8:	f00a fd33 	bl	8015012 <memset>

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI48;
 800a5ac:	193b      	adds	r3, r7, r4
 800a5ae:	2220      	movs	r2, #32
 800a5b0:	601a      	str	r2, [r3, #0]
  RCC_OscInitStruct.HSI48State = RCC_HSI48_ON;
 800a5b2:	193b      	adds	r3, r7, r4
 800a5b4:	2201      	movs	r2, #1
 800a5b6:	621a      	str	r2, [r3, #32]
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
 800a5b8:	193b      	adds	r3, r7, r4
 800a5ba:	2200      	movs	r2, #0
 800a5bc:	625a      	str	r2, [r3, #36]	; 0x24
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 800a5be:	193b      	adds	r3, r7, r4
 800a5c0:	0018      	movs	r0, r3
 800a5c2:	f002 ff87 	bl	800d4d4 <HAL_RCC_OscConfig>
 800a5c6:	1e03      	subs	r3, r0, #0
 800a5c8:	d001      	beq.n	800a5ce <SystemClock_Config+0x56>
  {
    Error_Handler();
 800a5ca:	f000 f9c7 	bl	800a95c <Error_Handler>
  }
  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 800a5ce:	211c      	movs	r1, #28
 800a5d0:	187b      	adds	r3, r7, r1
 800a5d2:	2207      	movs	r2, #7
 800a5d4:	601a      	str	r2, [r3, #0]
                              |RCC_CLOCKTYPE_PCLK1;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI48;
 800a5d6:	187b      	adds	r3, r7, r1
 800a5d8:	2203      	movs	r2, #3
 800a5da:	605a      	str	r2, [r3, #4]
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 800a5dc:	187b      	adds	r3, r7, r1
 800a5de:	2200      	movs	r2, #0
 800a5e0:	609a      	str	r2, [r3, #8]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
 800a5e2:	187b      	adds	r3, r7, r1
 800a5e4:	2280      	movs	r2, #128	; 0x80
 800a5e6:	00d2      	lsls	r2, r2, #3
 800a5e8:	60da      	str	r2, [r3, #12]

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK)
 800a5ea:	187b      	adds	r3, r7, r1
 800a5ec:	2101      	movs	r1, #1
 800a5ee:	0018      	movs	r0, r3
 800a5f0:	f003 faf6 	bl	800dbe0 <HAL_RCC_ClockConfig>
 800a5f4:	1e03      	subs	r3, r0, #0
 800a5f6:	d001      	beq.n	800a5fc <SystemClock_Config+0x84>
  {
    Error_Handler();
 800a5f8:	f000 f9b0 	bl	800a95c <Error_Handler>
  }
  PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USB|RCC_PERIPHCLK_USART1
 800a5fc:	003b      	movs	r3, r7
 800a5fe:	4a0b      	ldr	r2, [pc, #44]	; (800a62c <SystemClock_Config+0xb4>)
 800a600:	601a      	str	r2, [r3, #0]
                              |RCC_PERIPHCLK_USART2;
  PeriphClkInit.Usart1ClockSelection = RCC_USART1CLKSOURCE_PCLK1;
 800a602:	003b      	movs	r3, r7
 800a604:	2200      	movs	r2, #0
 800a606:	609a      	str	r2, [r3, #8]
  PeriphClkInit.Usart2ClockSelection = RCC_USART2CLKSOURCE_PCLK1;
 800a608:	003b      	movs	r3, r7
 800a60a:	2200      	movs	r2, #0
 800a60c:	60da      	str	r2, [r3, #12]
  PeriphClkInit.UsbClockSelection = RCC_USBCLKSOURCE_HSI48;
 800a60e:	003b      	movs	r3, r7
 800a610:	2200      	movs	r2, #0
 800a612:	619a      	str	r2, [r3, #24]

  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
 800a614:	003b      	movs	r3, r7
 800a616:	0018      	movs	r0, r3
 800a618:	f003 fc5c 	bl	800ded4 <HAL_RCCEx_PeriphCLKConfig>
 800a61c:	1e03      	subs	r3, r0, #0
 800a61e:	d001      	beq.n	800a624 <SystemClock_Config+0xac>
  {
    Error_Handler();
 800a620:	f000 f99c 	bl	800a95c <Error_Handler>
  }
}
 800a624:	46c0      	nop			; (mov r8, r8)
 800a626:	46bd      	mov	sp, r7
 800a628:	b019      	add	sp, #100	; 0x64
 800a62a:	bd90      	pop	{r4, r7, pc}
 800a62c:	00020003 	.word	0x00020003

0800a630 <MX_SPI2_Init>:
  * @brief SPI2 Initialization Function
  * @param None
  * @retval None
  */
static void MX_SPI2_Init(void)
{
 800a630:	b580      	push	{r7, lr}
 800a632:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN SPI2_Init 1 */

  /* USER CODE END SPI2_Init 1 */
  /* SPI2 parameter configuration*/
  hspi2.Instance = SPI2;
 800a634:	4b1b      	ldr	r3, [pc, #108]	; (800a6a4 <MX_SPI2_Init+0x74>)
 800a636:	4a1c      	ldr	r2, [pc, #112]	; (800a6a8 <MX_SPI2_Init+0x78>)
 800a638:	601a      	str	r2, [r3, #0]
  hspi2.Init.Mode = SPI_MODE_MASTER;
 800a63a:	4b1a      	ldr	r3, [pc, #104]	; (800a6a4 <MX_SPI2_Init+0x74>)
 800a63c:	2282      	movs	r2, #130	; 0x82
 800a63e:	0052      	lsls	r2, r2, #1
 800a640:	605a      	str	r2, [r3, #4]
  hspi2.Init.Direction = SPI_DIRECTION_2LINES;
 800a642:	4b18      	ldr	r3, [pc, #96]	; (800a6a4 <MX_SPI2_Init+0x74>)
 800a644:	2200      	movs	r2, #0
 800a646:	609a      	str	r2, [r3, #8]
  hspi2.Init.DataSize = SPI_DATASIZE_8BIT;
 800a648:	4b16      	ldr	r3, [pc, #88]	; (800a6a4 <MX_SPI2_Init+0x74>)
 800a64a:	22e0      	movs	r2, #224	; 0xe0
 800a64c:	00d2      	lsls	r2, r2, #3
 800a64e:	60da      	str	r2, [r3, #12]
  hspi2.Init.CLKPolarity = SPI_POLARITY_LOW;
 800a650:	4b14      	ldr	r3, [pc, #80]	; (800a6a4 <MX_SPI2_Init+0x74>)
 800a652:	2200      	movs	r2, #0
 800a654:	611a      	str	r2, [r3, #16]
  hspi2.Init.CLKPhase = SPI_PHASE_1EDGE;
 800a656:	4b13      	ldr	r3, [pc, #76]	; (800a6a4 <MX_SPI2_Init+0x74>)
 800a658:	2200      	movs	r2, #0
 800a65a:	615a      	str	r2, [r3, #20]
  hspi2.Init.NSS = SPI_NSS_SOFT;
 800a65c:	4b11      	ldr	r3, [pc, #68]	; (800a6a4 <MX_SPI2_Init+0x74>)
 800a65e:	2280      	movs	r2, #128	; 0x80
 800a660:	0092      	lsls	r2, r2, #2
 800a662:	619a      	str	r2, [r3, #24]
  hspi2.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_32;
 800a664:	4b0f      	ldr	r3, [pc, #60]	; (800a6a4 <MX_SPI2_Init+0x74>)
 800a666:	2220      	movs	r2, #32
 800a668:	61da      	str	r2, [r3, #28]
  hspi2.Init.FirstBit = SPI_FIRSTBIT_MSB;
 800a66a:	4b0e      	ldr	r3, [pc, #56]	; (800a6a4 <MX_SPI2_Init+0x74>)
 800a66c:	2200      	movs	r2, #0
 800a66e:	621a      	str	r2, [r3, #32]
  hspi2.Init.TIMode = SPI_TIMODE_DISABLE;
 800a670:	4b0c      	ldr	r3, [pc, #48]	; (800a6a4 <MX_SPI2_Init+0x74>)
 800a672:	2200      	movs	r2, #0
 800a674:	625a      	str	r2, [r3, #36]	; 0x24
  hspi2.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 800a676:	4b0b      	ldr	r3, [pc, #44]	; (800a6a4 <MX_SPI2_Init+0x74>)
 800a678:	2200      	movs	r2, #0
 800a67a:	629a      	str	r2, [r3, #40]	; 0x28
  hspi2.Init.CRCPolynomial = 7;
 800a67c:	4b09      	ldr	r3, [pc, #36]	; (800a6a4 <MX_SPI2_Init+0x74>)
 800a67e:	2207      	movs	r2, #7
 800a680:	62da      	str	r2, [r3, #44]	; 0x2c
  hspi2.Init.CRCLength = SPI_CRC_LENGTH_DATASIZE;
 800a682:	4b08      	ldr	r3, [pc, #32]	; (800a6a4 <MX_SPI2_Init+0x74>)
 800a684:	2200      	movs	r2, #0
 800a686:	631a      	str	r2, [r3, #48]	; 0x30
  hspi2.Init.NSSPMode = SPI_NSS_PULSE_ENABLE;
 800a688:	4b06      	ldr	r3, [pc, #24]	; (800a6a4 <MX_SPI2_Init+0x74>)
 800a68a:	2208      	movs	r2, #8
 800a68c:	635a      	str	r2, [r3, #52]	; 0x34
  if (HAL_SPI_Init(&hspi2) != HAL_OK)
 800a68e:	4b05      	ldr	r3, [pc, #20]	; (800a6a4 <MX_SPI2_Init+0x74>)
 800a690:	0018      	movs	r0, r3
 800a692:	f003 fd1d 	bl	800e0d0 <HAL_SPI_Init>
 800a696:	1e03      	subs	r3, r0, #0
 800a698:	d001      	beq.n	800a69e <MX_SPI2_Init+0x6e>
  {
    Error_Handler();
 800a69a:	f000 f95f 	bl	800a95c <Error_Handler>
  }
  /* USER CODE BEGIN SPI2_Init 2 */

  /* USER CODE END SPI2_Init 2 */

}
 800a69e:	46c0      	nop			; (mov r8, r8)
 800a6a0:	46bd      	mov	sp, r7
 800a6a2:	bd80      	pop	{r7, pc}
 800a6a4:	20002670 	.word	0x20002670
 800a6a8:	40003800 	.word	0x40003800

0800a6ac <MX_USART1_UART_Init>:
  * @brief USART1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_USART1_UART_Init(void)
{
 800a6ac:	b580      	push	{r7, lr}
 800a6ae:	af00      	add	r7, sp, #0
  /* USER CODE END USART1_Init 0 */

  /* USER CODE BEGIN USART1_Init 1 */

  /* USER CODE END USART1_Init 1 */
  huart1.Instance = USART1;
 800a6b0:	4b14      	ldr	r3, [pc, #80]	; (800a704 <MX_USART1_UART_Init+0x58>)
 800a6b2:	4a15      	ldr	r2, [pc, #84]	; (800a708 <MX_USART1_UART_Init+0x5c>)
 800a6b4:	601a      	str	r2, [r3, #0]
  huart1.Init.BaudRate = 115200;
 800a6b6:	4b13      	ldr	r3, [pc, #76]	; (800a704 <MX_USART1_UART_Init+0x58>)
 800a6b8:	22e1      	movs	r2, #225	; 0xe1
 800a6ba:	0252      	lsls	r2, r2, #9
 800a6bc:	605a      	str	r2, [r3, #4]
  huart1.Init.WordLength = UART_WORDLENGTH_8B;
 800a6be:	4b11      	ldr	r3, [pc, #68]	; (800a704 <MX_USART1_UART_Init+0x58>)
 800a6c0:	2200      	movs	r2, #0
 800a6c2:	609a      	str	r2, [r3, #8]
  huart1.Init.StopBits = UART_STOPBITS_1;
 800a6c4:	4b0f      	ldr	r3, [pc, #60]	; (800a704 <MX_USART1_UART_Init+0x58>)
 800a6c6:	2200      	movs	r2, #0
 800a6c8:	60da      	str	r2, [r3, #12]
  huart1.Init.Parity = UART_PARITY_NONE;
 800a6ca:	4b0e      	ldr	r3, [pc, #56]	; (800a704 <MX_USART1_UART_Init+0x58>)
 800a6cc:	2200      	movs	r2, #0
 800a6ce:	611a      	str	r2, [r3, #16]
  huart1.Init.Mode = UART_MODE_TX_RX;
 800a6d0:	4b0c      	ldr	r3, [pc, #48]	; (800a704 <MX_USART1_UART_Init+0x58>)
 800a6d2:	220c      	movs	r2, #12
 800a6d4:	615a      	str	r2, [r3, #20]
  huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 800a6d6:	4b0b      	ldr	r3, [pc, #44]	; (800a704 <MX_USART1_UART_Init+0x58>)
 800a6d8:	2200      	movs	r2, #0
 800a6da:	619a      	str	r2, [r3, #24]
  huart1.Init.OverSampling = UART_OVERSAMPLING_16;
 800a6dc:	4b09      	ldr	r3, [pc, #36]	; (800a704 <MX_USART1_UART_Init+0x58>)
 800a6de:	2200      	movs	r2, #0
 800a6e0:	61da      	str	r2, [r3, #28]
  huart1.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
 800a6e2:	4b08      	ldr	r3, [pc, #32]	; (800a704 <MX_USART1_UART_Init+0x58>)
 800a6e4:	2200      	movs	r2, #0
 800a6e6:	621a      	str	r2, [r3, #32]
  huart1.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
 800a6e8:	4b06      	ldr	r3, [pc, #24]	; (800a704 <MX_USART1_UART_Init+0x58>)
 800a6ea:	2200      	movs	r2, #0
 800a6ec:	625a      	str	r2, [r3, #36]	; 0x24
  if (HAL_UART_Init(&huart1) != HAL_OK)
 800a6ee:	4b05      	ldr	r3, [pc, #20]	; (800a704 <MX_USART1_UART_Init+0x58>)
 800a6f0:	0018      	movs	r0, r3
 800a6f2:	f003 fda5 	bl	800e240 <HAL_UART_Init>
 800a6f6:	1e03      	subs	r3, r0, #0
 800a6f8:	d001      	beq.n	800a6fe <MX_USART1_UART_Init+0x52>
  {
    Error_Handler();
 800a6fa:	f000 f92f 	bl	800a95c <Error_Handler>
  }
  /* USER CODE BEGIN USART1_Init 2 */

  /* USER CODE END USART1_Init 2 */

}
 800a6fe:	46c0      	nop			; (mov r8, r8)
 800a700:	46bd      	mov	sp, r7
 800a702:	bd80      	pop	{r7, pc}
 800a704:	200026d4 	.word	0x200026d4
 800a708:	40013800 	.word	0x40013800

0800a70c <MX_USART2_UART_Init>:
  * @brief USART2 Initialization Function
  * @param None
  * @retval None
  */
static void MX_USART2_UART_Init(void)
{
 800a70c:	b580      	push	{r7, lr}
 800a70e:	af00      	add	r7, sp, #0
  /* USER CODE END USART2_Init 0 */

  /* USER CODE BEGIN USART2_Init 1 */

  /* USER CODE END USART2_Init 1 */
  huart2.Instance = USART2;
 800a710:	4b14      	ldr	r3, [pc, #80]	; (800a764 <MX_USART2_UART_Init+0x58>)
 800a712:	4a15      	ldr	r2, [pc, #84]	; (800a768 <MX_USART2_UART_Init+0x5c>)
 800a714:	601a      	str	r2, [r3, #0]
  huart2.Init.BaudRate = 115200;
 800a716:	4b13      	ldr	r3, [pc, #76]	; (800a764 <MX_USART2_UART_Init+0x58>)
 800a718:	22e1      	movs	r2, #225	; 0xe1
 800a71a:	0252      	lsls	r2, r2, #9
 800a71c:	605a      	str	r2, [r3, #4]
  huart2.Init.WordLength = UART_WORDLENGTH_8B;
 800a71e:	4b11      	ldr	r3, [pc, #68]	; (800a764 <MX_USART2_UART_Init+0x58>)
 800a720:	2200      	movs	r2, #0
 800a722:	609a      	str	r2, [r3, #8]
  huart2.Init.StopBits = UART_STOPBITS_1;
 800a724:	4b0f      	ldr	r3, [pc, #60]	; (800a764 <MX_USART2_UART_Init+0x58>)
 800a726:	2200      	movs	r2, #0
 800a728:	60da      	str	r2, [r3, #12]
  huart2.Init.Parity = UART_PARITY_NONE;
 800a72a:	4b0e      	ldr	r3, [pc, #56]	; (800a764 <MX_USART2_UART_Init+0x58>)
 800a72c:	2200      	movs	r2, #0
 800a72e:	611a      	str	r2, [r3, #16]
  huart2.Init.Mode = UART_MODE_TX_RX;
 800a730:	4b0c      	ldr	r3, [pc, #48]	; (800a764 <MX_USART2_UART_Init+0x58>)
 800a732:	220c      	movs	r2, #12
 800a734:	615a      	str	r2, [r3, #20]
  huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 800a736:	4b0b      	ldr	r3, [pc, #44]	; (800a764 <MX_USART2_UART_Init+0x58>)
 800a738:	2200      	movs	r2, #0
 800a73a:	619a      	str	r2, [r3, #24]
  huart2.Init.OverSampling = UART_OVERSAMPLING_16;
 800a73c:	4b09      	ldr	r3, [pc, #36]	; (800a764 <MX_USART2_UART_Init+0x58>)
 800a73e:	2200      	movs	r2, #0
 800a740:	61da      	str	r2, [r3, #28]
  huart2.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
 800a742:	4b08      	ldr	r3, [pc, #32]	; (800a764 <MX_USART2_UART_Init+0x58>)
 800a744:	2200      	movs	r2, #0
 800a746:	621a      	str	r2, [r3, #32]
  huart2.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
 800a748:	4b06      	ldr	r3, [pc, #24]	; (800a764 <MX_USART2_UART_Init+0x58>)
 800a74a:	2200      	movs	r2, #0
 800a74c:	625a      	str	r2, [r3, #36]	; 0x24
  if (HAL_UART_Init(&huart2) != HAL_OK)
 800a74e:	4b05      	ldr	r3, [pc, #20]	; (800a764 <MX_USART2_UART_Init+0x58>)
 800a750:	0018      	movs	r0, r3
 800a752:	f003 fd75 	bl	800e240 <HAL_UART_Init>
 800a756:	1e03      	subs	r3, r0, #0
 800a758:	d001      	beq.n	800a75e <MX_USART2_UART_Init+0x52>
  {
    Error_Handler();
 800a75a:	f000 f8ff 	bl	800a95c <Error_Handler>
  }
  /* USER CODE BEGIN USART2_Init 2 */

  /* USER CODE END USART2_Init 2 */

}
 800a75e:	46c0      	nop			; (mov r8, r8)
 800a760:	46bd      	mov	sp, r7
 800a762:	bd80      	pop	{r7, pc}
 800a764:	2000275c 	.word	0x2000275c
 800a768:	40004400 	.word	0x40004400

0800a76c <MX_GPIO_Init>:
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
 800a76c:	b590      	push	{r4, r7, lr}
 800a76e:	b089      	sub	sp, #36	; 0x24
 800a770:	af00      	add	r7, sp, #0
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 800a772:	240c      	movs	r4, #12
 800a774:	193b      	adds	r3, r7, r4
 800a776:	0018      	movs	r0, r3
 800a778:	2314      	movs	r3, #20
 800a77a:	001a      	movs	r2, r3
 800a77c:	2100      	movs	r1, #0
 800a77e:	f00a fc48 	bl	8015012 <memset>

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOC_CLK_ENABLE();
 800a782:	4b40      	ldr	r3, [pc, #256]	; (800a884 <MX_GPIO_Init+0x118>)
 800a784:	695a      	ldr	r2, [r3, #20]
 800a786:	4b3f      	ldr	r3, [pc, #252]	; (800a884 <MX_GPIO_Init+0x118>)
 800a788:	2180      	movs	r1, #128	; 0x80
 800a78a:	0309      	lsls	r1, r1, #12
 800a78c:	430a      	orrs	r2, r1
 800a78e:	615a      	str	r2, [r3, #20]
 800a790:	4b3c      	ldr	r3, [pc, #240]	; (800a884 <MX_GPIO_Init+0x118>)
 800a792:	695a      	ldr	r2, [r3, #20]
 800a794:	2380      	movs	r3, #128	; 0x80
 800a796:	031b      	lsls	r3, r3, #12
 800a798:	4013      	ands	r3, r2
 800a79a:	60bb      	str	r3, [r7, #8]
 800a79c:	68bb      	ldr	r3, [r7, #8]
  __HAL_RCC_GPIOA_CLK_ENABLE();
 800a79e:	4b39      	ldr	r3, [pc, #228]	; (800a884 <MX_GPIO_Init+0x118>)
 800a7a0:	695a      	ldr	r2, [r3, #20]
 800a7a2:	4b38      	ldr	r3, [pc, #224]	; (800a884 <MX_GPIO_Init+0x118>)
 800a7a4:	2180      	movs	r1, #128	; 0x80
 800a7a6:	0289      	lsls	r1, r1, #10
 800a7a8:	430a      	orrs	r2, r1
 800a7aa:	615a      	str	r2, [r3, #20]
 800a7ac:	4b35      	ldr	r3, [pc, #212]	; (800a884 <MX_GPIO_Init+0x118>)
 800a7ae:	695a      	ldr	r2, [r3, #20]
 800a7b0:	2380      	movs	r3, #128	; 0x80
 800a7b2:	029b      	lsls	r3, r3, #10
 800a7b4:	4013      	ands	r3, r2
 800a7b6:	607b      	str	r3, [r7, #4]
 800a7b8:	687b      	ldr	r3, [r7, #4]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 800a7ba:	4b32      	ldr	r3, [pc, #200]	; (800a884 <MX_GPIO_Init+0x118>)
 800a7bc:	695a      	ldr	r2, [r3, #20]
 800a7be:	4b31      	ldr	r3, [pc, #196]	; (800a884 <MX_GPIO_Init+0x118>)
 800a7c0:	2180      	movs	r1, #128	; 0x80
 800a7c2:	02c9      	lsls	r1, r1, #11
 800a7c4:	430a      	orrs	r2, r1
 800a7c6:	615a      	str	r2, [r3, #20]
 800a7c8:	4b2e      	ldr	r3, [pc, #184]	; (800a884 <MX_GPIO_Init+0x118>)
 800a7ca:	695a      	ldr	r2, [r3, #20]
 800a7cc:	2380      	movs	r3, #128	; 0x80
 800a7ce:	02db      	lsls	r3, r3, #11
 800a7d0:	4013      	ands	r3, r2
 800a7d2:	603b      	str	r3, [r7, #0]
 800a7d4:	683b      	ldr	r3, [r7, #0]

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOC, LED2_Pin|LED1_Pin|GSM_Enable_Pin, GPIO_PIN_RESET);
 800a7d6:	23e0      	movs	r3, #224	; 0xe0
 800a7d8:	021b      	lsls	r3, r3, #8
 800a7da:	482b      	ldr	r0, [pc, #172]	; (800a888 <MX_GPIO_Init+0x11c>)
 800a7dc:	2200      	movs	r2, #0
 800a7de:	0019      	movs	r1, r3
 800a7e0:	f000 ffce 	bl	800b780 <HAL_GPIO_WritePin>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOB, GSM_On_Pin|LED5_Pin|RelayOpen_Pin|RelayClose_Pin
 800a7e4:	23cf      	movs	r3, #207	; 0xcf
 800a7e6:	009b      	lsls	r3, r3, #2
 800a7e8:	4828      	ldr	r0, [pc, #160]	; (800a88c <MX_GPIO_Init+0x120>)
 800a7ea:	2200      	movs	r2, #0
 800a7ec:	0019      	movs	r1, r3
 800a7ee:	f000 ffc7 	bl	800b780 <HAL_GPIO_WritePin>
                          |LED4_Pin|LED3_Pin, GPIO_PIN_RESET);

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(CS_GPIO_Port, CS_Pin, GPIO_PIN_RESET);
 800a7f2:	2380      	movs	r3, #128	; 0x80
 800a7f4:	0059      	lsls	r1, r3, #1
 800a7f6:	2390      	movs	r3, #144	; 0x90
 800a7f8:	05db      	lsls	r3, r3, #23
 800a7fa:	2200      	movs	r2, #0
 800a7fc:	0018      	movs	r0, r3
 800a7fe:	f000 ffbf 	bl	800b780 <HAL_GPIO_WritePin>

  /*Configure GPIO pins : LED2_Pin LED1_Pin GSM_Enable_Pin */
  GPIO_InitStruct.Pin = LED2_Pin|LED1_Pin|GSM_Enable_Pin;
 800a802:	193b      	adds	r3, r7, r4
 800a804:	22e0      	movs	r2, #224	; 0xe0
 800a806:	0212      	lsls	r2, r2, #8
 800a808:	601a      	str	r2, [r3, #0]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800a80a:	193b      	adds	r3, r7, r4
 800a80c:	2201      	movs	r2, #1
 800a80e:	605a      	str	r2, [r3, #4]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800a810:	193b      	adds	r3, r7, r4
 800a812:	2200      	movs	r2, #0
 800a814:	609a      	str	r2, [r3, #8]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800a816:	193b      	adds	r3, r7, r4
 800a818:	2200      	movs	r2, #0
 800a81a:	60da      	str	r2, [r3, #12]
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 800a81c:	193b      	adds	r3, r7, r4
 800a81e:	4a1a      	ldr	r2, [pc, #104]	; (800a888 <MX_GPIO_Init+0x11c>)
 800a820:	0019      	movs	r1, r3
 800a822:	0010      	movs	r0, r2
 800a824:	f000 fe34 	bl	800b490 <HAL_GPIO_Init>

  /*Configure GPIO pins : GSM_On_Pin LED5_Pin RelayOpen_Pin RelayClose_Pin
                           LED4_Pin LED3_Pin */
  GPIO_InitStruct.Pin = GSM_On_Pin|LED5_Pin|RelayOpen_Pin|RelayClose_Pin
 800a828:	0021      	movs	r1, r4
 800a82a:	187b      	adds	r3, r7, r1
 800a82c:	22cf      	movs	r2, #207	; 0xcf
 800a82e:	0092      	lsls	r2, r2, #2
 800a830:	601a      	str	r2, [r3, #0]
                          |LED4_Pin|LED3_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800a832:	000c      	movs	r4, r1
 800a834:	193b      	adds	r3, r7, r4
 800a836:	2201      	movs	r2, #1
 800a838:	605a      	str	r2, [r3, #4]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800a83a:	193b      	adds	r3, r7, r4
 800a83c:	2200      	movs	r2, #0
 800a83e:	609a      	str	r2, [r3, #8]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800a840:	193b      	adds	r3, r7, r4
 800a842:	2200      	movs	r2, #0
 800a844:	60da      	str	r2, [r3, #12]
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 800a846:	193b      	adds	r3, r7, r4
 800a848:	4a10      	ldr	r2, [pc, #64]	; (800a88c <MX_GPIO_Init+0x120>)
 800a84a:	0019      	movs	r1, r3
 800a84c:	0010      	movs	r0, r2
 800a84e:	f000 fe1f 	bl	800b490 <HAL_GPIO_Init>

  /*Configure GPIO pin : CS_Pin */
  GPIO_InitStruct.Pin = CS_Pin;
 800a852:	0021      	movs	r1, r4
 800a854:	187b      	adds	r3, r7, r1
 800a856:	2280      	movs	r2, #128	; 0x80
 800a858:	0052      	lsls	r2, r2, #1
 800a85a:	601a      	str	r2, [r3, #0]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800a85c:	187b      	adds	r3, r7, r1
 800a85e:	2201      	movs	r2, #1
 800a860:	605a      	str	r2, [r3, #4]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800a862:	187b      	adds	r3, r7, r1
 800a864:	2200      	movs	r2, #0
 800a866:	609a      	str	r2, [r3, #8]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800a868:	187b      	adds	r3, r7, r1
 800a86a:	2200      	movs	r2, #0
 800a86c:	60da      	str	r2, [r3, #12]
  HAL_GPIO_Init(CS_GPIO_Port, &GPIO_InitStruct);
 800a86e:	187a      	adds	r2, r7, r1
 800a870:	2390      	movs	r3, #144	; 0x90
 800a872:	05db      	lsls	r3, r3, #23
 800a874:	0011      	movs	r1, r2
 800a876:	0018      	movs	r0, r3
 800a878:	f000 fe0a 	bl	800b490 <HAL_GPIO_Init>

}
 800a87c:	46c0      	nop			; (mov r8, r8)
 800a87e:	46bd      	mov	sp, r7
 800a880:	b009      	add	sp, #36	; 0x24
 800a882:	bd90      	pop	{r4, r7, pc}
 800a884:	40021000 	.word	0x40021000
 800a888:	48000800 	.word	0x48000800
 800a88c:	48000400 	.word	0x48000400

0800a890 <remap>:
	 //Debug_Send(flash);
	 Debug_Send("\r\n");

 }*/

void remap(){
 800a890:	b580      	push	{r7, lr}
 800a892:	b084      	sub	sp, #16
 800a894:	af00      	add	r7, sp, #0
	 // Copy interrupt vector table to the RAM.
	 volatile uint32_t *VectorTable = (volatile uint32_t *)0x20000000;
 800a896:	2380      	movs	r3, #128	; 0x80
 800a898:	059b      	lsls	r3, r3, #22
 800a89a:	60bb      	str	r3, [r7, #8]
	 uint32_t ui32_VectorIndex = 0;
 800a89c:	2300      	movs	r3, #0
 800a89e:	60fb      	str	r3, [r7, #12]

	 for(ui32_VectorIndex = 0; ui32_VectorIndex < 48; ui32_VectorIndex++)
 800a8a0:	2300      	movs	r3, #0
 800a8a2:	60fb      	str	r3, [r7, #12]
 800a8a4:	e00e      	b.n	800a8c4 <remap+0x34>
	 {
		 VectorTable[ui32_VectorIndex] = *(__IO uint32_t*)((uint32_t) 0x8009000 + (ui32_VectorIndex << 2));
 800a8a6:	68fb      	ldr	r3, [r7, #12]
 800a8a8:	009b      	lsls	r3, r3, #2
 800a8aa:	4a1c      	ldr	r2, [pc, #112]	; (800a91c <remap+0x8c>)
 800a8ac:	4694      	mov	ip, r2
 800a8ae:	4463      	add	r3, ip
 800a8b0:	001a      	movs	r2, r3
 800a8b2:	68fb      	ldr	r3, [r7, #12]
 800a8b4:	009b      	lsls	r3, r3, #2
 800a8b6:	68b9      	ldr	r1, [r7, #8]
 800a8b8:	18cb      	adds	r3, r1, r3
 800a8ba:	6812      	ldr	r2, [r2, #0]
 800a8bc:	601a      	str	r2, [r3, #0]
	 for(ui32_VectorIndex = 0; ui32_VectorIndex < 48; ui32_VectorIndex++)
 800a8be:	68fb      	ldr	r3, [r7, #12]
 800a8c0:	3301      	adds	r3, #1
 800a8c2:	60fb      	str	r3, [r7, #12]
 800a8c4:	68fb      	ldr	r3, [r7, #12]
 800a8c6:	2b2f      	cmp	r3, #47	; 0x2f
 800a8c8:	d9ed      	bls.n	800a8a6 <remap+0x16>
	 }

	 __HAL_RCC_AHB_FORCE_RESET();
 800a8ca:	4b15      	ldr	r3, [pc, #84]	; (800a920 <remap+0x90>)
 800a8cc:	2201      	movs	r2, #1
 800a8ce:	4252      	negs	r2, r2
 800a8d0:	629a      	str	r2, [r3, #40]	; 0x28

	 //  Enable SYSCFG peripheral clock
	 __HAL_RCC_SYSCFG_CLK_ENABLE();
 800a8d2:	4b13      	ldr	r3, [pc, #76]	; (800a920 <remap+0x90>)
 800a8d4:	699a      	ldr	r2, [r3, #24]
 800a8d6:	4b12      	ldr	r3, [pc, #72]	; (800a920 <remap+0x90>)
 800a8d8:	2101      	movs	r1, #1
 800a8da:	430a      	orrs	r2, r1
 800a8dc:	619a      	str	r2, [r3, #24]
 800a8de:	4b10      	ldr	r3, [pc, #64]	; (800a920 <remap+0x90>)
 800a8e0:	699b      	ldr	r3, [r3, #24]
 800a8e2:	2201      	movs	r2, #1
 800a8e4:	4013      	ands	r3, r2
 800a8e6:	607b      	str	r3, [r7, #4]
 800a8e8:	687b      	ldr	r3, [r7, #4]

	 __HAL_RCC_AHB_RELEASE_RESET();
 800a8ea:	4b0d      	ldr	r3, [pc, #52]	; (800a920 <remap+0x90>)
 800a8ec:	2200      	movs	r2, #0
 800a8ee:	629a      	str	r2, [r3, #40]	; 0x28

	 // Remap RAM into 0x0000 0000
	 __HAL_SYSCFG_REMAPMEMORY_SRAM();
 800a8f0:	4b0c      	ldr	r3, [pc, #48]	; (800a924 <remap+0x94>)
 800a8f2:	681a      	ldr	r2, [r3, #0]
 800a8f4:	4b0b      	ldr	r3, [pc, #44]	; (800a924 <remap+0x94>)
 800a8f6:	2103      	movs	r1, #3
 800a8f8:	438a      	bics	r2, r1
 800a8fa:	601a      	str	r2, [r3, #0]
 800a8fc:	4b09      	ldr	r3, [pc, #36]	; (800a924 <remap+0x94>)
 800a8fe:	681a      	ldr	r2, [r3, #0]
 800a900:	4b08      	ldr	r3, [pc, #32]	; (800a924 <remap+0x94>)
 800a902:	2103      	movs	r1, #3
 800a904:	430a      	orrs	r2, r1
 800a906:	601a      	str	r2, [r3, #0]
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800a908:	b662      	cpsie	i
}
 800a90a:	46c0      	nop			; (mov r8, r8)

	 __enable_irq();
	 Debug_Send("test Vector table remapped\r\n");
 800a90c:	4b06      	ldr	r3, [pc, #24]	; (800a928 <remap+0x98>)
 800a90e:	0018      	movs	r0, r3
 800a910:	f7fe fcbe 	bl	8009290 <Debug_Send>
}
 800a914:	46c0      	nop			; (mov r8, r8)
 800a916:	46bd      	mov	sp, r7
 800a918:	b004      	add	sp, #16
 800a91a:	bd80      	pop	{r7, pc}
 800a91c:	08009000 	.word	0x08009000
 800a920:	40021000 	.word	0x40021000
 800a924:	40010000 	.word	0x40010000
 800a928:	08015c44 	.word	0x08015c44

0800a92c <StartDefaultTask>:
  * @param  argument: Not used
  * @retval None
  */
/* USER CODE END Header_StartDefaultTask */
void StartDefaultTask(void const * argument)
{
 800a92c:	b580      	push	{r7, lr}
 800a92e:	b082      	sub	sp, #8
 800a930:	af00      	add	r7, sp, #0
 800a932:	6078      	str	r0, [r7, #4]
  /* init code for USB_DEVICE */
  MX_USB_DEVICE_Init();
 800a934:	f009 fe2a 	bl	801458c <MX_USB_DEVICE_Init>
  /* USER CODE BEGIN 5 */
  /* Infinite loop */
  for(;;)
  {
    osDelay(1000);
 800a938:	23fa      	movs	r3, #250	; 0xfa
 800a93a:	009b      	lsls	r3, r3, #2
 800a93c:	0018      	movs	r0, r3
 800a93e:	f008 fdd3 	bl	80134e8 <osDelay>
    //Debug_Send("M0 test running\r\n");
    //GSM_Service();
    //CDC_Transmit_FS((uint8_t*) USB_Send, strlen(USB_Send));
    //Debug_Send("M0 test running\r\n");
    //GSM_Send("AT\r\n");
    Wifi_Service();
 800a942:	f7fe fd69 	bl	8009418 <Wifi_Service>
  {
 800a946:	e7f7      	b.n	800a938 <StartDefaultTask+0xc>

0800a948 <StartTask02>:
* @param argument: Not used
* @retval None
*/
/* USER CODE END Header_StartTask02 */
void StartTask02(void const * argument)
{
 800a948:	b580      	push	{r7, lr}
 800a94a:	b082      	sub	sp, #8
 800a94c:	af00      	add	r7, sp, #0
 800a94e:	6078      	str	r0, [r7, #4]
  /* USER CODE BEGIN StartTask02 */
  /* Infinite loop */
  for(;;)
  {
    osDelay(50);
 800a950:	2032      	movs	r0, #50	; 0x32
 800a952:	f008 fdc9 	bl	80134e8 <osDelay>
    //recData();
    WifirecData();
 800a956:	f7fe ffb1 	bl	80098bc <WifirecData>
  {
 800a95a:	e7f9      	b.n	800a950 <StartTask02+0x8>

0800a95c <Error_Handler>:
/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
 800a95c:	b580      	push	{r7, lr}
 800a95e:	af00      	add	r7, sp, #0
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800a960:	b672      	cpsid	i
}
 800a962:	46c0      	nop			; (mov r8, r8)
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
 800a964:	e7fe      	b.n	800a964 <Error_Handler+0x8>

0800a966 <myStrSection>:
//#include "GSM.h"

//volatile unsigned char msisdn[80];
const char hex[16] = {'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};

short myStrSection(char *p_str,char *p_result,unsigned char p_size,char p_char,char p_pos){
 800a966:	b580      	push	{r7, lr}
 800a968:	b086      	sub	sp, #24
 800a96a:	af00      	add	r7, sp, #0
 800a96c:	60f8      	str	r0, [r7, #12]
 800a96e:	60b9      	str	r1, [r7, #8]
 800a970:	0019      	movs	r1, r3
 800a972:	1dfb      	adds	r3, r7, #7
 800a974:	701a      	strb	r2, [r3, #0]
 800a976:	1dbb      	adds	r3, r7, #6
 800a978:	1c0a      	adds	r2, r1, #0
 800a97a:	701a      	strb	r2, [r3, #0]
	short string_index;
	short result_index;
	char tmp_pos;

	string_index=0;
 800a97c:	2316      	movs	r3, #22
 800a97e:	18fb      	adds	r3, r7, r3
 800a980:	2200      	movs	r2, #0
 800a982:	801a      	strh	r2, [r3, #0]
	result_index=0;
 800a984:	2314      	movs	r3, #20
 800a986:	18fb      	adds	r3, r7, r3
 800a988:	2200      	movs	r2, #0
 800a98a:	801a      	strh	r2, [r3, #0]
	tmp_pos=0;
 800a98c:	2313      	movs	r3, #19
 800a98e:	18fb      	adds	r3, r7, r3
 800a990:	2200      	movs	r2, #0
 800a992:	701a      	strb	r2, [r3, #0]
	p_size--;
 800a994:	1dfb      	adds	r3, r7, #7
 800a996:	781a      	ldrb	r2, [r3, #0]
 800a998:	1dfb      	adds	r3, r7, #7
 800a99a:	3a01      	subs	r2, #1
 800a99c:	701a      	strb	r2, [r3, #0]
	while(p_str[string_index]!=0){
 800a99e:	e04a      	b.n	800aa36 <myStrSection+0xd0>
		if(p_str[string_index]==p_char){
 800a9a0:	2316      	movs	r3, #22
 800a9a2:	18fb      	adds	r3, r7, r3
 800a9a4:	2200      	movs	r2, #0
 800a9a6:	5e9b      	ldrsh	r3, [r3, r2]
 800a9a8:	68fa      	ldr	r2, [r7, #12]
 800a9aa:	18d3      	adds	r3, r2, r3
 800a9ac:	781b      	ldrb	r3, [r3, #0]
 800a9ae:	1dba      	adds	r2, r7, #6
 800a9b0:	7812      	ldrb	r2, [r2, #0]
 800a9b2:	429a      	cmp	r2, r3
 800a9b4:	d111      	bne.n	800a9da <myStrSection+0x74>

			if(tmp_pos==p_pos)break;
 800a9b6:	2113      	movs	r1, #19
 800a9b8:	187a      	adds	r2, r7, r1
 800a9ba:	2320      	movs	r3, #32
 800a9bc:	18fb      	adds	r3, r7, r3
 800a9be:	7812      	ldrb	r2, [r2, #0]
 800a9c0:	781b      	ldrb	r3, [r3, #0]
 800a9c2:	429a      	cmp	r2, r3
 800a9c4:	d041      	beq.n	800aa4a <myStrSection+0xe4>
			tmp_pos++;
 800a9c6:	187b      	adds	r3, r7, r1
 800a9c8:	781a      	ldrb	r2, [r3, #0]
 800a9ca:	187b      	adds	r3, r7, r1
 800a9cc:	3201      	adds	r2, #1
 800a9ce:	701a      	strb	r2, [r3, #0]
			result_index=0;
 800a9d0:	2314      	movs	r3, #20
 800a9d2:	18fb      	adds	r3, r7, r3
 800a9d4:	2200      	movs	r2, #0
 800a9d6:	801a      	strh	r2, [r3, #0]
 800a9d8:	e024      	b.n	800aa24 <myStrSection+0xbe>
		}else{
			if(p_str[string_index]>=' '){
 800a9da:	2116      	movs	r1, #22
 800a9dc:	187b      	adds	r3, r7, r1
 800a9de:	2200      	movs	r2, #0
 800a9e0:	5e9b      	ldrsh	r3, [r3, r2]
 800a9e2:	68fa      	ldr	r2, [r7, #12]
 800a9e4:	18d3      	adds	r3, r2, r3
 800a9e6:	781b      	ldrb	r3, [r3, #0]
 800a9e8:	2b1f      	cmp	r3, #31
 800a9ea:	d91b      	bls.n	800aa24 <myStrSection+0xbe>
				p_result[result_index]=p_str[string_index];				if(result_index<p_size)result_index++;
 800a9ec:	187b      	adds	r3, r7, r1
 800a9ee:	2200      	movs	r2, #0
 800a9f0:	5e9b      	ldrsh	r3, [r3, r2]
 800a9f2:	68fa      	ldr	r2, [r7, #12]
 800a9f4:	18d2      	adds	r2, r2, r3
 800a9f6:	2014      	movs	r0, #20
 800a9f8:	183b      	adds	r3, r7, r0
 800a9fa:	2100      	movs	r1, #0
 800a9fc:	5e5b      	ldrsh	r3, [r3, r1]
 800a9fe:	68b9      	ldr	r1, [r7, #8]
 800aa00:	18cb      	adds	r3, r1, r3
 800aa02:	7812      	ldrb	r2, [r2, #0]
 800aa04:	701a      	strb	r2, [r3, #0]
 800aa06:	183b      	adds	r3, r7, r0
 800aa08:	2200      	movs	r2, #0
 800aa0a:	5e9a      	ldrsh	r2, [r3, r2]
 800aa0c:	1dfb      	adds	r3, r7, #7
 800aa0e:	781b      	ldrb	r3, [r3, #0]
 800aa10:	429a      	cmp	r2, r3
 800aa12:	da07      	bge.n	800aa24 <myStrSection+0xbe>
 800aa14:	183b      	adds	r3, r7, r0
 800aa16:	2200      	movs	r2, #0
 800aa18:	5e9b      	ldrsh	r3, [r3, r2]
 800aa1a:	b29b      	uxth	r3, r3
 800aa1c:	3301      	adds	r3, #1
 800aa1e:	b29a      	uxth	r2, r3
 800aa20:	183b      	adds	r3, r7, r0
 800aa22:	801a      	strh	r2, [r3, #0]
			}
		}
		string_index++;
 800aa24:	2116      	movs	r1, #22
 800aa26:	187b      	adds	r3, r7, r1
 800aa28:	2200      	movs	r2, #0
 800aa2a:	5e9b      	ldrsh	r3, [r3, r2]
 800aa2c:	b29b      	uxth	r3, r3
 800aa2e:	3301      	adds	r3, #1
 800aa30:	b29a      	uxth	r2, r3
 800aa32:	187b      	adds	r3, r7, r1
 800aa34:	801a      	strh	r2, [r3, #0]
	while(p_str[string_index]!=0){
 800aa36:	2316      	movs	r3, #22
 800aa38:	18fb      	adds	r3, r7, r3
 800aa3a:	2200      	movs	r2, #0
 800aa3c:	5e9b      	ldrsh	r3, [r3, r2]
 800aa3e:	68fa      	ldr	r2, [r7, #12]
 800aa40:	18d3      	adds	r3, r2, r3
 800aa42:	781b      	ldrb	r3, [r3, #0]
 800aa44:	2b00      	cmp	r3, #0
 800aa46:	d1ab      	bne.n	800a9a0 <myStrSection+0x3a>
 800aa48:	e000      	b.n	800aa4c <myStrSection+0xe6>
			if(tmp_pos==p_pos)break;
 800aa4a:	46c0      	nop			; (mov r8, r8)
	}
	if(tmp_pos!=p_pos){
 800aa4c:	2313      	movs	r3, #19
 800aa4e:	18fa      	adds	r2, r7, r3
 800aa50:	2320      	movs	r3, #32
 800aa52:	18fb      	adds	r3, r7, r3
 800aa54:	7812      	ldrb	r2, [r2, #0]
 800aa56:	781b      	ldrb	r3, [r3, #0]
 800aa58:	429a      	cmp	r2, r3
 800aa5a:	d008      	beq.n	800aa6e <myStrSection+0x108>
		result_index=0;
 800aa5c:	2314      	movs	r3, #20
 800aa5e:	18fb      	adds	r3, r7, r3
 800aa60:	2200      	movs	r2, #0
 800aa62:	801a      	strh	r2, [r3, #0]
		string_index=-1;
 800aa64:	2316      	movs	r3, #22
 800aa66:	18fb      	adds	r3, r7, r3
 800aa68:	2201      	movs	r2, #1
 800aa6a:	4252      	negs	r2, r2
 800aa6c:	801a      	strh	r2, [r3, #0]
	}
	p_result[result_index]=0;
 800aa6e:	2314      	movs	r3, #20
 800aa70:	18fb      	adds	r3, r7, r3
 800aa72:	2200      	movs	r2, #0
 800aa74:	5e9b      	ldrsh	r3, [r3, r2]
 800aa76:	68ba      	ldr	r2, [r7, #8]
 800aa78:	18d3      	adds	r3, r2, r3
 800aa7a:	2200      	movs	r2, #0
 800aa7c:	701a      	strb	r2, [r3, #0]

	return string_index;
 800aa7e:	2316      	movs	r3, #22
 800aa80:	18fb      	adds	r3, r7, r3
 800aa82:	2200      	movs	r2, #0
 800aa84:	5e9b      	ldrsh	r3, [r3, r2]
}
 800aa86:	0018      	movs	r0, r3
 800aa88:	46bd      	mov	sp, r7
 800aa8a:	b006      	add	sp, #24
 800aa8c:	bd80      	pop	{r7, pc}
	...

0800aa90 <myLongStr>:


char* myLongStr(signed long p_val,char *p_dest,short p_size,char p_base){
 800aa90:	b580      	push	{r7, lr}
 800aa92:	b086      	sub	sp, #24
 800aa94:	af00      	add	r7, sp, #0
 800aa96:	60f8      	str	r0, [r7, #12]
 800aa98:	60b9      	str	r1, [r7, #8]
 800aa9a:	0019      	movs	r1, r3
 800aa9c:	1dbb      	adds	r3, r7, #6
 800aa9e:	801a      	strh	r2, [r3, #0]
 800aaa0:	1d7b      	adds	r3, r7, #5
 800aaa2:	1c0a      	adds	r2, r1, #0
 800aaa4:	701a      	strb	r2, [r3, #0]
	unsigned long tmp_index;
	short tmp_size;
	char tmp_val;
	char tmp_iszero;

	tmp_size=0;
 800aaa6:	2112      	movs	r1, #18
 800aaa8:	187b      	adds	r3, r7, r1
 800aaaa:	2200      	movs	r2, #0
 800aaac:	801a      	strh	r2, [r3, #0]
	tmp_iszero=1;
 800aaae:	2311      	movs	r3, #17
 800aab0:	18fb      	adds	r3, r7, r3
 800aab2:	2201      	movs	r2, #1
 800aab4:	701a      	strb	r2, [r3, #0]

	if(p_base==10){
 800aab6:	1d7b      	adds	r3, r7, #5
 800aab8:	781b      	ldrb	r3, [r3, #0]
 800aaba:	2b0a      	cmp	r3, #10
 800aabc:	d15f      	bne.n	800ab7e <myLongStr+0xee>
		tmp_index=1000000000;
 800aabe:	4b6f      	ldr	r3, [pc, #444]	; (800ac7c <myLongStr+0x1ec>)
 800aac0:	617b      	str	r3, [r7, #20]

		if(p_val<0){
 800aac2:	68fb      	ldr	r3, [r7, #12]
 800aac4:	2b00      	cmp	r3, #0
 800aac6:	da56      	bge.n	800ab76 <myLongStr+0xe6>
			p_val*=-1;
 800aac8:	68fb      	ldr	r3, [r7, #12]
 800aaca:	425b      	negs	r3, r3
 800aacc:	60fb      	str	r3, [r7, #12]
			p_dest[tmp_size]='-';
 800aace:	187b      	adds	r3, r7, r1
 800aad0:	2200      	movs	r2, #0
 800aad2:	5e9b      	ldrsh	r3, [r3, r2]
 800aad4:	68ba      	ldr	r2, [r7, #8]
 800aad6:	18d3      	adds	r3, r2, r3
 800aad8:	222d      	movs	r2, #45	; 0x2d
 800aada:	701a      	strb	r2, [r3, #0]
			tmp_size++;
 800aadc:	187b      	adds	r3, r7, r1
 800aade:	2200      	movs	r2, #0
 800aae0:	5e9b      	ldrsh	r3, [r3, r2]
 800aae2:	b29b      	uxth	r3, r3
 800aae4:	3301      	adds	r3, #1
 800aae6:	b29a      	uxth	r2, r3
 800aae8:	187b      	adds	r3, r7, r1
 800aaea:	801a      	strh	r2, [r3, #0]
		}

		while(tmp_index>0){
 800aaec:	e043      	b.n	800ab76 <myLongStr+0xe6>
			tmp_val=p_val/tmp_index;
 800aaee:	68fb      	ldr	r3, [r7, #12]
 800aaf0:	6979      	ldr	r1, [r7, #20]
 800aaf2:	0018      	movs	r0, r3
 800aaf4:	f7fe fb1a 	bl	800912c <__udivsi3>
 800aaf8:	0003      	movs	r3, r0
 800aafa:	001a      	movs	r2, r3
 800aafc:	2110      	movs	r1, #16
 800aafe:	187b      	adds	r3, r7, r1
 800ab00:	701a      	strb	r2, [r3, #0]
			if(tmp_val>0)tmp_iszero=0;
 800ab02:	187b      	adds	r3, r7, r1
 800ab04:	781b      	ldrb	r3, [r3, #0]
 800ab06:	2b00      	cmp	r3, #0
 800ab08:	d003      	beq.n	800ab12 <myLongStr+0x82>
 800ab0a:	2311      	movs	r3, #17
 800ab0c:	18fb      	adds	r3, r7, r3
 800ab0e:	2200      	movs	r2, #0
 800ab10:	701a      	strb	r2, [r3, #0]
			if(tmp_iszero==0){
 800ab12:	2311      	movs	r3, #17
 800ab14:	18fb      	adds	r3, r7, r3
 800ab16:	781b      	ldrb	r3, [r3, #0]
 800ab18:	2b00      	cmp	r3, #0
 800ab1a:	d113      	bne.n	800ab44 <myLongStr+0xb4>
				p_dest[tmp_size]=tmp_val+0x30;
 800ab1c:	2112      	movs	r1, #18
 800ab1e:	187b      	adds	r3, r7, r1
 800ab20:	2200      	movs	r2, #0
 800ab22:	5e9b      	ldrsh	r3, [r3, r2]
 800ab24:	68ba      	ldr	r2, [r7, #8]
 800ab26:	18d3      	adds	r3, r2, r3
 800ab28:	2210      	movs	r2, #16
 800ab2a:	18ba      	adds	r2, r7, r2
 800ab2c:	7812      	ldrb	r2, [r2, #0]
 800ab2e:	3230      	adds	r2, #48	; 0x30
 800ab30:	b2d2      	uxtb	r2, r2
 800ab32:	701a      	strb	r2, [r3, #0]
				tmp_size++;
 800ab34:	187b      	adds	r3, r7, r1
 800ab36:	2200      	movs	r2, #0
 800ab38:	5e9b      	ldrsh	r3, [r3, r2]
 800ab3a:	b29b      	uxth	r3, r3
 800ab3c:	3301      	adds	r3, #1
 800ab3e:	b29a      	uxth	r2, r3
 800ab40:	187b      	adds	r3, r7, r1
 800ab42:	801a      	strh	r2, [r3, #0]
			}
			p_val=p_val-(tmp_val*tmp_index);
 800ab44:	68fa      	ldr	r2, [r7, #12]
 800ab46:	2310      	movs	r3, #16
 800ab48:	18fb      	adds	r3, r7, r3
 800ab4a:	781b      	ldrb	r3, [r3, #0]
 800ab4c:	6979      	ldr	r1, [r7, #20]
 800ab4e:	434b      	muls	r3, r1
 800ab50:	1ad3      	subs	r3, r2, r3
 800ab52:	60fb      	str	r3, [r7, #12]
			tmp_index/=10;
 800ab54:	697b      	ldr	r3, [r7, #20]
 800ab56:	210a      	movs	r1, #10
 800ab58:	0018      	movs	r0, r3
 800ab5a:	f7fe fae7 	bl	800912c <__udivsi3>
 800ab5e:	0003      	movs	r3, r0
 800ab60:	617b      	str	r3, [r7, #20]
			if(tmp_size>=(p_size-1))break;
 800ab62:	2312      	movs	r3, #18
 800ab64:	18fb      	adds	r3, r7, r3
 800ab66:	2200      	movs	r2, #0
 800ab68:	5e9a      	ldrsh	r2, [r3, r2]
 800ab6a:	1dbb      	adds	r3, r7, #6
 800ab6c:	2100      	movs	r1, #0
 800ab6e:	5e5b      	ldrsh	r3, [r3, r1]
 800ab70:	3b01      	subs	r3, #1
 800ab72:	429a      	cmp	r2, r3
 800ab74:	da5d      	bge.n	800ac32 <myLongStr+0x1a2>
		while(tmp_index>0){
 800ab76:	697b      	ldr	r3, [r7, #20]
 800ab78:	2b00      	cmp	r3, #0
 800ab7a:	d1b8      	bne.n	800aaee <myLongStr+0x5e>
 800ab7c:	e05c      	b.n	800ac38 <myLongStr+0x1a8>
		}

	}
	else if(p_base==16){
 800ab7e:	1d7b      	adds	r3, r7, #5
 800ab80:	781b      	ldrb	r3, [r3, #0]
 800ab82:	2b10      	cmp	r3, #16
 800ab84:	d158      	bne.n	800ac38 <myLongStr+0x1a8>
		tmp_index=32;
 800ab86:	2320      	movs	r3, #32
 800ab88:	617b      	str	r3, [r7, #20]
		while(tmp_index>0){
 800ab8a:	e04e      	b.n	800ac2a <myLongStr+0x19a>
			tmp_val=(p_val>>(tmp_index-4))&0x0f;
 800ab8c:	697b      	ldr	r3, [r7, #20]
 800ab8e:	3b04      	subs	r3, #4
 800ab90:	68fa      	ldr	r2, [r7, #12]
 800ab92:	411a      	asrs	r2, r3
 800ab94:	0013      	movs	r3, r2
 800ab96:	b2da      	uxtb	r2, r3
 800ab98:	2010      	movs	r0, #16
 800ab9a:	183b      	adds	r3, r7, r0
 800ab9c:	210f      	movs	r1, #15
 800ab9e:	400a      	ands	r2, r1
 800aba0:	701a      	strb	r2, [r3, #0]

			if(tmp_val>0)tmp_iszero=0;
 800aba2:	183b      	adds	r3, r7, r0
 800aba4:	781b      	ldrb	r3, [r3, #0]
 800aba6:	2b00      	cmp	r3, #0
 800aba8:	d003      	beq.n	800abb2 <myLongStr+0x122>
 800abaa:	2311      	movs	r3, #17
 800abac:	18fb      	adds	r3, r7, r3
 800abae:	2200      	movs	r2, #0
 800abb0:	701a      	strb	r2, [r3, #0]
			if(tmp_iszero==0){
 800abb2:	2311      	movs	r3, #17
 800abb4:	18fb      	adds	r3, r7, r3
 800abb6:	781b      	ldrb	r3, [r3, #0]
 800abb8:	2b00      	cmp	r3, #0
 800abba:	d129      	bne.n	800ac10 <myLongStr+0x180>
				if(tmp_val<=9)p_dest[tmp_size]=tmp_val+0x30;
 800abbc:	2110      	movs	r1, #16
 800abbe:	187b      	adds	r3, r7, r1
 800abc0:	781b      	ldrb	r3, [r3, #0]
 800abc2:	2b09      	cmp	r3, #9
 800abc4:	d80b      	bhi.n	800abde <myLongStr+0x14e>
 800abc6:	2312      	movs	r3, #18
 800abc8:	18fb      	adds	r3, r7, r3
 800abca:	2200      	movs	r2, #0
 800abcc:	5e9b      	ldrsh	r3, [r3, r2]
 800abce:	68ba      	ldr	r2, [r7, #8]
 800abd0:	18d3      	adds	r3, r2, r3
 800abd2:	187a      	adds	r2, r7, r1
 800abd4:	7812      	ldrb	r2, [r2, #0]
 800abd6:	3230      	adds	r2, #48	; 0x30
 800abd8:	b2d2      	uxtb	r2, r2
 800abda:	701a      	strb	r2, [r3, #0]
 800abdc:	e00f      	b.n	800abfe <myLongStr+0x16e>
				else if(tmp_val>=10)p_dest[tmp_size]=(tmp_val-10)+'A';
 800abde:	2110      	movs	r1, #16
 800abe0:	187b      	adds	r3, r7, r1
 800abe2:	781b      	ldrb	r3, [r3, #0]
 800abe4:	2b09      	cmp	r3, #9
 800abe6:	d90a      	bls.n	800abfe <myLongStr+0x16e>
 800abe8:	2312      	movs	r3, #18
 800abea:	18fb      	adds	r3, r7, r3
 800abec:	2200      	movs	r2, #0
 800abee:	5e9b      	ldrsh	r3, [r3, r2]
 800abf0:	68ba      	ldr	r2, [r7, #8]
 800abf2:	18d3      	adds	r3, r2, r3
 800abf4:	187a      	adds	r2, r7, r1
 800abf6:	7812      	ldrb	r2, [r2, #0]
 800abf8:	3237      	adds	r2, #55	; 0x37
 800abfa:	b2d2      	uxtb	r2, r2
 800abfc:	701a      	strb	r2, [r3, #0]
				tmp_size++;
 800abfe:	2112      	movs	r1, #18
 800ac00:	187b      	adds	r3, r7, r1
 800ac02:	2200      	movs	r2, #0
 800ac04:	5e9b      	ldrsh	r3, [r3, r2]
 800ac06:	b29b      	uxth	r3, r3
 800ac08:	3301      	adds	r3, #1
 800ac0a:	b29a      	uxth	r2, r3
 800ac0c:	187b      	adds	r3, r7, r1
 800ac0e:	801a      	strh	r2, [r3, #0]
			}

			tmp_index-=4;
 800ac10:	697b      	ldr	r3, [r7, #20]
 800ac12:	3b04      	subs	r3, #4
 800ac14:	617b      	str	r3, [r7, #20]
			if(tmp_size>=(p_size-1))break;
 800ac16:	2312      	movs	r3, #18
 800ac18:	18fb      	adds	r3, r7, r3
 800ac1a:	2200      	movs	r2, #0
 800ac1c:	5e9a      	ldrsh	r2, [r3, r2]
 800ac1e:	1dbb      	adds	r3, r7, #6
 800ac20:	2100      	movs	r1, #0
 800ac22:	5e5b      	ldrsh	r3, [r3, r1]
 800ac24:	3b01      	subs	r3, #1
 800ac26:	429a      	cmp	r2, r3
 800ac28:	da05      	bge.n	800ac36 <myLongStr+0x1a6>
		while(tmp_index>0){
 800ac2a:	697b      	ldr	r3, [r7, #20]
 800ac2c:	2b00      	cmp	r3, #0
 800ac2e:	d1ad      	bne.n	800ab8c <myLongStr+0xfc>
 800ac30:	e002      	b.n	800ac38 <myLongStr+0x1a8>
			if(tmp_size>=(p_size-1))break;
 800ac32:	46c0      	nop			; (mov r8, r8)
 800ac34:	e000      	b.n	800ac38 <myLongStr+0x1a8>
			if(tmp_size>=(p_size-1))break;
 800ac36:	46c0      	nop			; (mov r8, r8)
		}

	}

	if(tmp_iszero==1){
 800ac38:	2311      	movs	r3, #17
 800ac3a:	18fb      	adds	r3, r7, r3
 800ac3c:	781b      	ldrb	r3, [r3, #0]
 800ac3e:	2b01      	cmp	r3, #1
 800ac40:	d10f      	bne.n	800ac62 <myLongStr+0x1d2>
		p_dest[tmp_size]='0';
 800ac42:	2112      	movs	r1, #18
 800ac44:	187b      	adds	r3, r7, r1
 800ac46:	2200      	movs	r2, #0
 800ac48:	5e9b      	ldrsh	r3, [r3, r2]
 800ac4a:	68ba      	ldr	r2, [r7, #8]
 800ac4c:	18d3      	adds	r3, r2, r3
 800ac4e:	2230      	movs	r2, #48	; 0x30
 800ac50:	701a      	strb	r2, [r3, #0]
		tmp_size++;
 800ac52:	187b      	adds	r3, r7, r1
 800ac54:	2200      	movs	r2, #0
 800ac56:	5e9b      	ldrsh	r3, [r3, r2]
 800ac58:	b29b      	uxth	r3, r3
 800ac5a:	3301      	adds	r3, #1
 800ac5c:	b29a      	uxth	r2, r3
 800ac5e:	187b      	adds	r3, r7, r1
 800ac60:	801a      	strh	r2, [r3, #0]
	}

	p_dest[tmp_size]=0;
 800ac62:	2312      	movs	r3, #18
 800ac64:	18fb      	adds	r3, r7, r3
 800ac66:	2200      	movs	r2, #0
 800ac68:	5e9b      	ldrsh	r3, [r3, r2]
 800ac6a:	68ba      	ldr	r2, [r7, #8]
 800ac6c:	18d3      	adds	r3, r2, r3
 800ac6e:	2200      	movs	r2, #0
 800ac70:	701a      	strb	r2, [r3, #0]
	return p_dest;
 800ac72:	68bb      	ldr	r3, [r7, #8]
}
 800ac74:	0018      	movs	r0, r3
 800ac76:	46bd      	mov	sp, r7
 800ac78:	b006      	add	sp, #24
 800ac7a:	bd80      	pop	{r7, pc}
 800ac7c:	3b9aca00 	.word	0x3b9aca00

0800ac80 <myStrLong>:

long myStrLong(char *p_str,char p_base){
 800ac80:	b580      	push	{r7, lr}
 800ac82:	b084      	sub	sp, #16
 800ac84:	af00      	add	r7, sp, #0
 800ac86:	6078      	str	r0, [r7, #4]
 800ac88:	000a      	movs	r2, r1
 800ac8a:	1cfb      	adds	r3, r7, #3
 800ac8c:	701a      	strb	r2, [r3, #0]
	long tmp_long;
	tmp_long=0;
 800ac8e:	2300      	movs	r3, #0
 800ac90:	60fb      	str	r3, [r7, #12]
	if(p_base==10){
 800ac92:	1cfb      	adds	r3, r7, #3
 800ac94:	781b      	ldrb	r3, [r3, #0]
 800ac96:	2b0a      	cmp	r3, #10
 800ac98:	d120      	bne.n	800acdc <myStrLong+0x5c>
		while(*p_str != 0){
 800ac9a:	e01a      	b.n	800acd2 <myStrLong+0x52>
			if((*p_str>='0')&&(*p_str<='9')){
 800ac9c:	687b      	ldr	r3, [r7, #4]
 800ac9e:	781b      	ldrb	r3, [r3, #0]
 800aca0:	2b2f      	cmp	r3, #47	; 0x2f
 800aca2:	d90f      	bls.n	800acc4 <myStrLong+0x44>
 800aca4:	687b      	ldr	r3, [r7, #4]
 800aca6:	781b      	ldrb	r3, [r3, #0]
 800aca8:	2b39      	cmp	r3, #57	; 0x39
 800acaa:	d80b      	bhi.n	800acc4 <myStrLong+0x44>
				tmp_long*=10;
 800acac:	68fa      	ldr	r2, [r7, #12]
 800acae:	0013      	movs	r3, r2
 800acb0:	009b      	lsls	r3, r3, #2
 800acb2:	189b      	adds	r3, r3, r2
 800acb4:	005b      	lsls	r3, r3, #1
 800acb6:	60fb      	str	r3, [r7, #12]
				tmp_long+=*p_str-0x30;
 800acb8:	687b      	ldr	r3, [r7, #4]
 800acba:	781b      	ldrb	r3, [r3, #0]
 800acbc:	3b30      	subs	r3, #48	; 0x30
 800acbe:	68fa      	ldr	r2, [r7, #12]
 800acc0:	18d3      	adds	r3, r2, r3
 800acc2:	60fb      	str	r3, [r7, #12]
			}
			if(*p_str>='.')
 800acc4:	687b      	ldr	r3, [r7, #4]
 800acc6:	781b      	ldrb	r3, [r3, #0]
 800acc8:	2b2d      	cmp	r3, #45	; 0x2d
 800acca:	d902      	bls.n	800acd2 <myStrLong+0x52>
			p_str++;
 800accc:	687b      	ldr	r3, [r7, #4]
 800acce:	3301      	adds	r3, #1
 800acd0:	607b      	str	r3, [r7, #4]
		while(*p_str != 0){
 800acd2:	687b      	ldr	r3, [r7, #4]
 800acd4:	781b      	ldrb	r3, [r3, #0]
 800acd6:	2b00      	cmp	r3, #0
 800acd8:	d1e0      	bne.n	800ac9c <myStrLong+0x1c>
 800acda:	e03e      	b.n	800ad5a <myStrLong+0xda>
		}
	}
	else if(p_base==16){
 800acdc:	1cfb      	adds	r3, r7, #3
 800acde:	781b      	ldrb	r3, [r3, #0]
 800ace0:	2b10      	cmp	r3, #16
 800ace2:	d13a      	bne.n	800ad5a <myStrLong+0xda>
		while(*p_str != 0){
 800ace4:	e035      	b.n	800ad52 <myStrLong+0xd2>
			if(*p_str>='0'){
 800ace6:	687b      	ldr	r3, [r7, #4]
 800ace8:	781b      	ldrb	r3, [r3, #0]
 800acea:	2b2f      	cmp	r3, #47	; 0x2f
 800acec:	d92e      	bls.n	800ad4c <myStrLong+0xcc>
				tmp_long=tmp_long<<4;
 800acee:	68fb      	ldr	r3, [r7, #12]
 800acf0:	011b      	lsls	r3, r3, #4
 800acf2:	60fb      	str	r3, [r7, #12]
				if((*p_str>='0')&&(*p_str<='9'))tmp_long|=*p_str-'0';
 800acf4:	687b      	ldr	r3, [r7, #4]
 800acf6:	781b      	ldrb	r3, [r3, #0]
 800acf8:	2b2f      	cmp	r3, #47	; 0x2f
 800acfa:	d90a      	bls.n	800ad12 <myStrLong+0x92>
 800acfc:	687b      	ldr	r3, [r7, #4]
 800acfe:	781b      	ldrb	r3, [r3, #0]
 800ad00:	2b39      	cmp	r3, #57	; 0x39
 800ad02:	d806      	bhi.n	800ad12 <myStrLong+0x92>
 800ad04:	687b      	ldr	r3, [r7, #4]
 800ad06:	781b      	ldrb	r3, [r3, #0]
 800ad08:	3b30      	subs	r3, #48	; 0x30
 800ad0a:	68fa      	ldr	r2, [r7, #12]
 800ad0c:	4313      	orrs	r3, r2
 800ad0e:	60fb      	str	r3, [r7, #12]
 800ad10:	e01c      	b.n	800ad4c <myStrLong+0xcc>
				else if((*p_str>='a')&&(*p_str<='f'))tmp_long|=(*p_str-'a')+10;
 800ad12:	687b      	ldr	r3, [r7, #4]
 800ad14:	781b      	ldrb	r3, [r3, #0]
 800ad16:	2b60      	cmp	r3, #96	; 0x60
 800ad18:	d90a      	bls.n	800ad30 <myStrLong+0xb0>
 800ad1a:	687b      	ldr	r3, [r7, #4]
 800ad1c:	781b      	ldrb	r3, [r3, #0]
 800ad1e:	2b66      	cmp	r3, #102	; 0x66
 800ad20:	d806      	bhi.n	800ad30 <myStrLong+0xb0>
 800ad22:	687b      	ldr	r3, [r7, #4]
 800ad24:	781b      	ldrb	r3, [r3, #0]
 800ad26:	3b57      	subs	r3, #87	; 0x57
 800ad28:	68fa      	ldr	r2, [r7, #12]
 800ad2a:	4313      	orrs	r3, r2
 800ad2c:	60fb      	str	r3, [r7, #12]
 800ad2e:	e00d      	b.n	800ad4c <myStrLong+0xcc>
				else if((*p_str>='A')&&(*p_str<='F'))tmp_long|=(*p_str-'A')+10;
 800ad30:	687b      	ldr	r3, [r7, #4]
 800ad32:	781b      	ldrb	r3, [r3, #0]
 800ad34:	2b40      	cmp	r3, #64	; 0x40
 800ad36:	d909      	bls.n	800ad4c <myStrLong+0xcc>
 800ad38:	687b      	ldr	r3, [r7, #4]
 800ad3a:	781b      	ldrb	r3, [r3, #0]
 800ad3c:	2b46      	cmp	r3, #70	; 0x46
 800ad3e:	d805      	bhi.n	800ad4c <myStrLong+0xcc>
 800ad40:	687b      	ldr	r3, [r7, #4]
 800ad42:	781b      	ldrb	r3, [r3, #0]
 800ad44:	3b37      	subs	r3, #55	; 0x37
 800ad46:	68fa      	ldr	r2, [r7, #12]
 800ad48:	4313      	orrs	r3, r2
 800ad4a:	60fb      	str	r3, [r7, #12]
			}
			p_str++;
 800ad4c:	687b      	ldr	r3, [r7, #4]
 800ad4e:	3301      	adds	r3, #1
 800ad50:	607b      	str	r3, [r7, #4]
		while(*p_str != 0){
 800ad52:	687b      	ldr	r3, [r7, #4]
 800ad54:	781b      	ldrb	r3, [r3, #0]
 800ad56:	2b00      	cmp	r3, #0
 800ad58:	d1c5      	bne.n	800ace6 <myStrLong+0x66>
		}
	}
	return tmp_long;
 800ad5a:	68fb      	ldr	r3, [r7, #12]
}
 800ad5c:	0018      	movs	r0, r3
 800ad5e:	46bd      	mov	sp, r7
 800ad60:	b004      	add	sp, #16
 800ad62:	bd80      	pop	{r7, pc}

0800ad64 <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 800ad64:	b580      	push	{r7, lr}
 800ad66:	b082      	sub	sp, #8
 800ad68:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
 800ad6a:	4b12      	ldr	r3, [pc, #72]	; (800adb4 <HAL_MspInit+0x50>)
 800ad6c:	699a      	ldr	r2, [r3, #24]
 800ad6e:	4b11      	ldr	r3, [pc, #68]	; (800adb4 <HAL_MspInit+0x50>)
 800ad70:	2101      	movs	r1, #1
 800ad72:	430a      	orrs	r2, r1
 800ad74:	619a      	str	r2, [r3, #24]
 800ad76:	4b0f      	ldr	r3, [pc, #60]	; (800adb4 <HAL_MspInit+0x50>)
 800ad78:	699b      	ldr	r3, [r3, #24]
 800ad7a:	2201      	movs	r2, #1
 800ad7c:	4013      	ands	r3, r2
 800ad7e:	607b      	str	r3, [r7, #4]
 800ad80:	687b      	ldr	r3, [r7, #4]
  __HAL_RCC_PWR_CLK_ENABLE();
 800ad82:	4b0c      	ldr	r3, [pc, #48]	; (800adb4 <HAL_MspInit+0x50>)
 800ad84:	69da      	ldr	r2, [r3, #28]
 800ad86:	4b0b      	ldr	r3, [pc, #44]	; (800adb4 <HAL_MspInit+0x50>)
 800ad88:	2180      	movs	r1, #128	; 0x80
 800ad8a:	0549      	lsls	r1, r1, #21
 800ad8c:	430a      	orrs	r2, r1
 800ad8e:	61da      	str	r2, [r3, #28]
 800ad90:	4b08      	ldr	r3, [pc, #32]	; (800adb4 <HAL_MspInit+0x50>)
 800ad92:	69da      	ldr	r2, [r3, #28]
 800ad94:	2380      	movs	r3, #128	; 0x80
 800ad96:	055b      	lsls	r3, r3, #21
 800ad98:	4013      	ands	r3, r2
 800ad9a:	603b      	str	r3, [r7, #0]
 800ad9c:	683b      	ldr	r3, [r7, #0]

  /* System interrupt init*/
  /* PendSV_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(PendSV_IRQn, 3, 0);
 800ad9e:	2302      	movs	r3, #2
 800ada0:	425b      	negs	r3, r3
 800ada2:	2200      	movs	r2, #0
 800ada4:	2103      	movs	r1, #3
 800ada6:	0018      	movs	r0, r3
 800ada8:	f000 fac2 	bl	800b330 <HAL_NVIC_SetPriority>

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 800adac:	46c0      	nop			; (mov r8, r8)
 800adae:	46bd      	mov	sp, r7
 800adb0:	b002      	add	sp, #8
 800adb2:	bd80      	pop	{r7, pc}
 800adb4:	40021000 	.word	0x40021000

0800adb8 <HAL_SPI_MspInit>:
* This function configures the hardware resources used in this example
* @param hspi: SPI handle pointer
* @retval None
*/
void HAL_SPI_MspInit(SPI_HandleTypeDef* hspi)
{
 800adb8:	b590      	push	{r4, r7, lr}
 800adba:	b08b      	sub	sp, #44	; 0x2c
 800adbc:	af00      	add	r7, sp, #0
 800adbe:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 800adc0:	2414      	movs	r4, #20
 800adc2:	193b      	adds	r3, r7, r4
 800adc4:	0018      	movs	r0, r3
 800adc6:	2314      	movs	r3, #20
 800adc8:	001a      	movs	r2, r3
 800adca:	2100      	movs	r1, #0
 800adcc:	f00a f921 	bl	8015012 <memset>
  if(hspi->Instance==SPI2)
 800add0:	687b      	ldr	r3, [r7, #4]
 800add2:	681b      	ldr	r3, [r3, #0]
 800add4:	4a1c      	ldr	r2, [pc, #112]	; (800ae48 <HAL_SPI_MspInit+0x90>)
 800add6:	4293      	cmp	r3, r2
 800add8:	d132      	bne.n	800ae40 <HAL_SPI_MspInit+0x88>
  {
  /* USER CODE BEGIN SPI2_MspInit 0 */

  /* USER CODE END SPI2_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_SPI2_CLK_ENABLE();
 800adda:	4b1c      	ldr	r3, [pc, #112]	; (800ae4c <HAL_SPI_MspInit+0x94>)
 800addc:	69da      	ldr	r2, [r3, #28]
 800adde:	4b1b      	ldr	r3, [pc, #108]	; (800ae4c <HAL_SPI_MspInit+0x94>)
 800ade0:	2180      	movs	r1, #128	; 0x80
 800ade2:	01c9      	lsls	r1, r1, #7
 800ade4:	430a      	orrs	r2, r1
 800ade6:	61da      	str	r2, [r3, #28]
 800ade8:	4b18      	ldr	r3, [pc, #96]	; (800ae4c <HAL_SPI_MspInit+0x94>)
 800adea:	69da      	ldr	r2, [r3, #28]
 800adec:	2380      	movs	r3, #128	; 0x80
 800adee:	01db      	lsls	r3, r3, #7
 800adf0:	4013      	ands	r3, r2
 800adf2:	613b      	str	r3, [r7, #16]
 800adf4:	693b      	ldr	r3, [r7, #16]

    __HAL_RCC_GPIOB_CLK_ENABLE();
 800adf6:	4b15      	ldr	r3, [pc, #84]	; (800ae4c <HAL_SPI_MspInit+0x94>)
 800adf8:	695a      	ldr	r2, [r3, #20]
 800adfa:	4b14      	ldr	r3, [pc, #80]	; (800ae4c <HAL_SPI_MspInit+0x94>)
 800adfc:	2180      	movs	r1, #128	; 0x80
 800adfe:	02c9      	lsls	r1, r1, #11
 800ae00:	430a      	orrs	r2, r1
 800ae02:	615a      	str	r2, [r3, #20]
 800ae04:	4b11      	ldr	r3, [pc, #68]	; (800ae4c <HAL_SPI_MspInit+0x94>)
 800ae06:	695a      	ldr	r2, [r3, #20]
 800ae08:	2380      	movs	r3, #128	; 0x80
 800ae0a:	02db      	lsls	r3, r3, #11
 800ae0c:	4013      	ands	r3, r2
 800ae0e:	60fb      	str	r3, [r7, #12]
 800ae10:	68fb      	ldr	r3, [r7, #12]
    /**SPI2 GPIO Configuration
    PB13     ------> SPI2_SCK
    PB14     ------> SPI2_MISO
    PB15     ------> SPI2_MOSI
    */
    GPIO_InitStruct.Pin = GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15;
 800ae12:	193b      	adds	r3, r7, r4
 800ae14:	22e0      	movs	r2, #224	; 0xe0
 800ae16:	0212      	lsls	r2, r2, #8
 800ae18:	601a      	str	r2, [r3, #0]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800ae1a:	0021      	movs	r1, r4
 800ae1c:	187b      	adds	r3, r7, r1
 800ae1e:	2202      	movs	r2, #2
 800ae20:	605a      	str	r2, [r3, #4]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 800ae22:	187b      	adds	r3, r7, r1
 800ae24:	2200      	movs	r2, #0
 800ae26:	609a      	str	r2, [r3, #8]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 800ae28:	187b      	adds	r3, r7, r1
 800ae2a:	2203      	movs	r2, #3
 800ae2c:	60da      	str	r2, [r3, #12]
    GPIO_InitStruct.Alternate = GPIO_AF0_SPI2;
 800ae2e:	187b      	adds	r3, r7, r1
 800ae30:	2200      	movs	r2, #0
 800ae32:	611a      	str	r2, [r3, #16]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 800ae34:	187b      	adds	r3, r7, r1
 800ae36:	4a06      	ldr	r2, [pc, #24]	; (800ae50 <HAL_SPI_MspInit+0x98>)
 800ae38:	0019      	movs	r1, r3
 800ae3a:	0010      	movs	r0, r2
 800ae3c:	f000 fb28 	bl	800b490 <HAL_GPIO_Init>
  /* USER CODE BEGIN SPI2_MspInit 1 */

  /* USER CODE END SPI2_MspInit 1 */
  }

}
 800ae40:	46c0      	nop			; (mov r8, r8)
 800ae42:	46bd      	mov	sp, r7
 800ae44:	b00b      	add	sp, #44	; 0x2c
 800ae46:	bd90      	pop	{r4, r7, pc}
 800ae48:	40003800 	.word	0x40003800
 800ae4c:	40021000 	.word	0x40021000
 800ae50:	48000400 	.word	0x48000400

0800ae54 <HAL_UART_MspInit>:
* This function configures the hardware resources used in this example
* @param huart: UART handle pointer
* @retval None
*/
void HAL_UART_MspInit(UART_HandleTypeDef* huart)
{
 800ae54:	b590      	push	{r4, r7, lr}
 800ae56:	b08d      	sub	sp, #52	; 0x34
 800ae58:	af00      	add	r7, sp, #0
 800ae5a:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 800ae5c:	241c      	movs	r4, #28
 800ae5e:	193b      	adds	r3, r7, r4
 800ae60:	0018      	movs	r0, r3
 800ae62:	2314      	movs	r3, #20
 800ae64:	001a      	movs	r2, r3
 800ae66:	2100      	movs	r1, #0
 800ae68:	f00a f8d3 	bl	8015012 <memset>
  if(huart->Instance==USART1)
 800ae6c:	687b      	ldr	r3, [r7, #4]
 800ae6e:	681b      	ldr	r3, [r3, #0]
 800ae70:	4a49      	ldr	r2, [pc, #292]	; (800af98 <HAL_UART_MspInit+0x144>)
 800ae72:	4293      	cmp	r3, r2
 800ae74:	d134      	bne.n	800aee0 <HAL_UART_MspInit+0x8c>
  {
  /* USER CODE BEGIN USART1_MspInit 0 */

  /* USER CODE END USART1_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_USART1_CLK_ENABLE();
 800ae76:	4b49      	ldr	r3, [pc, #292]	; (800af9c <HAL_UART_MspInit+0x148>)
 800ae78:	699a      	ldr	r2, [r3, #24]
 800ae7a:	4b48      	ldr	r3, [pc, #288]	; (800af9c <HAL_UART_MspInit+0x148>)
 800ae7c:	2180      	movs	r1, #128	; 0x80
 800ae7e:	01c9      	lsls	r1, r1, #7
 800ae80:	430a      	orrs	r2, r1
 800ae82:	619a      	str	r2, [r3, #24]
 800ae84:	4b45      	ldr	r3, [pc, #276]	; (800af9c <HAL_UART_MspInit+0x148>)
 800ae86:	699a      	ldr	r2, [r3, #24]
 800ae88:	2380      	movs	r3, #128	; 0x80
 800ae8a:	01db      	lsls	r3, r3, #7
 800ae8c:	4013      	ands	r3, r2
 800ae8e:	61bb      	str	r3, [r7, #24]
 800ae90:	69bb      	ldr	r3, [r7, #24]

    __HAL_RCC_GPIOA_CLK_ENABLE();
 800ae92:	4b42      	ldr	r3, [pc, #264]	; (800af9c <HAL_UART_MspInit+0x148>)
 800ae94:	695a      	ldr	r2, [r3, #20]
 800ae96:	4b41      	ldr	r3, [pc, #260]	; (800af9c <HAL_UART_MspInit+0x148>)
 800ae98:	2180      	movs	r1, #128	; 0x80
 800ae9a:	0289      	lsls	r1, r1, #10
 800ae9c:	430a      	orrs	r2, r1
 800ae9e:	615a      	str	r2, [r3, #20]
 800aea0:	4b3e      	ldr	r3, [pc, #248]	; (800af9c <HAL_UART_MspInit+0x148>)
 800aea2:	695a      	ldr	r2, [r3, #20]
 800aea4:	2380      	movs	r3, #128	; 0x80
 800aea6:	029b      	lsls	r3, r3, #10
 800aea8:	4013      	ands	r3, r2
 800aeaa:	617b      	str	r3, [r7, #20]
 800aeac:	697b      	ldr	r3, [r7, #20]
    /**USART1 GPIO Configuration
    PA9     ------> USART1_TX
    PA10     ------> USART1_RX
    */
    GPIO_InitStruct.Pin = GPIO_PIN_9|GPIO_PIN_10;
 800aeae:	193b      	adds	r3, r7, r4
 800aeb0:	22c0      	movs	r2, #192	; 0xc0
 800aeb2:	00d2      	lsls	r2, r2, #3
 800aeb4:	601a      	str	r2, [r3, #0]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800aeb6:	0021      	movs	r1, r4
 800aeb8:	187b      	adds	r3, r7, r1
 800aeba:	2202      	movs	r2, #2
 800aebc:	605a      	str	r2, [r3, #4]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 800aebe:	187b      	adds	r3, r7, r1
 800aec0:	2200      	movs	r2, #0
 800aec2:	609a      	str	r2, [r3, #8]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 800aec4:	187b      	adds	r3, r7, r1
 800aec6:	2203      	movs	r2, #3
 800aec8:	60da      	str	r2, [r3, #12]
    GPIO_InitStruct.Alternate = GPIO_AF1_USART1;
 800aeca:	187b      	adds	r3, r7, r1
 800aecc:	2201      	movs	r2, #1
 800aece:	611a      	str	r2, [r3, #16]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800aed0:	187a      	adds	r2, r7, r1
 800aed2:	2390      	movs	r3, #144	; 0x90
 800aed4:	05db      	lsls	r3, r3, #23
 800aed6:	0011      	movs	r1, r2
 800aed8:	0018      	movs	r0, r3
 800aeda:	f000 fad9 	bl	800b490 <HAL_GPIO_Init>
  /* USER CODE BEGIN USART2_MspInit 1 */

  /* USER CODE END USART2_MspInit 1 */
  }

}
 800aede:	e056      	b.n	800af8e <HAL_UART_MspInit+0x13a>
  else if(huart->Instance==USART2)
 800aee0:	687b      	ldr	r3, [r7, #4]
 800aee2:	681b      	ldr	r3, [r3, #0]
 800aee4:	4a2e      	ldr	r2, [pc, #184]	; (800afa0 <HAL_UART_MspInit+0x14c>)
 800aee6:	4293      	cmp	r3, r2
 800aee8:	d151      	bne.n	800af8e <HAL_UART_MspInit+0x13a>
    __HAL_RCC_USART2_CLK_ENABLE();
 800aeea:	4b2c      	ldr	r3, [pc, #176]	; (800af9c <HAL_UART_MspInit+0x148>)
 800aeec:	69da      	ldr	r2, [r3, #28]
 800aeee:	4b2b      	ldr	r3, [pc, #172]	; (800af9c <HAL_UART_MspInit+0x148>)
 800aef0:	2180      	movs	r1, #128	; 0x80
 800aef2:	0289      	lsls	r1, r1, #10
 800aef4:	430a      	orrs	r2, r1
 800aef6:	61da      	str	r2, [r3, #28]
 800aef8:	4b28      	ldr	r3, [pc, #160]	; (800af9c <HAL_UART_MspInit+0x148>)
 800aefa:	69da      	ldr	r2, [r3, #28]
 800aefc:	2380      	movs	r3, #128	; 0x80
 800aefe:	029b      	lsls	r3, r3, #10
 800af00:	4013      	ands	r3, r2
 800af02:	613b      	str	r3, [r7, #16]
 800af04:	693b      	ldr	r3, [r7, #16]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 800af06:	4b25      	ldr	r3, [pc, #148]	; (800af9c <HAL_UART_MspInit+0x148>)
 800af08:	695a      	ldr	r2, [r3, #20]
 800af0a:	4b24      	ldr	r3, [pc, #144]	; (800af9c <HAL_UART_MspInit+0x148>)
 800af0c:	2180      	movs	r1, #128	; 0x80
 800af0e:	0289      	lsls	r1, r1, #10
 800af10:	430a      	orrs	r2, r1
 800af12:	615a      	str	r2, [r3, #20]
 800af14:	4b21      	ldr	r3, [pc, #132]	; (800af9c <HAL_UART_MspInit+0x148>)
 800af16:	695a      	ldr	r2, [r3, #20]
 800af18:	2380      	movs	r3, #128	; 0x80
 800af1a:	029b      	lsls	r3, r3, #10
 800af1c:	4013      	ands	r3, r2
 800af1e:	60fb      	str	r3, [r7, #12]
 800af20:	68fb      	ldr	r3, [r7, #12]
    GPIO_InitStruct.Pin = GPIO_PIN_2;
 800af22:	241c      	movs	r4, #28
 800af24:	193b      	adds	r3, r7, r4
 800af26:	2204      	movs	r2, #4
 800af28:	601a      	str	r2, [r3, #0]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800af2a:	193b      	adds	r3, r7, r4
 800af2c:	2202      	movs	r2, #2
 800af2e:	605a      	str	r2, [r3, #4]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 800af30:	193b      	adds	r3, r7, r4
 800af32:	2200      	movs	r2, #0
 800af34:	609a      	str	r2, [r3, #8]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 800af36:	193b      	adds	r3, r7, r4
 800af38:	2203      	movs	r2, #3
 800af3a:	60da      	str	r2, [r3, #12]
    GPIO_InitStruct.Alternate = GPIO_AF1_USART2;
 800af3c:	193b      	adds	r3, r7, r4
 800af3e:	2201      	movs	r2, #1
 800af40:	611a      	str	r2, [r3, #16]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800af42:	193a      	adds	r2, r7, r4
 800af44:	2390      	movs	r3, #144	; 0x90
 800af46:	05db      	lsls	r3, r3, #23
 800af48:	0011      	movs	r1, r2
 800af4a:	0018      	movs	r0, r3
 800af4c:	f000 faa0 	bl	800b490 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = GPIO_PIN_3;
 800af50:	0021      	movs	r1, r4
 800af52:	187b      	adds	r3, r7, r1
 800af54:	2208      	movs	r2, #8
 800af56:	601a      	str	r2, [r3, #0]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800af58:	187b      	adds	r3, r7, r1
 800af5a:	2202      	movs	r2, #2
 800af5c:	605a      	str	r2, [r3, #4]
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 800af5e:	187b      	adds	r3, r7, r1
 800af60:	2201      	movs	r2, #1
 800af62:	609a      	str	r2, [r3, #8]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 800af64:	187b      	adds	r3, r7, r1
 800af66:	2203      	movs	r2, #3
 800af68:	60da      	str	r2, [r3, #12]
    GPIO_InitStruct.Alternate = GPIO_AF1_USART2;
 800af6a:	187b      	adds	r3, r7, r1
 800af6c:	2201      	movs	r2, #1
 800af6e:	611a      	str	r2, [r3, #16]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800af70:	187a      	adds	r2, r7, r1
 800af72:	2390      	movs	r3, #144	; 0x90
 800af74:	05db      	lsls	r3, r3, #23
 800af76:	0011      	movs	r1, r2
 800af78:	0018      	movs	r0, r3
 800af7a:	f000 fa89 	bl	800b490 <HAL_GPIO_Init>
    HAL_NVIC_SetPriority(USART2_IRQn, 3, 0);
 800af7e:	2200      	movs	r2, #0
 800af80:	2103      	movs	r1, #3
 800af82:	201c      	movs	r0, #28
 800af84:	f000 f9d4 	bl	800b330 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(USART2_IRQn);
 800af88:	201c      	movs	r0, #28
 800af8a:	f000 f9e6 	bl	800b35a <HAL_NVIC_EnableIRQ>
}
 800af8e:	46c0      	nop			; (mov r8, r8)
 800af90:	46bd      	mov	sp, r7
 800af92:	b00d      	add	sp, #52	; 0x34
 800af94:	bd90      	pop	{r4, r7, pc}
 800af96:	46c0      	nop			; (mov r8, r8)
 800af98:	40013800 	.word	0x40013800
 800af9c:	40021000 	.word	0x40021000
 800afa0:	40004400 	.word	0x40004400

0800afa4 <NMI_Handler>:
/******************************************************************************/
/**
  * @brief This function handles Non maskable interrupt.
  */
void NMI_Handler(void)
{
 800afa4:	b580      	push	{r7, lr}
 800afa6:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
  while (1)
 800afa8:	e7fe      	b.n	800afa8 <NMI_Handler+0x4>

0800afaa <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
 800afaa:	b580      	push	{r7, lr}
 800afac:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
 800afae:	e7fe      	b.n	800afae <HardFault_Handler+0x4>

0800afb0 <SysTick_Handler>:

/**
  * @brief This function handles System tick timer.
  */
void SysTick_Handler(void)
{
 800afb0:	b580      	push	{r7, lr}
 800afb2:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 800afb4:	f000 f8d0 	bl	800b158 <HAL_IncTick>
#if (INCLUDE_xTaskGetSchedulerState == 1 )
  if (xTaskGetSchedulerState() != taskSCHEDULER_NOT_STARTED)
 800afb8:	f008 ffa0 	bl	8013efc <xTaskGetSchedulerState>
 800afbc:	0003      	movs	r3, r0
 800afbe:	2b01      	cmp	r3, #1
 800afc0:	d001      	beq.n	800afc6 <SysTick_Handler+0x16>
  {
#endif /* INCLUDE_xTaskGetSchedulerState */
  xPortSysTickHandler();
 800afc2:	f009 f901 	bl	80141c8 <xPortSysTickHandler>
  }
#endif /* INCLUDE_xTaskGetSchedulerState */
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
 800afc6:	46c0      	nop			; (mov r8, r8)
 800afc8:	46bd      	mov	sp, r7
 800afca:	bd80      	pop	{r7, pc}

0800afcc <USART2_IRQHandler>:

/**
  * @brief This function handles USART2 global interrupt / USART2 wake-up interrupt through EXTI line 26.
  */
void USART2_IRQHandler(void)
{
 800afcc:	b580      	push	{r7, lr}
 800afce:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN USART2_IRQn 0 */

  /* USER CODE END USART2_IRQn 0 */
  HAL_UART_IRQHandler(&huart2);
 800afd0:	4b03      	ldr	r3, [pc, #12]	; (800afe0 <USART2_IRQHandler+0x14>)
 800afd2:	0018      	movs	r0, r3
 800afd4:	f003 fb14 	bl	800e600 <HAL_UART_IRQHandler>
  /* USER CODE BEGIN USART2_IRQn 1 */

  /* USER CODE END USART2_IRQn 1 */
}
 800afd8:	46c0      	nop			; (mov r8, r8)
 800afda:	46bd      	mov	sp, r7
 800afdc:	bd80      	pop	{r7, pc}
 800afde:	46c0      	nop			; (mov r8, r8)
 800afe0:	2000275c 	.word	0x2000275c

0800afe4 <USB_IRQHandler>:

/**
  * @brief This function handles USB global interrupt / USB wake-up interrupt through EXTI line 18.
  */
void USB_IRQHandler(void)
{
 800afe4:	b580      	push	{r7, lr}
 800afe6:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN USB_IRQn 0 */

  /* USER CODE END USB_IRQn 0 */
  HAL_PCD_IRQHandler(&hpcd_USB_FS);
 800afe8:	4b03      	ldr	r3, [pc, #12]	; (800aff8 <USB_IRQHandler+0x14>)
 800afea:	0018      	movs	r0, r3
 800afec:	f000 fd36 	bl	800ba5c <HAL_PCD_IRQHandler>
  /* USER CODE BEGIN USB_IRQn 1 */

  /* USER CODE END USB_IRQn 1 */
}
 800aff0:	46c0      	nop			; (mov r8, r8)
 800aff2:	46bd      	mov	sp, r7
 800aff4:	bd80      	pop	{r7, pc}
 800aff6:	46c0      	nop			; (mov r8, r8)
 800aff8:	20003478 	.word	0x20003478

0800affc <_sbrk>:
 *
 * @param incr Memory size
 * @return Pointer to allocated memory
 */
void *_sbrk(ptrdiff_t incr)
{
 800affc:	b580      	push	{r7, lr}
 800affe:	b086      	sub	sp, #24
 800b000:	af00      	add	r7, sp, #0
 800b002:	6078      	str	r0, [r7, #4]
  extern uint8_t _end; /* Symbol defined in the linker script */
  extern uint8_t _estack; /* Symbol defined in the linker script */
  extern uint32_t _Min_Stack_Size; /* Symbol defined in the linker script */
  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;
 800b004:	4a14      	ldr	r2, [pc, #80]	; (800b058 <_sbrk+0x5c>)
 800b006:	4b15      	ldr	r3, [pc, #84]	; (800b05c <_sbrk+0x60>)
 800b008:	1ad3      	subs	r3, r2, r3
 800b00a:	617b      	str	r3, [r7, #20]
  const uint8_t *max_heap = (uint8_t *)stack_limit;
 800b00c:	697b      	ldr	r3, [r7, #20]
 800b00e:	613b      	str	r3, [r7, #16]
  uint8_t *prev_heap_end;

  /* Initialize heap end at first call */
  if (NULL == __sbrk_heap_end)
 800b010:	4b13      	ldr	r3, [pc, #76]	; (800b060 <_sbrk+0x64>)
 800b012:	681b      	ldr	r3, [r3, #0]
 800b014:	2b00      	cmp	r3, #0
 800b016:	d102      	bne.n	800b01e <_sbrk+0x22>
  {
    __sbrk_heap_end = &_end;
 800b018:	4b11      	ldr	r3, [pc, #68]	; (800b060 <_sbrk+0x64>)
 800b01a:	4a12      	ldr	r2, [pc, #72]	; (800b064 <_sbrk+0x68>)
 800b01c:	601a      	str	r2, [r3, #0]
  }

  /* Protect heap from growing into the reserved MSP stack */
  if (__sbrk_heap_end + incr > max_heap)
 800b01e:	4b10      	ldr	r3, [pc, #64]	; (800b060 <_sbrk+0x64>)
 800b020:	681a      	ldr	r2, [r3, #0]
 800b022:	687b      	ldr	r3, [r7, #4]
 800b024:	18d3      	adds	r3, r2, r3
 800b026:	693a      	ldr	r2, [r7, #16]
 800b028:	429a      	cmp	r2, r3
 800b02a:	d207      	bcs.n	800b03c <_sbrk+0x40>
  {
    errno = ENOMEM;
 800b02c:	f009 ffbe 	bl	8014fac <__errno>
 800b030:	0003      	movs	r3, r0
 800b032:	220c      	movs	r2, #12
 800b034:	601a      	str	r2, [r3, #0]
    return (void *)-1;
 800b036:	2301      	movs	r3, #1
 800b038:	425b      	negs	r3, r3
 800b03a:	e009      	b.n	800b050 <_sbrk+0x54>
  }

  prev_heap_end = __sbrk_heap_end;
 800b03c:	4b08      	ldr	r3, [pc, #32]	; (800b060 <_sbrk+0x64>)
 800b03e:	681b      	ldr	r3, [r3, #0]
 800b040:	60fb      	str	r3, [r7, #12]
  __sbrk_heap_end += incr;
 800b042:	4b07      	ldr	r3, [pc, #28]	; (800b060 <_sbrk+0x64>)
 800b044:	681a      	ldr	r2, [r3, #0]
 800b046:	687b      	ldr	r3, [r7, #4]
 800b048:	18d2      	adds	r2, r2, r3
 800b04a:	4b05      	ldr	r3, [pc, #20]	; (800b060 <_sbrk+0x64>)
 800b04c:	601a      	str	r2, [r3, #0]

  return (void *)prev_heap_end;
 800b04e:	68fb      	ldr	r3, [r7, #12]
}
 800b050:	0018      	movs	r0, r3
 800b052:	46bd      	mov	sp, r7
 800b054:	b006      	add	sp, #24
 800b056:	bd80      	pop	{r7, pc}
 800b058:	20004000 	.word	0x20004000
 800b05c:	00000400 	.word	0x00000400
 800b060:	200005c8 	.word	0x200005c8
 800b064:	20003780 	.word	0x20003780

0800b068 <SystemInit>:
  * @brief  Setup the microcontroller system
  * @param  None
  * @retval None
  */
void SystemInit(void)
{
 800b068:	b580      	push	{r7, lr}
 800b06a:	af00      	add	r7, sp, #0
                         before branch to main program. This call is made inside
                         the "startup_stm32f0xx.s" file.
                         User can setups the default system clock (System clock source, PLL Multiplier
                         and Divider factors, AHB/APBx prescalers and Flash settings).
   */
}
 800b06c:	46c0      	nop			; (mov r8, r8)
 800b06e:	46bd      	mov	sp, r7
 800b070:	bd80      	pop	{r7, pc}
	...

0800b074 <Reset_Handler>:

  .section .text.Reset_Handler
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:
  ldr   r0, =_estack
 800b074:	480d      	ldr	r0, [pc, #52]	; (800b0ac <LoopForever+0x2>)
  mov   sp, r0          /* set stack pointer */
 800b076:	4685      	mov	sp, r0

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
 800b078:	480d      	ldr	r0, [pc, #52]	; (800b0b0 <LoopForever+0x6>)
  ldr r1, =_edata
 800b07a:	490e      	ldr	r1, [pc, #56]	; (800b0b4 <LoopForever+0xa>)
  ldr r2, =_sidata
 800b07c:	4a0e      	ldr	r2, [pc, #56]	; (800b0b8 <LoopForever+0xe>)
  movs r3, #0
 800b07e:	2300      	movs	r3, #0
  b LoopCopyDataInit
 800b080:	e002      	b.n	800b088 <LoopCopyDataInit>

0800b082 <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 800b082:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 800b084:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 800b086:	3304      	adds	r3, #4

0800b088 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 800b088:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 800b08a:	428c      	cmp	r4, r1
  bcc CopyDataInit
 800b08c:	d3f9      	bcc.n	800b082 <CopyDataInit>
  
/* Zero fill the bss segment. */
  ldr r2, =_sbss
 800b08e:	4a0b      	ldr	r2, [pc, #44]	; (800b0bc <LoopForever+0x12>)
  ldr r4, =_ebss
 800b090:	4c0b      	ldr	r4, [pc, #44]	; (800b0c0 <LoopForever+0x16>)
  movs r3, #0
 800b092:	2300      	movs	r3, #0
  b LoopFillZerobss
 800b094:	e001      	b.n	800b09a <LoopFillZerobss>

0800b096 <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 800b096:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 800b098:	3204      	adds	r2, #4

0800b09a <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 800b09a:	42a2      	cmp	r2, r4
  bcc FillZerobss
 800b09c:	d3fb      	bcc.n	800b096 <FillZerobss>

/* Call the clock system intitialization function.*/
  bl  SystemInit
 800b09e:	f7ff ffe3 	bl	800b068 <SystemInit>
/* Call static constructors */
  bl __libc_init_array
 800b0a2:	f009 ff89 	bl	8014fb8 <__libc_init_array>
/* Call the application's entry point.*/
  bl main
 800b0a6:	f7ff fa17 	bl	800a4d8 <main>

0800b0aa <LoopForever>:

LoopForever:
    b LoopForever
 800b0aa:	e7fe      	b.n	800b0aa <LoopForever>
  ldr   r0, =_estack
 800b0ac:	20004000 	.word	0x20004000
  ldr r0, =_sdata
 800b0b0:	200000c0 	.word	0x200000c0
  ldr r1, =_edata
 800b0b4:	20000340 	.word	0x20000340
  ldr r2, =_sidata
 800b0b8:	08015e80 	.word	0x08015e80
  ldr r2, =_sbss
 800b0bc:	20000340 	.word	0x20000340
  ldr r4, =_ebss
 800b0c0:	2000377c 	.word	0x2000377c

0800b0c4 <ADC1_COMP_IRQHandler>:
 * @retval : None
*/
    .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
 800b0c4:	e7fe      	b.n	800b0c4 <ADC1_COMP_IRQHandler>
	...

0800b0c8 <HAL_Init>:
  *       In the default implementation,Systick is used as source of time base.
  *       The tick variable is incremented each 1ms in its ISR.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 800b0c8:	b580      	push	{r7, lr}
 800b0ca:	af00      	add	r7, sp, #0
  /* Configure Flash prefetch */ 
#if (PREFETCH_ENABLE != 0)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 800b0cc:	4b07      	ldr	r3, [pc, #28]	; (800b0ec <HAL_Init+0x24>)
 800b0ce:	681a      	ldr	r2, [r3, #0]
 800b0d0:	4b06      	ldr	r3, [pc, #24]	; (800b0ec <HAL_Init+0x24>)
 800b0d2:	2110      	movs	r1, #16
 800b0d4:	430a      	orrs	r2, r1
 800b0d6:	601a      	str	r2, [r3, #0]
#endif /* PREFETCH_ENABLE */

  /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */

  HAL_InitTick(TICK_INT_PRIORITY);
 800b0d8:	2003      	movs	r0, #3
 800b0da:	f000 f809 	bl	800b0f0 <HAL_InitTick>

  /* Init the low level hardware */
  HAL_MspInit();
 800b0de:	f7ff fe41 	bl	800ad64 <HAL_MspInit>

  /* Return function status */
  return HAL_OK;
 800b0e2:	2300      	movs	r3, #0
}
 800b0e4:	0018      	movs	r0, r3
 800b0e6:	46bd      	mov	sp, r7
 800b0e8:	bd80      	pop	{r7, pc}
 800b0ea:	46c0      	nop			; (mov r8, r8)
 800b0ec:	40022000 	.word	0x40022000

0800b0f0 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 800b0f0:	b590      	push	{r4, r7, lr}
 800b0f2:	b083      	sub	sp, #12
 800b0f4:	af00      	add	r7, sp, #0
 800b0f6:	6078      	str	r0, [r7, #4]
  /*Configure the SysTick to have interrupt in 1ms time basis*/
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) > 0U)
 800b0f8:	4b14      	ldr	r3, [pc, #80]	; (800b14c <HAL_InitTick+0x5c>)
 800b0fa:	681c      	ldr	r4, [r3, #0]
 800b0fc:	4b14      	ldr	r3, [pc, #80]	; (800b150 <HAL_InitTick+0x60>)
 800b0fe:	781b      	ldrb	r3, [r3, #0]
 800b100:	0019      	movs	r1, r3
 800b102:	23fa      	movs	r3, #250	; 0xfa
 800b104:	0098      	lsls	r0, r3, #2
 800b106:	f7fe f811 	bl	800912c <__udivsi3>
 800b10a:	0003      	movs	r3, r0
 800b10c:	0019      	movs	r1, r3
 800b10e:	0020      	movs	r0, r4
 800b110:	f7fe f80c 	bl	800912c <__udivsi3>
 800b114:	0003      	movs	r3, r0
 800b116:	0018      	movs	r0, r3
 800b118:	f000 f92f 	bl	800b37a <HAL_SYSTICK_Config>
 800b11c:	1e03      	subs	r3, r0, #0
 800b11e:	d001      	beq.n	800b124 <HAL_InitTick+0x34>
  {
    return HAL_ERROR;
 800b120:	2301      	movs	r3, #1
 800b122:	e00f      	b.n	800b144 <HAL_InitTick+0x54>
  }

  /* Configure the SysTick IRQ priority */
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 800b124:	687b      	ldr	r3, [r7, #4]
 800b126:	2b03      	cmp	r3, #3
 800b128:	d80b      	bhi.n	800b142 <HAL_InitTick+0x52>
  {
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 800b12a:	6879      	ldr	r1, [r7, #4]
 800b12c:	2301      	movs	r3, #1
 800b12e:	425b      	negs	r3, r3
 800b130:	2200      	movs	r2, #0
 800b132:	0018      	movs	r0, r3
 800b134:	f000 f8fc 	bl	800b330 <HAL_NVIC_SetPriority>
    uwTickPrio = TickPriority;
 800b138:	4b06      	ldr	r3, [pc, #24]	; (800b154 <HAL_InitTick+0x64>)
 800b13a:	687a      	ldr	r2, [r7, #4]
 800b13c:	601a      	str	r2, [r3, #0]
  {
    return HAL_ERROR;
  }

   /* Return function status */
  return HAL_OK;
 800b13e:	2300      	movs	r3, #0
 800b140:	e000      	b.n	800b144 <HAL_InitTick+0x54>
    return HAL_ERROR;
 800b142:	2301      	movs	r3, #1
}
 800b144:	0018      	movs	r0, r3
 800b146:	46bd      	mov	sp, r7
 800b148:	b003      	add	sp, #12
 800b14a:	bd90      	pop	{r4, r7, pc}
 800b14c:	2000015c 	.word	0x2000015c
 800b150:	20000164 	.word	0x20000164
 800b154:	20000160 	.word	0x20000160

0800b158 <HAL_IncTick>:
  * @note This function is declared as __weak to be overwritten in case of other 
  *       implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
 800b158:	b580      	push	{r7, lr}
 800b15a:	af00      	add	r7, sp, #0
  uwTick += uwTickFreq;
 800b15c:	4b05      	ldr	r3, [pc, #20]	; (800b174 <HAL_IncTick+0x1c>)
 800b15e:	781b      	ldrb	r3, [r3, #0]
 800b160:	001a      	movs	r2, r3
 800b162:	4b05      	ldr	r3, [pc, #20]	; (800b178 <HAL_IncTick+0x20>)
 800b164:	681b      	ldr	r3, [r3, #0]
 800b166:	18d2      	adds	r2, r2, r3
 800b168:	4b03      	ldr	r3, [pc, #12]	; (800b178 <HAL_IncTick+0x20>)
 800b16a:	601a      	str	r2, [r3, #0]
}
 800b16c:	46c0      	nop			; (mov r8, r8)
 800b16e:	46bd      	mov	sp, r7
 800b170:	bd80      	pop	{r7, pc}
 800b172:	46c0      	nop			; (mov r8, r8)
 800b174:	20000164 	.word	0x20000164
 800b178:	200027e0 	.word	0x200027e0

0800b17c <HAL_GetTick>:
  * @note   This function is declared as __weak  to be overwritten  in case of other 
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
 800b17c:	b580      	push	{r7, lr}
 800b17e:	af00      	add	r7, sp, #0
  return uwTick;
 800b180:	4b02      	ldr	r3, [pc, #8]	; (800b18c <HAL_GetTick+0x10>)
 800b182:	681b      	ldr	r3, [r3, #0]
}
 800b184:	0018      	movs	r0, r3
 800b186:	46bd      	mov	sp, r7
 800b188:	bd80      	pop	{r7, pc}
 800b18a:	46c0      	nop			; (mov r8, r8)
 800b18c:	200027e0 	.word	0x200027e0

0800b190 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 800b190:	b580      	push	{r7, lr}
 800b192:	b084      	sub	sp, #16
 800b194:	af00      	add	r7, sp, #0
 800b196:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = HAL_GetTick();
 800b198:	f7ff fff0 	bl	800b17c <HAL_GetTick>
 800b19c:	0003      	movs	r3, r0
 800b19e:	60bb      	str	r3, [r7, #8]
  uint32_t wait = Delay;
 800b1a0:	687b      	ldr	r3, [r7, #4]
 800b1a2:	60fb      	str	r3, [r7, #12]
  
  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
 800b1a4:	68fb      	ldr	r3, [r7, #12]
 800b1a6:	3301      	adds	r3, #1
 800b1a8:	d005      	beq.n	800b1b6 <HAL_Delay+0x26>
  {
    wait += (uint32_t)(uwTickFreq);
 800b1aa:	4b0a      	ldr	r3, [pc, #40]	; (800b1d4 <HAL_Delay+0x44>)
 800b1ac:	781b      	ldrb	r3, [r3, #0]
 800b1ae:	001a      	movs	r2, r3
 800b1b0:	68fb      	ldr	r3, [r7, #12]
 800b1b2:	189b      	adds	r3, r3, r2
 800b1b4:	60fb      	str	r3, [r7, #12]
  }
  
  while((HAL_GetTick() - tickstart) < wait)
 800b1b6:	46c0      	nop			; (mov r8, r8)
 800b1b8:	f7ff ffe0 	bl	800b17c <HAL_GetTick>
 800b1bc:	0002      	movs	r2, r0
 800b1be:	68bb      	ldr	r3, [r7, #8]
 800b1c0:	1ad3      	subs	r3, r2, r3
 800b1c2:	68fa      	ldr	r2, [r7, #12]
 800b1c4:	429a      	cmp	r2, r3
 800b1c6:	d8f7      	bhi.n	800b1b8 <HAL_Delay+0x28>
  {
  }
}
 800b1c8:	46c0      	nop			; (mov r8, r8)
 800b1ca:	46c0      	nop			; (mov r8, r8)
 800b1cc:	46bd      	mov	sp, r7
 800b1ce:	b004      	add	sp, #16
 800b1d0:	bd80      	pop	{r7, pc}
 800b1d2:	46c0      	nop			; (mov r8, r8)
 800b1d4:	20000164 	.word	0x20000164

0800b1d8 <__NVIC_EnableIRQ>:
  \details Enables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
 800b1d8:	b580      	push	{r7, lr}
 800b1da:	b082      	sub	sp, #8
 800b1dc:	af00      	add	r7, sp, #0
 800b1de:	0002      	movs	r2, r0
 800b1e0:	1dfb      	adds	r3, r7, #7
 800b1e2:	701a      	strb	r2, [r3, #0]
  if ((int32_t)(IRQn) >= 0)
 800b1e4:	1dfb      	adds	r3, r7, #7
 800b1e6:	781b      	ldrb	r3, [r3, #0]
 800b1e8:	2b7f      	cmp	r3, #127	; 0x7f
 800b1ea:	d809      	bhi.n	800b200 <__NVIC_EnableIRQ+0x28>
  {
    NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 800b1ec:	1dfb      	adds	r3, r7, #7
 800b1ee:	781b      	ldrb	r3, [r3, #0]
 800b1f0:	001a      	movs	r2, r3
 800b1f2:	231f      	movs	r3, #31
 800b1f4:	401a      	ands	r2, r3
 800b1f6:	4b04      	ldr	r3, [pc, #16]	; (800b208 <__NVIC_EnableIRQ+0x30>)
 800b1f8:	2101      	movs	r1, #1
 800b1fa:	4091      	lsls	r1, r2
 800b1fc:	000a      	movs	r2, r1
 800b1fe:	601a      	str	r2, [r3, #0]
  }
}
 800b200:	46c0      	nop			; (mov r8, r8)
 800b202:	46bd      	mov	sp, r7
 800b204:	b002      	add	sp, #8
 800b206:	bd80      	pop	{r7, pc}
 800b208:	e000e100 	.word	0xe000e100

0800b20c <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 800b20c:	b590      	push	{r4, r7, lr}
 800b20e:	b083      	sub	sp, #12
 800b210:	af00      	add	r7, sp, #0
 800b212:	0002      	movs	r2, r0
 800b214:	6039      	str	r1, [r7, #0]
 800b216:	1dfb      	adds	r3, r7, #7
 800b218:	701a      	strb	r2, [r3, #0]
  if ((int32_t)(IRQn) >= 0)
 800b21a:	1dfb      	adds	r3, r7, #7
 800b21c:	781b      	ldrb	r3, [r3, #0]
 800b21e:	2b7f      	cmp	r3, #127	; 0x7f
 800b220:	d828      	bhi.n	800b274 <__NVIC_SetPriority+0x68>
  {
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 800b222:	4a2f      	ldr	r2, [pc, #188]	; (800b2e0 <__NVIC_SetPriority+0xd4>)
 800b224:	1dfb      	adds	r3, r7, #7
 800b226:	781b      	ldrb	r3, [r3, #0]
 800b228:	b25b      	sxtb	r3, r3
 800b22a:	089b      	lsrs	r3, r3, #2
 800b22c:	33c0      	adds	r3, #192	; 0xc0
 800b22e:	009b      	lsls	r3, r3, #2
 800b230:	589b      	ldr	r3, [r3, r2]
 800b232:	1dfa      	adds	r2, r7, #7
 800b234:	7812      	ldrb	r2, [r2, #0]
 800b236:	0011      	movs	r1, r2
 800b238:	2203      	movs	r2, #3
 800b23a:	400a      	ands	r2, r1
 800b23c:	00d2      	lsls	r2, r2, #3
 800b23e:	21ff      	movs	r1, #255	; 0xff
 800b240:	4091      	lsls	r1, r2
 800b242:	000a      	movs	r2, r1
 800b244:	43d2      	mvns	r2, r2
 800b246:	401a      	ands	r2, r3
 800b248:	0011      	movs	r1, r2
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
 800b24a:	683b      	ldr	r3, [r7, #0]
 800b24c:	019b      	lsls	r3, r3, #6
 800b24e:	22ff      	movs	r2, #255	; 0xff
 800b250:	401a      	ands	r2, r3
 800b252:	1dfb      	adds	r3, r7, #7
 800b254:	781b      	ldrb	r3, [r3, #0]
 800b256:	0018      	movs	r0, r3
 800b258:	2303      	movs	r3, #3
 800b25a:	4003      	ands	r3, r0
 800b25c:	00db      	lsls	r3, r3, #3
 800b25e:	409a      	lsls	r2, r3
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 800b260:	481f      	ldr	r0, [pc, #124]	; (800b2e0 <__NVIC_SetPriority+0xd4>)
 800b262:	1dfb      	adds	r3, r7, #7
 800b264:	781b      	ldrb	r3, [r3, #0]
 800b266:	b25b      	sxtb	r3, r3
 800b268:	089b      	lsrs	r3, r3, #2
 800b26a:	430a      	orrs	r2, r1
 800b26c:	33c0      	adds	r3, #192	; 0xc0
 800b26e:	009b      	lsls	r3, r3, #2
 800b270:	501a      	str	r2, [r3, r0]
  else
  {
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
  }
}
 800b272:	e031      	b.n	800b2d8 <__NVIC_SetPriority+0xcc>
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 800b274:	4a1b      	ldr	r2, [pc, #108]	; (800b2e4 <__NVIC_SetPriority+0xd8>)
 800b276:	1dfb      	adds	r3, r7, #7
 800b278:	781b      	ldrb	r3, [r3, #0]
 800b27a:	0019      	movs	r1, r3
 800b27c:	230f      	movs	r3, #15
 800b27e:	400b      	ands	r3, r1
 800b280:	3b08      	subs	r3, #8
 800b282:	089b      	lsrs	r3, r3, #2
 800b284:	3306      	adds	r3, #6
 800b286:	009b      	lsls	r3, r3, #2
 800b288:	18d3      	adds	r3, r2, r3
 800b28a:	3304      	adds	r3, #4
 800b28c:	681b      	ldr	r3, [r3, #0]
 800b28e:	1dfa      	adds	r2, r7, #7
 800b290:	7812      	ldrb	r2, [r2, #0]
 800b292:	0011      	movs	r1, r2
 800b294:	2203      	movs	r2, #3
 800b296:	400a      	ands	r2, r1
 800b298:	00d2      	lsls	r2, r2, #3
 800b29a:	21ff      	movs	r1, #255	; 0xff
 800b29c:	4091      	lsls	r1, r2
 800b29e:	000a      	movs	r2, r1
 800b2a0:	43d2      	mvns	r2, r2
 800b2a2:	401a      	ands	r2, r3
 800b2a4:	0011      	movs	r1, r2
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
 800b2a6:	683b      	ldr	r3, [r7, #0]
 800b2a8:	019b      	lsls	r3, r3, #6
 800b2aa:	22ff      	movs	r2, #255	; 0xff
 800b2ac:	401a      	ands	r2, r3
 800b2ae:	1dfb      	adds	r3, r7, #7
 800b2b0:	781b      	ldrb	r3, [r3, #0]
 800b2b2:	0018      	movs	r0, r3
 800b2b4:	2303      	movs	r3, #3
 800b2b6:	4003      	ands	r3, r0
 800b2b8:	00db      	lsls	r3, r3, #3
 800b2ba:	409a      	lsls	r2, r3
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 800b2bc:	4809      	ldr	r0, [pc, #36]	; (800b2e4 <__NVIC_SetPriority+0xd8>)
 800b2be:	1dfb      	adds	r3, r7, #7
 800b2c0:	781b      	ldrb	r3, [r3, #0]
 800b2c2:	001c      	movs	r4, r3
 800b2c4:	230f      	movs	r3, #15
 800b2c6:	4023      	ands	r3, r4
 800b2c8:	3b08      	subs	r3, #8
 800b2ca:	089b      	lsrs	r3, r3, #2
 800b2cc:	430a      	orrs	r2, r1
 800b2ce:	3306      	adds	r3, #6
 800b2d0:	009b      	lsls	r3, r3, #2
 800b2d2:	18c3      	adds	r3, r0, r3
 800b2d4:	3304      	adds	r3, #4
 800b2d6:	601a      	str	r2, [r3, #0]
}
 800b2d8:	46c0      	nop			; (mov r8, r8)
 800b2da:	46bd      	mov	sp, r7
 800b2dc:	b003      	add	sp, #12
 800b2de:	bd90      	pop	{r4, r7, pc}
 800b2e0:	e000e100 	.word	0xe000e100
 800b2e4:	e000ed00 	.word	0xe000ed00

0800b2e8 <SysTick_Config>:
  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
 800b2e8:	b580      	push	{r7, lr}
 800b2ea:	b082      	sub	sp, #8
 800b2ec:	af00      	add	r7, sp, #0
 800b2ee:	6078      	str	r0, [r7, #4]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 800b2f0:	687b      	ldr	r3, [r7, #4]
 800b2f2:	1e5a      	subs	r2, r3, #1
 800b2f4:	2380      	movs	r3, #128	; 0x80
 800b2f6:	045b      	lsls	r3, r3, #17
 800b2f8:	429a      	cmp	r2, r3
 800b2fa:	d301      	bcc.n	800b300 <SysTick_Config+0x18>
  {
    return (1UL);                                                   /* Reload value impossible */
 800b2fc:	2301      	movs	r3, #1
 800b2fe:	e010      	b.n	800b322 <SysTick_Config+0x3a>
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 800b300:	4b0a      	ldr	r3, [pc, #40]	; (800b32c <SysTick_Config+0x44>)
 800b302:	687a      	ldr	r2, [r7, #4]
 800b304:	3a01      	subs	r2, #1
 800b306:	605a      	str	r2, [r3, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
 800b308:	2301      	movs	r3, #1
 800b30a:	425b      	negs	r3, r3
 800b30c:	2103      	movs	r1, #3
 800b30e:	0018      	movs	r0, r3
 800b310:	f7ff ff7c 	bl	800b20c <__NVIC_SetPriority>
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 800b314:	4b05      	ldr	r3, [pc, #20]	; (800b32c <SysTick_Config+0x44>)
 800b316:	2200      	movs	r2, #0
 800b318:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 800b31a:	4b04      	ldr	r3, [pc, #16]	; (800b32c <SysTick_Config+0x44>)
 800b31c:	2207      	movs	r2, #7
 800b31e:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 800b320:	2300      	movs	r3, #0
}
 800b322:	0018      	movs	r0, r3
 800b324:	46bd      	mov	sp, r7
 800b326:	b002      	add	sp, #8
 800b328:	bd80      	pop	{r7, pc}
 800b32a:	46c0      	nop			; (mov r8, r8)
 800b32c:	e000e010 	.word	0xe000e010

0800b330 <HAL_NVIC_SetPriority>:
  *         with stm32f0xx devices, this parameter is a dummy value and it is ignored, because 
  *         no subpriority supported in Cortex M0 based products.   
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 800b330:	b580      	push	{r7, lr}
 800b332:	b084      	sub	sp, #16
 800b334:	af00      	add	r7, sp, #0
 800b336:	60b9      	str	r1, [r7, #8]
 800b338:	607a      	str	r2, [r7, #4]
 800b33a:	210f      	movs	r1, #15
 800b33c:	187b      	adds	r3, r7, r1
 800b33e:	1c02      	adds	r2, r0, #0
 800b340:	701a      	strb	r2, [r3, #0]
  /* Check the parameters */
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  NVIC_SetPriority(IRQn,PreemptPriority);
 800b342:	68ba      	ldr	r2, [r7, #8]
 800b344:	187b      	adds	r3, r7, r1
 800b346:	781b      	ldrb	r3, [r3, #0]
 800b348:	b25b      	sxtb	r3, r3
 800b34a:	0011      	movs	r1, r2
 800b34c:	0018      	movs	r0, r3
 800b34e:	f7ff ff5d 	bl	800b20c <__NVIC_SetPriority>
}
 800b352:	46c0      	nop			; (mov r8, r8)
 800b354:	46bd      	mov	sp, r7
 800b356:	b004      	add	sp, #16
 800b358:	bd80      	pop	{r7, pc}

0800b35a <HAL_NVIC_EnableIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32f0xxxx.h))
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
 800b35a:	b580      	push	{r7, lr}
 800b35c:	b082      	sub	sp, #8
 800b35e:	af00      	add	r7, sp, #0
 800b360:	0002      	movs	r2, r0
 800b362:	1dfb      	adds	r3, r7, #7
 800b364:	701a      	strb	r2, [r3, #0]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
 800b366:	1dfb      	adds	r3, r7, #7
 800b368:	781b      	ldrb	r3, [r3, #0]
 800b36a:	b25b      	sxtb	r3, r3
 800b36c:	0018      	movs	r0, r3
 800b36e:	f7ff ff33 	bl	800b1d8 <__NVIC_EnableIRQ>
}
 800b372:	46c0      	nop			; (mov r8, r8)
 800b374:	46bd      	mov	sp, r7
 800b376:	b002      	add	sp, #8
 800b378:	bd80      	pop	{r7, pc}

0800b37a <HAL_SYSTICK_Config>:
  * @param  TicksNumb Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
 800b37a:	b580      	push	{r7, lr}
 800b37c:	b082      	sub	sp, #8
 800b37e:	af00      	add	r7, sp, #0
 800b380:	6078      	str	r0, [r7, #4]
   return SysTick_Config(TicksNumb);
 800b382:	687b      	ldr	r3, [r7, #4]
 800b384:	0018      	movs	r0, r3
 800b386:	f7ff ffaf 	bl	800b2e8 <SysTick_Config>
 800b38a:	0003      	movs	r3, r0
}
 800b38c:	0018      	movs	r0, r3
 800b38e:	46bd      	mov	sp, r7
 800b390:	b002      	add	sp, #8
 800b392:	bd80      	pop	{r7, pc}

0800b394 <HAL_DMA_Abort>:
  * @param  hdma  pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Channel.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Abort(DMA_HandleTypeDef *hdma)
{
 800b394:	b580      	push	{r7, lr}
 800b396:	b082      	sub	sp, #8
 800b398:	af00      	add	r7, sp, #0
 800b39a:	6078      	str	r0, [r7, #4]
  if(hdma->State != HAL_DMA_STATE_BUSY)
 800b39c:	687b      	ldr	r3, [r7, #4]
 800b39e:	2221      	movs	r2, #33	; 0x21
 800b3a0:	5c9b      	ldrb	r3, [r3, r2]
 800b3a2:	b2db      	uxtb	r3, r3
 800b3a4:	2b02      	cmp	r3, #2
 800b3a6:	d008      	beq.n	800b3ba <HAL_DMA_Abort+0x26>
  {
    /* no transfer ongoing */
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 800b3a8:	687b      	ldr	r3, [r7, #4]
 800b3aa:	2204      	movs	r2, #4
 800b3ac:	639a      	str	r2, [r3, #56]	; 0x38
    
    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
 800b3ae:	687b      	ldr	r3, [r7, #4]
 800b3b0:	2220      	movs	r2, #32
 800b3b2:	2100      	movs	r1, #0
 800b3b4:	5499      	strb	r1, [r3, r2]
    
    return HAL_ERROR;
 800b3b6:	2301      	movs	r3, #1
 800b3b8:	e020      	b.n	800b3fc <HAL_DMA_Abort+0x68>
  }
  else
  {
    /* Disable DMA IT */
    hdma->Instance->CCR &= ~(DMA_IT_TC | DMA_IT_HT | DMA_IT_TE);
 800b3ba:	687b      	ldr	r3, [r7, #4]
 800b3bc:	681b      	ldr	r3, [r3, #0]
 800b3be:	681a      	ldr	r2, [r3, #0]
 800b3c0:	687b      	ldr	r3, [r7, #4]
 800b3c2:	681b      	ldr	r3, [r3, #0]
 800b3c4:	210e      	movs	r1, #14
 800b3c6:	438a      	bics	r2, r1
 800b3c8:	601a      	str	r2, [r3, #0]
    
    /* Disable the channel */
    hdma->Instance->CCR &= ~DMA_CCR_EN;
 800b3ca:	687b      	ldr	r3, [r7, #4]
 800b3cc:	681b      	ldr	r3, [r3, #0]
 800b3ce:	681a      	ldr	r2, [r3, #0]
 800b3d0:	687b      	ldr	r3, [r7, #4]
 800b3d2:	681b      	ldr	r3, [r3, #0]
 800b3d4:	2101      	movs	r1, #1
 800b3d6:	438a      	bics	r2, r1
 800b3d8:	601a      	str	r2, [r3, #0]
    
    /* Clear all flags */
    hdma->DmaBaseAddress->IFCR = (DMA_FLAG_GL1 << hdma->ChannelIndex);
 800b3da:	687b      	ldr	r3, [r7, #4]
 800b3dc:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 800b3de:	687b      	ldr	r3, [r7, #4]
 800b3e0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800b3e2:	2101      	movs	r1, #1
 800b3e4:	4091      	lsls	r1, r2
 800b3e6:	000a      	movs	r2, r1
 800b3e8:	605a      	str	r2, [r3, #4]
  }
  /* Change the DMA state*/
  hdma->State = HAL_DMA_STATE_READY; 
 800b3ea:	687b      	ldr	r3, [r7, #4]
 800b3ec:	2221      	movs	r2, #33	; 0x21
 800b3ee:	2101      	movs	r1, #1
 800b3f0:	5499      	strb	r1, [r3, r2]
  
  /* Process Unlocked */
  __HAL_UNLOCK(hdma);
 800b3f2:	687b      	ldr	r3, [r7, #4]
 800b3f4:	2220      	movs	r2, #32
 800b3f6:	2100      	movs	r1, #0
 800b3f8:	5499      	strb	r1, [r3, r2]
  
  return HAL_OK;
 800b3fa:	2300      	movs	r3, #0
}
 800b3fc:	0018      	movs	r0, r3
 800b3fe:	46bd      	mov	sp, r7
 800b400:	b002      	add	sp, #8
 800b402:	bd80      	pop	{r7, pc}

0800b404 <HAL_DMA_Abort_IT>:
  * @param  hdma  pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Abort_IT(DMA_HandleTypeDef *hdma)
{  
 800b404:	b580      	push	{r7, lr}
 800b406:	b084      	sub	sp, #16
 800b408:	af00      	add	r7, sp, #0
 800b40a:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
 800b40c:	210f      	movs	r1, #15
 800b40e:	187b      	adds	r3, r7, r1
 800b410:	2200      	movs	r2, #0
 800b412:	701a      	strb	r2, [r3, #0]
  
  if(HAL_DMA_STATE_BUSY != hdma->State)
 800b414:	687b      	ldr	r3, [r7, #4]
 800b416:	2221      	movs	r2, #33	; 0x21
 800b418:	5c9b      	ldrb	r3, [r3, r2]
 800b41a:	b2db      	uxtb	r3, r3
 800b41c:	2b02      	cmp	r3, #2
 800b41e:	d006      	beq.n	800b42e <HAL_DMA_Abort_IT+0x2a>
  {
    /* no transfer ongoing */
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 800b420:	687b      	ldr	r3, [r7, #4]
 800b422:	2204      	movs	r2, #4
 800b424:	639a      	str	r2, [r3, #56]	; 0x38
        
    status = HAL_ERROR;
 800b426:	187b      	adds	r3, r7, r1
 800b428:	2201      	movs	r2, #1
 800b42a:	701a      	strb	r2, [r3, #0]
 800b42c:	e028      	b.n	800b480 <HAL_DMA_Abort_IT+0x7c>
  }
  else
  { 
  
    /* Disable DMA IT */
    hdma->Instance->CCR &= ~(DMA_IT_TC | DMA_IT_HT | DMA_IT_TE);
 800b42e:	687b      	ldr	r3, [r7, #4]
 800b430:	681b      	ldr	r3, [r3, #0]
 800b432:	681a      	ldr	r2, [r3, #0]
 800b434:	687b      	ldr	r3, [r7, #4]
 800b436:	681b      	ldr	r3, [r3, #0]
 800b438:	210e      	movs	r1, #14
 800b43a:	438a      	bics	r2, r1
 800b43c:	601a      	str	r2, [r3, #0]
    
    /* Disable the channel */
    hdma->Instance->CCR &= ~DMA_CCR_EN;
 800b43e:	687b      	ldr	r3, [r7, #4]
 800b440:	681b      	ldr	r3, [r3, #0]
 800b442:	681a      	ldr	r2, [r3, #0]
 800b444:	687b      	ldr	r3, [r7, #4]
 800b446:	681b      	ldr	r3, [r3, #0]
 800b448:	2101      	movs	r1, #1
 800b44a:	438a      	bics	r2, r1
 800b44c:	601a      	str	r2, [r3, #0]
    
    /* Clear all flags */
    hdma->DmaBaseAddress->IFCR = DMA_FLAG_GL1 << hdma->ChannelIndex;
 800b44e:	687b      	ldr	r3, [r7, #4]
 800b450:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 800b452:	687b      	ldr	r3, [r7, #4]
 800b454:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800b456:	2101      	movs	r1, #1
 800b458:	4091      	lsls	r1, r2
 800b45a:	000a      	movs	r2, r1
 800b45c:	605a      	str	r2, [r3, #4]
    
    /* Change the DMA state */
    hdma->State = HAL_DMA_STATE_READY;
 800b45e:	687b      	ldr	r3, [r7, #4]
 800b460:	2221      	movs	r2, #33	; 0x21
 800b462:	2101      	movs	r1, #1
 800b464:	5499      	strb	r1, [r3, r2]
    
    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
 800b466:	687b      	ldr	r3, [r7, #4]
 800b468:	2220      	movs	r2, #32
 800b46a:	2100      	movs	r1, #0
 800b46c:	5499      	strb	r1, [r3, r2]
    
    /* Call User Abort callback */ 
    if(hdma->XferAbortCallback != NULL)
 800b46e:	687b      	ldr	r3, [r7, #4]
 800b470:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800b472:	2b00      	cmp	r3, #0
 800b474:	d004      	beq.n	800b480 <HAL_DMA_Abort_IT+0x7c>
    {
      hdma->XferAbortCallback(hdma);
 800b476:	687b      	ldr	r3, [r7, #4]
 800b478:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800b47a:	687a      	ldr	r2, [r7, #4]
 800b47c:	0010      	movs	r0, r2
 800b47e:	4798      	blx	r3
    } 
  }
  return status;
 800b480:	230f      	movs	r3, #15
 800b482:	18fb      	adds	r3, r7, r3
 800b484:	781b      	ldrb	r3, [r3, #0]
}
 800b486:	0018      	movs	r0, r3
 800b488:	46bd      	mov	sp, r7
 800b48a:	b004      	add	sp, #16
 800b48c:	bd80      	pop	{r7, pc}
	...

0800b490 <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 800b490:	b580      	push	{r7, lr}
 800b492:	b086      	sub	sp, #24
 800b494:	af00      	add	r7, sp, #0
 800b496:	6078      	str	r0, [r7, #4]
 800b498:	6039      	str	r1, [r7, #0]
  uint32_t position = 0x00u;
 800b49a:	2300      	movs	r3, #0
 800b49c:	617b      	str	r3, [r7, #20]
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 800b49e:	e155      	b.n	800b74c <HAL_GPIO_Init+0x2bc>
  {
    /* Get current io position */
    iocurrent = (GPIO_Init->Pin) & (1uL << position);
 800b4a0:	683b      	ldr	r3, [r7, #0]
 800b4a2:	681b      	ldr	r3, [r3, #0]
 800b4a4:	2101      	movs	r1, #1
 800b4a6:	697a      	ldr	r2, [r7, #20]
 800b4a8:	4091      	lsls	r1, r2
 800b4aa:	000a      	movs	r2, r1
 800b4ac:	4013      	ands	r3, r2
 800b4ae:	60fb      	str	r3, [r7, #12]

    if (iocurrent != 0x00u)
 800b4b0:	68fb      	ldr	r3, [r7, #12]
 800b4b2:	2b00      	cmp	r3, #0
 800b4b4:	d100      	bne.n	800b4b8 <HAL_GPIO_Init+0x28>
 800b4b6:	e146      	b.n	800b746 <HAL_GPIO_Init+0x2b6>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Output or Alternate function mode selection */
      if(((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) ||
 800b4b8:	683b      	ldr	r3, [r7, #0]
 800b4ba:	685b      	ldr	r3, [r3, #4]
 800b4bc:	2203      	movs	r2, #3
 800b4be:	4013      	ands	r3, r2
 800b4c0:	2b01      	cmp	r3, #1
 800b4c2:	d005      	beq.n	800b4d0 <HAL_GPIO_Init+0x40>
         ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
 800b4c4:	683b      	ldr	r3, [r7, #0]
 800b4c6:	685b      	ldr	r3, [r3, #4]
 800b4c8:	2203      	movs	r2, #3
 800b4ca:	4013      	ands	r3, r2
      if(((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) ||
 800b4cc:	2b02      	cmp	r3, #2
 800b4ce:	d130      	bne.n	800b532 <HAL_GPIO_Init+0xa2>
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR;
 800b4d0:	687b      	ldr	r3, [r7, #4]
 800b4d2:	689b      	ldr	r3, [r3, #8]
 800b4d4:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2u));
 800b4d6:	697b      	ldr	r3, [r7, #20]
 800b4d8:	005b      	lsls	r3, r3, #1
 800b4da:	2203      	movs	r2, #3
 800b4dc:	409a      	lsls	r2, r3
 800b4de:	0013      	movs	r3, r2
 800b4e0:	43da      	mvns	r2, r3
 800b4e2:	693b      	ldr	r3, [r7, #16]
 800b4e4:	4013      	ands	r3, r2
 800b4e6:	613b      	str	r3, [r7, #16]
        temp |= (GPIO_Init->Speed << (position * 2u));
 800b4e8:	683b      	ldr	r3, [r7, #0]
 800b4ea:	68da      	ldr	r2, [r3, #12]
 800b4ec:	697b      	ldr	r3, [r7, #20]
 800b4ee:	005b      	lsls	r3, r3, #1
 800b4f0:	409a      	lsls	r2, r3
 800b4f2:	0013      	movs	r3, r2
 800b4f4:	693a      	ldr	r2, [r7, #16]
 800b4f6:	4313      	orrs	r3, r2
 800b4f8:	613b      	str	r3, [r7, #16]
        GPIOx->OSPEEDR = temp;
 800b4fa:	687b      	ldr	r3, [r7, #4]
 800b4fc:	693a      	ldr	r2, [r7, #16]
 800b4fe:	609a      	str	r2, [r3, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
 800b500:	687b      	ldr	r3, [r7, #4]
 800b502:	685b      	ldr	r3, [r3, #4]
 800b504:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
 800b506:	2201      	movs	r2, #1
 800b508:	697b      	ldr	r3, [r7, #20]
 800b50a:	409a      	lsls	r2, r3
 800b50c:	0013      	movs	r3, r2
 800b50e:	43da      	mvns	r2, r3
 800b510:	693b      	ldr	r3, [r7, #16]
 800b512:	4013      	ands	r3, r2
 800b514:	613b      	str	r3, [r7, #16]
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
 800b516:	683b      	ldr	r3, [r7, #0]
 800b518:	685b      	ldr	r3, [r3, #4]
 800b51a:	091b      	lsrs	r3, r3, #4
 800b51c:	2201      	movs	r2, #1
 800b51e:	401a      	ands	r2, r3
 800b520:	697b      	ldr	r3, [r7, #20]
 800b522:	409a      	lsls	r2, r3
 800b524:	0013      	movs	r3, r2
 800b526:	693a      	ldr	r2, [r7, #16]
 800b528:	4313      	orrs	r3, r2
 800b52a:	613b      	str	r3, [r7, #16]
        GPIOx->OTYPER = temp;
 800b52c:	687b      	ldr	r3, [r7, #4]
 800b52e:	693a      	ldr	r2, [r7, #16]
 800b530:	605a      	str	r2, [r3, #4]
      }
      
      if((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG)
 800b532:	683b      	ldr	r3, [r7, #0]
 800b534:	685b      	ldr	r3, [r3, #4]
 800b536:	2203      	movs	r2, #3
 800b538:	4013      	ands	r3, r2
 800b53a:	2b03      	cmp	r3, #3
 800b53c:	d017      	beq.n	800b56e <HAL_GPIO_Init+0xde>
      {
        /* Check the Pull parameter */
        assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

        /* Activate the Pull-up or Pull down resistor for the current IO */
        temp = GPIOx->PUPDR;
 800b53e:	687b      	ldr	r3, [r7, #4]
 800b540:	68db      	ldr	r3, [r3, #12]
 800b542:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2u));
 800b544:	697b      	ldr	r3, [r7, #20]
 800b546:	005b      	lsls	r3, r3, #1
 800b548:	2203      	movs	r2, #3
 800b54a:	409a      	lsls	r2, r3
 800b54c:	0013      	movs	r3, r2
 800b54e:	43da      	mvns	r2, r3
 800b550:	693b      	ldr	r3, [r7, #16]
 800b552:	4013      	ands	r3, r2
 800b554:	613b      	str	r3, [r7, #16]
        temp |= ((GPIO_Init->Pull) << (position * 2u));
 800b556:	683b      	ldr	r3, [r7, #0]
 800b558:	689a      	ldr	r2, [r3, #8]
 800b55a:	697b      	ldr	r3, [r7, #20]
 800b55c:	005b      	lsls	r3, r3, #1
 800b55e:	409a      	lsls	r2, r3
 800b560:	0013      	movs	r3, r2
 800b562:	693a      	ldr	r2, [r7, #16]
 800b564:	4313      	orrs	r3, r2
 800b566:	613b      	str	r3, [r7, #16]
        GPIOx->PUPDR = temp;
 800b568:	687b      	ldr	r3, [r7, #4]
 800b56a:	693a      	ldr	r2, [r7, #16]
 800b56c:	60da      	str	r2, [r3, #12]
      }

      /* In case of Alternate function mode selection */
      if((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 800b56e:	683b      	ldr	r3, [r7, #0]
 800b570:	685b      	ldr	r3, [r3, #4]
 800b572:	2203      	movs	r2, #3
 800b574:	4013      	ands	r3, r2
 800b576:	2b02      	cmp	r3, #2
 800b578:	d123      	bne.n	800b5c2 <HAL_GPIO_Init+0x132>
        /* Check the Alternate function parameters */
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));

        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3u];
 800b57a:	697b      	ldr	r3, [r7, #20]
 800b57c:	08da      	lsrs	r2, r3, #3
 800b57e:	687b      	ldr	r3, [r7, #4]
 800b580:	3208      	adds	r2, #8
 800b582:	0092      	lsls	r2, r2, #2
 800b584:	58d3      	ldr	r3, [r2, r3]
 800b586:	613b      	str	r3, [r7, #16]
        temp &= ~(0xFu << ((position & 0x07u) * 4u));
 800b588:	697b      	ldr	r3, [r7, #20]
 800b58a:	2207      	movs	r2, #7
 800b58c:	4013      	ands	r3, r2
 800b58e:	009b      	lsls	r3, r3, #2
 800b590:	220f      	movs	r2, #15
 800b592:	409a      	lsls	r2, r3
 800b594:	0013      	movs	r3, r2
 800b596:	43da      	mvns	r2, r3
 800b598:	693b      	ldr	r3, [r7, #16]
 800b59a:	4013      	ands	r3, r2
 800b59c:	613b      	str	r3, [r7, #16]
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07u) * 4u));
 800b59e:	683b      	ldr	r3, [r7, #0]
 800b5a0:	691a      	ldr	r2, [r3, #16]
 800b5a2:	697b      	ldr	r3, [r7, #20]
 800b5a4:	2107      	movs	r1, #7
 800b5a6:	400b      	ands	r3, r1
 800b5a8:	009b      	lsls	r3, r3, #2
 800b5aa:	409a      	lsls	r2, r3
 800b5ac:	0013      	movs	r3, r2
 800b5ae:	693a      	ldr	r2, [r7, #16]
 800b5b0:	4313      	orrs	r3, r2
 800b5b2:	613b      	str	r3, [r7, #16]
        GPIOx->AFR[position >> 3u] = temp;
 800b5b4:	697b      	ldr	r3, [r7, #20]
 800b5b6:	08da      	lsrs	r2, r3, #3
 800b5b8:	687b      	ldr	r3, [r7, #4]
 800b5ba:	3208      	adds	r2, #8
 800b5bc:	0092      	lsls	r2, r2, #2
 800b5be:	6939      	ldr	r1, [r7, #16]
 800b5c0:	50d1      	str	r1, [r2, r3]
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
 800b5c2:	687b      	ldr	r3, [r7, #4]
 800b5c4:	681b      	ldr	r3, [r3, #0]
 800b5c6:	613b      	str	r3, [r7, #16]
      temp &= ~(GPIO_MODER_MODER0 << (position * 2u));
 800b5c8:	697b      	ldr	r3, [r7, #20]
 800b5ca:	005b      	lsls	r3, r3, #1
 800b5cc:	2203      	movs	r2, #3
 800b5ce:	409a      	lsls	r2, r3
 800b5d0:	0013      	movs	r3, r2
 800b5d2:	43da      	mvns	r2, r3
 800b5d4:	693b      	ldr	r3, [r7, #16]
 800b5d6:	4013      	ands	r3, r2
 800b5d8:	613b      	str	r3, [r7, #16]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2u));
 800b5da:	683b      	ldr	r3, [r7, #0]
 800b5dc:	685b      	ldr	r3, [r3, #4]
 800b5de:	2203      	movs	r2, #3
 800b5e0:	401a      	ands	r2, r3
 800b5e2:	697b      	ldr	r3, [r7, #20]
 800b5e4:	005b      	lsls	r3, r3, #1
 800b5e6:	409a      	lsls	r2, r3
 800b5e8:	0013      	movs	r3, r2
 800b5ea:	693a      	ldr	r2, [r7, #16]
 800b5ec:	4313      	orrs	r3, r2
 800b5ee:	613b      	str	r3, [r7, #16]
      GPIOx->MODER = temp;
 800b5f0:	687b      	ldr	r3, [r7, #4]
 800b5f2:	693a      	ldr	r2, [r7, #16]
 800b5f4:	601a      	str	r2, [r3, #0]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) != 0x00u)
 800b5f6:	683b      	ldr	r3, [r7, #0]
 800b5f8:	685a      	ldr	r2, [r3, #4]
 800b5fa:	23c0      	movs	r3, #192	; 0xc0
 800b5fc:	029b      	lsls	r3, r3, #10
 800b5fe:	4013      	ands	r3, r2
 800b600:	d100      	bne.n	800b604 <HAL_GPIO_Init+0x174>
 800b602:	e0a0      	b.n	800b746 <HAL_GPIO_Init+0x2b6>
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 800b604:	4b57      	ldr	r3, [pc, #348]	; (800b764 <HAL_GPIO_Init+0x2d4>)
 800b606:	699a      	ldr	r2, [r3, #24]
 800b608:	4b56      	ldr	r3, [pc, #344]	; (800b764 <HAL_GPIO_Init+0x2d4>)
 800b60a:	2101      	movs	r1, #1
 800b60c:	430a      	orrs	r2, r1
 800b60e:	619a      	str	r2, [r3, #24]
 800b610:	4b54      	ldr	r3, [pc, #336]	; (800b764 <HAL_GPIO_Init+0x2d4>)
 800b612:	699b      	ldr	r3, [r3, #24]
 800b614:	2201      	movs	r2, #1
 800b616:	4013      	ands	r3, r2
 800b618:	60bb      	str	r3, [r7, #8]
 800b61a:	68bb      	ldr	r3, [r7, #8]

        temp = SYSCFG->EXTICR[position >> 2u];
 800b61c:	4a52      	ldr	r2, [pc, #328]	; (800b768 <HAL_GPIO_Init+0x2d8>)
 800b61e:	697b      	ldr	r3, [r7, #20]
 800b620:	089b      	lsrs	r3, r3, #2
 800b622:	3302      	adds	r3, #2
 800b624:	009b      	lsls	r3, r3, #2
 800b626:	589b      	ldr	r3, [r3, r2]
 800b628:	613b      	str	r3, [r7, #16]
        temp &= ~(0x0FuL << (4u * (position & 0x03u)));
 800b62a:	697b      	ldr	r3, [r7, #20]
 800b62c:	2203      	movs	r2, #3
 800b62e:	4013      	ands	r3, r2
 800b630:	009b      	lsls	r3, r3, #2
 800b632:	220f      	movs	r2, #15
 800b634:	409a      	lsls	r2, r3
 800b636:	0013      	movs	r3, r2
 800b638:	43da      	mvns	r2, r3
 800b63a:	693b      	ldr	r3, [r7, #16]
 800b63c:	4013      	ands	r3, r2
 800b63e:	613b      	str	r3, [r7, #16]
        temp |= (GPIO_GET_INDEX(GPIOx) << (4u * (position & 0x03u)));
 800b640:	687a      	ldr	r2, [r7, #4]
 800b642:	2390      	movs	r3, #144	; 0x90
 800b644:	05db      	lsls	r3, r3, #23
 800b646:	429a      	cmp	r2, r3
 800b648:	d019      	beq.n	800b67e <HAL_GPIO_Init+0x1ee>
 800b64a:	687b      	ldr	r3, [r7, #4]
 800b64c:	4a47      	ldr	r2, [pc, #284]	; (800b76c <HAL_GPIO_Init+0x2dc>)
 800b64e:	4293      	cmp	r3, r2
 800b650:	d013      	beq.n	800b67a <HAL_GPIO_Init+0x1ea>
 800b652:	687b      	ldr	r3, [r7, #4]
 800b654:	4a46      	ldr	r2, [pc, #280]	; (800b770 <HAL_GPIO_Init+0x2e0>)
 800b656:	4293      	cmp	r3, r2
 800b658:	d00d      	beq.n	800b676 <HAL_GPIO_Init+0x1e6>
 800b65a:	687b      	ldr	r3, [r7, #4]
 800b65c:	4a45      	ldr	r2, [pc, #276]	; (800b774 <HAL_GPIO_Init+0x2e4>)
 800b65e:	4293      	cmp	r3, r2
 800b660:	d007      	beq.n	800b672 <HAL_GPIO_Init+0x1e2>
 800b662:	687b      	ldr	r3, [r7, #4]
 800b664:	4a44      	ldr	r2, [pc, #272]	; (800b778 <HAL_GPIO_Init+0x2e8>)
 800b666:	4293      	cmp	r3, r2
 800b668:	d101      	bne.n	800b66e <HAL_GPIO_Init+0x1de>
 800b66a:	2304      	movs	r3, #4
 800b66c:	e008      	b.n	800b680 <HAL_GPIO_Init+0x1f0>
 800b66e:	2305      	movs	r3, #5
 800b670:	e006      	b.n	800b680 <HAL_GPIO_Init+0x1f0>
 800b672:	2303      	movs	r3, #3
 800b674:	e004      	b.n	800b680 <HAL_GPIO_Init+0x1f0>
 800b676:	2302      	movs	r3, #2
 800b678:	e002      	b.n	800b680 <HAL_GPIO_Init+0x1f0>
 800b67a:	2301      	movs	r3, #1
 800b67c:	e000      	b.n	800b680 <HAL_GPIO_Init+0x1f0>
 800b67e:	2300      	movs	r3, #0
 800b680:	697a      	ldr	r2, [r7, #20]
 800b682:	2103      	movs	r1, #3
 800b684:	400a      	ands	r2, r1
 800b686:	0092      	lsls	r2, r2, #2
 800b688:	4093      	lsls	r3, r2
 800b68a:	693a      	ldr	r2, [r7, #16]
 800b68c:	4313      	orrs	r3, r2
 800b68e:	613b      	str	r3, [r7, #16]
        SYSCFG->EXTICR[position >> 2u] = temp;
 800b690:	4935      	ldr	r1, [pc, #212]	; (800b768 <HAL_GPIO_Init+0x2d8>)
 800b692:	697b      	ldr	r3, [r7, #20]
 800b694:	089b      	lsrs	r3, r3, #2
 800b696:	3302      	adds	r3, #2
 800b698:	009b      	lsls	r3, r3, #2
 800b69a:	693a      	ldr	r2, [r7, #16]
 800b69c:	505a      	str	r2, [r3, r1]

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
 800b69e:	4b37      	ldr	r3, [pc, #220]	; (800b77c <HAL_GPIO_Init+0x2ec>)
 800b6a0:	681b      	ldr	r3, [r3, #0]
 800b6a2:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
 800b6a4:	68fb      	ldr	r3, [r7, #12]
 800b6a6:	43da      	mvns	r2, r3
 800b6a8:	693b      	ldr	r3, [r7, #16]
 800b6aa:	4013      	ands	r3, r2
 800b6ac:	613b      	str	r3, [r7, #16]
        if((GPIO_Init->Mode & EXTI_IT) != 0x00u)
 800b6ae:	683b      	ldr	r3, [r7, #0]
 800b6b0:	685a      	ldr	r2, [r3, #4]
 800b6b2:	2380      	movs	r3, #128	; 0x80
 800b6b4:	025b      	lsls	r3, r3, #9
 800b6b6:	4013      	ands	r3, r2
 800b6b8:	d003      	beq.n	800b6c2 <HAL_GPIO_Init+0x232>
        {
          temp |= iocurrent;
 800b6ba:	693a      	ldr	r2, [r7, #16]
 800b6bc:	68fb      	ldr	r3, [r7, #12]
 800b6be:	4313      	orrs	r3, r2
 800b6c0:	613b      	str	r3, [r7, #16]
        }
        EXTI->IMR = temp;
 800b6c2:	4b2e      	ldr	r3, [pc, #184]	; (800b77c <HAL_GPIO_Init+0x2ec>)
 800b6c4:	693a      	ldr	r2, [r7, #16]
 800b6c6:	601a      	str	r2, [r3, #0]

        temp = EXTI->EMR;
 800b6c8:	4b2c      	ldr	r3, [pc, #176]	; (800b77c <HAL_GPIO_Init+0x2ec>)
 800b6ca:	685b      	ldr	r3, [r3, #4]
 800b6cc:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
 800b6ce:	68fb      	ldr	r3, [r7, #12]
 800b6d0:	43da      	mvns	r2, r3
 800b6d2:	693b      	ldr	r3, [r7, #16]
 800b6d4:	4013      	ands	r3, r2
 800b6d6:	613b      	str	r3, [r7, #16]
        if((GPIO_Init->Mode & EXTI_EVT) != 0x00u)
 800b6d8:	683b      	ldr	r3, [r7, #0]
 800b6da:	685a      	ldr	r2, [r3, #4]
 800b6dc:	2380      	movs	r3, #128	; 0x80
 800b6de:	029b      	lsls	r3, r3, #10
 800b6e0:	4013      	ands	r3, r2
 800b6e2:	d003      	beq.n	800b6ec <HAL_GPIO_Init+0x25c>
        {
          temp |= iocurrent;
 800b6e4:	693a      	ldr	r2, [r7, #16]
 800b6e6:	68fb      	ldr	r3, [r7, #12]
 800b6e8:	4313      	orrs	r3, r2
 800b6ea:	613b      	str	r3, [r7, #16]
        }
        EXTI->EMR = temp;
 800b6ec:	4b23      	ldr	r3, [pc, #140]	; (800b77c <HAL_GPIO_Init+0x2ec>)
 800b6ee:	693a      	ldr	r2, [r7, #16]
 800b6f0:	605a      	str	r2, [r3, #4]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
 800b6f2:	4b22      	ldr	r3, [pc, #136]	; (800b77c <HAL_GPIO_Init+0x2ec>)
 800b6f4:	689b      	ldr	r3, [r3, #8]
 800b6f6:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
 800b6f8:	68fb      	ldr	r3, [r7, #12]
 800b6fa:	43da      	mvns	r2, r3
 800b6fc:	693b      	ldr	r3, [r7, #16]
 800b6fe:	4013      	ands	r3, r2
 800b700:	613b      	str	r3, [r7, #16]
        if((GPIO_Init->Mode & TRIGGER_RISING) != 0x00u)
 800b702:	683b      	ldr	r3, [r7, #0]
 800b704:	685a      	ldr	r2, [r3, #4]
 800b706:	2380      	movs	r3, #128	; 0x80
 800b708:	035b      	lsls	r3, r3, #13
 800b70a:	4013      	ands	r3, r2
 800b70c:	d003      	beq.n	800b716 <HAL_GPIO_Init+0x286>
        {
          temp |= iocurrent;
 800b70e:	693a      	ldr	r2, [r7, #16]
 800b710:	68fb      	ldr	r3, [r7, #12]
 800b712:	4313      	orrs	r3, r2
 800b714:	613b      	str	r3, [r7, #16]
        }
        EXTI->RTSR = temp;
 800b716:	4b19      	ldr	r3, [pc, #100]	; (800b77c <HAL_GPIO_Init+0x2ec>)
 800b718:	693a      	ldr	r2, [r7, #16]
 800b71a:	609a      	str	r2, [r3, #8]

        temp = EXTI->FTSR;
 800b71c:	4b17      	ldr	r3, [pc, #92]	; (800b77c <HAL_GPIO_Init+0x2ec>)
 800b71e:	68db      	ldr	r3, [r3, #12]
 800b720:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
 800b722:	68fb      	ldr	r3, [r7, #12]
 800b724:	43da      	mvns	r2, r3
 800b726:	693b      	ldr	r3, [r7, #16]
 800b728:	4013      	ands	r3, r2
 800b72a:	613b      	str	r3, [r7, #16]
        if((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00u)
 800b72c:	683b      	ldr	r3, [r7, #0]
 800b72e:	685a      	ldr	r2, [r3, #4]
 800b730:	2380      	movs	r3, #128	; 0x80
 800b732:	039b      	lsls	r3, r3, #14
 800b734:	4013      	ands	r3, r2
 800b736:	d003      	beq.n	800b740 <HAL_GPIO_Init+0x2b0>
        {
          temp |= iocurrent;
 800b738:	693a      	ldr	r2, [r7, #16]
 800b73a:	68fb      	ldr	r3, [r7, #12]
 800b73c:	4313      	orrs	r3, r2
 800b73e:	613b      	str	r3, [r7, #16]
        }
        EXTI->FTSR = temp;
 800b740:	4b0e      	ldr	r3, [pc, #56]	; (800b77c <HAL_GPIO_Init+0x2ec>)
 800b742:	693a      	ldr	r2, [r7, #16]
 800b744:	60da      	str	r2, [r3, #12]
      }
    }

    position++;
 800b746:	697b      	ldr	r3, [r7, #20]
 800b748:	3301      	adds	r3, #1
 800b74a:	617b      	str	r3, [r7, #20]
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 800b74c:	683b      	ldr	r3, [r7, #0]
 800b74e:	681a      	ldr	r2, [r3, #0]
 800b750:	697b      	ldr	r3, [r7, #20]
 800b752:	40da      	lsrs	r2, r3
 800b754:	1e13      	subs	r3, r2, #0
 800b756:	d000      	beq.n	800b75a <HAL_GPIO_Init+0x2ca>
 800b758:	e6a2      	b.n	800b4a0 <HAL_GPIO_Init+0x10>
  } 
}
 800b75a:	46c0      	nop			; (mov r8, r8)
 800b75c:	46c0      	nop			; (mov r8, r8)
 800b75e:	46bd      	mov	sp, r7
 800b760:	b006      	add	sp, #24
 800b762:	bd80      	pop	{r7, pc}
 800b764:	40021000 	.word	0x40021000
 800b768:	40010000 	.word	0x40010000
 800b76c:	48000400 	.word	0x48000400
 800b770:	48000800 	.word	0x48000800
 800b774:	48000c00 	.word	0x48000c00
 800b778:	48001000 	.word	0x48001000
 800b77c:	40010400 	.word	0x40010400

0800b780 <HAL_GPIO_WritePin>:
  *            @arg GPIO_PIN_RESET: to clear the port pin
  *            @arg GPIO_PIN_SET: to set the port pin
  * @retval None
  */
void HAL_GPIO_WritePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
 800b780:	b580      	push	{r7, lr}
 800b782:	b082      	sub	sp, #8
 800b784:	af00      	add	r7, sp, #0
 800b786:	6078      	str	r0, [r7, #4]
 800b788:	0008      	movs	r0, r1
 800b78a:	0011      	movs	r1, r2
 800b78c:	1cbb      	adds	r3, r7, #2
 800b78e:	1c02      	adds	r2, r0, #0
 800b790:	801a      	strh	r2, [r3, #0]
 800b792:	1c7b      	adds	r3, r7, #1
 800b794:	1c0a      	adds	r2, r1, #0
 800b796:	701a      	strb	r2, [r3, #0]
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if (PinState != GPIO_PIN_RESET)
 800b798:	1c7b      	adds	r3, r7, #1
 800b79a:	781b      	ldrb	r3, [r3, #0]
 800b79c:	2b00      	cmp	r3, #0
 800b79e:	d004      	beq.n	800b7aa <HAL_GPIO_WritePin+0x2a>
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
 800b7a0:	1cbb      	adds	r3, r7, #2
 800b7a2:	881a      	ldrh	r2, [r3, #0]
 800b7a4:	687b      	ldr	r3, [r7, #4]
 800b7a6:	619a      	str	r2, [r3, #24]
  }
  else
  {
    GPIOx->BRR = (uint32_t)GPIO_Pin;
  }
}
 800b7a8:	e003      	b.n	800b7b2 <HAL_GPIO_WritePin+0x32>
    GPIOx->BRR = (uint32_t)GPIO_Pin;
 800b7aa:	1cbb      	adds	r3, r7, #2
 800b7ac:	881a      	ldrh	r2, [r3, #0]
 800b7ae:	687b      	ldr	r3, [r7, #4]
 800b7b0:	629a      	str	r2, [r3, #40]	; 0x28
}
 800b7b2:	46c0      	nop			; (mov r8, r8)
 800b7b4:	46bd      	mov	sp, r7
 800b7b6:	b002      	add	sp, #8
 800b7b8:	bd80      	pop	{r7, pc}

0800b7ba <HAL_GPIO_TogglePin>:
  * @param  GPIOx where x can be (A..F) to select the GPIO peripheral for STM32F0 family
  * @param  GPIO_Pin specifies the pin to be toggled.
  * @retval None
  */
void HAL_GPIO_TogglePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
 800b7ba:	b580      	push	{r7, lr}
 800b7bc:	b084      	sub	sp, #16
 800b7be:	af00      	add	r7, sp, #0
 800b7c0:	6078      	str	r0, [r7, #4]
 800b7c2:	000a      	movs	r2, r1
 800b7c4:	1cbb      	adds	r3, r7, #2
 800b7c6:	801a      	strh	r2, [r3, #0]

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* get current Ouput Data Register value */
  odr = GPIOx->ODR;
 800b7c8:	687b      	ldr	r3, [r7, #4]
 800b7ca:	695b      	ldr	r3, [r3, #20]
 800b7cc:	60fb      	str	r3, [r7, #12]

  /* Set selected pins that were at low level, and reset ones that were high */
  GPIOx->BSRR = ((odr & GPIO_Pin) << GPIO_NUMBER) | (~odr & GPIO_Pin);
 800b7ce:	1cbb      	adds	r3, r7, #2
 800b7d0:	881b      	ldrh	r3, [r3, #0]
 800b7d2:	68fa      	ldr	r2, [r7, #12]
 800b7d4:	4013      	ands	r3, r2
 800b7d6:	041a      	lsls	r2, r3, #16
 800b7d8:	68fb      	ldr	r3, [r7, #12]
 800b7da:	43db      	mvns	r3, r3
 800b7dc:	1cb9      	adds	r1, r7, #2
 800b7de:	8809      	ldrh	r1, [r1, #0]
 800b7e0:	400b      	ands	r3, r1
 800b7e2:	431a      	orrs	r2, r3
 800b7e4:	687b      	ldr	r3, [r7, #4]
 800b7e6:	619a      	str	r2, [r3, #24]
}
 800b7e8:	46c0      	nop			; (mov r8, r8)
 800b7ea:	46bd      	mov	sp, r7
 800b7ec:	b004      	add	sp, #16
 800b7ee:	bd80      	pop	{r7, pc}

0800b7f0 <HAL_PCD_Init>:
  *         parameters in the PCD_InitTypeDef and initialize the associated handle.
  * @param  hpcd PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Init(PCD_HandleTypeDef *hpcd)
{
 800b7f0:	b5f0      	push	{r4, r5, r6, r7, lr}
 800b7f2:	b08b      	sub	sp, #44	; 0x2c
 800b7f4:	af06      	add	r7, sp, #24
 800b7f6:	6078      	str	r0, [r7, #4]
  uint8_t i;

  /* Check the PCD handle allocation */
  if (hpcd == NULL)
 800b7f8:	687b      	ldr	r3, [r7, #4]
 800b7fa:	2b00      	cmp	r3, #0
 800b7fc:	d101      	bne.n	800b802 <HAL_PCD_Init+0x12>
  {
    return HAL_ERROR;
 800b7fe:	2301      	movs	r3, #1
 800b800:	e0ff      	b.n	800ba02 <HAL_PCD_Init+0x212>
  }

  /* Check the parameters */
  assert_param(IS_PCD_ALL_INSTANCE(hpcd->Instance));

  if (hpcd->State == HAL_PCD_STATE_RESET)
 800b802:	687b      	ldr	r3, [r7, #4]
 800b804:	4a81      	ldr	r2, [pc, #516]	; (800ba0c <HAL_PCD_Init+0x21c>)
 800b806:	5c9b      	ldrb	r3, [r3, r2]
 800b808:	b2db      	uxtb	r3, r3
 800b80a:	2b00      	cmp	r3, #0
 800b80c:	d108      	bne.n	800b820 <HAL_PCD_Init+0x30>
  {
    /* Allocate lock resource and initialize it */
    hpcd->Lock = HAL_UNLOCKED;
 800b80e:	687a      	ldr	r2, [r7, #4]
 800b810:	23aa      	movs	r3, #170	; 0xaa
 800b812:	009b      	lsls	r3, r3, #2
 800b814:	2100      	movs	r1, #0
 800b816:	54d1      	strb	r1, [r2, r3]

    /* Init the low level hardware */
    hpcd->MspInitCallback(hpcd);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_PCD_MspInit(hpcd);
 800b818:	687b      	ldr	r3, [r7, #4]
 800b81a:	0018      	movs	r0, r3
 800b81c:	f009 f868 	bl	80148f0 <HAL_PCD_MspInit>
#endif /* (USE_HAL_PCD_REGISTER_CALLBACKS) */
  }

  hpcd->State = HAL_PCD_STATE_BUSY;
 800b820:	687b      	ldr	r3, [r7, #4]
 800b822:	4a7a      	ldr	r2, [pc, #488]	; (800ba0c <HAL_PCD_Init+0x21c>)
 800b824:	2103      	movs	r1, #3
 800b826:	5499      	strb	r1, [r3, r2]

  /* Disable the Interrupts */
  __HAL_PCD_DISABLE(hpcd);
 800b828:	687b      	ldr	r3, [r7, #4]
 800b82a:	681b      	ldr	r3, [r3, #0]
 800b82c:	0018      	movs	r0, r3
 800b82e:	f004 f8d3 	bl	800f9d8 <USB_DisableGlobalInt>

  /* Init endpoints structures */
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 800b832:	230f      	movs	r3, #15
 800b834:	18fb      	adds	r3, r7, r3
 800b836:	2200      	movs	r2, #0
 800b838:	701a      	strb	r2, [r3, #0]
 800b83a:	e058      	b.n	800b8ee <HAL_PCD_Init+0xfe>
  {
    /* Init ep structure */
    hpcd->IN_ep[i].is_in = 1U;
 800b83c:	200f      	movs	r0, #15
 800b83e:	183b      	adds	r3, r7, r0
 800b840:	781b      	ldrb	r3, [r3, #0]
 800b842:	6879      	ldr	r1, [r7, #4]
 800b844:	1c5a      	adds	r2, r3, #1
 800b846:	0013      	movs	r3, r2
 800b848:	009b      	lsls	r3, r3, #2
 800b84a:	189b      	adds	r3, r3, r2
 800b84c:	00db      	lsls	r3, r3, #3
 800b84e:	18cb      	adds	r3, r1, r3
 800b850:	3301      	adds	r3, #1
 800b852:	2201      	movs	r2, #1
 800b854:	701a      	strb	r2, [r3, #0]
    hpcd->IN_ep[i].num = i;
 800b856:	183b      	adds	r3, r7, r0
 800b858:	781b      	ldrb	r3, [r3, #0]
 800b85a:	6879      	ldr	r1, [r7, #4]
 800b85c:	1c5a      	adds	r2, r3, #1
 800b85e:	0013      	movs	r3, r2
 800b860:	009b      	lsls	r3, r3, #2
 800b862:	189b      	adds	r3, r3, r2
 800b864:	00db      	lsls	r3, r3, #3
 800b866:	183a      	adds	r2, r7, r0
 800b868:	7812      	ldrb	r2, [r2, #0]
 800b86a:	545a      	strb	r2, [r3, r1]
    hpcd->IN_ep[i].tx_fifo_num = i;
 800b86c:	0004      	movs	r4, r0
 800b86e:	183b      	adds	r3, r7, r0
 800b870:	781a      	ldrb	r2, [r3, #0]
 800b872:	193b      	adds	r3, r7, r4
 800b874:	781b      	ldrb	r3, [r3, #0]
 800b876:	b298      	uxth	r0, r3
 800b878:	6879      	ldr	r1, [r7, #4]
 800b87a:	0013      	movs	r3, r2
 800b87c:	009b      	lsls	r3, r3, #2
 800b87e:	189b      	adds	r3, r3, r2
 800b880:	00db      	lsls	r3, r3, #3
 800b882:	18cb      	adds	r3, r1, r3
 800b884:	3336      	adds	r3, #54	; 0x36
 800b886:	1c02      	adds	r2, r0, #0
 800b888:	801a      	strh	r2, [r3, #0]
    /* Control until ep is activated */
    hpcd->IN_ep[i].type = EP_TYPE_CTRL;
 800b88a:	193b      	adds	r3, r7, r4
 800b88c:	781b      	ldrb	r3, [r3, #0]
 800b88e:	6879      	ldr	r1, [r7, #4]
 800b890:	1c5a      	adds	r2, r3, #1
 800b892:	0013      	movs	r3, r2
 800b894:	009b      	lsls	r3, r3, #2
 800b896:	189b      	adds	r3, r3, r2
 800b898:	00db      	lsls	r3, r3, #3
 800b89a:	18cb      	adds	r3, r1, r3
 800b89c:	3303      	adds	r3, #3
 800b89e:	2200      	movs	r2, #0
 800b8a0:	701a      	strb	r2, [r3, #0]
    hpcd->IN_ep[i].maxpacket = 0U;
 800b8a2:	193b      	adds	r3, r7, r4
 800b8a4:	781a      	ldrb	r2, [r3, #0]
 800b8a6:	6879      	ldr	r1, [r7, #4]
 800b8a8:	0013      	movs	r3, r2
 800b8aa:	009b      	lsls	r3, r3, #2
 800b8ac:	189b      	adds	r3, r3, r2
 800b8ae:	00db      	lsls	r3, r3, #3
 800b8b0:	18cb      	adds	r3, r1, r3
 800b8b2:	3338      	adds	r3, #56	; 0x38
 800b8b4:	2200      	movs	r2, #0
 800b8b6:	601a      	str	r2, [r3, #0]
    hpcd->IN_ep[i].xfer_buff = 0U;
 800b8b8:	193b      	adds	r3, r7, r4
 800b8ba:	781a      	ldrb	r2, [r3, #0]
 800b8bc:	6879      	ldr	r1, [r7, #4]
 800b8be:	0013      	movs	r3, r2
 800b8c0:	009b      	lsls	r3, r3, #2
 800b8c2:	189b      	adds	r3, r3, r2
 800b8c4:	00db      	lsls	r3, r3, #3
 800b8c6:	18cb      	adds	r3, r1, r3
 800b8c8:	333c      	adds	r3, #60	; 0x3c
 800b8ca:	2200      	movs	r2, #0
 800b8cc:	601a      	str	r2, [r3, #0]
    hpcd->IN_ep[i].xfer_len = 0U;
 800b8ce:	193b      	adds	r3, r7, r4
 800b8d0:	781a      	ldrb	r2, [r3, #0]
 800b8d2:	6879      	ldr	r1, [r7, #4]
 800b8d4:	0013      	movs	r3, r2
 800b8d6:	009b      	lsls	r3, r3, #2
 800b8d8:	189b      	adds	r3, r3, r2
 800b8da:	00db      	lsls	r3, r3, #3
 800b8dc:	18cb      	adds	r3, r1, r3
 800b8de:	3340      	adds	r3, #64	; 0x40
 800b8e0:	2200      	movs	r2, #0
 800b8e2:	601a      	str	r2, [r3, #0]
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 800b8e4:	193b      	adds	r3, r7, r4
 800b8e6:	781a      	ldrb	r2, [r3, #0]
 800b8e8:	193b      	adds	r3, r7, r4
 800b8ea:	3201      	adds	r2, #1
 800b8ec:	701a      	strb	r2, [r3, #0]
 800b8ee:	210f      	movs	r1, #15
 800b8f0:	187b      	adds	r3, r7, r1
 800b8f2:	781a      	ldrb	r2, [r3, #0]
 800b8f4:	687b      	ldr	r3, [r7, #4]
 800b8f6:	685b      	ldr	r3, [r3, #4]
 800b8f8:	429a      	cmp	r2, r3
 800b8fa:	d39f      	bcc.n	800b83c <HAL_PCD_Init+0x4c>
  }

  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 800b8fc:	187b      	adds	r3, r7, r1
 800b8fe:	2200      	movs	r2, #0
 800b900:	701a      	strb	r2, [r3, #0]
 800b902:	e056      	b.n	800b9b2 <HAL_PCD_Init+0x1c2>
  {
    hpcd->OUT_ep[i].is_in = 0U;
 800b904:	240f      	movs	r4, #15
 800b906:	193b      	adds	r3, r7, r4
 800b908:	781a      	ldrb	r2, [r3, #0]
 800b90a:	6878      	ldr	r0, [r7, #4]
 800b90c:	236a      	movs	r3, #106	; 0x6a
 800b90e:	33ff      	adds	r3, #255	; 0xff
 800b910:	0019      	movs	r1, r3
 800b912:	0013      	movs	r3, r2
 800b914:	009b      	lsls	r3, r3, #2
 800b916:	189b      	adds	r3, r3, r2
 800b918:	00db      	lsls	r3, r3, #3
 800b91a:	18c3      	adds	r3, r0, r3
 800b91c:	185b      	adds	r3, r3, r1
 800b91e:	2200      	movs	r2, #0
 800b920:	701a      	strb	r2, [r3, #0]
    hpcd->OUT_ep[i].num = i;
 800b922:	193b      	adds	r3, r7, r4
 800b924:	781a      	ldrb	r2, [r3, #0]
 800b926:	6878      	ldr	r0, [r7, #4]
 800b928:	23b4      	movs	r3, #180	; 0xb4
 800b92a:	0059      	lsls	r1, r3, #1
 800b92c:	0013      	movs	r3, r2
 800b92e:	009b      	lsls	r3, r3, #2
 800b930:	189b      	adds	r3, r3, r2
 800b932:	00db      	lsls	r3, r3, #3
 800b934:	18c3      	adds	r3, r0, r3
 800b936:	185b      	adds	r3, r3, r1
 800b938:	193a      	adds	r2, r7, r4
 800b93a:	7812      	ldrb	r2, [r2, #0]
 800b93c:	701a      	strb	r2, [r3, #0]
    /* Control until ep is activated */
    hpcd->OUT_ep[i].type = EP_TYPE_CTRL;
 800b93e:	193b      	adds	r3, r7, r4
 800b940:	781a      	ldrb	r2, [r3, #0]
 800b942:	6878      	ldr	r0, [r7, #4]
 800b944:	236c      	movs	r3, #108	; 0x6c
 800b946:	33ff      	adds	r3, #255	; 0xff
 800b948:	0019      	movs	r1, r3
 800b94a:	0013      	movs	r3, r2
 800b94c:	009b      	lsls	r3, r3, #2
 800b94e:	189b      	adds	r3, r3, r2
 800b950:	00db      	lsls	r3, r3, #3
 800b952:	18c3      	adds	r3, r0, r3
 800b954:	185b      	adds	r3, r3, r1
 800b956:	2200      	movs	r2, #0
 800b958:	701a      	strb	r2, [r3, #0]
    hpcd->OUT_ep[i].maxpacket = 0U;
 800b95a:	193b      	adds	r3, r7, r4
 800b95c:	781a      	ldrb	r2, [r3, #0]
 800b95e:	6878      	ldr	r0, [r7, #4]
 800b960:	23bc      	movs	r3, #188	; 0xbc
 800b962:	0059      	lsls	r1, r3, #1
 800b964:	0013      	movs	r3, r2
 800b966:	009b      	lsls	r3, r3, #2
 800b968:	189b      	adds	r3, r3, r2
 800b96a:	00db      	lsls	r3, r3, #3
 800b96c:	18c3      	adds	r3, r0, r3
 800b96e:	185b      	adds	r3, r3, r1
 800b970:	2200      	movs	r2, #0
 800b972:	601a      	str	r2, [r3, #0]
    hpcd->OUT_ep[i].xfer_buff = 0U;
 800b974:	193b      	adds	r3, r7, r4
 800b976:	781a      	ldrb	r2, [r3, #0]
 800b978:	6878      	ldr	r0, [r7, #4]
 800b97a:	23be      	movs	r3, #190	; 0xbe
 800b97c:	0059      	lsls	r1, r3, #1
 800b97e:	0013      	movs	r3, r2
 800b980:	009b      	lsls	r3, r3, #2
 800b982:	189b      	adds	r3, r3, r2
 800b984:	00db      	lsls	r3, r3, #3
 800b986:	18c3      	adds	r3, r0, r3
 800b988:	185b      	adds	r3, r3, r1
 800b98a:	2200      	movs	r2, #0
 800b98c:	601a      	str	r2, [r3, #0]
    hpcd->OUT_ep[i].xfer_len = 0U;
 800b98e:	193b      	adds	r3, r7, r4
 800b990:	781a      	ldrb	r2, [r3, #0]
 800b992:	6878      	ldr	r0, [r7, #4]
 800b994:	23c0      	movs	r3, #192	; 0xc0
 800b996:	0059      	lsls	r1, r3, #1
 800b998:	0013      	movs	r3, r2
 800b99a:	009b      	lsls	r3, r3, #2
 800b99c:	189b      	adds	r3, r3, r2
 800b99e:	00db      	lsls	r3, r3, #3
 800b9a0:	18c3      	adds	r3, r0, r3
 800b9a2:	185b      	adds	r3, r3, r1
 800b9a4:	2200      	movs	r2, #0
 800b9a6:	601a      	str	r2, [r3, #0]
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 800b9a8:	193b      	adds	r3, r7, r4
 800b9aa:	781a      	ldrb	r2, [r3, #0]
 800b9ac:	193b      	adds	r3, r7, r4
 800b9ae:	3201      	adds	r2, #1
 800b9b0:	701a      	strb	r2, [r3, #0]
 800b9b2:	230f      	movs	r3, #15
 800b9b4:	18fb      	adds	r3, r7, r3
 800b9b6:	781a      	ldrb	r2, [r3, #0]
 800b9b8:	687b      	ldr	r3, [r7, #4]
 800b9ba:	685b      	ldr	r3, [r3, #4]
 800b9bc:	429a      	cmp	r2, r3
 800b9be:	d3a1      	bcc.n	800b904 <HAL_PCD_Init+0x114>
  }

  /* Init Device */
  (void)USB_DevInit(hpcd->Instance, hpcd->Init);
 800b9c0:	687b      	ldr	r3, [r7, #4]
 800b9c2:	6818      	ldr	r0, [r3, #0]
 800b9c4:	687b      	ldr	r3, [r7, #4]
 800b9c6:	466a      	mov	r2, sp
 800b9c8:	0011      	movs	r1, r2
 800b9ca:	001a      	movs	r2, r3
 800b9cc:	3210      	adds	r2, #16
 800b9ce:	ca70      	ldmia	r2!, {r4, r5, r6}
 800b9d0:	c170      	stmia	r1!, {r4, r5, r6}
 800b9d2:	ca30      	ldmia	r2!, {r4, r5}
 800b9d4:	c130      	stmia	r1!, {r4, r5}
 800b9d6:	6859      	ldr	r1, [r3, #4]
 800b9d8:	689a      	ldr	r2, [r3, #8]
 800b9da:	68db      	ldr	r3, [r3, #12]
 800b9dc:	f004 f816 	bl	800fa0c <USB_DevInit>

  hpcd->USB_Address = 0U;
 800b9e0:	687b      	ldr	r3, [r7, #4]
 800b9e2:	2224      	movs	r2, #36	; 0x24
 800b9e4:	2100      	movs	r1, #0
 800b9e6:	5499      	strb	r1, [r3, r2]
  hpcd->State = HAL_PCD_STATE_READY;
 800b9e8:	687b      	ldr	r3, [r7, #4]
 800b9ea:	4a08      	ldr	r2, [pc, #32]	; (800ba0c <HAL_PCD_Init+0x21c>)
 800b9ec:	2101      	movs	r1, #1
 800b9ee:	5499      	strb	r1, [r3, r2]

  /* Activate LPM */
  if (hpcd->Init.lpm_enable == 1U)
 800b9f0:	687b      	ldr	r3, [r7, #4]
 800b9f2:	69db      	ldr	r3, [r3, #28]
 800b9f4:	2b01      	cmp	r3, #1
 800b9f6:	d103      	bne.n	800ba00 <HAL_PCD_Init+0x210>
  {
    (void)HAL_PCDEx_ActivateLPM(hpcd);
 800b9f8:	687b      	ldr	r3, [r7, #4]
 800b9fa:	0018      	movs	r0, r3
 800b9fc:	f001 fd34 	bl	800d468 <HAL_PCDEx_ActivateLPM>
  }

  return HAL_OK;
 800ba00:	2300      	movs	r3, #0
}
 800ba02:	0018      	movs	r0, r3
 800ba04:	46bd      	mov	sp, r7
 800ba06:	b005      	add	sp, #20
 800ba08:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800ba0a:	46c0      	nop			; (mov r8, r8)
 800ba0c:	000002a9 	.word	0x000002a9

0800ba10 <HAL_PCD_Start>:
  * @brief  Start the USB device
  * @param  hpcd PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Start(PCD_HandleTypeDef *hpcd)
{
 800ba10:	b580      	push	{r7, lr}
 800ba12:	b082      	sub	sp, #8
 800ba14:	af00      	add	r7, sp, #0
 800ba16:	6078      	str	r0, [r7, #4]
  __HAL_LOCK(hpcd);
 800ba18:	687a      	ldr	r2, [r7, #4]
 800ba1a:	23aa      	movs	r3, #170	; 0xaa
 800ba1c:	009b      	lsls	r3, r3, #2
 800ba1e:	5cd3      	ldrb	r3, [r2, r3]
 800ba20:	2b01      	cmp	r3, #1
 800ba22:	d101      	bne.n	800ba28 <HAL_PCD_Start+0x18>
 800ba24:	2302      	movs	r3, #2
 800ba26:	e014      	b.n	800ba52 <HAL_PCD_Start+0x42>
 800ba28:	687a      	ldr	r2, [r7, #4]
 800ba2a:	23aa      	movs	r3, #170	; 0xaa
 800ba2c:	009b      	lsls	r3, r3, #2
 800ba2e:	2101      	movs	r1, #1
 800ba30:	54d1      	strb	r1, [r2, r3]
  __HAL_PCD_ENABLE(hpcd);
 800ba32:	687b      	ldr	r3, [r7, #4]
 800ba34:	681b      	ldr	r3, [r3, #0]
 800ba36:	0018      	movs	r0, r3
 800ba38:	f003 ffb8 	bl	800f9ac <USB_EnableGlobalInt>
  (void)USB_DevConnect(hpcd->Instance);
 800ba3c:	687b      	ldr	r3, [r7, #4]
 800ba3e:	681b      	ldr	r3, [r3, #0]
 800ba40:	0018      	movs	r0, r3
 800ba42:	f005 ff13 	bl	801186c <USB_DevConnect>
  __HAL_UNLOCK(hpcd);
 800ba46:	687a      	ldr	r2, [r7, #4]
 800ba48:	23aa      	movs	r3, #170	; 0xaa
 800ba4a:	009b      	lsls	r3, r3, #2
 800ba4c:	2100      	movs	r1, #0
 800ba4e:	54d1      	strb	r1, [r2, r3]

  return HAL_OK;
 800ba50:	2300      	movs	r3, #0
}
 800ba52:	0018      	movs	r0, r3
 800ba54:	46bd      	mov	sp, r7
 800ba56:	b002      	add	sp, #8
 800ba58:	bd80      	pop	{r7, pc}
	...

0800ba5c <HAL_PCD_IRQHandler>:
  * @brief  This function handles PCD interrupt request.
  * @param  hpcd PCD handle
  * @retval HAL status
  */
void HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd)
{
 800ba5c:	b580      	push	{r7, lr}
 800ba5e:	b082      	sub	sp, #8
 800ba60:	af00      	add	r7, sp, #0
 800ba62:	6078      	str	r0, [r7, #4]
  if (__HAL_PCD_GET_FLAG(hpcd, USB_ISTR_CTR))
 800ba64:	687b      	ldr	r3, [r7, #4]
 800ba66:	681b      	ldr	r3, [r3, #0]
 800ba68:	0018      	movs	r0, r3
 800ba6a:	f005 ff15 	bl	8011898 <USB_ReadInterrupts>
 800ba6e:	0002      	movs	r2, r0
 800ba70:	2380      	movs	r3, #128	; 0x80
 800ba72:	021b      	lsls	r3, r3, #8
 800ba74:	401a      	ands	r2, r3
 800ba76:	2380      	movs	r3, #128	; 0x80
 800ba78:	021b      	lsls	r3, r3, #8
 800ba7a:	429a      	cmp	r2, r3
 800ba7c:	d103      	bne.n	800ba86 <HAL_PCD_IRQHandler+0x2a>
  {
    /* servicing of the endpoint correct transfer interrupt */
    /* clear of the CTR flag into the sub */
    (void)PCD_EP_ISR_Handler(hpcd);
 800ba7e:	687b      	ldr	r3, [r7, #4]
 800ba80:	0018      	movs	r0, r3
 800ba82:	f000 fbbb 	bl	800c1fc <PCD_EP_ISR_Handler>
  }

  if (__HAL_PCD_GET_FLAG(hpcd, USB_ISTR_RESET))
 800ba86:	687b      	ldr	r3, [r7, #4]
 800ba88:	681b      	ldr	r3, [r3, #0]
 800ba8a:	0018      	movs	r0, r3
 800ba8c:	f005 ff04 	bl	8011898 <USB_ReadInterrupts>
 800ba90:	0002      	movs	r2, r0
 800ba92:	2380      	movs	r3, #128	; 0x80
 800ba94:	00db      	lsls	r3, r3, #3
 800ba96:	401a      	ands	r2, r3
 800ba98:	2380      	movs	r3, #128	; 0x80
 800ba9a:	00db      	lsls	r3, r3, #3
 800ba9c:	429a      	cmp	r2, r3
 800ba9e:	d114      	bne.n	800baca <HAL_PCD_IRQHandler+0x6e>
  {
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_RESET);
 800baa0:	687b      	ldr	r3, [r7, #4]
 800baa2:	681b      	ldr	r3, [r3, #0]
 800baa4:	2244      	movs	r2, #68	; 0x44
 800baa6:	5a9b      	ldrh	r3, [r3, r2]
 800baa8:	b29a      	uxth	r2, r3
 800baaa:	687b      	ldr	r3, [r7, #4]
 800baac:	681b      	ldr	r3, [r3, #0]
 800baae:	49a2      	ldr	r1, [pc, #648]	; (800bd38 <HAL_PCD_IRQHandler+0x2dc>)
 800bab0:	400a      	ands	r2, r1
 800bab2:	b291      	uxth	r1, r2
 800bab4:	2244      	movs	r2, #68	; 0x44
 800bab6:	5299      	strh	r1, [r3, r2]

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
    hpcd->ResetCallback(hpcd);
#else
    HAL_PCD_ResetCallback(hpcd);
 800bab8:	687b      	ldr	r3, [r7, #4]
 800baba:	0018      	movs	r0, r3
 800babc:	f008 ffa3 	bl	8014a06 <HAL_PCD_ResetCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */

    (void)HAL_PCD_SetAddress(hpcd, 0U);
 800bac0:	687b      	ldr	r3, [r7, #4]
 800bac2:	2100      	movs	r1, #0
 800bac4:	0018      	movs	r0, r3
 800bac6:	f000 f945 	bl	800bd54 <HAL_PCD_SetAddress>
  }

  if (__HAL_PCD_GET_FLAG(hpcd, USB_ISTR_PMAOVR))
 800baca:	687b      	ldr	r3, [r7, #4]
 800bacc:	681b      	ldr	r3, [r3, #0]
 800bace:	0018      	movs	r0, r3
 800bad0:	f005 fee2 	bl	8011898 <USB_ReadInterrupts>
 800bad4:	0002      	movs	r2, r0
 800bad6:	2380      	movs	r3, #128	; 0x80
 800bad8:	01db      	lsls	r3, r3, #7
 800bada:	401a      	ands	r2, r3
 800badc:	2380      	movs	r3, #128	; 0x80
 800bade:	01db      	lsls	r3, r3, #7
 800bae0:	429a      	cmp	r2, r3
 800bae2:	d10b      	bne.n	800bafc <HAL_PCD_IRQHandler+0xa0>
  {
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_PMAOVR);
 800bae4:	687b      	ldr	r3, [r7, #4]
 800bae6:	681b      	ldr	r3, [r3, #0]
 800bae8:	2244      	movs	r2, #68	; 0x44
 800baea:	5a9b      	ldrh	r3, [r3, r2]
 800baec:	b29a      	uxth	r2, r3
 800baee:	687b      	ldr	r3, [r7, #4]
 800baf0:	681b      	ldr	r3, [r3, #0]
 800baf2:	4992      	ldr	r1, [pc, #584]	; (800bd3c <HAL_PCD_IRQHandler+0x2e0>)
 800baf4:	400a      	ands	r2, r1
 800baf6:	b291      	uxth	r1, r2
 800baf8:	2244      	movs	r2, #68	; 0x44
 800bafa:	5299      	strh	r1, [r3, r2]
  }

  if (__HAL_PCD_GET_FLAG(hpcd, USB_ISTR_ERR))
 800bafc:	687b      	ldr	r3, [r7, #4]
 800bafe:	681b      	ldr	r3, [r3, #0]
 800bb00:	0018      	movs	r0, r3
 800bb02:	f005 fec9 	bl	8011898 <USB_ReadInterrupts>
 800bb06:	0002      	movs	r2, r0
 800bb08:	2380      	movs	r3, #128	; 0x80
 800bb0a:	019b      	lsls	r3, r3, #6
 800bb0c:	401a      	ands	r2, r3
 800bb0e:	2380      	movs	r3, #128	; 0x80
 800bb10:	019b      	lsls	r3, r3, #6
 800bb12:	429a      	cmp	r2, r3
 800bb14:	d10b      	bne.n	800bb2e <HAL_PCD_IRQHandler+0xd2>
  {
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_ERR);
 800bb16:	687b      	ldr	r3, [r7, #4]
 800bb18:	681b      	ldr	r3, [r3, #0]
 800bb1a:	2244      	movs	r2, #68	; 0x44
 800bb1c:	5a9b      	ldrh	r3, [r3, r2]
 800bb1e:	b29a      	uxth	r2, r3
 800bb20:	687b      	ldr	r3, [r7, #4]
 800bb22:	681b      	ldr	r3, [r3, #0]
 800bb24:	4986      	ldr	r1, [pc, #536]	; (800bd40 <HAL_PCD_IRQHandler+0x2e4>)
 800bb26:	400a      	ands	r2, r1
 800bb28:	b291      	uxth	r1, r2
 800bb2a:	2244      	movs	r2, #68	; 0x44
 800bb2c:	5299      	strh	r1, [r3, r2]
  }

  if (__HAL_PCD_GET_FLAG(hpcd, USB_ISTR_WKUP))
 800bb2e:	687b      	ldr	r3, [r7, #4]
 800bb30:	681b      	ldr	r3, [r3, #0]
 800bb32:	0018      	movs	r0, r3
 800bb34:	f005 feb0 	bl	8011898 <USB_ReadInterrupts>
 800bb38:	0002      	movs	r2, r0
 800bb3a:	2380      	movs	r3, #128	; 0x80
 800bb3c:	015b      	lsls	r3, r3, #5
 800bb3e:	401a      	ands	r2, r3
 800bb40:	2380      	movs	r3, #128	; 0x80
 800bb42:	015b      	lsls	r3, r3, #5
 800bb44:	429a      	cmp	r2, r3
 800bb46:	d137      	bne.n	800bbb8 <HAL_PCD_IRQHandler+0x15c>
  {
    hpcd->Instance->CNTR &= (uint16_t) ~(USB_CNTR_LPMODE);
 800bb48:	687b      	ldr	r3, [r7, #4]
 800bb4a:	681b      	ldr	r3, [r3, #0]
 800bb4c:	2240      	movs	r2, #64	; 0x40
 800bb4e:	5a9b      	ldrh	r3, [r3, r2]
 800bb50:	b29a      	uxth	r2, r3
 800bb52:	687b      	ldr	r3, [r7, #4]
 800bb54:	681b      	ldr	r3, [r3, #0]
 800bb56:	2104      	movs	r1, #4
 800bb58:	438a      	bics	r2, r1
 800bb5a:	b291      	uxth	r1, r2
 800bb5c:	2240      	movs	r2, #64	; 0x40
 800bb5e:	5299      	strh	r1, [r3, r2]
    hpcd->Instance->CNTR &= (uint16_t) ~(USB_CNTR_FSUSP);
 800bb60:	687b      	ldr	r3, [r7, #4]
 800bb62:	681b      	ldr	r3, [r3, #0]
 800bb64:	2240      	movs	r2, #64	; 0x40
 800bb66:	5a9b      	ldrh	r3, [r3, r2]
 800bb68:	b29a      	uxth	r2, r3
 800bb6a:	687b      	ldr	r3, [r7, #4]
 800bb6c:	681b      	ldr	r3, [r3, #0]
 800bb6e:	2108      	movs	r1, #8
 800bb70:	438a      	bics	r2, r1
 800bb72:	b291      	uxth	r1, r2
 800bb74:	2240      	movs	r2, #64	; 0x40
 800bb76:	5299      	strh	r1, [r3, r2]

    if (hpcd->LPM_State == LPM_L1)
 800bb78:	687a      	ldr	r2, [r7, #4]
 800bb7a:	23b8      	movs	r3, #184	; 0xb8
 800bb7c:	009b      	lsls	r3, r3, #2
 800bb7e:	5cd3      	ldrb	r3, [r2, r3]
 800bb80:	2b01      	cmp	r3, #1
 800bb82:	d109      	bne.n	800bb98 <HAL_PCD_IRQHandler+0x13c>
    {
      hpcd->LPM_State = LPM_L0;
 800bb84:	687a      	ldr	r2, [r7, #4]
 800bb86:	23b8      	movs	r3, #184	; 0xb8
 800bb88:	009b      	lsls	r3, r3, #2
 800bb8a:	2100      	movs	r1, #0
 800bb8c:	54d1      	strb	r1, [r2, r3]
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
      hpcd->LPMCallback(hpcd, PCD_LPM_L0_ACTIVE);
#else
      HAL_PCDEx_LPM_Callback(hpcd, PCD_LPM_L0_ACTIVE);
 800bb8e:	687b      	ldr	r3, [r7, #4]
 800bb90:	2100      	movs	r1, #0
 800bb92:	0018      	movs	r0, r3
 800bb94:	f001 fc92 	bl	800d4bc <HAL_PCDEx_LPM_Callback>
    }

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
    hpcd->ResumeCallback(hpcd);
#else
    HAL_PCD_ResumeCallback(hpcd);
 800bb98:	687b      	ldr	r3, [r7, #4]
 800bb9a:	0018      	movs	r0, r3
 800bb9c:	f008 ff74 	bl	8014a88 <HAL_PCD_ResumeCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */

    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_WKUP);
 800bba0:	687b      	ldr	r3, [r7, #4]
 800bba2:	681b      	ldr	r3, [r3, #0]
 800bba4:	2244      	movs	r2, #68	; 0x44
 800bba6:	5a9b      	ldrh	r3, [r3, r2]
 800bba8:	b29a      	uxth	r2, r3
 800bbaa:	687b      	ldr	r3, [r7, #4]
 800bbac:	681b      	ldr	r3, [r3, #0]
 800bbae:	4965      	ldr	r1, [pc, #404]	; (800bd44 <HAL_PCD_IRQHandler+0x2e8>)
 800bbb0:	400a      	ands	r2, r1
 800bbb2:	b291      	uxth	r1, r2
 800bbb4:	2244      	movs	r2, #68	; 0x44
 800bbb6:	5299      	strh	r1, [r3, r2]
  }

  if (__HAL_PCD_GET_FLAG(hpcd, USB_ISTR_SUSP))
 800bbb8:	687b      	ldr	r3, [r7, #4]
 800bbba:	681b      	ldr	r3, [r3, #0]
 800bbbc:	0018      	movs	r0, r3
 800bbbe:	f005 fe6b 	bl	8011898 <USB_ReadInterrupts>
 800bbc2:	0002      	movs	r2, r0
 800bbc4:	2380      	movs	r3, #128	; 0x80
 800bbc6:	011b      	lsls	r3, r3, #4
 800bbc8:	401a      	ands	r2, r3
 800bbca:	2380      	movs	r3, #128	; 0x80
 800bbcc:	011b      	lsls	r3, r3, #4
 800bbce:	429a      	cmp	r2, r3
 800bbd0:	d127      	bne.n	800bc22 <HAL_PCD_IRQHandler+0x1c6>
  {
    /* Force low-power mode in the macrocell */
    hpcd->Instance->CNTR |= (uint16_t)USB_CNTR_FSUSP;
 800bbd2:	687b      	ldr	r3, [r7, #4]
 800bbd4:	681b      	ldr	r3, [r3, #0]
 800bbd6:	2240      	movs	r2, #64	; 0x40
 800bbd8:	5a9b      	ldrh	r3, [r3, r2]
 800bbda:	b29a      	uxth	r2, r3
 800bbdc:	687b      	ldr	r3, [r7, #4]
 800bbde:	681b      	ldr	r3, [r3, #0]
 800bbe0:	2108      	movs	r1, #8
 800bbe2:	430a      	orrs	r2, r1
 800bbe4:	b291      	uxth	r1, r2
 800bbe6:	2240      	movs	r2, #64	; 0x40
 800bbe8:	5299      	strh	r1, [r3, r2]

    /* clear of the ISTR bit must be done after setting of CNTR_FSUSP */
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_SUSP);
 800bbea:	687b      	ldr	r3, [r7, #4]
 800bbec:	681b      	ldr	r3, [r3, #0]
 800bbee:	2244      	movs	r2, #68	; 0x44
 800bbf0:	5a9b      	ldrh	r3, [r3, r2]
 800bbf2:	b29a      	uxth	r2, r3
 800bbf4:	687b      	ldr	r3, [r7, #4]
 800bbf6:	681b      	ldr	r3, [r3, #0]
 800bbf8:	4953      	ldr	r1, [pc, #332]	; (800bd48 <HAL_PCD_IRQHandler+0x2ec>)
 800bbfa:	400a      	ands	r2, r1
 800bbfc:	b291      	uxth	r1, r2
 800bbfe:	2244      	movs	r2, #68	; 0x44
 800bc00:	5299      	strh	r1, [r3, r2]

    hpcd->Instance->CNTR |= (uint16_t)USB_CNTR_LPMODE;
 800bc02:	687b      	ldr	r3, [r7, #4]
 800bc04:	681b      	ldr	r3, [r3, #0]
 800bc06:	2240      	movs	r2, #64	; 0x40
 800bc08:	5a9b      	ldrh	r3, [r3, r2]
 800bc0a:	b29a      	uxth	r2, r3
 800bc0c:	687b      	ldr	r3, [r7, #4]
 800bc0e:	681b      	ldr	r3, [r3, #0]
 800bc10:	2104      	movs	r1, #4
 800bc12:	430a      	orrs	r2, r1
 800bc14:	b291      	uxth	r1, r2
 800bc16:	2240      	movs	r2, #64	; 0x40
 800bc18:	5299      	strh	r1, [r3, r2]

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
    hpcd->SuspendCallback(hpcd);
#else
    HAL_PCD_SuspendCallback(hpcd);
 800bc1a:	687b      	ldr	r3, [r7, #4]
 800bc1c:	0018      	movs	r0, r3
 800bc1e:	f008 ff17 	bl	8014a50 <HAL_PCD_SuspendCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
  }

  /* Handle LPM Interrupt */
  if (__HAL_PCD_GET_FLAG(hpcd, USB_ISTR_L1REQ))
 800bc22:	687b      	ldr	r3, [r7, #4]
 800bc24:	681b      	ldr	r3, [r3, #0]
 800bc26:	0018      	movs	r0, r3
 800bc28:	f005 fe36 	bl	8011898 <USB_ReadInterrupts>
 800bc2c:	0003      	movs	r3, r0
 800bc2e:	2280      	movs	r2, #128	; 0x80
 800bc30:	4013      	ands	r3, r2
 800bc32:	2b80      	cmp	r3, #128	; 0x80
 800bc34:	d145      	bne.n	800bcc2 <HAL_PCD_IRQHandler+0x266>
  {
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_L1REQ);
 800bc36:	687b      	ldr	r3, [r7, #4]
 800bc38:	681b      	ldr	r3, [r3, #0]
 800bc3a:	2244      	movs	r2, #68	; 0x44
 800bc3c:	5a9b      	ldrh	r3, [r3, r2]
 800bc3e:	b29a      	uxth	r2, r3
 800bc40:	687b      	ldr	r3, [r7, #4]
 800bc42:	681b      	ldr	r3, [r3, #0]
 800bc44:	2180      	movs	r1, #128	; 0x80
 800bc46:	438a      	bics	r2, r1
 800bc48:	b291      	uxth	r1, r2
 800bc4a:	2244      	movs	r2, #68	; 0x44
 800bc4c:	5299      	strh	r1, [r3, r2]
    if (hpcd->LPM_State == LPM_L0)
 800bc4e:	687a      	ldr	r2, [r7, #4]
 800bc50:	23b8      	movs	r3, #184	; 0xb8
 800bc52:	009b      	lsls	r3, r3, #2
 800bc54:	5cd3      	ldrb	r3, [r2, r3]
 800bc56:	2b00      	cmp	r3, #0
 800bc58:	d12f      	bne.n	800bcba <HAL_PCD_IRQHandler+0x25e>
    {
      /* Force suspend and low-power mode before going to L1 state*/
      hpcd->Instance->CNTR |= (uint16_t)USB_CNTR_LPMODE;
 800bc5a:	687b      	ldr	r3, [r7, #4]
 800bc5c:	681b      	ldr	r3, [r3, #0]
 800bc5e:	2240      	movs	r2, #64	; 0x40
 800bc60:	5a9b      	ldrh	r3, [r3, r2]
 800bc62:	b29a      	uxth	r2, r3
 800bc64:	687b      	ldr	r3, [r7, #4]
 800bc66:	681b      	ldr	r3, [r3, #0]
 800bc68:	2104      	movs	r1, #4
 800bc6a:	430a      	orrs	r2, r1
 800bc6c:	b291      	uxth	r1, r2
 800bc6e:	2240      	movs	r2, #64	; 0x40
 800bc70:	5299      	strh	r1, [r3, r2]
      hpcd->Instance->CNTR |= (uint16_t)USB_CNTR_FSUSP;
 800bc72:	687b      	ldr	r3, [r7, #4]
 800bc74:	681b      	ldr	r3, [r3, #0]
 800bc76:	2240      	movs	r2, #64	; 0x40
 800bc78:	5a9b      	ldrh	r3, [r3, r2]
 800bc7a:	b29a      	uxth	r2, r3
 800bc7c:	687b      	ldr	r3, [r7, #4]
 800bc7e:	681b      	ldr	r3, [r3, #0]
 800bc80:	2108      	movs	r1, #8
 800bc82:	430a      	orrs	r2, r1
 800bc84:	b291      	uxth	r1, r2
 800bc86:	2240      	movs	r2, #64	; 0x40
 800bc88:	5299      	strh	r1, [r3, r2]

      hpcd->LPM_State = LPM_L1;
 800bc8a:	687a      	ldr	r2, [r7, #4]
 800bc8c:	23b8      	movs	r3, #184	; 0xb8
 800bc8e:	009b      	lsls	r3, r3, #2
 800bc90:	2101      	movs	r1, #1
 800bc92:	54d1      	strb	r1, [r2, r3]
      hpcd->BESL = ((uint32_t)hpcd->Instance->LPMCSR & USB_LPMCSR_BESL) >> 2;
 800bc94:	687b      	ldr	r3, [r7, #4]
 800bc96:	681b      	ldr	r3, [r3, #0]
 800bc98:	2254      	movs	r2, #84	; 0x54
 800bc9a:	5a9b      	ldrh	r3, [r3, r2]
 800bc9c:	b29b      	uxth	r3, r3
 800bc9e:	089b      	lsrs	r3, r3, #2
 800bca0:	223c      	movs	r2, #60	; 0x3c
 800bca2:	4013      	ands	r3, r2
 800bca4:	0019      	movs	r1, r3
 800bca6:	687a      	ldr	r2, [r7, #4]
 800bca8:	23b9      	movs	r3, #185	; 0xb9
 800bcaa:	009b      	lsls	r3, r3, #2
 800bcac:	50d1      	str	r1, [r2, r3]
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
      hpcd->LPMCallback(hpcd, PCD_LPM_L1_ACTIVE);
#else
      HAL_PCDEx_LPM_Callback(hpcd, PCD_LPM_L1_ACTIVE);
 800bcae:	687b      	ldr	r3, [r7, #4]
 800bcb0:	2101      	movs	r1, #1
 800bcb2:	0018      	movs	r0, r3
 800bcb4:	f001 fc02 	bl	800d4bc <HAL_PCDEx_LPM_Callback>
 800bcb8:	e003      	b.n	800bcc2 <HAL_PCD_IRQHandler+0x266>
    else
    {
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
      hpcd->SuspendCallback(hpcd);
#else
      HAL_PCD_SuspendCallback(hpcd);
 800bcba:	687b      	ldr	r3, [r7, #4]
 800bcbc:	0018      	movs	r0, r3
 800bcbe:	f008 fec7 	bl	8014a50 <HAL_PCD_SuspendCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
    }
  }

  if (__HAL_PCD_GET_FLAG(hpcd, USB_ISTR_SOF))
 800bcc2:	687b      	ldr	r3, [r7, #4]
 800bcc4:	681b      	ldr	r3, [r3, #0]
 800bcc6:	0018      	movs	r0, r3
 800bcc8:	f005 fde6 	bl	8011898 <USB_ReadInterrupts>
 800bccc:	0002      	movs	r2, r0
 800bcce:	2380      	movs	r3, #128	; 0x80
 800bcd0:	009b      	lsls	r3, r3, #2
 800bcd2:	401a      	ands	r2, r3
 800bcd4:	2380      	movs	r3, #128	; 0x80
 800bcd6:	009b      	lsls	r3, r3, #2
 800bcd8:	429a      	cmp	r2, r3
 800bcda:	d10f      	bne.n	800bcfc <HAL_PCD_IRQHandler+0x2a0>
  {
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_SOF);
 800bcdc:	687b      	ldr	r3, [r7, #4]
 800bcde:	681b      	ldr	r3, [r3, #0]
 800bce0:	2244      	movs	r2, #68	; 0x44
 800bce2:	5a9b      	ldrh	r3, [r3, r2]
 800bce4:	b29a      	uxth	r2, r3
 800bce6:	687b      	ldr	r3, [r7, #4]
 800bce8:	681b      	ldr	r3, [r3, #0]
 800bcea:	4918      	ldr	r1, [pc, #96]	; (800bd4c <HAL_PCD_IRQHandler+0x2f0>)
 800bcec:	400a      	ands	r2, r1
 800bcee:	b291      	uxth	r1, r2
 800bcf0:	2244      	movs	r2, #68	; 0x44
 800bcf2:	5299      	strh	r1, [r3, r2]

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
    hpcd->SOFCallback(hpcd);
#else
    HAL_PCD_SOFCallback(hpcd);
 800bcf4:	687b      	ldr	r3, [r7, #4]
 800bcf6:	0018      	movs	r0, r3
 800bcf8:	f008 fe76 	bl	80149e8 <HAL_PCD_SOFCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
  }

  if (__HAL_PCD_GET_FLAG(hpcd, USB_ISTR_ESOF))
 800bcfc:	687b      	ldr	r3, [r7, #4]
 800bcfe:	681b      	ldr	r3, [r3, #0]
 800bd00:	0018      	movs	r0, r3
 800bd02:	f005 fdc9 	bl	8011898 <USB_ReadInterrupts>
 800bd06:	0002      	movs	r2, r0
 800bd08:	2380      	movs	r3, #128	; 0x80
 800bd0a:	005b      	lsls	r3, r3, #1
 800bd0c:	401a      	ands	r2, r3
 800bd0e:	2380      	movs	r3, #128	; 0x80
 800bd10:	005b      	lsls	r3, r3, #1
 800bd12:	429a      	cmp	r2, r3
 800bd14:	d10b      	bne.n	800bd2e <HAL_PCD_IRQHandler+0x2d2>
  {
    /* clear ESOF flag in ISTR */
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_ESOF);
 800bd16:	687b      	ldr	r3, [r7, #4]
 800bd18:	681b      	ldr	r3, [r3, #0]
 800bd1a:	2244      	movs	r2, #68	; 0x44
 800bd1c:	5a9b      	ldrh	r3, [r3, r2]
 800bd1e:	b29a      	uxth	r2, r3
 800bd20:	687b      	ldr	r3, [r7, #4]
 800bd22:	681b      	ldr	r3, [r3, #0]
 800bd24:	490a      	ldr	r1, [pc, #40]	; (800bd50 <HAL_PCD_IRQHandler+0x2f4>)
 800bd26:	400a      	ands	r2, r1
 800bd28:	b291      	uxth	r1, r2
 800bd2a:	2244      	movs	r2, #68	; 0x44
 800bd2c:	5299      	strh	r1, [r3, r2]
  }
}
 800bd2e:	46c0      	nop			; (mov r8, r8)
 800bd30:	46bd      	mov	sp, r7
 800bd32:	b002      	add	sp, #8
 800bd34:	bd80      	pop	{r7, pc}
 800bd36:	46c0      	nop			; (mov r8, r8)
 800bd38:	fffffbff 	.word	0xfffffbff
 800bd3c:	ffffbfff 	.word	0xffffbfff
 800bd40:	ffffdfff 	.word	0xffffdfff
 800bd44:	ffffefff 	.word	0xffffefff
 800bd48:	fffff7ff 	.word	0xfffff7ff
 800bd4c:	fffffdff 	.word	0xfffffdff
 800bd50:	fffffeff 	.word	0xfffffeff

0800bd54 <HAL_PCD_SetAddress>:
  * @param  hpcd PCD handle
  * @param  address new device address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_SetAddress(PCD_HandleTypeDef *hpcd, uint8_t address)
{
 800bd54:	b580      	push	{r7, lr}
 800bd56:	b082      	sub	sp, #8
 800bd58:	af00      	add	r7, sp, #0
 800bd5a:	6078      	str	r0, [r7, #4]
 800bd5c:	000a      	movs	r2, r1
 800bd5e:	1cfb      	adds	r3, r7, #3
 800bd60:	701a      	strb	r2, [r3, #0]
  __HAL_LOCK(hpcd);
 800bd62:	687a      	ldr	r2, [r7, #4]
 800bd64:	23aa      	movs	r3, #170	; 0xaa
 800bd66:	009b      	lsls	r3, r3, #2
 800bd68:	5cd3      	ldrb	r3, [r2, r3]
 800bd6a:	2b01      	cmp	r3, #1
 800bd6c:	d101      	bne.n	800bd72 <HAL_PCD_SetAddress+0x1e>
 800bd6e:	2302      	movs	r3, #2
 800bd70:	e017      	b.n	800bda2 <HAL_PCD_SetAddress+0x4e>
 800bd72:	687a      	ldr	r2, [r7, #4]
 800bd74:	23aa      	movs	r3, #170	; 0xaa
 800bd76:	009b      	lsls	r3, r3, #2
 800bd78:	2101      	movs	r1, #1
 800bd7a:	54d1      	strb	r1, [r2, r3]
  hpcd->USB_Address = address;
 800bd7c:	687b      	ldr	r3, [r7, #4]
 800bd7e:	1cfa      	adds	r2, r7, #3
 800bd80:	2124      	movs	r1, #36	; 0x24
 800bd82:	7812      	ldrb	r2, [r2, #0]
 800bd84:	545a      	strb	r2, [r3, r1]
  (void)USB_SetDevAddress(hpcd->Instance, address);
 800bd86:	687b      	ldr	r3, [r7, #4]
 800bd88:	681a      	ldr	r2, [r3, #0]
 800bd8a:	1cfb      	adds	r3, r7, #3
 800bd8c:	781b      	ldrb	r3, [r3, #0]
 800bd8e:	0019      	movs	r1, r3
 800bd90:	0010      	movs	r0, r2
 800bd92:	f005 fd57 	bl	8011844 <USB_SetDevAddress>
  __HAL_UNLOCK(hpcd);
 800bd96:	687a      	ldr	r2, [r7, #4]
 800bd98:	23aa      	movs	r3, #170	; 0xaa
 800bd9a:	009b      	lsls	r3, r3, #2
 800bd9c:	2100      	movs	r1, #0
 800bd9e:	54d1      	strb	r1, [r2, r3]

  return HAL_OK;
 800bda0:	2300      	movs	r3, #0
}
 800bda2:	0018      	movs	r0, r3
 800bda4:	46bd      	mov	sp, r7
 800bda6:	b002      	add	sp, #8
 800bda8:	bd80      	pop	{r7, pc}

0800bdaa <HAL_PCD_EP_Open>:
  * @param  ep_type endpoint type
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Open(PCD_HandleTypeDef *hpcd, uint8_t ep_addr,
                                  uint16_t ep_mps, uint8_t ep_type)
{
 800bdaa:	b590      	push	{r4, r7, lr}
 800bdac:	b085      	sub	sp, #20
 800bdae:	af00      	add	r7, sp, #0
 800bdb0:	6078      	str	r0, [r7, #4]
 800bdb2:	000c      	movs	r4, r1
 800bdb4:	0010      	movs	r0, r2
 800bdb6:	0019      	movs	r1, r3
 800bdb8:	1cfb      	adds	r3, r7, #3
 800bdba:	1c22      	adds	r2, r4, #0
 800bdbc:	701a      	strb	r2, [r3, #0]
 800bdbe:	003b      	movs	r3, r7
 800bdc0:	1c02      	adds	r2, r0, #0
 800bdc2:	801a      	strh	r2, [r3, #0]
 800bdc4:	1cbb      	adds	r3, r7, #2
 800bdc6:	1c0a      	adds	r2, r1, #0
 800bdc8:	701a      	strb	r2, [r3, #0]
  HAL_StatusTypeDef  ret = HAL_OK;
 800bdca:	230b      	movs	r3, #11
 800bdcc:	18fb      	adds	r3, r7, r3
 800bdce:	2200      	movs	r2, #0
 800bdd0:	701a      	strb	r2, [r3, #0]
  PCD_EPTypeDef *ep;

  if ((ep_addr & 0x80U) == 0x80U)
 800bdd2:	1cfb      	adds	r3, r7, #3
 800bdd4:	781b      	ldrb	r3, [r3, #0]
 800bdd6:	b25b      	sxtb	r3, r3
 800bdd8:	2b00      	cmp	r3, #0
 800bdda:	da0f      	bge.n	800bdfc <HAL_PCD_EP_Open+0x52>
  {
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 800bddc:	1cfb      	adds	r3, r7, #3
 800bdde:	781b      	ldrb	r3, [r3, #0]
 800bde0:	2207      	movs	r2, #7
 800bde2:	4013      	ands	r3, r2
 800bde4:	1c5a      	adds	r2, r3, #1
 800bde6:	0013      	movs	r3, r2
 800bde8:	009b      	lsls	r3, r3, #2
 800bdea:	189b      	adds	r3, r3, r2
 800bdec:	00db      	lsls	r3, r3, #3
 800bdee:	687a      	ldr	r2, [r7, #4]
 800bdf0:	18d3      	adds	r3, r2, r3
 800bdf2:	60fb      	str	r3, [r7, #12]
    ep->is_in = 1U;
 800bdf4:	68fb      	ldr	r3, [r7, #12]
 800bdf6:	2201      	movs	r2, #1
 800bdf8:	705a      	strb	r2, [r3, #1]
 800bdfa:	e00f      	b.n	800be1c <HAL_PCD_EP_Open+0x72>
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 800bdfc:	1cfb      	adds	r3, r7, #3
 800bdfe:	781b      	ldrb	r3, [r3, #0]
 800be00:	2207      	movs	r2, #7
 800be02:	401a      	ands	r2, r3
 800be04:	0013      	movs	r3, r2
 800be06:	009b      	lsls	r3, r3, #2
 800be08:	189b      	adds	r3, r3, r2
 800be0a:	00db      	lsls	r3, r3, #3
 800be0c:	3369      	adds	r3, #105	; 0x69
 800be0e:	33ff      	adds	r3, #255	; 0xff
 800be10:	687a      	ldr	r2, [r7, #4]
 800be12:	18d3      	adds	r3, r2, r3
 800be14:	60fb      	str	r3, [r7, #12]
    ep->is_in = 0U;
 800be16:	68fb      	ldr	r3, [r7, #12]
 800be18:	2200      	movs	r2, #0
 800be1a:	705a      	strb	r2, [r3, #1]
  }

  ep->num = ep_addr & EP_ADDR_MSK;
 800be1c:	1cfb      	adds	r3, r7, #3
 800be1e:	781b      	ldrb	r3, [r3, #0]
 800be20:	2207      	movs	r2, #7
 800be22:	4013      	ands	r3, r2
 800be24:	b2da      	uxtb	r2, r3
 800be26:	68fb      	ldr	r3, [r7, #12]
 800be28:	701a      	strb	r2, [r3, #0]
  ep->maxpacket = ep_mps;
 800be2a:	003b      	movs	r3, r7
 800be2c:	881a      	ldrh	r2, [r3, #0]
 800be2e:	68fb      	ldr	r3, [r7, #12]
 800be30:	611a      	str	r2, [r3, #16]
  ep->type = ep_type;
 800be32:	68fb      	ldr	r3, [r7, #12]
 800be34:	1cba      	adds	r2, r7, #2
 800be36:	7812      	ldrb	r2, [r2, #0]
 800be38:	70da      	strb	r2, [r3, #3]

  if (ep->is_in != 0U)
 800be3a:	68fb      	ldr	r3, [r7, #12]
 800be3c:	785b      	ldrb	r3, [r3, #1]
 800be3e:	2b00      	cmp	r3, #0
 800be40:	d004      	beq.n	800be4c <HAL_PCD_EP_Open+0xa2>
  {
    /* Assign a Tx FIFO */
    ep->tx_fifo_num = ep->num;
 800be42:	68fb      	ldr	r3, [r7, #12]
 800be44:	781b      	ldrb	r3, [r3, #0]
 800be46:	b29a      	uxth	r2, r3
 800be48:	68fb      	ldr	r3, [r7, #12]
 800be4a:	81da      	strh	r2, [r3, #14]
  }
  /* Set initial data PID. */
  if (ep_type == EP_TYPE_BULK)
 800be4c:	1cbb      	adds	r3, r7, #2
 800be4e:	781b      	ldrb	r3, [r3, #0]
 800be50:	2b02      	cmp	r3, #2
 800be52:	d102      	bne.n	800be5a <HAL_PCD_EP_Open+0xb0>
  {
    ep->data_pid_start = 0U;
 800be54:	68fb      	ldr	r3, [r7, #12]
 800be56:	2200      	movs	r2, #0
 800be58:	711a      	strb	r2, [r3, #4]
  }

  __HAL_LOCK(hpcd);
 800be5a:	687a      	ldr	r2, [r7, #4]
 800be5c:	23aa      	movs	r3, #170	; 0xaa
 800be5e:	009b      	lsls	r3, r3, #2
 800be60:	5cd3      	ldrb	r3, [r2, r3]
 800be62:	2b01      	cmp	r3, #1
 800be64:	d101      	bne.n	800be6a <HAL_PCD_EP_Open+0xc0>
 800be66:	2302      	movs	r3, #2
 800be68:	e013      	b.n	800be92 <HAL_PCD_EP_Open+0xe8>
 800be6a:	687a      	ldr	r2, [r7, #4]
 800be6c:	23aa      	movs	r3, #170	; 0xaa
 800be6e:	009b      	lsls	r3, r3, #2
 800be70:	2101      	movs	r1, #1
 800be72:	54d1      	strb	r1, [r2, r3]
  (void)USB_ActivateEndpoint(hpcd->Instance, ep);
 800be74:	687b      	ldr	r3, [r7, #4]
 800be76:	681b      	ldr	r3, [r3, #0]
 800be78:	68fa      	ldr	r2, [r7, #12]
 800be7a:	0011      	movs	r1, r2
 800be7c:	0018      	movs	r0, r3
 800be7e:	f003 fdf1 	bl	800fa64 <USB_ActivateEndpoint>
  __HAL_UNLOCK(hpcd);
 800be82:	687a      	ldr	r2, [r7, #4]
 800be84:	23aa      	movs	r3, #170	; 0xaa
 800be86:	009b      	lsls	r3, r3, #2
 800be88:	2100      	movs	r1, #0
 800be8a:	54d1      	strb	r1, [r2, r3]

  return ret;
 800be8c:	230b      	movs	r3, #11
 800be8e:	18fb      	adds	r3, r7, r3
 800be90:	781b      	ldrb	r3, [r3, #0]
}
 800be92:	0018      	movs	r0, r3
 800be94:	46bd      	mov	sp, r7
 800be96:	b005      	add	sp, #20
 800be98:	bd90      	pop	{r4, r7, pc}

0800be9a <HAL_PCD_EP_Close>:
  * @param  hpcd PCD handle
  * @param  ep_addr endpoint address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Close(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
 800be9a:	b580      	push	{r7, lr}
 800be9c:	b084      	sub	sp, #16
 800be9e:	af00      	add	r7, sp, #0
 800bea0:	6078      	str	r0, [r7, #4]
 800bea2:	000a      	movs	r2, r1
 800bea4:	1cfb      	adds	r3, r7, #3
 800bea6:	701a      	strb	r2, [r3, #0]
  PCD_EPTypeDef *ep;

  if ((ep_addr & 0x80U) == 0x80U)
 800bea8:	1cfb      	adds	r3, r7, #3
 800beaa:	781b      	ldrb	r3, [r3, #0]
 800beac:	b25b      	sxtb	r3, r3
 800beae:	2b00      	cmp	r3, #0
 800beb0:	da0f      	bge.n	800bed2 <HAL_PCD_EP_Close+0x38>
  {
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 800beb2:	1cfb      	adds	r3, r7, #3
 800beb4:	781b      	ldrb	r3, [r3, #0]
 800beb6:	2207      	movs	r2, #7
 800beb8:	4013      	ands	r3, r2
 800beba:	1c5a      	adds	r2, r3, #1
 800bebc:	0013      	movs	r3, r2
 800bebe:	009b      	lsls	r3, r3, #2
 800bec0:	189b      	adds	r3, r3, r2
 800bec2:	00db      	lsls	r3, r3, #3
 800bec4:	687a      	ldr	r2, [r7, #4]
 800bec6:	18d3      	adds	r3, r2, r3
 800bec8:	60fb      	str	r3, [r7, #12]
    ep->is_in = 1U;
 800beca:	68fb      	ldr	r3, [r7, #12]
 800becc:	2201      	movs	r2, #1
 800bece:	705a      	strb	r2, [r3, #1]
 800bed0:	e00f      	b.n	800bef2 <HAL_PCD_EP_Close+0x58>
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 800bed2:	1cfb      	adds	r3, r7, #3
 800bed4:	781b      	ldrb	r3, [r3, #0]
 800bed6:	2207      	movs	r2, #7
 800bed8:	401a      	ands	r2, r3
 800beda:	0013      	movs	r3, r2
 800bedc:	009b      	lsls	r3, r3, #2
 800bede:	189b      	adds	r3, r3, r2
 800bee0:	00db      	lsls	r3, r3, #3
 800bee2:	3369      	adds	r3, #105	; 0x69
 800bee4:	33ff      	adds	r3, #255	; 0xff
 800bee6:	687a      	ldr	r2, [r7, #4]
 800bee8:	18d3      	adds	r3, r2, r3
 800beea:	60fb      	str	r3, [r7, #12]
    ep->is_in = 0U;
 800beec:	68fb      	ldr	r3, [r7, #12]
 800beee:	2200      	movs	r2, #0
 800bef0:	705a      	strb	r2, [r3, #1]
  }
  ep->num   = ep_addr & EP_ADDR_MSK;
 800bef2:	1cfb      	adds	r3, r7, #3
 800bef4:	781b      	ldrb	r3, [r3, #0]
 800bef6:	2207      	movs	r2, #7
 800bef8:	4013      	ands	r3, r2
 800befa:	b2da      	uxtb	r2, r3
 800befc:	68fb      	ldr	r3, [r7, #12]
 800befe:	701a      	strb	r2, [r3, #0]

  __HAL_LOCK(hpcd);
 800bf00:	687a      	ldr	r2, [r7, #4]
 800bf02:	23aa      	movs	r3, #170	; 0xaa
 800bf04:	009b      	lsls	r3, r3, #2
 800bf06:	5cd3      	ldrb	r3, [r2, r3]
 800bf08:	2b01      	cmp	r3, #1
 800bf0a:	d101      	bne.n	800bf10 <HAL_PCD_EP_Close+0x76>
 800bf0c:	2302      	movs	r3, #2
 800bf0e:	e011      	b.n	800bf34 <HAL_PCD_EP_Close+0x9a>
 800bf10:	687a      	ldr	r2, [r7, #4]
 800bf12:	23aa      	movs	r3, #170	; 0xaa
 800bf14:	009b      	lsls	r3, r3, #2
 800bf16:	2101      	movs	r1, #1
 800bf18:	54d1      	strb	r1, [r2, r3]
  (void)USB_DeactivateEndpoint(hpcd->Instance, ep);
 800bf1a:	687b      	ldr	r3, [r7, #4]
 800bf1c:	681b      	ldr	r3, [r3, #0]
 800bf1e:	68fa      	ldr	r2, [r7, #12]
 800bf20:	0011      	movs	r1, r2
 800bf22:	0018      	movs	r0, r3
 800bf24:	f004 f912 	bl	801014c <USB_DeactivateEndpoint>
  __HAL_UNLOCK(hpcd);
 800bf28:	687a      	ldr	r2, [r7, #4]
 800bf2a:	23aa      	movs	r3, #170	; 0xaa
 800bf2c:	009b      	lsls	r3, r3, #2
 800bf2e:	2100      	movs	r1, #0
 800bf30:	54d1      	strb	r1, [r2, r3]
  return HAL_OK;
 800bf32:	2300      	movs	r3, #0
}
 800bf34:	0018      	movs	r0, r3
 800bf36:	46bd      	mov	sp, r7
 800bf38:	b004      	add	sp, #16
 800bf3a:	bd80      	pop	{r7, pc}

0800bf3c <HAL_PCD_EP_Receive>:
  * @param  pBuf pointer to the reception buffer
  * @param  len amount of data to be received
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Receive(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len)
{
 800bf3c:	b580      	push	{r7, lr}
 800bf3e:	b086      	sub	sp, #24
 800bf40:	af00      	add	r7, sp, #0
 800bf42:	60f8      	str	r0, [r7, #12]
 800bf44:	607a      	str	r2, [r7, #4]
 800bf46:	603b      	str	r3, [r7, #0]
 800bf48:	200b      	movs	r0, #11
 800bf4a:	183b      	adds	r3, r7, r0
 800bf4c:	1c0a      	adds	r2, r1, #0
 800bf4e:	701a      	strb	r2, [r3, #0]
  PCD_EPTypeDef *ep;

  ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 800bf50:	0001      	movs	r1, r0
 800bf52:	187b      	adds	r3, r7, r1
 800bf54:	781b      	ldrb	r3, [r3, #0]
 800bf56:	2207      	movs	r2, #7
 800bf58:	401a      	ands	r2, r3
 800bf5a:	0013      	movs	r3, r2
 800bf5c:	009b      	lsls	r3, r3, #2
 800bf5e:	189b      	adds	r3, r3, r2
 800bf60:	00db      	lsls	r3, r3, #3
 800bf62:	3369      	adds	r3, #105	; 0x69
 800bf64:	33ff      	adds	r3, #255	; 0xff
 800bf66:	68fa      	ldr	r2, [r7, #12]
 800bf68:	18d3      	adds	r3, r2, r3
 800bf6a:	617b      	str	r3, [r7, #20]

  /*setup and start the Xfer */
  ep->xfer_buff = pBuf;
 800bf6c:	697b      	ldr	r3, [r7, #20]
 800bf6e:	687a      	ldr	r2, [r7, #4]
 800bf70:	615a      	str	r2, [r3, #20]
  ep->xfer_len = len;
 800bf72:	697b      	ldr	r3, [r7, #20]
 800bf74:	683a      	ldr	r2, [r7, #0]
 800bf76:	619a      	str	r2, [r3, #24]
  ep->xfer_count = 0U;
 800bf78:	697b      	ldr	r3, [r7, #20]
 800bf7a:	2200      	movs	r2, #0
 800bf7c:	61da      	str	r2, [r3, #28]
  ep->is_in = 0U;
 800bf7e:	697b      	ldr	r3, [r7, #20]
 800bf80:	2200      	movs	r2, #0
 800bf82:	705a      	strb	r2, [r3, #1]
  ep->num = ep_addr & EP_ADDR_MSK;
 800bf84:	187b      	adds	r3, r7, r1
 800bf86:	781b      	ldrb	r3, [r3, #0]
 800bf88:	2207      	movs	r2, #7
 800bf8a:	4013      	ands	r3, r2
 800bf8c:	b2da      	uxtb	r2, r3
 800bf8e:	697b      	ldr	r3, [r7, #20]
 800bf90:	701a      	strb	r2, [r3, #0]

  if ((ep_addr & EP_ADDR_MSK) == 0U)
 800bf92:	187b      	adds	r3, r7, r1
 800bf94:	781b      	ldrb	r3, [r3, #0]
 800bf96:	2207      	movs	r2, #7
 800bf98:	4013      	ands	r3, r2
 800bf9a:	d107      	bne.n	800bfac <HAL_PCD_EP_Receive+0x70>
  {
    (void)USB_EP0StartXfer(hpcd->Instance, ep);
 800bf9c:	68fb      	ldr	r3, [r7, #12]
 800bf9e:	681b      	ldr	r3, [r3, #0]
 800bfa0:	697a      	ldr	r2, [r7, #20]
 800bfa2:	0011      	movs	r1, r2
 800bfa4:	0018      	movs	r0, r3
 800bfa6:	f004 fa91 	bl	80104cc <USB_EPStartXfer>
 800bfaa:	e006      	b.n	800bfba <HAL_PCD_EP_Receive+0x7e>
  }
  else
  {
    (void)USB_EPStartXfer(hpcd->Instance, ep);
 800bfac:	68fb      	ldr	r3, [r7, #12]
 800bfae:	681b      	ldr	r3, [r3, #0]
 800bfb0:	697a      	ldr	r2, [r7, #20]
 800bfb2:	0011      	movs	r1, r2
 800bfb4:	0018      	movs	r0, r3
 800bfb6:	f004 fa89 	bl	80104cc <USB_EPStartXfer>
  }

  return HAL_OK;
 800bfba:	2300      	movs	r3, #0
}
 800bfbc:	0018      	movs	r0, r3
 800bfbe:	46bd      	mov	sp, r7
 800bfc0:	b006      	add	sp, #24
 800bfc2:	bd80      	pop	{r7, pc}

0800bfc4 <HAL_PCD_EP_GetRxCount>:
  * @param  hpcd PCD handle
  * @param  ep_addr endpoint address
  * @retval Data Size
  */
uint32_t HAL_PCD_EP_GetRxCount(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
 800bfc4:	b580      	push	{r7, lr}
 800bfc6:	b082      	sub	sp, #8
 800bfc8:	af00      	add	r7, sp, #0
 800bfca:	6078      	str	r0, [r7, #4]
 800bfcc:	000a      	movs	r2, r1
 800bfce:	1cfb      	adds	r3, r7, #3
 800bfd0:	701a      	strb	r2, [r3, #0]
  return hpcd->OUT_ep[ep_addr & EP_ADDR_MSK].xfer_count;
 800bfd2:	1cfb      	adds	r3, r7, #3
 800bfd4:	781b      	ldrb	r3, [r3, #0]
 800bfd6:	2207      	movs	r2, #7
 800bfd8:	401a      	ands	r2, r3
 800bfda:	6878      	ldr	r0, [r7, #4]
 800bfdc:	23c2      	movs	r3, #194	; 0xc2
 800bfde:	0059      	lsls	r1, r3, #1
 800bfe0:	0013      	movs	r3, r2
 800bfe2:	009b      	lsls	r3, r3, #2
 800bfe4:	189b      	adds	r3, r3, r2
 800bfe6:	00db      	lsls	r3, r3, #3
 800bfe8:	18c3      	adds	r3, r0, r3
 800bfea:	185b      	adds	r3, r3, r1
 800bfec:	681b      	ldr	r3, [r3, #0]
}
 800bfee:	0018      	movs	r0, r3
 800bff0:	46bd      	mov	sp, r7
 800bff2:	b002      	add	sp, #8
 800bff4:	bd80      	pop	{r7, pc}

0800bff6 <HAL_PCD_EP_Transmit>:
  * @param  pBuf pointer to the transmission buffer
  * @param  len amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Transmit(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len)
{
 800bff6:	b580      	push	{r7, lr}
 800bff8:	b086      	sub	sp, #24
 800bffa:	af00      	add	r7, sp, #0
 800bffc:	60f8      	str	r0, [r7, #12]
 800bffe:	607a      	str	r2, [r7, #4]
 800c000:	603b      	str	r3, [r7, #0]
 800c002:	200b      	movs	r0, #11
 800c004:	183b      	adds	r3, r7, r0
 800c006:	1c0a      	adds	r2, r1, #0
 800c008:	701a      	strb	r2, [r3, #0]
  PCD_EPTypeDef *ep;

  ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 800c00a:	183b      	adds	r3, r7, r0
 800c00c:	781b      	ldrb	r3, [r3, #0]
 800c00e:	2207      	movs	r2, #7
 800c010:	4013      	ands	r3, r2
 800c012:	1c5a      	adds	r2, r3, #1
 800c014:	0013      	movs	r3, r2
 800c016:	009b      	lsls	r3, r3, #2
 800c018:	189b      	adds	r3, r3, r2
 800c01a:	00db      	lsls	r3, r3, #3
 800c01c:	68fa      	ldr	r2, [r7, #12]
 800c01e:	18d3      	adds	r3, r2, r3
 800c020:	617b      	str	r3, [r7, #20]

  /*setup and start the Xfer */
  ep->xfer_buff = pBuf;
 800c022:	697b      	ldr	r3, [r7, #20]
 800c024:	687a      	ldr	r2, [r7, #4]
 800c026:	615a      	str	r2, [r3, #20]
  ep->xfer_len = len;
 800c028:	697b      	ldr	r3, [r7, #20]
 800c02a:	683a      	ldr	r2, [r7, #0]
 800c02c:	619a      	str	r2, [r3, #24]
  ep->xfer_fill_db = 1U;
 800c02e:	697b      	ldr	r3, [r7, #20]
 800c030:	2224      	movs	r2, #36	; 0x24
 800c032:	2101      	movs	r1, #1
 800c034:	5499      	strb	r1, [r3, r2]
  ep->xfer_len_db = len;
 800c036:	697b      	ldr	r3, [r7, #20]
 800c038:	683a      	ldr	r2, [r7, #0]
 800c03a:	621a      	str	r2, [r3, #32]
  ep->xfer_count = 0U;
 800c03c:	697b      	ldr	r3, [r7, #20]
 800c03e:	2200      	movs	r2, #0
 800c040:	61da      	str	r2, [r3, #28]
  ep->is_in = 1U;
 800c042:	697b      	ldr	r3, [r7, #20]
 800c044:	2201      	movs	r2, #1
 800c046:	705a      	strb	r2, [r3, #1]
  ep->num = ep_addr & EP_ADDR_MSK;
 800c048:	183b      	adds	r3, r7, r0
 800c04a:	781b      	ldrb	r3, [r3, #0]
 800c04c:	2207      	movs	r2, #7
 800c04e:	4013      	ands	r3, r2
 800c050:	b2da      	uxtb	r2, r3
 800c052:	697b      	ldr	r3, [r7, #20]
 800c054:	701a      	strb	r2, [r3, #0]

  if ((ep_addr & EP_ADDR_MSK) == 0U)
 800c056:	183b      	adds	r3, r7, r0
 800c058:	781b      	ldrb	r3, [r3, #0]
 800c05a:	2207      	movs	r2, #7
 800c05c:	4013      	ands	r3, r2
 800c05e:	d107      	bne.n	800c070 <HAL_PCD_EP_Transmit+0x7a>
  {
    (void)USB_EP0StartXfer(hpcd->Instance, ep);
 800c060:	68fb      	ldr	r3, [r7, #12]
 800c062:	681b      	ldr	r3, [r3, #0]
 800c064:	697a      	ldr	r2, [r7, #20]
 800c066:	0011      	movs	r1, r2
 800c068:	0018      	movs	r0, r3
 800c06a:	f004 fa2f 	bl	80104cc <USB_EPStartXfer>
 800c06e:	e006      	b.n	800c07e <HAL_PCD_EP_Transmit+0x88>
  }
  else
  {
    (void)USB_EPStartXfer(hpcd->Instance, ep);
 800c070:	68fb      	ldr	r3, [r7, #12]
 800c072:	681b      	ldr	r3, [r3, #0]
 800c074:	697a      	ldr	r2, [r7, #20]
 800c076:	0011      	movs	r1, r2
 800c078:	0018      	movs	r0, r3
 800c07a:	f004 fa27 	bl	80104cc <USB_EPStartXfer>
  }

  return HAL_OK;
 800c07e:	2300      	movs	r3, #0
}
 800c080:	0018      	movs	r0, r3
 800c082:	46bd      	mov	sp, r7
 800c084:	b006      	add	sp, #24
 800c086:	bd80      	pop	{r7, pc}

0800c088 <HAL_PCD_EP_SetStall>:
  * @param  hpcd PCD handle
  * @param  ep_addr endpoint address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_SetStall(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
 800c088:	b580      	push	{r7, lr}
 800c08a:	b084      	sub	sp, #16
 800c08c:	af00      	add	r7, sp, #0
 800c08e:	6078      	str	r0, [r7, #4]
 800c090:	000a      	movs	r2, r1
 800c092:	1cfb      	adds	r3, r7, #3
 800c094:	701a      	strb	r2, [r3, #0]
  PCD_EPTypeDef *ep;

  if (((uint32_t)ep_addr & EP_ADDR_MSK) > hpcd->Init.dev_endpoints)
 800c096:	1cfb      	adds	r3, r7, #3
 800c098:	781b      	ldrb	r3, [r3, #0]
 800c09a:	2207      	movs	r2, #7
 800c09c:	401a      	ands	r2, r3
 800c09e:	687b      	ldr	r3, [r7, #4]
 800c0a0:	685b      	ldr	r3, [r3, #4]
 800c0a2:	429a      	cmp	r2, r3
 800c0a4:	d901      	bls.n	800c0aa <HAL_PCD_EP_SetStall+0x22>
  {
    return HAL_ERROR;
 800c0a6:	2301      	movs	r3, #1
 800c0a8:	e046      	b.n	800c138 <HAL_PCD_EP_SetStall+0xb0>
  }

  if ((0x80U & ep_addr) == 0x80U)
 800c0aa:	1cfb      	adds	r3, r7, #3
 800c0ac:	781b      	ldrb	r3, [r3, #0]
 800c0ae:	b25b      	sxtb	r3, r3
 800c0b0:	2b00      	cmp	r3, #0
 800c0b2:	da0f      	bge.n	800c0d4 <HAL_PCD_EP_SetStall+0x4c>
  {
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 800c0b4:	1cfb      	adds	r3, r7, #3
 800c0b6:	781b      	ldrb	r3, [r3, #0]
 800c0b8:	2207      	movs	r2, #7
 800c0ba:	4013      	ands	r3, r2
 800c0bc:	1c5a      	adds	r2, r3, #1
 800c0be:	0013      	movs	r3, r2
 800c0c0:	009b      	lsls	r3, r3, #2
 800c0c2:	189b      	adds	r3, r3, r2
 800c0c4:	00db      	lsls	r3, r3, #3
 800c0c6:	687a      	ldr	r2, [r7, #4]
 800c0c8:	18d3      	adds	r3, r2, r3
 800c0ca:	60fb      	str	r3, [r7, #12]
    ep->is_in = 1U;
 800c0cc:	68fb      	ldr	r3, [r7, #12]
 800c0ce:	2201      	movs	r2, #1
 800c0d0:	705a      	strb	r2, [r3, #1]
 800c0d2:	e00d      	b.n	800c0f0 <HAL_PCD_EP_SetStall+0x68>
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr];
 800c0d4:	1cfb      	adds	r3, r7, #3
 800c0d6:	781a      	ldrb	r2, [r3, #0]
 800c0d8:	0013      	movs	r3, r2
 800c0da:	009b      	lsls	r3, r3, #2
 800c0dc:	189b      	adds	r3, r3, r2
 800c0de:	00db      	lsls	r3, r3, #3
 800c0e0:	3369      	adds	r3, #105	; 0x69
 800c0e2:	33ff      	adds	r3, #255	; 0xff
 800c0e4:	687a      	ldr	r2, [r7, #4]
 800c0e6:	18d3      	adds	r3, r2, r3
 800c0e8:	60fb      	str	r3, [r7, #12]
    ep->is_in = 0U;
 800c0ea:	68fb      	ldr	r3, [r7, #12]
 800c0ec:	2200      	movs	r2, #0
 800c0ee:	705a      	strb	r2, [r3, #1]
  }

  ep->is_stall = 1U;
 800c0f0:	68fb      	ldr	r3, [r7, #12]
 800c0f2:	2201      	movs	r2, #1
 800c0f4:	709a      	strb	r2, [r3, #2]
  ep->num = ep_addr & EP_ADDR_MSK;
 800c0f6:	1cfb      	adds	r3, r7, #3
 800c0f8:	781b      	ldrb	r3, [r3, #0]
 800c0fa:	2207      	movs	r2, #7
 800c0fc:	4013      	ands	r3, r2
 800c0fe:	b2da      	uxtb	r2, r3
 800c100:	68fb      	ldr	r3, [r7, #12]
 800c102:	701a      	strb	r2, [r3, #0]

  __HAL_LOCK(hpcd);
 800c104:	687a      	ldr	r2, [r7, #4]
 800c106:	23aa      	movs	r3, #170	; 0xaa
 800c108:	009b      	lsls	r3, r3, #2
 800c10a:	5cd3      	ldrb	r3, [r2, r3]
 800c10c:	2b01      	cmp	r3, #1
 800c10e:	d101      	bne.n	800c114 <HAL_PCD_EP_SetStall+0x8c>
 800c110:	2302      	movs	r3, #2
 800c112:	e011      	b.n	800c138 <HAL_PCD_EP_SetStall+0xb0>
 800c114:	687a      	ldr	r2, [r7, #4]
 800c116:	23aa      	movs	r3, #170	; 0xaa
 800c118:	009b      	lsls	r3, r3, #2
 800c11a:	2101      	movs	r1, #1
 800c11c:	54d1      	strb	r1, [r2, r3]

  (void)USB_EPSetStall(hpcd->Instance, ep);
 800c11e:	687b      	ldr	r3, [r7, #4]
 800c120:	681b      	ldr	r3, [r3, #0]
 800c122:	68fa      	ldr	r2, [r7, #12]
 800c124:	0011      	movs	r1, r2
 800c126:	0018      	movs	r0, r3
 800c128:	f005 fa8a 	bl	8011640 <USB_EPSetStall>

  __HAL_UNLOCK(hpcd);
 800c12c:	687a      	ldr	r2, [r7, #4]
 800c12e:	23aa      	movs	r3, #170	; 0xaa
 800c130:	009b      	lsls	r3, r3, #2
 800c132:	2100      	movs	r1, #0
 800c134:	54d1      	strb	r1, [r2, r3]

  return HAL_OK;
 800c136:	2300      	movs	r3, #0
}
 800c138:	0018      	movs	r0, r3
 800c13a:	46bd      	mov	sp, r7
 800c13c:	b004      	add	sp, #16
 800c13e:	bd80      	pop	{r7, pc}

0800c140 <HAL_PCD_EP_ClrStall>:
  * @param  hpcd PCD handle
  * @param  ep_addr endpoint address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_ClrStall(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
 800c140:	b580      	push	{r7, lr}
 800c142:	b084      	sub	sp, #16
 800c144:	af00      	add	r7, sp, #0
 800c146:	6078      	str	r0, [r7, #4]
 800c148:	000a      	movs	r2, r1
 800c14a:	1cfb      	adds	r3, r7, #3
 800c14c:	701a      	strb	r2, [r3, #0]
  PCD_EPTypeDef *ep;

  if (((uint32_t)ep_addr & 0x0FU) > hpcd->Init.dev_endpoints)
 800c14e:	1cfb      	adds	r3, r7, #3
 800c150:	781b      	ldrb	r3, [r3, #0]
 800c152:	220f      	movs	r2, #15
 800c154:	401a      	ands	r2, r3
 800c156:	687b      	ldr	r3, [r7, #4]
 800c158:	685b      	ldr	r3, [r3, #4]
 800c15a:	429a      	cmp	r2, r3
 800c15c:	d901      	bls.n	800c162 <HAL_PCD_EP_ClrStall+0x22>
  {
    return HAL_ERROR;
 800c15e:	2301      	movs	r3, #1
 800c160:	e048      	b.n	800c1f4 <HAL_PCD_EP_ClrStall+0xb4>
  }

  if ((0x80U & ep_addr) == 0x80U)
 800c162:	1cfb      	adds	r3, r7, #3
 800c164:	781b      	ldrb	r3, [r3, #0]
 800c166:	b25b      	sxtb	r3, r3
 800c168:	2b00      	cmp	r3, #0
 800c16a:	da0f      	bge.n	800c18c <HAL_PCD_EP_ClrStall+0x4c>
  {
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 800c16c:	1cfb      	adds	r3, r7, #3
 800c16e:	781b      	ldrb	r3, [r3, #0]
 800c170:	2207      	movs	r2, #7
 800c172:	4013      	ands	r3, r2
 800c174:	1c5a      	adds	r2, r3, #1
 800c176:	0013      	movs	r3, r2
 800c178:	009b      	lsls	r3, r3, #2
 800c17a:	189b      	adds	r3, r3, r2
 800c17c:	00db      	lsls	r3, r3, #3
 800c17e:	687a      	ldr	r2, [r7, #4]
 800c180:	18d3      	adds	r3, r2, r3
 800c182:	60fb      	str	r3, [r7, #12]
    ep->is_in = 1U;
 800c184:	68fb      	ldr	r3, [r7, #12]
 800c186:	2201      	movs	r2, #1
 800c188:	705a      	strb	r2, [r3, #1]
 800c18a:	e00f      	b.n	800c1ac <HAL_PCD_EP_ClrStall+0x6c>
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 800c18c:	1cfb      	adds	r3, r7, #3
 800c18e:	781b      	ldrb	r3, [r3, #0]
 800c190:	2207      	movs	r2, #7
 800c192:	401a      	ands	r2, r3
 800c194:	0013      	movs	r3, r2
 800c196:	009b      	lsls	r3, r3, #2
 800c198:	189b      	adds	r3, r3, r2
 800c19a:	00db      	lsls	r3, r3, #3
 800c19c:	3369      	adds	r3, #105	; 0x69
 800c19e:	33ff      	adds	r3, #255	; 0xff
 800c1a0:	687a      	ldr	r2, [r7, #4]
 800c1a2:	18d3      	adds	r3, r2, r3
 800c1a4:	60fb      	str	r3, [r7, #12]
    ep->is_in = 0U;
 800c1a6:	68fb      	ldr	r3, [r7, #12]
 800c1a8:	2200      	movs	r2, #0
 800c1aa:	705a      	strb	r2, [r3, #1]
  }

  ep->is_stall = 0U;
 800c1ac:	68fb      	ldr	r3, [r7, #12]
 800c1ae:	2200      	movs	r2, #0
 800c1b0:	709a      	strb	r2, [r3, #2]
  ep->num = ep_addr & EP_ADDR_MSK;
 800c1b2:	1cfb      	adds	r3, r7, #3
 800c1b4:	781b      	ldrb	r3, [r3, #0]
 800c1b6:	2207      	movs	r2, #7
 800c1b8:	4013      	ands	r3, r2
 800c1ba:	b2da      	uxtb	r2, r3
 800c1bc:	68fb      	ldr	r3, [r7, #12]
 800c1be:	701a      	strb	r2, [r3, #0]

  __HAL_LOCK(hpcd);
 800c1c0:	687a      	ldr	r2, [r7, #4]
 800c1c2:	23aa      	movs	r3, #170	; 0xaa
 800c1c4:	009b      	lsls	r3, r3, #2
 800c1c6:	5cd3      	ldrb	r3, [r2, r3]
 800c1c8:	2b01      	cmp	r3, #1
 800c1ca:	d101      	bne.n	800c1d0 <HAL_PCD_EP_ClrStall+0x90>
 800c1cc:	2302      	movs	r3, #2
 800c1ce:	e011      	b.n	800c1f4 <HAL_PCD_EP_ClrStall+0xb4>
 800c1d0:	687a      	ldr	r2, [r7, #4]
 800c1d2:	23aa      	movs	r3, #170	; 0xaa
 800c1d4:	009b      	lsls	r3, r3, #2
 800c1d6:	2101      	movs	r1, #1
 800c1d8:	54d1      	strb	r1, [r2, r3]
  (void)USB_EPClearStall(hpcd->Instance, ep);
 800c1da:	687b      	ldr	r3, [r7, #4]
 800c1dc:	681b      	ldr	r3, [r3, #0]
 800c1de:	68fa      	ldr	r2, [r7, #12]
 800c1e0:	0011      	movs	r1, r2
 800c1e2:	0018      	movs	r0, r3
 800c1e4:	f005 fa7c 	bl	80116e0 <USB_EPClearStall>
  __HAL_UNLOCK(hpcd);
 800c1e8:	687a      	ldr	r2, [r7, #4]
 800c1ea:	23aa      	movs	r3, #170	; 0xaa
 800c1ec:	009b      	lsls	r3, r3, #2
 800c1ee:	2100      	movs	r1, #0
 800c1f0:	54d1      	strb	r1, [r2, r3]

  return HAL_OK;
 800c1f2:	2300      	movs	r3, #0
}
 800c1f4:	0018      	movs	r0, r3
 800c1f6:	46bd      	mov	sp, r7
 800c1f8:	b004      	add	sp, #16
 800c1fa:	bd80      	pop	{r7, pc}

0800c1fc <PCD_EP_ISR_Handler>:
  * @brief  This function handles PCD Endpoint interrupt request.
  * @param  hpcd PCD handle
  * @retval HAL status
  */
static HAL_StatusTypeDef PCD_EP_ISR_Handler(PCD_HandleTypeDef *hpcd)
{
 800c1fc:	b5b0      	push	{r4, r5, r7, lr}
 800c1fe:	b096      	sub	sp, #88	; 0x58
 800c200:	af00      	add	r7, sp, #0
 800c202:	6078      	str	r0, [r7, #4]
  PCD_EPTypeDef *ep;
  uint16_t count, wIstr, wEPVal, TxByteNbre;
  uint8_t epindex;

  /* stay in loop while pending interrupts */
  while ((hpcd->Instance->ISTR & USB_ISTR_CTR) != 0U)
 800c204:	f000 fbd8 	bl	800c9b8 <PCD_EP_ISR_Handler+0x7bc>
  {
    wIstr = hpcd->Instance->ISTR;
 800c208:	687b      	ldr	r3, [r7, #4]
 800c20a:	681a      	ldr	r2, [r3, #0]
 800c20c:	2056      	movs	r0, #86	; 0x56
 800c20e:	183b      	adds	r3, r7, r0
 800c210:	2144      	movs	r1, #68	; 0x44
 800c212:	5a52      	ldrh	r2, [r2, r1]
 800c214:	801a      	strh	r2, [r3, #0]

    /* extract highest priority endpoint number */
    epindex = (uint8_t)(wIstr & USB_ISTR_EP_ID);
 800c216:	183b      	adds	r3, r7, r0
 800c218:	881b      	ldrh	r3, [r3, #0]
 800c21a:	b2da      	uxtb	r2, r3
 800c21c:	2455      	movs	r4, #85	; 0x55
 800c21e:	193b      	adds	r3, r7, r4
 800c220:	210f      	movs	r1, #15
 800c222:	400a      	ands	r2, r1
 800c224:	701a      	strb	r2, [r3, #0]

    if (epindex == 0U)
 800c226:	193b      	adds	r3, r7, r4
 800c228:	781b      	ldrb	r3, [r3, #0]
 800c22a:	2b00      	cmp	r3, #0
 800c22c:	d000      	beq.n	800c230 <PCD_EP_ISR_Handler+0x34>
 800c22e:	e179      	b.n	800c524 <PCD_EP_ISR_Handler+0x328>
    {
      /* Decode and service control endpoint interrupt */

      /* DIR bit = origin of the interrupt */
      if ((wIstr & USB_ISTR_DIR) == 0U)
 800c230:	183b      	adds	r3, r7, r0
 800c232:	881b      	ldrh	r3, [r3, #0]
 800c234:	2210      	movs	r2, #16
 800c236:	4013      	ands	r3, r2
 800c238:	d154      	bne.n	800c2e4 <PCD_EP_ISR_Handler+0xe8>
      {
        /* DIR = 0 */

        /* DIR = 0 => IN  int */
        /* DIR = 0 implies that (EP_CTR_TX = 1) always */
        PCD_CLEAR_TX_EP_CTR(hpcd->Instance, PCD_ENDP0);
 800c23a:	687b      	ldr	r3, [r7, #4]
 800c23c:	681b      	ldr	r3, [r3, #0]
 800c23e:	881b      	ldrh	r3, [r3, #0]
 800c240:	b29a      	uxth	r2, r3
 800c242:	200e      	movs	r0, #14
 800c244:	183b      	adds	r3, r7, r0
 800c246:	49af      	ldr	r1, [pc, #700]	; (800c504 <PCD_EP_ISR_Handler+0x308>)
 800c248:	400a      	ands	r2, r1
 800c24a:	801a      	strh	r2, [r3, #0]
 800c24c:	687b      	ldr	r3, [r7, #4]
 800c24e:	681b      	ldr	r3, [r3, #0]
 800c250:	183a      	adds	r2, r7, r0
 800c252:	8812      	ldrh	r2, [r2, #0]
 800c254:	49ac      	ldr	r1, [pc, #688]	; (800c508 <PCD_EP_ISR_Handler+0x30c>)
 800c256:	430a      	orrs	r2, r1
 800c258:	b292      	uxth	r2, r2
 800c25a:	801a      	strh	r2, [r3, #0]
        ep = &hpcd->IN_ep[0];
 800c25c:	687b      	ldr	r3, [r7, #4]
 800c25e:	3328      	adds	r3, #40	; 0x28
 800c260:	64fb      	str	r3, [r7, #76]	; 0x4c

        ep->xfer_count = PCD_GET_EP_TX_CNT(hpcd->Instance, ep->num);
 800c262:	687b      	ldr	r3, [r7, #4]
 800c264:	681b      	ldr	r3, [r3, #0]
 800c266:	2250      	movs	r2, #80	; 0x50
 800c268:	5a9b      	ldrh	r3, [r3, r2]
 800c26a:	b29b      	uxth	r3, r3
 800c26c:	001a      	movs	r2, r3
 800c26e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800c270:	781b      	ldrb	r3, [r3, #0]
 800c272:	00db      	lsls	r3, r3, #3
 800c274:	18d2      	adds	r2, r2, r3
 800c276:	687b      	ldr	r3, [r7, #4]
 800c278:	681b      	ldr	r3, [r3, #0]
 800c27a:	18d3      	adds	r3, r2, r3
 800c27c:	4aa3      	ldr	r2, [pc, #652]	; (800c50c <PCD_EP_ISR_Handler+0x310>)
 800c27e:	4694      	mov	ip, r2
 800c280:	4463      	add	r3, ip
 800c282:	881b      	ldrh	r3, [r3, #0]
 800c284:	059b      	lsls	r3, r3, #22
 800c286:	0d9a      	lsrs	r2, r3, #22
 800c288:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800c28a:	61da      	str	r2, [r3, #28]
        ep->xfer_buff += ep->xfer_count;
 800c28c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800c28e:	695a      	ldr	r2, [r3, #20]
 800c290:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800c292:	69db      	ldr	r3, [r3, #28]
 800c294:	18d2      	adds	r2, r2, r3
 800c296:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800c298:	615a      	str	r2, [r3, #20]

        /* TX COMPLETE */
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
        hpcd->DataInStageCallback(hpcd, 0U);
#else
        HAL_PCD_DataInStageCallback(hpcd, 0U);
 800c29a:	687b      	ldr	r3, [r7, #4]
 800c29c:	2100      	movs	r1, #0
 800c29e:	0018      	movs	r0, r3
 800c2a0:	f008 fb84 	bl	80149ac <HAL_PCD_DataInStageCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */

        if ((hpcd->USB_Address > 0U) && (ep->xfer_len == 0U))
 800c2a4:	687b      	ldr	r3, [r7, #4]
 800c2a6:	2224      	movs	r2, #36	; 0x24
 800c2a8:	5c9b      	ldrb	r3, [r3, r2]
 800c2aa:	b2db      	uxtb	r3, r3
 800c2ac:	2b00      	cmp	r3, #0
 800c2ae:	d101      	bne.n	800c2b4 <PCD_EP_ISR_Handler+0xb8>
 800c2b0:	f000 fb82 	bl	800c9b8 <PCD_EP_ISR_Handler+0x7bc>
 800c2b4:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800c2b6:	699b      	ldr	r3, [r3, #24]
 800c2b8:	2b00      	cmp	r3, #0
 800c2ba:	d001      	beq.n	800c2c0 <PCD_EP_ISR_Handler+0xc4>
 800c2bc:	f000 fb7c 	bl	800c9b8 <PCD_EP_ISR_Handler+0x7bc>
        {
          hpcd->Instance->DADDR = ((uint16_t)hpcd->USB_Address | USB_DADDR_EF);
 800c2c0:	687b      	ldr	r3, [r7, #4]
 800c2c2:	2224      	movs	r2, #36	; 0x24
 800c2c4:	5c9b      	ldrb	r3, [r3, r2]
 800c2c6:	b2db      	uxtb	r3, r3
 800c2c8:	2280      	movs	r2, #128	; 0x80
 800c2ca:	4252      	negs	r2, r2
 800c2cc:	4313      	orrs	r3, r2
 800c2ce:	b2da      	uxtb	r2, r3
 800c2d0:	687b      	ldr	r3, [r7, #4]
 800c2d2:	681b      	ldr	r3, [r3, #0]
 800c2d4:	b291      	uxth	r1, r2
 800c2d6:	224c      	movs	r2, #76	; 0x4c
 800c2d8:	5299      	strh	r1, [r3, r2]
          hpcd->USB_Address = 0U;
 800c2da:	687b      	ldr	r3, [r7, #4]
 800c2dc:	2224      	movs	r2, #36	; 0x24
 800c2de:	2100      	movs	r1, #0
 800c2e0:	5499      	strb	r1, [r3, r2]
 800c2e2:	e369      	b.n	800c9b8 <PCD_EP_ISR_Handler+0x7bc>
      {
        /* DIR = 1 */

        /* DIR = 1 & CTR_RX => SETUP or OUT int */
        /* DIR = 1 & (CTR_TX | CTR_RX) => 2 int pending */
        ep = &hpcd->OUT_ep[0];
 800c2e4:	687b      	ldr	r3, [r7, #4]
 800c2e6:	3369      	adds	r3, #105	; 0x69
 800c2e8:	33ff      	adds	r3, #255	; 0xff
 800c2ea:	64fb      	str	r3, [r7, #76]	; 0x4c
        wEPVal = PCD_GET_ENDPOINT(hpcd->Instance, PCD_ENDP0);
 800c2ec:	687b      	ldr	r3, [r7, #4]
 800c2ee:	681a      	ldr	r2, [r3, #0]
 800c2f0:	2152      	movs	r1, #82	; 0x52
 800c2f2:	187b      	adds	r3, r7, r1
 800c2f4:	8812      	ldrh	r2, [r2, #0]
 800c2f6:	801a      	strh	r2, [r3, #0]

        if ((wEPVal & USB_EP_SETUP) != 0U)
 800c2f8:	187b      	adds	r3, r7, r1
 800c2fa:	881a      	ldrh	r2, [r3, #0]
 800c2fc:	2380      	movs	r3, #128	; 0x80
 800c2fe:	011b      	lsls	r3, r3, #4
 800c300:	4013      	ands	r3, r2
 800c302:	d037      	beq.n	800c374 <PCD_EP_ISR_Handler+0x178>
        {
          /* Get SETUP Packet */
          ep->xfer_count = PCD_GET_EP_RX_CNT(hpcd->Instance, ep->num);
 800c304:	687b      	ldr	r3, [r7, #4]
 800c306:	681b      	ldr	r3, [r3, #0]
 800c308:	2250      	movs	r2, #80	; 0x50
 800c30a:	5a9b      	ldrh	r3, [r3, r2]
 800c30c:	b29b      	uxth	r3, r3
 800c30e:	001a      	movs	r2, r3
 800c310:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800c312:	781b      	ldrb	r3, [r3, #0]
 800c314:	00db      	lsls	r3, r3, #3
 800c316:	18d2      	adds	r2, r2, r3
 800c318:	687b      	ldr	r3, [r7, #4]
 800c31a:	681b      	ldr	r3, [r3, #0]
 800c31c:	18d3      	adds	r3, r2, r3
 800c31e:	4a7c      	ldr	r2, [pc, #496]	; (800c510 <PCD_EP_ISR_Handler+0x314>)
 800c320:	4694      	mov	ip, r2
 800c322:	4463      	add	r3, ip
 800c324:	881b      	ldrh	r3, [r3, #0]
 800c326:	059b      	lsls	r3, r3, #22
 800c328:	0d9a      	lsrs	r2, r3, #22
 800c32a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800c32c:	61da      	str	r2, [r3, #28]

          USB_ReadPMA(hpcd->Instance, (uint8_t *)hpcd->Setup,
 800c32e:	687b      	ldr	r3, [r7, #4]
 800c330:	6818      	ldr	r0, [r3, #0]
 800c332:	687b      	ldr	r3, [r7, #4]
 800c334:	22ac      	movs	r2, #172	; 0xac
 800c336:	0092      	lsls	r2, r2, #2
 800c338:	1899      	adds	r1, r3, r2
 800c33a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800c33c:	88da      	ldrh	r2, [r3, #6]
                      ep->pmaadress, (uint16_t)ep->xfer_count);
 800c33e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800c340:	69db      	ldr	r3, [r3, #28]
          USB_ReadPMA(hpcd->Instance, (uint8_t *)hpcd->Setup,
 800c342:	b29b      	uxth	r3, r3
 800c344:	f005 fafa 	bl	801193c <USB_ReadPMA>

          /* SETUP bit kept frozen while CTR_RX = 1 */
          PCD_CLEAR_RX_EP_CTR(hpcd->Instance, PCD_ENDP0);
 800c348:	687b      	ldr	r3, [r7, #4]
 800c34a:	681b      	ldr	r3, [r3, #0]
 800c34c:	881b      	ldrh	r3, [r3, #0]
 800c34e:	b29a      	uxth	r2, r3
 800c350:	2010      	movs	r0, #16
 800c352:	183b      	adds	r3, r7, r0
 800c354:	496f      	ldr	r1, [pc, #444]	; (800c514 <PCD_EP_ISR_Handler+0x318>)
 800c356:	400a      	ands	r2, r1
 800c358:	801a      	strh	r2, [r3, #0]
 800c35a:	687b      	ldr	r3, [r7, #4]
 800c35c:	681b      	ldr	r3, [r3, #0]
 800c35e:	183a      	adds	r2, r7, r0
 800c360:	8812      	ldrh	r2, [r2, #0]
 800c362:	2180      	movs	r1, #128	; 0x80
 800c364:	430a      	orrs	r2, r1
 800c366:	b292      	uxth	r2, r2
 800c368:	801a      	strh	r2, [r3, #0]

          /* Process SETUP Packet*/
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
          hpcd->SetupStageCallback(hpcd);
#else
          HAL_PCD_SetupStageCallback(hpcd);
 800c36a:	687b      	ldr	r3, [r7, #4]
 800c36c:	0018      	movs	r0, r3
 800c36e:	f008 fae7 	bl	8014940 <HAL_PCD_SetupStageCallback>
 800c372:	e321      	b.n	800c9b8 <PCD_EP_ISR_Handler+0x7bc>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
        }
        else if ((wEPVal & USB_EP_CTR_RX) != 0U)
 800c374:	2352      	movs	r3, #82	; 0x52
 800c376:	18fb      	adds	r3, r7, r3
 800c378:	2200      	movs	r2, #0
 800c37a:	5e9b      	ldrsh	r3, [r3, r2]
 800c37c:	2b00      	cmp	r3, #0
 800c37e:	db00      	blt.n	800c382 <PCD_EP_ISR_Handler+0x186>
 800c380:	e31a      	b.n	800c9b8 <PCD_EP_ISR_Handler+0x7bc>
        {
          PCD_CLEAR_RX_EP_CTR(hpcd->Instance, PCD_ENDP0);
 800c382:	687b      	ldr	r3, [r7, #4]
 800c384:	681b      	ldr	r3, [r3, #0]
 800c386:	881b      	ldrh	r3, [r3, #0]
 800c388:	b29a      	uxth	r2, r3
 800c38a:	201e      	movs	r0, #30
 800c38c:	183b      	adds	r3, r7, r0
 800c38e:	4961      	ldr	r1, [pc, #388]	; (800c514 <PCD_EP_ISR_Handler+0x318>)
 800c390:	400a      	ands	r2, r1
 800c392:	801a      	strh	r2, [r3, #0]
 800c394:	687b      	ldr	r3, [r7, #4]
 800c396:	681b      	ldr	r3, [r3, #0]
 800c398:	183a      	adds	r2, r7, r0
 800c39a:	8812      	ldrh	r2, [r2, #0]
 800c39c:	2180      	movs	r1, #128	; 0x80
 800c39e:	430a      	orrs	r2, r1
 800c3a0:	b292      	uxth	r2, r2
 800c3a2:	801a      	strh	r2, [r3, #0]

          /* Get Control Data OUT Packet */
          ep->xfer_count = PCD_GET_EP_RX_CNT(hpcd->Instance, ep->num);
 800c3a4:	687b      	ldr	r3, [r7, #4]
 800c3a6:	681b      	ldr	r3, [r3, #0]
 800c3a8:	2250      	movs	r2, #80	; 0x50
 800c3aa:	5a9b      	ldrh	r3, [r3, r2]
 800c3ac:	b29b      	uxth	r3, r3
 800c3ae:	001a      	movs	r2, r3
 800c3b0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800c3b2:	781b      	ldrb	r3, [r3, #0]
 800c3b4:	00db      	lsls	r3, r3, #3
 800c3b6:	18d2      	adds	r2, r2, r3
 800c3b8:	687b      	ldr	r3, [r7, #4]
 800c3ba:	681b      	ldr	r3, [r3, #0]
 800c3bc:	18d3      	adds	r3, r2, r3
 800c3be:	4a54      	ldr	r2, [pc, #336]	; (800c510 <PCD_EP_ISR_Handler+0x314>)
 800c3c0:	4694      	mov	ip, r2
 800c3c2:	4463      	add	r3, ip
 800c3c4:	881b      	ldrh	r3, [r3, #0]
 800c3c6:	059b      	lsls	r3, r3, #22
 800c3c8:	0d9a      	lsrs	r2, r3, #22
 800c3ca:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800c3cc:	61da      	str	r2, [r3, #28]

          if ((ep->xfer_count != 0U) && (ep->xfer_buff != 0U))
 800c3ce:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800c3d0:	69db      	ldr	r3, [r3, #28]
 800c3d2:	2b00      	cmp	r3, #0
 800c3d4:	d01a      	beq.n	800c40c <PCD_EP_ISR_Handler+0x210>
 800c3d6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800c3d8:	695b      	ldr	r3, [r3, #20]
 800c3da:	2b00      	cmp	r3, #0
 800c3dc:	d016      	beq.n	800c40c <PCD_EP_ISR_Handler+0x210>
          {
            USB_ReadPMA(hpcd->Instance, ep->xfer_buff,
 800c3de:	687b      	ldr	r3, [r7, #4]
 800c3e0:	6818      	ldr	r0, [r3, #0]
 800c3e2:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800c3e4:	6959      	ldr	r1, [r3, #20]
 800c3e6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800c3e8:	88da      	ldrh	r2, [r3, #6]
                        ep->pmaadress, (uint16_t)ep->xfer_count);
 800c3ea:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800c3ec:	69db      	ldr	r3, [r3, #28]
            USB_ReadPMA(hpcd->Instance, ep->xfer_buff,
 800c3ee:	b29b      	uxth	r3, r3
 800c3f0:	f005 faa4 	bl	801193c <USB_ReadPMA>

            ep->xfer_buff += ep->xfer_count;
 800c3f4:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800c3f6:	695a      	ldr	r2, [r3, #20]
 800c3f8:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800c3fa:	69db      	ldr	r3, [r3, #28]
 800c3fc:	18d2      	adds	r2, r2, r3
 800c3fe:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800c400:	615a      	str	r2, [r3, #20]

            /* Process Control Data OUT Packet */
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
            hpcd->DataOutStageCallback(hpcd, 0U);
#else
            HAL_PCD_DataOutStageCallback(hpcd, 0U);
 800c402:	687b      	ldr	r3, [r7, #4]
 800c404:	2100      	movs	r1, #0
 800c406:	0018      	movs	r0, r3
 800c408:	f008 faaf 	bl	801496a <HAL_PCD_DataOutStageCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
          }

          if ((PCD_GET_ENDPOINT(hpcd->Instance, PCD_ENDP0) & USB_EP_SETUP) == 0U)
 800c40c:	687b      	ldr	r3, [r7, #4]
 800c40e:	681b      	ldr	r3, [r3, #0]
 800c410:	881b      	ldrh	r3, [r3, #0]
 800c412:	b29b      	uxth	r3, r3
 800c414:	001a      	movs	r2, r3
 800c416:	2380      	movs	r3, #128	; 0x80
 800c418:	011b      	lsls	r3, r3, #4
 800c41a:	4013      	ands	r3, r2
 800c41c:	d000      	beq.n	800c420 <PCD_EP_ISR_Handler+0x224>
 800c41e:	e2cb      	b.n	800c9b8 <PCD_EP_ISR_Handler+0x7bc>
          {
            PCD_SET_EP_RX_CNT(hpcd->Instance, PCD_ENDP0, ep->maxpacket);
 800c420:	687b      	ldr	r3, [r7, #4]
 800c422:	681b      	ldr	r3, [r3, #0]
 800c424:	61bb      	str	r3, [r7, #24]
 800c426:	687b      	ldr	r3, [r7, #4]
 800c428:	681b      	ldr	r3, [r3, #0]
 800c42a:	2250      	movs	r2, #80	; 0x50
 800c42c:	5a9b      	ldrh	r3, [r3, r2]
 800c42e:	b29b      	uxth	r3, r3
 800c430:	001a      	movs	r2, r3
 800c432:	69bb      	ldr	r3, [r7, #24]
 800c434:	189b      	adds	r3, r3, r2
 800c436:	61bb      	str	r3, [r7, #24]
 800c438:	69bb      	ldr	r3, [r7, #24]
 800c43a:	4a35      	ldr	r2, [pc, #212]	; (800c510 <PCD_EP_ISR_Handler+0x314>)
 800c43c:	4694      	mov	ip, r2
 800c43e:	4463      	add	r3, ip
 800c440:	617b      	str	r3, [r7, #20]
 800c442:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800c444:	691b      	ldr	r3, [r3, #16]
 800c446:	2b00      	cmp	r3, #0
 800c448:	d110      	bne.n	800c46c <PCD_EP_ISR_Handler+0x270>
 800c44a:	697b      	ldr	r3, [r7, #20]
 800c44c:	881b      	ldrh	r3, [r3, #0]
 800c44e:	b29b      	uxth	r3, r3
 800c450:	4a31      	ldr	r2, [pc, #196]	; (800c518 <PCD_EP_ISR_Handler+0x31c>)
 800c452:	4013      	ands	r3, r2
 800c454:	b29a      	uxth	r2, r3
 800c456:	697b      	ldr	r3, [r7, #20]
 800c458:	801a      	strh	r2, [r3, #0]
 800c45a:	697b      	ldr	r3, [r7, #20]
 800c45c:	881b      	ldrh	r3, [r3, #0]
 800c45e:	b29b      	uxth	r3, r3
 800c460:	4a29      	ldr	r2, [pc, #164]	; (800c508 <PCD_EP_ISR_Handler+0x30c>)
 800c462:	4313      	orrs	r3, r2
 800c464:	b29a      	uxth	r2, r3
 800c466:	697b      	ldr	r3, [r7, #20]
 800c468:	801a      	strh	r2, [r3, #0]
 800c46a:	e02b      	b.n	800c4c4 <PCD_EP_ISR_Handler+0x2c8>
 800c46c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800c46e:	691b      	ldr	r3, [r3, #16]
 800c470:	2b3e      	cmp	r3, #62	; 0x3e
 800c472:	d812      	bhi.n	800c49a <PCD_EP_ISR_Handler+0x29e>
 800c474:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800c476:	691b      	ldr	r3, [r3, #16]
 800c478:	085b      	lsrs	r3, r3, #1
 800c47a:	647b      	str	r3, [r7, #68]	; 0x44
 800c47c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800c47e:	691b      	ldr	r3, [r3, #16]
 800c480:	2201      	movs	r2, #1
 800c482:	4013      	ands	r3, r2
 800c484:	d002      	beq.n	800c48c <PCD_EP_ISR_Handler+0x290>
 800c486:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800c488:	3301      	adds	r3, #1
 800c48a:	647b      	str	r3, [r7, #68]	; 0x44
 800c48c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800c48e:	b29b      	uxth	r3, r3
 800c490:	029b      	lsls	r3, r3, #10
 800c492:	b29a      	uxth	r2, r3
 800c494:	697b      	ldr	r3, [r7, #20]
 800c496:	801a      	strh	r2, [r3, #0]
 800c498:	e014      	b.n	800c4c4 <PCD_EP_ISR_Handler+0x2c8>
 800c49a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800c49c:	691b      	ldr	r3, [r3, #16]
 800c49e:	095b      	lsrs	r3, r3, #5
 800c4a0:	647b      	str	r3, [r7, #68]	; 0x44
 800c4a2:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800c4a4:	691b      	ldr	r3, [r3, #16]
 800c4a6:	221f      	movs	r2, #31
 800c4a8:	4013      	ands	r3, r2
 800c4aa:	d102      	bne.n	800c4b2 <PCD_EP_ISR_Handler+0x2b6>
 800c4ac:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800c4ae:	3b01      	subs	r3, #1
 800c4b0:	647b      	str	r3, [r7, #68]	; 0x44
 800c4b2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800c4b4:	b29b      	uxth	r3, r3
 800c4b6:	029b      	lsls	r3, r3, #10
 800c4b8:	b29b      	uxth	r3, r3
 800c4ba:	4a13      	ldr	r2, [pc, #76]	; (800c508 <PCD_EP_ISR_Handler+0x30c>)
 800c4bc:	4313      	orrs	r3, r2
 800c4be:	b29a      	uxth	r2, r3
 800c4c0:	697b      	ldr	r3, [r7, #20]
 800c4c2:	801a      	strh	r2, [r3, #0]
            PCD_SET_EP_RX_STATUS(hpcd->Instance, PCD_ENDP0, USB_EP_RX_VALID);
 800c4c4:	687b      	ldr	r3, [r7, #4]
 800c4c6:	681b      	ldr	r3, [r3, #0]
 800c4c8:	881b      	ldrh	r3, [r3, #0]
 800c4ca:	b29a      	uxth	r2, r3
 800c4cc:	2012      	movs	r0, #18
 800c4ce:	183b      	adds	r3, r7, r0
 800c4d0:	4912      	ldr	r1, [pc, #72]	; (800c51c <PCD_EP_ISR_Handler+0x320>)
 800c4d2:	400a      	ands	r2, r1
 800c4d4:	801a      	strh	r2, [r3, #0]
 800c4d6:	183b      	adds	r3, r7, r0
 800c4d8:	183a      	adds	r2, r7, r0
 800c4da:	8812      	ldrh	r2, [r2, #0]
 800c4dc:	2180      	movs	r1, #128	; 0x80
 800c4de:	0149      	lsls	r1, r1, #5
 800c4e0:	404a      	eors	r2, r1
 800c4e2:	801a      	strh	r2, [r3, #0]
 800c4e4:	183b      	adds	r3, r7, r0
 800c4e6:	183a      	adds	r2, r7, r0
 800c4e8:	8812      	ldrh	r2, [r2, #0]
 800c4ea:	2180      	movs	r1, #128	; 0x80
 800c4ec:	0189      	lsls	r1, r1, #6
 800c4ee:	404a      	eors	r2, r1
 800c4f0:	801a      	strh	r2, [r3, #0]
 800c4f2:	687b      	ldr	r3, [r7, #4]
 800c4f4:	681b      	ldr	r3, [r3, #0]
 800c4f6:	183a      	adds	r2, r7, r0
 800c4f8:	8812      	ldrh	r2, [r2, #0]
 800c4fa:	4909      	ldr	r1, [pc, #36]	; (800c520 <PCD_EP_ISR_Handler+0x324>)
 800c4fc:	430a      	orrs	r2, r1
 800c4fe:	b292      	uxth	r2, r2
 800c500:	801a      	strh	r2, [r3, #0]
 800c502:	e259      	b.n	800c9b8 <PCD_EP_ISR_Handler+0x7bc>
 800c504:	ffff8f0f 	.word	0xffff8f0f
 800c508:	ffff8000 	.word	0xffff8000
 800c50c:	00000402 	.word	0x00000402
 800c510:	00000406 	.word	0x00000406
 800c514:	00000f8f 	.word	0x00000f8f
 800c518:	ffff83ff 	.word	0xffff83ff
 800c51c:	ffffbf8f 	.word	0xffffbf8f
 800c520:	ffff8080 	.word	0xffff8080
    }
    else
    {
      /* Decode and service non control endpoints interrupt */
      /* process related endpoint register */
      wEPVal = PCD_GET_ENDPOINT(hpcd->Instance, epindex);
 800c524:	687b      	ldr	r3, [r7, #4]
 800c526:	681b      	ldr	r3, [r3, #0]
 800c528:	001a      	movs	r2, r3
 800c52a:	2055      	movs	r0, #85	; 0x55
 800c52c:	183b      	adds	r3, r7, r0
 800c52e:	781b      	ldrb	r3, [r3, #0]
 800c530:	009b      	lsls	r3, r3, #2
 800c532:	18d2      	adds	r2, r2, r3
 800c534:	2152      	movs	r1, #82	; 0x52
 800c536:	187b      	adds	r3, r7, r1
 800c538:	8812      	ldrh	r2, [r2, #0]
 800c53a:	801a      	strh	r2, [r3, #0]

      if ((wEPVal & USB_EP_CTR_RX) != 0U)
 800c53c:	187b      	adds	r3, r7, r1
 800c53e:	2200      	movs	r2, #0
 800c540:	5e9b      	ldrsh	r3, [r3, r2]
 800c542:	2b00      	cmp	r3, #0
 800c544:	db00      	blt.n	800c548 <PCD_EP_ISR_Handler+0x34c>
 800c546:	e0fa      	b.n	800c73e <PCD_EP_ISR_Handler+0x542>
      {
        /* clear int flag */
        PCD_CLEAR_RX_EP_CTR(hpcd->Instance, epindex);
 800c548:	687b      	ldr	r3, [r7, #4]
 800c54a:	681b      	ldr	r3, [r3, #0]
 800c54c:	001a      	movs	r2, r3
 800c54e:	183b      	adds	r3, r7, r0
 800c550:	781b      	ldrb	r3, [r3, #0]
 800c552:	009b      	lsls	r3, r3, #2
 800c554:	18d3      	adds	r3, r2, r3
 800c556:	881b      	ldrh	r3, [r3, #0]
 800c558:	b29a      	uxth	r2, r3
 800c55a:	2450      	movs	r4, #80	; 0x50
 800c55c:	193b      	adds	r3, r7, r4
 800c55e:	49cf      	ldr	r1, [pc, #828]	; (800c89c <PCD_EP_ISR_Handler+0x6a0>)
 800c560:	400a      	ands	r2, r1
 800c562:	801a      	strh	r2, [r3, #0]
 800c564:	687b      	ldr	r3, [r7, #4]
 800c566:	681b      	ldr	r3, [r3, #0]
 800c568:	001a      	movs	r2, r3
 800c56a:	183b      	adds	r3, r7, r0
 800c56c:	781b      	ldrb	r3, [r3, #0]
 800c56e:	009b      	lsls	r3, r3, #2
 800c570:	18d3      	adds	r3, r2, r3
 800c572:	193a      	adds	r2, r7, r4
 800c574:	8812      	ldrh	r2, [r2, #0]
 800c576:	2180      	movs	r1, #128	; 0x80
 800c578:	430a      	orrs	r2, r1
 800c57a:	b292      	uxth	r2, r2
 800c57c:	801a      	strh	r2, [r3, #0]
        ep = &hpcd->OUT_ep[epindex];
 800c57e:	183b      	adds	r3, r7, r0
 800c580:	781a      	ldrb	r2, [r3, #0]
 800c582:	0013      	movs	r3, r2
 800c584:	009b      	lsls	r3, r3, #2
 800c586:	189b      	adds	r3, r3, r2
 800c588:	00db      	lsls	r3, r3, #3
 800c58a:	3369      	adds	r3, #105	; 0x69
 800c58c:	33ff      	adds	r3, #255	; 0xff
 800c58e:	687a      	ldr	r2, [r7, #4]
 800c590:	18d3      	adds	r3, r2, r3
 800c592:	64fb      	str	r3, [r7, #76]	; 0x4c

        /* OUT Single Buffering */
        if (ep->doublebuffer == 0U)
 800c594:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800c596:	7b1b      	ldrb	r3, [r3, #12]
 800c598:	2b00      	cmp	r3, #0
 800c59a:	d125      	bne.n	800c5e8 <PCD_EP_ISR_Handler+0x3ec>
        {
          count = (uint16_t)PCD_GET_EP_RX_CNT(hpcd->Instance, ep->num);
 800c59c:	687b      	ldr	r3, [r7, #4]
 800c59e:	681b      	ldr	r3, [r3, #0]
 800c5a0:	2250      	movs	r2, #80	; 0x50
 800c5a2:	5a9b      	ldrh	r3, [r3, r2]
 800c5a4:	b29b      	uxth	r3, r3
 800c5a6:	001a      	movs	r2, r3
 800c5a8:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800c5aa:	781b      	ldrb	r3, [r3, #0]
 800c5ac:	00db      	lsls	r3, r3, #3
 800c5ae:	18d2      	adds	r2, r2, r3
 800c5b0:	687b      	ldr	r3, [r7, #4]
 800c5b2:	681b      	ldr	r3, [r3, #0]
 800c5b4:	18d3      	adds	r3, r2, r3
 800c5b6:	4aba      	ldr	r2, [pc, #744]	; (800c8a0 <PCD_EP_ISR_Handler+0x6a4>)
 800c5b8:	4694      	mov	ip, r2
 800c5ba:	4463      	add	r3, ip
 800c5bc:	881a      	ldrh	r2, [r3, #0]
 800c5be:	2448      	movs	r4, #72	; 0x48
 800c5c0:	193b      	adds	r3, r7, r4
 800c5c2:	0592      	lsls	r2, r2, #22
 800c5c4:	0d92      	lsrs	r2, r2, #22
 800c5c6:	801a      	strh	r2, [r3, #0]

          if (count != 0U)
 800c5c8:	193b      	adds	r3, r7, r4
 800c5ca:	881b      	ldrh	r3, [r3, #0]
 800c5cc:	2b00      	cmp	r3, #0
 800c5ce:	d100      	bne.n	800c5d2 <PCD_EP_ISR_Handler+0x3d6>
 800c5d0:	e08d      	b.n	800c6ee <PCD_EP_ISR_Handler+0x4f2>
          {
            USB_ReadPMA(hpcd->Instance, ep->xfer_buff, ep->pmaadress, count);
 800c5d2:	687b      	ldr	r3, [r7, #4]
 800c5d4:	6818      	ldr	r0, [r3, #0]
 800c5d6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800c5d8:	6959      	ldr	r1, [r3, #20]
 800c5da:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800c5dc:	88da      	ldrh	r2, [r3, #6]
 800c5de:	193b      	adds	r3, r7, r4
 800c5e0:	881b      	ldrh	r3, [r3, #0]
 800c5e2:	f005 f9ab 	bl	801193c <USB_ReadPMA>
 800c5e6:	e082      	b.n	800c6ee <PCD_EP_ISR_Handler+0x4f2>
          }
        }
        else
        {
          /* manage double buffer bulk out */
          if (ep->type == EP_TYPE_BULK)
 800c5e8:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800c5ea:	78db      	ldrb	r3, [r3, #3]
 800c5ec:	2b02      	cmp	r3, #2
 800c5ee:	d10c      	bne.n	800c60a <PCD_EP_ISR_Handler+0x40e>
          {
            count = HAL_PCD_EP_DB_Receive(hpcd, ep, wEPVal);
 800c5f0:	2348      	movs	r3, #72	; 0x48
 800c5f2:	18fc      	adds	r4, r7, r3
 800c5f4:	2352      	movs	r3, #82	; 0x52
 800c5f6:	18fb      	adds	r3, r7, r3
 800c5f8:	881a      	ldrh	r2, [r3, #0]
 800c5fa:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
 800c5fc:	687b      	ldr	r3, [r7, #4]
 800c5fe:	0018      	movs	r0, r3
 800c600:	f000 f9ee 	bl	800c9e0 <HAL_PCD_EP_DB_Receive>
 800c604:	0003      	movs	r3, r0
 800c606:	8023      	strh	r3, [r4, #0]
 800c608:	e071      	b.n	800c6ee <PCD_EP_ISR_Handler+0x4f2>
          }
          else /* manage double buffer iso out */
          {
            /* free EP OUT Buffer */
            PCD_FreeUserBuffer(hpcd->Instance, ep->num, 0U);
 800c60a:	687b      	ldr	r3, [r7, #4]
 800c60c:	681b      	ldr	r3, [r3, #0]
 800c60e:	001a      	movs	r2, r3
 800c610:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800c612:	781b      	ldrb	r3, [r3, #0]
 800c614:	009b      	lsls	r3, r3, #2
 800c616:	18d3      	adds	r3, r2, r3
 800c618:	881b      	ldrh	r3, [r3, #0]
 800c61a:	b29a      	uxth	r2, r3
 800c61c:	204a      	movs	r0, #74	; 0x4a
 800c61e:	183b      	adds	r3, r7, r0
 800c620:	49a0      	ldr	r1, [pc, #640]	; (800c8a4 <PCD_EP_ISR_Handler+0x6a8>)
 800c622:	400a      	ands	r2, r1
 800c624:	801a      	strh	r2, [r3, #0]
 800c626:	687b      	ldr	r3, [r7, #4]
 800c628:	681b      	ldr	r3, [r3, #0]
 800c62a:	001a      	movs	r2, r3
 800c62c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800c62e:	781b      	ldrb	r3, [r3, #0]
 800c630:	009b      	lsls	r3, r3, #2
 800c632:	18d3      	adds	r3, r2, r3
 800c634:	183a      	adds	r2, r7, r0
 800c636:	8812      	ldrh	r2, [r2, #0]
 800c638:	499b      	ldr	r1, [pc, #620]	; (800c8a8 <PCD_EP_ISR_Handler+0x6ac>)
 800c63a:	430a      	orrs	r2, r1
 800c63c:	b292      	uxth	r2, r2
 800c63e:	801a      	strh	r2, [r3, #0]

            if ((PCD_GET_ENDPOINT(hpcd->Instance, ep->num) & USB_EP_DTOG_RX) != 0U)
 800c640:	687b      	ldr	r3, [r7, #4]
 800c642:	681b      	ldr	r3, [r3, #0]
 800c644:	001a      	movs	r2, r3
 800c646:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800c648:	781b      	ldrb	r3, [r3, #0]
 800c64a:	009b      	lsls	r3, r3, #2
 800c64c:	18d3      	adds	r3, r2, r3
 800c64e:	881b      	ldrh	r3, [r3, #0]
 800c650:	b29b      	uxth	r3, r3
 800c652:	001a      	movs	r2, r3
 800c654:	2380      	movs	r3, #128	; 0x80
 800c656:	01db      	lsls	r3, r3, #7
 800c658:	4013      	ands	r3, r2
 800c65a:	d024      	beq.n	800c6a6 <PCD_EP_ISR_Handler+0x4aa>
            {
              /* read from endpoint BUF0Addr buffer */
              count = (uint16_t)PCD_GET_EP_DBUF0_CNT(hpcd->Instance, ep->num);
 800c65c:	687b      	ldr	r3, [r7, #4]
 800c65e:	681b      	ldr	r3, [r3, #0]
 800c660:	2250      	movs	r2, #80	; 0x50
 800c662:	5a9b      	ldrh	r3, [r3, r2]
 800c664:	b29b      	uxth	r3, r3
 800c666:	001a      	movs	r2, r3
 800c668:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800c66a:	781b      	ldrb	r3, [r3, #0]
 800c66c:	00db      	lsls	r3, r3, #3
 800c66e:	18d2      	adds	r2, r2, r3
 800c670:	687b      	ldr	r3, [r7, #4]
 800c672:	681b      	ldr	r3, [r3, #0]
 800c674:	18d3      	adds	r3, r2, r3
 800c676:	4a8d      	ldr	r2, [pc, #564]	; (800c8ac <PCD_EP_ISR_Handler+0x6b0>)
 800c678:	4694      	mov	ip, r2
 800c67a:	4463      	add	r3, ip
 800c67c:	881a      	ldrh	r2, [r3, #0]
 800c67e:	2448      	movs	r4, #72	; 0x48
 800c680:	193b      	adds	r3, r7, r4
 800c682:	0592      	lsls	r2, r2, #22
 800c684:	0d92      	lsrs	r2, r2, #22
 800c686:	801a      	strh	r2, [r3, #0]

              if (count != 0U)
 800c688:	193b      	adds	r3, r7, r4
 800c68a:	881b      	ldrh	r3, [r3, #0]
 800c68c:	2b00      	cmp	r3, #0
 800c68e:	d02e      	beq.n	800c6ee <PCD_EP_ISR_Handler+0x4f2>
              {
                USB_ReadPMA(hpcd->Instance, ep->xfer_buff, ep->pmaaddr0, count);
 800c690:	687b      	ldr	r3, [r7, #4]
 800c692:	6818      	ldr	r0, [r3, #0]
 800c694:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800c696:	6959      	ldr	r1, [r3, #20]
 800c698:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800c69a:	891a      	ldrh	r2, [r3, #8]
 800c69c:	193b      	adds	r3, r7, r4
 800c69e:	881b      	ldrh	r3, [r3, #0]
 800c6a0:	f005 f94c 	bl	801193c <USB_ReadPMA>
 800c6a4:	e023      	b.n	800c6ee <PCD_EP_ISR_Handler+0x4f2>
              }
            }
            else
            {
              /* read from endpoint BUF1Addr buffer */
              count = (uint16_t)PCD_GET_EP_DBUF1_CNT(hpcd->Instance, ep->num);
 800c6a6:	687b      	ldr	r3, [r7, #4]
 800c6a8:	681b      	ldr	r3, [r3, #0]
 800c6aa:	2250      	movs	r2, #80	; 0x50
 800c6ac:	5a9b      	ldrh	r3, [r3, r2]
 800c6ae:	b29b      	uxth	r3, r3
 800c6b0:	001a      	movs	r2, r3
 800c6b2:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800c6b4:	781b      	ldrb	r3, [r3, #0]
 800c6b6:	00db      	lsls	r3, r3, #3
 800c6b8:	18d2      	adds	r2, r2, r3
 800c6ba:	687b      	ldr	r3, [r7, #4]
 800c6bc:	681b      	ldr	r3, [r3, #0]
 800c6be:	18d3      	adds	r3, r2, r3
 800c6c0:	4a77      	ldr	r2, [pc, #476]	; (800c8a0 <PCD_EP_ISR_Handler+0x6a4>)
 800c6c2:	4694      	mov	ip, r2
 800c6c4:	4463      	add	r3, ip
 800c6c6:	881a      	ldrh	r2, [r3, #0]
 800c6c8:	2448      	movs	r4, #72	; 0x48
 800c6ca:	193b      	adds	r3, r7, r4
 800c6cc:	0592      	lsls	r2, r2, #22
 800c6ce:	0d92      	lsrs	r2, r2, #22
 800c6d0:	801a      	strh	r2, [r3, #0]

              if (count != 0U)
 800c6d2:	193b      	adds	r3, r7, r4
 800c6d4:	881b      	ldrh	r3, [r3, #0]
 800c6d6:	2b00      	cmp	r3, #0
 800c6d8:	d009      	beq.n	800c6ee <PCD_EP_ISR_Handler+0x4f2>
              {
                USB_ReadPMA(hpcd->Instance, ep->xfer_buff, ep->pmaaddr1, count);
 800c6da:	687b      	ldr	r3, [r7, #4]
 800c6dc:	6818      	ldr	r0, [r3, #0]
 800c6de:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800c6e0:	6959      	ldr	r1, [r3, #20]
 800c6e2:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800c6e4:	895a      	ldrh	r2, [r3, #10]
 800c6e6:	193b      	adds	r3, r7, r4
 800c6e8:	881b      	ldrh	r3, [r3, #0]
 800c6ea:	f005 f927 	bl	801193c <USB_ReadPMA>
              }
            }
          }
        }
        /* multi-packet on the NON control OUT endpoint */
        ep->xfer_count += count;
 800c6ee:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800c6f0:	69da      	ldr	r2, [r3, #28]
 800c6f2:	2148      	movs	r1, #72	; 0x48
 800c6f4:	187b      	adds	r3, r7, r1
 800c6f6:	881b      	ldrh	r3, [r3, #0]
 800c6f8:	18d2      	adds	r2, r2, r3
 800c6fa:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800c6fc:	61da      	str	r2, [r3, #28]
        ep->xfer_buff += count;
 800c6fe:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800c700:	695a      	ldr	r2, [r3, #20]
 800c702:	187b      	adds	r3, r7, r1
 800c704:	881b      	ldrh	r3, [r3, #0]
 800c706:	18d2      	adds	r2, r2, r3
 800c708:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800c70a:	615a      	str	r2, [r3, #20]

        if ((ep->xfer_len == 0U) || (count < ep->maxpacket))
 800c70c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800c70e:	699b      	ldr	r3, [r3, #24]
 800c710:	2b00      	cmp	r3, #0
 800c712:	d005      	beq.n	800c720 <PCD_EP_ISR_Handler+0x524>
 800c714:	187b      	adds	r3, r7, r1
 800c716:	881a      	ldrh	r2, [r3, #0]
 800c718:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800c71a:	691b      	ldr	r3, [r3, #16]
 800c71c:	429a      	cmp	r2, r3
 800c71e:	d207      	bcs.n	800c730 <PCD_EP_ISR_Handler+0x534>
        {
          /* RX COMPLETE */
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
          hpcd->DataOutStageCallback(hpcd, ep->num);
#else
          HAL_PCD_DataOutStageCallback(hpcd, ep->num);
 800c720:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800c722:	781a      	ldrb	r2, [r3, #0]
 800c724:	687b      	ldr	r3, [r7, #4]
 800c726:	0011      	movs	r1, r2
 800c728:	0018      	movs	r0, r3
 800c72a:	f008 f91e 	bl	801496a <HAL_PCD_DataOutStageCallback>
 800c72e:	e006      	b.n	800c73e <PCD_EP_ISR_Handler+0x542>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
        }
        else
        {
          (void) USB_EPStartXfer(hpcd->Instance, ep);
 800c730:	687b      	ldr	r3, [r7, #4]
 800c732:	681b      	ldr	r3, [r3, #0]
 800c734:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 800c736:	0011      	movs	r1, r2
 800c738:	0018      	movs	r0, r3
 800c73a:	f003 fec7 	bl	80104cc <USB_EPStartXfer>
        }
      }

      if ((wEPVal & USB_EP_CTR_TX) != 0U)
 800c73e:	2452      	movs	r4, #82	; 0x52
 800c740:	193b      	adds	r3, r7, r4
 800c742:	881b      	ldrh	r3, [r3, #0]
 800c744:	2280      	movs	r2, #128	; 0x80
 800c746:	4013      	ands	r3, r2
 800c748:	d100      	bne.n	800c74c <PCD_EP_ISR_Handler+0x550>
 800c74a:	e135      	b.n	800c9b8 <PCD_EP_ISR_Handler+0x7bc>
      {
        ep = &hpcd->IN_ep[epindex];
 800c74c:	2055      	movs	r0, #85	; 0x55
 800c74e:	183b      	adds	r3, r7, r0
 800c750:	781b      	ldrb	r3, [r3, #0]
 800c752:	1c5a      	adds	r2, r3, #1
 800c754:	0013      	movs	r3, r2
 800c756:	009b      	lsls	r3, r3, #2
 800c758:	189b      	adds	r3, r3, r2
 800c75a:	00db      	lsls	r3, r3, #3
 800c75c:	687a      	ldr	r2, [r7, #4]
 800c75e:	18d3      	adds	r3, r2, r3
 800c760:	64fb      	str	r3, [r7, #76]	; 0x4c

        /* clear int flag */
        PCD_CLEAR_TX_EP_CTR(hpcd->Instance, epindex);
 800c762:	687b      	ldr	r3, [r7, #4]
 800c764:	681b      	ldr	r3, [r3, #0]
 800c766:	001a      	movs	r2, r3
 800c768:	183b      	adds	r3, r7, r0
 800c76a:	781b      	ldrb	r3, [r3, #0]
 800c76c:	009b      	lsls	r3, r3, #2
 800c76e:	18d3      	adds	r3, r2, r3
 800c770:	881b      	ldrh	r3, [r3, #0]
 800c772:	b29a      	uxth	r2, r3
 800c774:	2542      	movs	r5, #66	; 0x42
 800c776:	197b      	adds	r3, r7, r5
 800c778:	494d      	ldr	r1, [pc, #308]	; (800c8b0 <PCD_EP_ISR_Handler+0x6b4>)
 800c77a:	400a      	ands	r2, r1
 800c77c:	801a      	strh	r2, [r3, #0]
 800c77e:	687b      	ldr	r3, [r7, #4]
 800c780:	681b      	ldr	r3, [r3, #0]
 800c782:	001a      	movs	r2, r3
 800c784:	183b      	adds	r3, r7, r0
 800c786:	781b      	ldrb	r3, [r3, #0]
 800c788:	009b      	lsls	r3, r3, #2
 800c78a:	18d3      	adds	r3, r2, r3
 800c78c:	197a      	adds	r2, r7, r5
 800c78e:	8812      	ldrh	r2, [r2, #0]
 800c790:	4948      	ldr	r1, [pc, #288]	; (800c8b4 <PCD_EP_ISR_Handler+0x6b8>)
 800c792:	430a      	orrs	r2, r1
 800c794:	b292      	uxth	r2, r2
 800c796:	801a      	strh	r2, [r3, #0]

        if (ep->type != EP_TYPE_BULK)
 800c798:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800c79a:	78db      	ldrb	r3, [r3, #3]
 800c79c:	2b02      	cmp	r3, #2
 800c79e:	d100      	bne.n	800c7a2 <PCD_EP_ISR_Handler+0x5a6>
 800c7a0:	e0ad      	b.n	800c8fe <PCD_EP_ISR_Handler+0x702>
        {
          ep->xfer_len = 0U;
 800c7a2:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800c7a4:	2200      	movs	r2, #0
 800c7a6:	619a      	str	r2, [r3, #24]

          if ((wEPVal & USB_EP_DTOG_TX) != 0U)
 800c7a8:	193b      	adds	r3, r7, r4
 800c7aa:	881b      	ldrh	r3, [r3, #0]
 800c7ac:	2240      	movs	r2, #64	; 0x40
 800c7ae:	4013      	ands	r3, r2
 800c7b0:	d046      	beq.n	800c840 <PCD_EP_ISR_Handler+0x644>
          {
            PCD_SET_EP_DBUF0_CNT(hpcd->Instance, ep->num, ep->is_in, 0U);
 800c7b2:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800c7b4:	785b      	ldrb	r3, [r3, #1]
 800c7b6:	2b00      	cmp	r3, #0
 800c7b8:	d125      	bne.n	800c806 <PCD_EP_ISR_Handler+0x60a>
 800c7ba:	687b      	ldr	r3, [r7, #4]
 800c7bc:	681b      	ldr	r3, [r3, #0]
 800c7be:	627b      	str	r3, [r7, #36]	; 0x24
 800c7c0:	687b      	ldr	r3, [r7, #4]
 800c7c2:	681b      	ldr	r3, [r3, #0]
 800c7c4:	2250      	movs	r2, #80	; 0x50
 800c7c6:	5a9b      	ldrh	r3, [r3, r2]
 800c7c8:	b29b      	uxth	r3, r3
 800c7ca:	001a      	movs	r2, r3
 800c7cc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c7ce:	189b      	adds	r3, r3, r2
 800c7d0:	627b      	str	r3, [r7, #36]	; 0x24
 800c7d2:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800c7d4:	781b      	ldrb	r3, [r3, #0]
 800c7d6:	00da      	lsls	r2, r3, #3
 800c7d8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c7da:	18d3      	adds	r3, r2, r3
 800c7dc:	4a33      	ldr	r2, [pc, #204]	; (800c8ac <PCD_EP_ISR_Handler+0x6b0>)
 800c7de:	4694      	mov	ip, r2
 800c7e0:	4463      	add	r3, ip
 800c7e2:	623b      	str	r3, [r7, #32]
 800c7e4:	6a3b      	ldr	r3, [r7, #32]
 800c7e6:	881b      	ldrh	r3, [r3, #0]
 800c7e8:	b29b      	uxth	r3, r3
 800c7ea:	4a33      	ldr	r2, [pc, #204]	; (800c8b8 <PCD_EP_ISR_Handler+0x6bc>)
 800c7ec:	4013      	ands	r3, r2
 800c7ee:	b29a      	uxth	r2, r3
 800c7f0:	6a3b      	ldr	r3, [r7, #32]
 800c7f2:	801a      	strh	r2, [r3, #0]
 800c7f4:	6a3b      	ldr	r3, [r7, #32]
 800c7f6:	881b      	ldrh	r3, [r3, #0]
 800c7f8:	b29b      	uxth	r3, r3
 800c7fa:	4a2e      	ldr	r2, [pc, #184]	; (800c8b4 <PCD_EP_ISR_Handler+0x6b8>)
 800c7fc:	4313      	orrs	r3, r2
 800c7fe:	b29a      	uxth	r2, r3
 800c800:	6a3b      	ldr	r3, [r7, #32]
 800c802:	801a      	strh	r2, [r3, #0]
 800c804:	e073      	b.n	800c8ee <PCD_EP_ISR_Handler+0x6f2>
 800c806:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800c808:	785b      	ldrb	r3, [r3, #1]
 800c80a:	2b01      	cmp	r3, #1
 800c80c:	d16f      	bne.n	800c8ee <PCD_EP_ISR_Handler+0x6f2>
 800c80e:	687b      	ldr	r3, [r7, #4]
 800c810:	681b      	ldr	r3, [r3, #0]
 800c812:	62fb      	str	r3, [r7, #44]	; 0x2c
 800c814:	687b      	ldr	r3, [r7, #4]
 800c816:	681b      	ldr	r3, [r3, #0]
 800c818:	2250      	movs	r2, #80	; 0x50
 800c81a:	5a9b      	ldrh	r3, [r3, r2]
 800c81c:	b29b      	uxth	r3, r3
 800c81e:	001a      	movs	r2, r3
 800c820:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c822:	189b      	adds	r3, r3, r2
 800c824:	62fb      	str	r3, [r7, #44]	; 0x2c
 800c826:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800c828:	781b      	ldrb	r3, [r3, #0]
 800c82a:	00da      	lsls	r2, r3, #3
 800c82c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c82e:	18d3      	adds	r3, r2, r3
 800c830:	4a1e      	ldr	r2, [pc, #120]	; (800c8ac <PCD_EP_ISR_Handler+0x6b0>)
 800c832:	4694      	mov	ip, r2
 800c834:	4463      	add	r3, ip
 800c836:	62bb      	str	r3, [r7, #40]	; 0x28
 800c838:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800c83a:	2200      	movs	r2, #0
 800c83c:	801a      	strh	r2, [r3, #0]
 800c83e:	e056      	b.n	800c8ee <PCD_EP_ISR_Handler+0x6f2>
          }
          else
          {
            PCD_SET_EP_DBUF1_CNT(hpcd->Instance, ep->num, ep->is_in, 0U);
 800c840:	687b      	ldr	r3, [r7, #4]
 800c842:	681b      	ldr	r3, [r3, #0]
 800c844:	63fb      	str	r3, [r7, #60]	; 0x3c
 800c846:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800c848:	785b      	ldrb	r3, [r3, #1]
 800c84a:	2b00      	cmp	r3, #0
 800c84c:	d136      	bne.n	800c8bc <PCD_EP_ISR_Handler+0x6c0>
 800c84e:	687b      	ldr	r3, [r7, #4]
 800c850:	681b      	ldr	r3, [r3, #0]
 800c852:	637b      	str	r3, [r7, #52]	; 0x34
 800c854:	687b      	ldr	r3, [r7, #4]
 800c856:	681b      	ldr	r3, [r3, #0]
 800c858:	2250      	movs	r2, #80	; 0x50
 800c85a:	5a9b      	ldrh	r3, [r3, r2]
 800c85c:	b29b      	uxth	r3, r3
 800c85e:	001a      	movs	r2, r3
 800c860:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800c862:	189b      	adds	r3, r3, r2
 800c864:	637b      	str	r3, [r7, #52]	; 0x34
 800c866:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800c868:	781b      	ldrb	r3, [r3, #0]
 800c86a:	00da      	lsls	r2, r3, #3
 800c86c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800c86e:	18d3      	adds	r3, r2, r3
 800c870:	4a0b      	ldr	r2, [pc, #44]	; (800c8a0 <PCD_EP_ISR_Handler+0x6a4>)
 800c872:	4694      	mov	ip, r2
 800c874:	4463      	add	r3, ip
 800c876:	633b      	str	r3, [r7, #48]	; 0x30
 800c878:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800c87a:	881b      	ldrh	r3, [r3, #0]
 800c87c:	b29b      	uxth	r3, r3
 800c87e:	4a0e      	ldr	r2, [pc, #56]	; (800c8b8 <PCD_EP_ISR_Handler+0x6bc>)
 800c880:	4013      	ands	r3, r2
 800c882:	b29a      	uxth	r2, r3
 800c884:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800c886:	801a      	strh	r2, [r3, #0]
 800c888:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800c88a:	881b      	ldrh	r3, [r3, #0]
 800c88c:	b29b      	uxth	r3, r3
 800c88e:	4a09      	ldr	r2, [pc, #36]	; (800c8b4 <PCD_EP_ISR_Handler+0x6b8>)
 800c890:	4313      	orrs	r3, r2
 800c892:	b29a      	uxth	r2, r3
 800c894:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800c896:	801a      	strh	r2, [r3, #0]
 800c898:	e029      	b.n	800c8ee <PCD_EP_ISR_Handler+0x6f2>
 800c89a:	46c0      	nop			; (mov r8, r8)
 800c89c:	00000f8f 	.word	0x00000f8f
 800c8a0:	00000406 	.word	0x00000406
 800c8a4:	ffff8f8f 	.word	0xffff8f8f
 800c8a8:	ffff80c0 	.word	0xffff80c0
 800c8ac:	00000402 	.word	0x00000402
 800c8b0:	ffff8f0f 	.word	0xffff8f0f
 800c8b4:	ffff8000 	.word	0xffff8000
 800c8b8:	ffff83ff 	.word	0xffff83ff
 800c8bc:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800c8be:	785b      	ldrb	r3, [r3, #1]
 800c8c0:	2b01      	cmp	r3, #1
 800c8c2:	d114      	bne.n	800c8ee <PCD_EP_ISR_Handler+0x6f2>
 800c8c4:	687b      	ldr	r3, [r7, #4]
 800c8c6:	681b      	ldr	r3, [r3, #0]
 800c8c8:	2250      	movs	r2, #80	; 0x50
 800c8ca:	5a9b      	ldrh	r3, [r3, r2]
 800c8cc:	b29b      	uxth	r3, r3
 800c8ce:	001a      	movs	r2, r3
 800c8d0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800c8d2:	189b      	adds	r3, r3, r2
 800c8d4:	63fb      	str	r3, [r7, #60]	; 0x3c
 800c8d6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800c8d8:	781b      	ldrb	r3, [r3, #0]
 800c8da:	00da      	lsls	r2, r3, #3
 800c8dc:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800c8de:	18d3      	adds	r3, r2, r3
 800c8e0:	4a3d      	ldr	r2, [pc, #244]	; (800c9d8 <PCD_EP_ISR_Handler+0x7dc>)
 800c8e2:	4694      	mov	ip, r2
 800c8e4:	4463      	add	r3, ip
 800c8e6:	63bb      	str	r3, [r7, #56]	; 0x38
 800c8e8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800c8ea:	2200      	movs	r2, #0
 800c8ec:	801a      	strh	r2, [r3, #0]

          /* TX COMPLETE */
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
          hpcd->DataInStageCallback(hpcd, ep->num);
#else
          HAL_PCD_DataInStageCallback(hpcd, ep->num);
 800c8ee:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800c8f0:	781a      	ldrb	r2, [r3, #0]
 800c8f2:	687b      	ldr	r3, [r7, #4]
 800c8f4:	0011      	movs	r1, r2
 800c8f6:	0018      	movs	r0, r3
 800c8f8:	f008 f858 	bl	80149ac <HAL_PCD_DataInStageCallback>
 800c8fc:	e05c      	b.n	800c9b8 <PCD_EP_ISR_Handler+0x7bc>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
        }
        else
        /* Manage Bulk Single Buffer Transaction */
        if ((ep->type == EP_TYPE_BULK) && ((wEPVal & USB_EP_KIND) == 0U))
 800c8fe:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800c900:	78db      	ldrb	r3, [r3, #3]
 800c902:	2b02      	cmp	r3, #2
 800c904:	d150      	bne.n	800c9a8 <PCD_EP_ISR_Handler+0x7ac>
 800c906:	2352      	movs	r3, #82	; 0x52
 800c908:	18fb      	adds	r3, r7, r3
 800c90a:	881a      	ldrh	r2, [r3, #0]
 800c90c:	2380      	movs	r3, #128	; 0x80
 800c90e:	005b      	lsls	r3, r3, #1
 800c910:	4013      	ands	r3, r2
 800c912:	d149      	bne.n	800c9a8 <PCD_EP_ISR_Handler+0x7ac>
        {
          /* multi-packet on the NON control IN endpoint */
          TxByteNbre = (uint16_t)PCD_GET_EP_TX_CNT(hpcd->Instance, ep->num);
 800c914:	687b      	ldr	r3, [r7, #4]
 800c916:	681b      	ldr	r3, [r3, #0]
 800c918:	2250      	movs	r2, #80	; 0x50
 800c91a:	5a9b      	ldrh	r3, [r3, r2]
 800c91c:	b29b      	uxth	r3, r3
 800c91e:	001a      	movs	r2, r3
 800c920:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800c922:	781b      	ldrb	r3, [r3, #0]
 800c924:	00db      	lsls	r3, r3, #3
 800c926:	18d2      	adds	r2, r2, r3
 800c928:	687b      	ldr	r3, [r7, #4]
 800c92a:	681b      	ldr	r3, [r3, #0]
 800c92c:	18d3      	adds	r3, r2, r3
 800c92e:	4a2b      	ldr	r2, [pc, #172]	; (800c9dc <PCD_EP_ISR_Handler+0x7e0>)
 800c930:	4694      	mov	ip, r2
 800c932:	4463      	add	r3, ip
 800c934:	881a      	ldrh	r2, [r3, #0]
 800c936:	2140      	movs	r1, #64	; 0x40
 800c938:	187b      	adds	r3, r7, r1
 800c93a:	0592      	lsls	r2, r2, #22
 800c93c:	0d92      	lsrs	r2, r2, #22
 800c93e:	801a      	strh	r2, [r3, #0]

          if (ep->xfer_len > TxByteNbre)
 800c940:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800c942:	699a      	ldr	r2, [r3, #24]
 800c944:	187b      	adds	r3, r7, r1
 800c946:	881b      	ldrh	r3, [r3, #0]
 800c948:	429a      	cmp	r2, r3
 800c94a:	d907      	bls.n	800c95c <PCD_EP_ISR_Handler+0x760>
          {
            ep->xfer_len -= TxByteNbre;
 800c94c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800c94e:	699a      	ldr	r2, [r3, #24]
 800c950:	187b      	adds	r3, r7, r1
 800c952:	881b      	ldrh	r3, [r3, #0]
 800c954:	1ad2      	subs	r2, r2, r3
 800c956:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800c958:	619a      	str	r2, [r3, #24]
 800c95a:	e002      	b.n	800c962 <PCD_EP_ISR_Handler+0x766>
          }
          else
          {
            ep->xfer_len = 0U;
 800c95c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800c95e:	2200      	movs	r2, #0
 800c960:	619a      	str	r2, [r3, #24]
          }

          /* Zero Length Packet? */
          if (ep->xfer_len == 0U)
 800c962:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800c964:	699b      	ldr	r3, [r3, #24]
 800c966:	2b00      	cmp	r3, #0
 800c968:	d107      	bne.n	800c97a <PCD_EP_ISR_Handler+0x77e>
          {
            /* TX COMPLETE */
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
            hpcd->DataInStageCallback(hpcd, ep->num);
#else
            HAL_PCD_DataInStageCallback(hpcd, ep->num);
 800c96a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800c96c:	781a      	ldrb	r2, [r3, #0]
 800c96e:	687b      	ldr	r3, [r7, #4]
 800c970:	0011      	movs	r1, r2
 800c972:	0018      	movs	r0, r3
 800c974:	f008 f81a 	bl	80149ac <HAL_PCD_DataInStageCallback>
 800c978:	e01e      	b.n	800c9b8 <PCD_EP_ISR_Handler+0x7bc>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
          }
          else
          {
            /* Transfer is not yet Done */
            ep->xfer_buff += TxByteNbre;
 800c97a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800c97c:	695a      	ldr	r2, [r3, #20]
 800c97e:	2140      	movs	r1, #64	; 0x40
 800c980:	187b      	adds	r3, r7, r1
 800c982:	881b      	ldrh	r3, [r3, #0]
 800c984:	18d2      	adds	r2, r2, r3
 800c986:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800c988:	615a      	str	r2, [r3, #20]
            ep->xfer_count += TxByteNbre;
 800c98a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800c98c:	69da      	ldr	r2, [r3, #28]
 800c98e:	187b      	adds	r3, r7, r1
 800c990:	881b      	ldrh	r3, [r3, #0]
 800c992:	18d2      	adds	r2, r2, r3
 800c994:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800c996:	61da      	str	r2, [r3, #28]
            (void)USB_EPStartXfer(hpcd->Instance, ep);
 800c998:	687b      	ldr	r3, [r7, #4]
 800c99a:	681b      	ldr	r3, [r3, #0]
 800c99c:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 800c99e:	0011      	movs	r1, r2
 800c9a0:	0018      	movs	r0, r3
 800c9a2:	f003 fd93 	bl	80104cc <USB_EPStartXfer>
          if (ep->xfer_len == 0U)
 800c9a6:	e007      	b.n	800c9b8 <PCD_EP_ISR_Handler+0x7bc>
          }
        }
        /* Double Buffer bulk IN (bulk transfer Len > Ep_Mps) */
        else
        {
          (void)HAL_PCD_EP_DB_Transmit(hpcd, ep, wEPVal);
 800c9a8:	2352      	movs	r3, #82	; 0x52
 800c9aa:	18fb      	adds	r3, r7, r3
 800c9ac:	881a      	ldrh	r2, [r3, #0]
 800c9ae:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
 800c9b0:	687b      	ldr	r3, [r7, #4]
 800c9b2:	0018      	movs	r0, r3
 800c9b4:	f000 f930 	bl	800cc18 <HAL_PCD_EP_DB_Transmit>
  while ((hpcd->Instance->ISTR & USB_ISTR_CTR) != 0U)
 800c9b8:	687b      	ldr	r3, [r7, #4]
 800c9ba:	681b      	ldr	r3, [r3, #0]
 800c9bc:	2244      	movs	r2, #68	; 0x44
 800c9be:	5a9b      	ldrh	r3, [r3, r2]
 800c9c0:	b29b      	uxth	r3, r3
 800c9c2:	b21b      	sxth	r3, r3
 800c9c4:	2b00      	cmp	r3, #0
 800c9c6:	da01      	bge.n	800c9cc <PCD_EP_ISR_Handler+0x7d0>
 800c9c8:	f7ff fc1e 	bl	800c208 <PCD_EP_ISR_Handler+0xc>
        }
      }
    }
  }

  return HAL_OK;
 800c9cc:	2300      	movs	r3, #0
}
 800c9ce:	0018      	movs	r0, r3
 800c9d0:	46bd      	mov	sp, r7
 800c9d2:	b016      	add	sp, #88	; 0x58
 800c9d4:	bdb0      	pop	{r4, r5, r7, pc}
 800c9d6:	46c0      	nop			; (mov r8, r8)
 800c9d8:	00000406 	.word	0x00000406
 800c9dc:	00000402 	.word	0x00000402

0800c9e0 <HAL_PCD_EP_DB_Receive>:
  * @param  wEPVal Last snapshot of EPRx register value taken in ISR
  * @retval HAL status
  */
static uint16_t HAL_PCD_EP_DB_Receive(PCD_HandleTypeDef *hpcd,
                                      PCD_EPTypeDef *ep, uint16_t wEPVal)
{
 800c9e0:	b590      	push	{r4, r7, lr}
 800c9e2:	b089      	sub	sp, #36	; 0x24
 800c9e4:	af00      	add	r7, sp, #0
 800c9e6:	60f8      	str	r0, [r7, #12]
 800c9e8:	60b9      	str	r1, [r7, #8]
 800c9ea:	1dbb      	adds	r3, r7, #6
 800c9ec:	801a      	strh	r2, [r3, #0]
  uint16_t count;

  /* Manage Buffer0 OUT */
  if ((wEPVal & USB_EP_DTOG_RX) != 0U)
 800c9ee:	1dbb      	adds	r3, r7, #6
 800c9f0:	881a      	ldrh	r2, [r3, #0]
 800c9f2:	2380      	movs	r3, #128	; 0x80
 800c9f4:	01db      	lsls	r3, r3, #7
 800c9f6:	4013      	ands	r3, r2
 800c9f8:	d100      	bne.n	800c9fc <HAL_PCD_EP_DB_Receive+0x1c>
 800c9fa:	e07d      	b.n	800caf8 <HAL_PCD_EP_DB_Receive+0x118>
  {
    /* Get count of received Data on buffer0 */
    count = (uint16_t)PCD_GET_EP_DBUF0_CNT(hpcd->Instance, ep->num);
 800c9fc:	68fb      	ldr	r3, [r7, #12]
 800c9fe:	681b      	ldr	r3, [r3, #0]
 800ca00:	2250      	movs	r2, #80	; 0x50
 800ca02:	5a9b      	ldrh	r3, [r3, r2]
 800ca04:	b29b      	uxth	r3, r3
 800ca06:	001a      	movs	r2, r3
 800ca08:	68bb      	ldr	r3, [r7, #8]
 800ca0a:	781b      	ldrb	r3, [r3, #0]
 800ca0c:	00db      	lsls	r3, r3, #3
 800ca0e:	18d2      	adds	r2, r2, r3
 800ca10:	68fb      	ldr	r3, [r7, #12]
 800ca12:	681b      	ldr	r3, [r3, #0]
 800ca14:	18d3      	adds	r3, r2, r3
 800ca16:	4a7a      	ldr	r2, [pc, #488]	; (800cc00 <HAL_PCD_EP_DB_Receive+0x220>)
 800ca18:	4694      	mov	ip, r2
 800ca1a:	4463      	add	r3, ip
 800ca1c:	881a      	ldrh	r2, [r3, #0]
 800ca1e:	211a      	movs	r1, #26
 800ca20:	187b      	adds	r3, r7, r1
 800ca22:	0592      	lsls	r2, r2, #22
 800ca24:	0d92      	lsrs	r2, r2, #22
 800ca26:	801a      	strh	r2, [r3, #0]

    if (ep->xfer_len >= count)
 800ca28:	68bb      	ldr	r3, [r7, #8]
 800ca2a:	699a      	ldr	r2, [r3, #24]
 800ca2c:	187b      	adds	r3, r7, r1
 800ca2e:	881b      	ldrh	r3, [r3, #0]
 800ca30:	429a      	cmp	r2, r3
 800ca32:	d307      	bcc.n	800ca44 <HAL_PCD_EP_DB_Receive+0x64>
    {
      ep->xfer_len -= count;
 800ca34:	68bb      	ldr	r3, [r7, #8]
 800ca36:	699a      	ldr	r2, [r3, #24]
 800ca38:	187b      	adds	r3, r7, r1
 800ca3a:	881b      	ldrh	r3, [r3, #0]
 800ca3c:	1ad2      	subs	r2, r2, r3
 800ca3e:	68bb      	ldr	r3, [r7, #8]
 800ca40:	619a      	str	r2, [r3, #24]
 800ca42:	e002      	b.n	800ca4a <HAL_PCD_EP_DB_Receive+0x6a>
    }
    else
    {
      ep->xfer_len = 0U;
 800ca44:	68bb      	ldr	r3, [r7, #8]
 800ca46:	2200      	movs	r2, #0
 800ca48:	619a      	str	r2, [r3, #24]
    }

    if (ep->xfer_len == 0U)
 800ca4a:	68bb      	ldr	r3, [r7, #8]
 800ca4c:	699b      	ldr	r3, [r3, #24]
 800ca4e:	2b00      	cmp	r3, #0
 800ca50:	d121      	bne.n	800ca96 <HAL_PCD_EP_DB_Receive+0xb6>
    {
      /* set NAK to OUT endpoint since double buffer is enabled */
      PCD_SET_EP_RX_STATUS(hpcd->Instance, ep->num, USB_EP_RX_NAK);
 800ca52:	68fb      	ldr	r3, [r7, #12]
 800ca54:	681b      	ldr	r3, [r3, #0]
 800ca56:	001a      	movs	r2, r3
 800ca58:	68bb      	ldr	r3, [r7, #8]
 800ca5a:	781b      	ldrb	r3, [r3, #0]
 800ca5c:	009b      	lsls	r3, r3, #2
 800ca5e:	18d3      	adds	r3, r2, r3
 800ca60:	881b      	ldrh	r3, [r3, #0]
 800ca62:	b29a      	uxth	r2, r3
 800ca64:	2018      	movs	r0, #24
 800ca66:	183b      	adds	r3, r7, r0
 800ca68:	4966      	ldr	r1, [pc, #408]	; (800cc04 <HAL_PCD_EP_DB_Receive+0x224>)
 800ca6a:	400a      	ands	r2, r1
 800ca6c:	801a      	strh	r2, [r3, #0]
 800ca6e:	183b      	adds	r3, r7, r0
 800ca70:	183a      	adds	r2, r7, r0
 800ca72:	8812      	ldrh	r2, [r2, #0]
 800ca74:	2180      	movs	r1, #128	; 0x80
 800ca76:	0189      	lsls	r1, r1, #6
 800ca78:	404a      	eors	r2, r1
 800ca7a:	801a      	strh	r2, [r3, #0]
 800ca7c:	68fb      	ldr	r3, [r7, #12]
 800ca7e:	681b      	ldr	r3, [r3, #0]
 800ca80:	001a      	movs	r2, r3
 800ca82:	68bb      	ldr	r3, [r7, #8]
 800ca84:	781b      	ldrb	r3, [r3, #0]
 800ca86:	009b      	lsls	r3, r3, #2
 800ca88:	18d3      	adds	r3, r2, r3
 800ca8a:	183a      	adds	r2, r7, r0
 800ca8c:	8812      	ldrh	r2, [r2, #0]
 800ca8e:	495e      	ldr	r1, [pc, #376]	; (800cc08 <HAL_PCD_EP_DB_Receive+0x228>)
 800ca90:	430a      	orrs	r2, r1
 800ca92:	b292      	uxth	r2, r2
 800ca94:	801a      	strh	r2, [r3, #0]
    }

    /* Check if Buffer1 is in blocked sate which requires to toggle */
    if ((wEPVal & USB_EP_DTOG_TX) != 0U)
 800ca96:	1dbb      	adds	r3, r7, #6
 800ca98:	881b      	ldrh	r3, [r3, #0]
 800ca9a:	2240      	movs	r2, #64	; 0x40
 800ca9c:	4013      	ands	r3, r2
 800ca9e:	d01a      	beq.n	800cad6 <HAL_PCD_EP_DB_Receive+0xf6>
    {
      PCD_FreeUserBuffer(hpcd->Instance, ep->num, 0U);
 800caa0:	68fb      	ldr	r3, [r7, #12]
 800caa2:	681b      	ldr	r3, [r3, #0]
 800caa4:	001a      	movs	r2, r3
 800caa6:	68bb      	ldr	r3, [r7, #8]
 800caa8:	781b      	ldrb	r3, [r3, #0]
 800caaa:	009b      	lsls	r3, r3, #2
 800caac:	18d3      	adds	r3, r2, r3
 800caae:	881b      	ldrh	r3, [r3, #0]
 800cab0:	b29a      	uxth	r2, r3
 800cab2:	2016      	movs	r0, #22
 800cab4:	183b      	adds	r3, r7, r0
 800cab6:	4955      	ldr	r1, [pc, #340]	; (800cc0c <HAL_PCD_EP_DB_Receive+0x22c>)
 800cab8:	400a      	ands	r2, r1
 800caba:	801a      	strh	r2, [r3, #0]
 800cabc:	68fb      	ldr	r3, [r7, #12]
 800cabe:	681b      	ldr	r3, [r3, #0]
 800cac0:	001a      	movs	r2, r3
 800cac2:	68bb      	ldr	r3, [r7, #8]
 800cac4:	781b      	ldrb	r3, [r3, #0]
 800cac6:	009b      	lsls	r3, r3, #2
 800cac8:	18d3      	adds	r3, r2, r3
 800caca:	183a      	adds	r2, r7, r0
 800cacc:	8812      	ldrh	r2, [r2, #0]
 800cace:	4950      	ldr	r1, [pc, #320]	; (800cc10 <HAL_PCD_EP_DB_Receive+0x230>)
 800cad0:	430a      	orrs	r2, r1
 800cad2:	b292      	uxth	r2, r2
 800cad4:	801a      	strh	r2, [r3, #0]
    }

    if (count != 0U)
 800cad6:	241a      	movs	r4, #26
 800cad8:	193b      	adds	r3, r7, r4
 800cada:	881b      	ldrh	r3, [r3, #0]
 800cadc:	2b00      	cmp	r3, #0
 800cade:	d100      	bne.n	800cae2 <HAL_PCD_EP_DB_Receive+0x102>
 800cae0:	e086      	b.n	800cbf0 <HAL_PCD_EP_DB_Receive+0x210>
    {
      USB_ReadPMA(hpcd->Instance, ep->xfer_buff, ep->pmaaddr0, count);
 800cae2:	68fb      	ldr	r3, [r7, #12]
 800cae4:	6818      	ldr	r0, [r3, #0]
 800cae6:	68bb      	ldr	r3, [r7, #8]
 800cae8:	6959      	ldr	r1, [r3, #20]
 800caea:	68bb      	ldr	r3, [r7, #8]
 800caec:	891a      	ldrh	r2, [r3, #8]
 800caee:	193b      	adds	r3, r7, r4
 800caf0:	881b      	ldrh	r3, [r3, #0]
 800caf2:	f004 ff23 	bl	801193c <USB_ReadPMA>
 800caf6:	e07b      	b.n	800cbf0 <HAL_PCD_EP_DB_Receive+0x210>
  }
  /* Manage Buffer 1 DTOG_RX=0 */
  else
  {
    /* Get count of received data */
    count = (uint16_t)PCD_GET_EP_DBUF1_CNT(hpcd->Instance, ep->num);
 800caf8:	68fb      	ldr	r3, [r7, #12]
 800cafa:	681b      	ldr	r3, [r3, #0]
 800cafc:	2250      	movs	r2, #80	; 0x50
 800cafe:	5a9b      	ldrh	r3, [r3, r2]
 800cb00:	b29b      	uxth	r3, r3
 800cb02:	001a      	movs	r2, r3
 800cb04:	68bb      	ldr	r3, [r7, #8]
 800cb06:	781b      	ldrb	r3, [r3, #0]
 800cb08:	00db      	lsls	r3, r3, #3
 800cb0a:	18d2      	adds	r2, r2, r3
 800cb0c:	68fb      	ldr	r3, [r7, #12]
 800cb0e:	681b      	ldr	r3, [r3, #0]
 800cb10:	18d3      	adds	r3, r2, r3
 800cb12:	4a40      	ldr	r2, [pc, #256]	; (800cc14 <HAL_PCD_EP_DB_Receive+0x234>)
 800cb14:	4694      	mov	ip, r2
 800cb16:	4463      	add	r3, ip
 800cb18:	881a      	ldrh	r2, [r3, #0]
 800cb1a:	211a      	movs	r1, #26
 800cb1c:	187b      	adds	r3, r7, r1
 800cb1e:	0592      	lsls	r2, r2, #22
 800cb20:	0d92      	lsrs	r2, r2, #22
 800cb22:	801a      	strh	r2, [r3, #0]

    if (ep->xfer_len >= count)
 800cb24:	68bb      	ldr	r3, [r7, #8]
 800cb26:	699a      	ldr	r2, [r3, #24]
 800cb28:	187b      	adds	r3, r7, r1
 800cb2a:	881b      	ldrh	r3, [r3, #0]
 800cb2c:	429a      	cmp	r2, r3
 800cb2e:	d307      	bcc.n	800cb40 <HAL_PCD_EP_DB_Receive+0x160>
    {
      ep->xfer_len -= count;
 800cb30:	68bb      	ldr	r3, [r7, #8]
 800cb32:	699a      	ldr	r2, [r3, #24]
 800cb34:	187b      	adds	r3, r7, r1
 800cb36:	881b      	ldrh	r3, [r3, #0]
 800cb38:	1ad2      	subs	r2, r2, r3
 800cb3a:	68bb      	ldr	r3, [r7, #8]
 800cb3c:	619a      	str	r2, [r3, #24]
 800cb3e:	e002      	b.n	800cb46 <HAL_PCD_EP_DB_Receive+0x166>
    }
    else
    {
      ep->xfer_len = 0U;
 800cb40:	68bb      	ldr	r3, [r7, #8]
 800cb42:	2200      	movs	r2, #0
 800cb44:	619a      	str	r2, [r3, #24]
    }

    if (ep->xfer_len == 0U)
 800cb46:	68bb      	ldr	r3, [r7, #8]
 800cb48:	699b      	ldr	r3, [r3, #24]
 800cb4a:	2b00      	cmp	r3, #0
 800cb4c:	d121      	bne.n	800cb92 <HAL_PCD_EP_DB_Receive+0x1b2>
    {
      /* set NAK on the current endpoint */
      PCD_SET_EP_RX_STATUS(hpcd->Instance, ep->num, USB_EP_RX_NAK);
 800cb4e:	68fb      	ldr	r3, [r7, #12]
 800cb50:	681b      	ldr	r3, [r3, #0]
 800cb52:	001a      	movs	r2, r3
 800cb54:	68bb      	ldr	r3, [r7, #8]
 800cb56:	781b      	ldrb	r3, [r3, #0]
 800cb58:	009b      	lsls	r3, r3, #2
 800cb5a:	18d3      	adds	r3, r2, r3
 800cb5c:	881b      	ldrh	r3, [r3, #0]
 800cb5e:	b29a      	uxth	r2, r3
 800cb60:	201e      	movs	r0, #30
 800cb62:	183b      	adds	r3, r7, r0
 800cb64:	4927      	ldr	r1, [pc, #156]	; (800cc04 <HAL_PCD_EP_DB_Receive+0x224>)
 800cb66:	400a      	ands	r2, r1
 800cb68:	801a      	strh	r2, [r3, #0]
 800cb6a:	183b      	adds	r3, r7, r0
 800cb6c:	183a      	adds	r2, r7, r0
 800cb6e:	8812      	ldrh	r2, [r2, #0]
 800cb70:	2180      	movs	r1, #128	; 0x80
 800cb72:	0189      	lsls	r1, r1, #6
 800cb74:	404a      	eors	r2, r1
 800cb76:	801a      	strh	r2, [r3, #0]
 800cb78:	68fb      	ldr	r3, [r7, #12]
 800cb7a:	681b      	ldr	r3, [r3, #0]
 800cb7c:	001a      	movs	r2, r3
 800cb7e:	68bb      	ldr	r3, [r7, #8]
 800cb80:	781b      	ldrb	r3, [r3, #0]
 800cb82:	009b      	lsls	r3, r3, #2
 800cb84:	18d3      	adds	r3, r2, r3
 800cb86:	183a      	adds	r2, r7, r0
 800cb88:	8812      	ldrh	r2, [r2, #0]
 800cb8a:	491f      	ldr	r1, [pc, #124]	; (800cc08 <HAL_PCD_EP_DB_Receive+0x228>)
 800cb8c:	430a      	orrs	r2, r1
 800cb8e:	b292      	uxth	r2, r2
 800cb90:	801a      	strh	r2, [r3, #0]
    }

    /*Need to FreeUser Buffer*/
    if ((wEPVal & USB_EP_DTOG_TX) == 0U)
 800cb92:	1dbb      	adds	r3, r7, #6
 800cb94:	881b      	ldrh	r3, [r3, #0]
 800cb96:	2240      	movs	r2, #64	; 0x40
 800cb98:	4013      	ands	r3, r2
 800cb9a:	d11a      	bne.n	800cbd2 <HAL_PCD_EP_DB_Receive+0x1f2>
    {
      PCD_FreeUserBuffer(hpcd->Instance, ep->num, 0U);
 800cb9c:	68fb      	ldr	r3, [r7, #12]
 800cb9e:	681b      	ldr	r3, [r3, #0]
 800cba0:	001a      	movs	r2, r3
 800cba2:	68bb      	ldr	r3, [r7, #8]
 800cba4:	781b      	ldrb	r3, [r3, #0]
 800cba6:	009b      	lsls	r3, r3, #2
 800cba8:	18d3      	adds	r3, r2, r3
 800cbaa:	881b      	ldrh	r3, [r3, #0]
 800cbac:	b29a      	uxth	r2, r3
 800cbae:	201c      	movs	r0, #28
 800cbb0:	183b      	adds	r3, r7, r0
 800cbb2:	4916      	ldr	r1, [pc, #88]	; (800cc0c <HAL_PCD_EP_DB_Receive+0x22c>)
 800cbb4:	400a      	ands	r2, r1
 800cbb6:	801a      	strh	r2, [r3, #0]
 800cbb8:	68fb      	ldr	r3, [r7, #12]
 800cbba:	681b      	ldr	r3, [r3, #0]
 800cbbc:	001a      	movs	r2, r3
 800cbbe:	68bb      	ldr	r3, [r7, #8]
 800cbc0:	781b      	ldrb	r3, [r3, #0]
 800cbc2:	009b      	lsls	r3, r3, #2
 800cbc4:	18d3      	adds	r3, r2, r3
 800cbc6:	183a      	adds	r2, r7, r0
 800cbc8:	8812      	ldrh	r2, [r2, #0]
 800cbca:	4911      	ldr	r1, [pc, #68]	; (800cc10 <HAL_PCD_EP_DB_Receive+0x230>)
 800cbcc:	430a      	orrs	r2, r1
 800cbce:	b292      	uxth	r2, r2
 800cbd0:	801a      	strh	r2, [r3, #0]
    }

    if (count != 0U)
 800cbd2:	241a      	movs	r4, #26
 800cbd4:	193b      	adds	r3, r7, r4
 800cbd6:	881b      	ldrh	r3, [r3, #0]
 800cbd8:	2b00      	cmp	r3, #0
 800cbda:	d009      	beq.n	800cbf0 <HAL_PCD_EP_DB_Receive+0x210>
    {
      USB_ReadPMA(hpcd->Instance, ep->xfer_buff, ep->pmaaddr1, count);
 800cbdc:	68fb      	ldr	r3, [r7, #12]
 800cbde:	6818      	ldr	r0, [r3, #0]
 800cbe0:	68bb      	ldr	r3, [r7, #8]
 800cbe2:	6959      	ldr	r1, [r3, #20]
 800cbe4:	68bb      	ldr	r3, [r7, #8]
 800cbe6:	895a      	ldrh	r2, [r3, #10]
 800cbe8:	193b      	adds	r3, r7, r4
 800cbea:	881b      	ldrh	r3, [r3, #0]
 800cbec:	f004 fea6 	bl	801193c <USB_ReadPMA>
    }
  }

  return count;
 800cbf0:	231a      	movs	r3, #26
 800cbf2:	18fb      	adds	r3, r7, r3
 800cbf4:	881b      	ldrh	r3, [r3, #0]
}
 800cbf6:	0018      	movs	r0, r3
 800cbf8:	46bd      	mov	sp, r7
 800cbfa:	b009      	add	sp, #36	; 0x24
 800cbfc:	bd90      	pop	{r4, r7, pc}
 800cbfe:	46c0      	nop			; (mov r8, r8)
 800cc00:	00000402 	.word	0x00000402
 800cc04:	ffffbf8f 	.word	0xffffbf8f
 800cc08:	ffff8080 	.word	0xffff8080
 800cc0c:	ffff8f8f 	.word	0xffff8f8f
 800cc10:	ffff80c0 	.word	0xffff80c0
 800cc14:	00000406 	.word	0x00000406

0800cc18 <HAL_PCD_EP_DB_Transmit>:
  * @param  wEPVal Last snapshot of EPRx register value taken in ISR
  * @retval HAL status
  */
static HAL_StatusTypeDef HAL_PCD_EP_DB_Transmit(PCD_HandleTypeDef *hpcd,
                                                PCD_EPTypeDef *ep, uint16_t wEPVal)
{
 800cc18:	b580      	push	{r7, lr}
 800cc1a:	b0a2      	sub	sp, #136	; 0x88
 800cc1c:	af00      	add	r7, sp, #0
 800cc1e:	60f8      	str	r0, [r7, #12]
 800cc20:	60b9      	str	r1, [r7, #8]
 800cc22:	1dbb      	adds	r3, r7, #6
 800cc24:	801a      	strh	r2, [r3, #0]
  uint32_t len;
  uint16_t TxByteNbre;

  /* Data Buffer0 ACK received */
  if ((wEPVal & USB_EP_DTOG_TX) != 0U)
 800cc26:	1dbb      	adds	r3, r7, #6
 800cc28:	881b      	ldrh	r3, [r3, #0]
 800cc2a:	2240      	movs	r2, #64	; 0x40
 800cc2c:	4013      	ands	r3, r2
 800cc2e:	d100      	bne.n	800cc32 <HAL_PCD_EP_DB_Transmit+0x1a>
 800cc30:	e1c8      	b.n	800cfc4 <HAL_PCD_EP_DB_Transmit+0x3ac>
  {
    /* multi-packet on the NON control IN endpoint */
    TxByteNbre = (uint16_t)PCD_GET_EP_DBUF0_CNT(hpcd->Instance, ep->num);
 800cc32:	68fb      	ldr	r3, [r7, #12]
 800cc34:	681b      	ldr	r3, [r3, #0]
 800cc36:	2250      	movs	r2, #80	; 0x50
 800cc38:	5a9b      	ldrh	r3, [r3, r2]
 800cc3a:	b29b      	uxth	r3, r3
 800cc3c:	001a      	movs	r2, r3
 800cc3e:	68bb      	ldr	r3, [r7, #8]
 800cc40:	781b      	ldrb	r3, [r3, #0]
 800cc42:	00db      	lsls	r3, r3, #3
 800cc44:	18d2      	adds	r2, r2, r3
 800cc46:	68fb      	ldr	r3, [r7, #12]
 800cc48:	681b      	ldr	r3, [r3, #0]
 800cc4a:	18d3      	adds	r3, r2, r3
 800cc4c:	4ad7      	ldr	r2, [pc, #860]	; (800cfac <HAL_PCD_EP_DB_Transmit+0x394>)
 800cc4e:	4694      	mov	ip, r2
 800cc50:	4463      	add	r3, ip
 800cc52:	881a      	ldrh	r2, [r3, #0]
 800cc54:	214e      	movs	r1, #78	; 0x4e
 800cc56:	187b      	adds	r3, r7, r1
 800cc58:	0592      	lsls	r2, r2, #22
 800cc5a:	0d92      	lsrs	r2, r2, #22
 800cc5c:	801a      	strh	r2, [r3, #0]

    if (ep->xfer_len > TxByteNbre)
 800cc5e:	68bb      	ldr	r3, [r7, #8]
 800cc60:	699a      	ldr	r2, [r3, #24]
 800cc62:	187b      	adds	r3, r7, r1
 800cc64:	881b      	ldrh	r3, [r3, #0]
 800cc66:	429a      	cmp	r2, r3
 800cc68:	d907      	bls.n	800cc7a <HAL_PCD_EP_DB_Transmit+0x62>
    {
      ep->xfer_len -= TxByteNbre;
 800cc6a:	68bb      	ldr	r3, [r7, #8]
 800cc6c:	699a      	ldr	r2, [r3, #24]
 800cc6e:	187b      	adds	r3, r7, r1
 800cc70:	881b      	ldrh	r3, [r3, #0]
 800cc72:	1ad2      	subs	r2, r2, r3
 800cc74:	68bb      	ldr	r3, [r7, #8]
 800cc76:	619a      	str	r2, [r3, #24]
 800cc78:	e002      	b.n	800cc80 <HAL_PCD_EP_DB_Transmit+0x68>
    }
    else
    {
      ep->xfer_len = 0U;
 800cc7a:	68bb      	ldr	r3, [r7, #8]
 800cc7c:	2200      	movs	r2, #0
 800cc7e:	619a      	str	r2, [r3, #24]
    }
    /* Transfer is completed */
    if (ep->xfer_len == 0U)
 800cc80:	68bb      	ldr	r3, [r7, #8]
 800cc82:	699b      	ldr	r3, [r3, #24]
 800cc84:	2b00      	cmp	r3, #0
 800cc86:	d000      	beq.n	800cc8a <HAL_PCD_EP_DB_Transmit+0x72>
 800cc88:	e0b5      	b.n	800cdf6 <HAL_PCD_EP_DB_Transmit+0x1de>
    {
      PCD_SET_EP_DBUF0_CNT(hpcd->Instance, ep->num, ep->is_in, 0U);
 800cc8a:	68bb      	ldr	r3, [r7, #8]
 800cc8c:	785b      	ldrb	r3, [r3, #1]
 800cc8e:	2b00      	cmp	r3, #0
 800cc90:	d125      	bne.n	800ccde <HAL_PCD_EP_DB_Transmit+0xc6>
 800cc92:	68fb      	ldr	r3, [r7, #12]
 800cc94:	681b      	ldr	r3, [r3, #0]
 800cc96:	62bb      	str	r3, [r7, #40]	; 0x28
 800cc98:	68fb      	ldr	r3, [r7, #12]
 800cc9a:	681b      	ldr	r3, [r3, #0]
 800cc9c:	2250      	movs	r2, #80	; 0x50
 800cc9e:	5a9b      	ldrh	r3, [r3, r2]
 800cca0:	b29b      	uxth	r3, r3
 800cca2:	001a      	movs	r2, r3
 800cca4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800cca6:	189b      	adds	r3, r3, r2
 800cca8:	62bb      	str	r3, [r7, #40]	; 0x28
 800ccaa:	68bb      	ldr	r3, [r7, #8]
 800ccac:	781b      	ldrb	r3, [r3, #0]
 800ccae:	00da      	lsls	r2, r3, #3
 800ccb0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800ccb2:	18d3      	adds	r3, r2, r3
 800ccb4:	4abd      	ldr	r2, [pc, #756]	; (800cfac <HAL_PCD_EP_DB_Transmit+0x394>)
 800ccb6:	4694      	mov	ip, r2
 800ccb8:	4463      	add	r3, ip
 800ccba:	627b      	str	r3, [r7, #36]	; 0x24
 800ccbc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800ccbe:	881b      	ldrh	r3, [r3, #0]
 800ccc0:	b29b      	uxth	r3, r3
 800ccc2:	4abb      	ldr	r2, [pc, #748]	; (800cfb0 <HAL_PCD_EP_DB_Transmit+0x398>)
 800ccc4:	4013      	ands	r3, r2
 800ccc6:	b29a      	uxth	r2, r3
 800ccc8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800ccca:	801a      	strh	r2, [r3, #0]
 800cccc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800ccce:	881b      	ldrh	r3, [r3, #0]
 800ccd0:	b29b      	uxth	r3, r3
 800ccd2:	4ab8      	ldr	r2, [pc, #736]	; (800cfb4 <HAL_PCD_EP_DB_Transmit+0x39c>)
 800ccd4:	4313      	orrs	r3, r2
 800ccd6:	b29a      	uxth	r2, r3
 800ccd8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800ccda:	801a      	strh	r2, [r3, #0]
 800ccdc:	e01b      	b.n	800cd16 <HAL_PCD_EP_DB_Transmit+0xfe>
 800ccde:	68bb      	ldr	r3, [r7, #8]
 800cce0:	785b      	ldrb	r3, [r3, #1]
 800cce2:	2b01      	cmp	r3, #1
 800cce4:	d117      	bne.n	800cd16 <HAL_PCD_EP_DB_Transmit+0xfe>
 800cce6:	68fb      	ldr	r3, [r7, #12]
 800cce8:	681b      	ldr	r3, [r3, #0]
 800ccea:	633b      	str	r3, [r7, #48]	; 0x30
 800ccec:	68fb      	ldr	r3, [r7, #12]
 800ccee:	681b      	ldr	r3, [r3, #0]
 800ccf0:	2250      	movs	r2, #80	; 0x50
 800ccf2:	5a9b      	ldrh	r3, [r3, r2]
 800ccf4:	b29b      	uxth	r3, r3
 800ccf6:	001a      	movs	r2, r3
 800ccf8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800ccfa:	189b      	adds	r3, r3, r2
 800ccfc:	633b      	str	r3, [r7, #48]	; 0x30
 800ccfe:	68bb      	ldr	r3, [r7, #8]
 800cd00:	781b      	ldrb	r3, [r3, #0]
 800cd02:	00da      	lsls	r2, r3, #3
 800cd04:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800cd06:	18d3      	adds	r3, r2, r3
 800cd08:	4aa8      	ldr	r2, [pc, #672]	; (800cfac <HAL_PCD_EP_DB_Transmit+0x394>)
 800cd0a:	4694      	mov	ip, r2
 800cd0c:	4463      	add	r3, ip
 800cd0e:	62fb      	str	r3, [r7, #44]	; 0x2c
 800cd10:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800cd12:	2200      	movs	r2, #0
 800cd14:	801a      	strh	r2, [r3, #0]
      PCD_SET_EP_DBUF1_CNT(hpcd->Instance, ep->num, ep->is_in, 0U);
 800cd16:	68fb      	ldr	r3, [r7, #12]
 800cd18:	681b      	ldr	r3, [r3, #0]
 800cd1a:	623b      	str	r3, [r7, #32]
 800cd1c:	68bb      	ldr	r3, [r7, #8]
 800cd1e:	785b      	ldrb	r3, [r3, #1]
 800cd20:	2b00      	cmp	r3, #0
 800cd22:	d125      	bne.n	800cd70 <HAL_PCD_EP_DB_Transmit+0x158>
 800cd24:	68fb      	ldr	r3, [r7, #12]
 800cd26:	681b      	ldr	r3, [r3, #0]
 800cd28:	61bb      	str	r3, [r7, #24]
 800cd2a:	68fb      	ldr	r3, [r7, #12]
 800cd2c:	681b      	ldr	r3, [r3, #0]
 800cd2e:	2250      	movs	r2, #80	; 0x50
 800cd30:	5a9b      	ldrh	r3, [r3, r2]
 800cd32:	b29b      	uxth	r3, r3
 800cd34:	001a      	movs	r2, r3
 800cd36:	69bb      	ldr	r3, [r7, #24]
 800cd38:	189b      	adds	r3, r3, r2
 800cd3a:	61bb      	str	r3, [r7, #24]
 800cd3c:	68bb      	ldr	r3, [r7, #8]
 800cd3e:	781b      	ldrb	r3, [r3, #0]
 800cd40:	00da      	lsls	r2, r3, #3
 800cd42:	69bb      	ldr	r3, [r7, #24]
 800cd44:	18d3      	adds	r3, r2, r3
 800cd46:	4a9c      	ldr	r2, [pc, #624]	; (800cfb8 <HAL_PCD_EP_DB_Transmit+0x3a0>)
 800cd48:	4694      	mov	ip, r2
 800cd4a:	4463      	add	r3, ip
 800cd4c:	617b      	str	r3, [r7, #20]
 800cd4e:	697b      	ldr	r3, [r7, #20]
 800cd50:	881b      	ldrh	r3, [r3, #0]
 800cd52:	b29b      	uxth	r3, r3
 800cd54:	4a96      	ldr	r2, [pc, #600]	; (800cfb0 <HAL_PCD_EP_DB_Transmit+0x398>)
 800cd56:	4013      	ands	r3, r2
 800cd58:	b29a      	uxth	r2, r3
 800cd5a:	697b      	ldr	r3, [r7, #20]
 800cd5c:	801a      	strh	r2, [r3, #0]
 800cd5e:	697b      	ldr	r3, [r7, #20]
 800cd60:	881b      	ldrh	r3, [r3, #0]
 800cd62:	b29b      	uxth	r3, r3
 800cd64:	4a93      	ldr	r2, [pc, #588]	; (800cfb4 <HAL_PCD_EP_DB_Transmit+0x39c>)
 800cd66:	4313      	orrs	r3, r2
 800cd68:	b29a      	uxth	r2, r3
 800cd6a:	697b      	ldr	r3, [r7, #20]
 800cd6c:	801a      	strh	r2, [r3, #0]
 800cd6e:	e018      	b.n	800cda2 <HAL_PCD_EP_DB_Transmit+0x18a>
 800cd70:	68bb      	ldr	r3, [r7, #8]
 800cd72:	785b      	ldrb	r3, [r3, #1]
 800cd74:	2b01      	cmp	r3, #1
 800cd76:	d114      	bne.n	800cda2 <HAL_PCD_EP_DB_Transmit+0x18a>
 800cd78:	68fb      	ldr	r3, [r7, #12]
 800cd7a:	681b      	ldr	r3, [r3, #0]
 800cd7c:	2250      	movs	r2, #80	; 0x50
 800cd7e:	5a9b      	ldrh	r3, [r3, r2]
 800cd80:	b29b      	uxth	r3, r3
 800cd82:	001a      	movs	r2, r3
 800cd84:	6a3b      	ldr	r3, [r7, #32]
 800cd86:	189b      	adds	r3, r3, r2
 800cd88:	623b      	str	r3, [r7, #32]
 800cd8a:	68bb      	ldr	r3, [r7, #8]
 800cd8c:	781b      	ldrb	r3, [r3, #0]
 800cd8e:	00da      	lsls	r2, r3, #3
 800cd90:	6a3b      	ldr	r3, [r7, #32]
 800cd92:	18d3      	adds	r3, r2, r3
 800cd94:	4a88      	ldr	r2, [pc, #544]	; (800cfb8 <HAL_PCD_EP_DB_Transmit+0x3a0>)
 800cd96:	4694      	mov	ip, r2
 800cd98:	4463      	add	r3, ip
 800cd9a:	61fb      	str	r3, [r7, #28]
 800cd9c:	69fb      	ldr	r3, [r7, #28]
 800cd9e:	2200      	movs	r2, #0
 800cda0:	801a      	strh	r2, [r3, #0]

      /* TX COMPLETE */
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
      hpcd->DataInStageCallback(hpcd, ep->num);
#else
      HAL_PCD_DataInStageCallback(hpcd, ep->num);
 800cda2:	68bb      	ldr	r3, [r7, #8]
 800cda4:	781a      	ldrb	r2, [r3, #0]
 800cda6:	68fb      	ldr	r3, [r7, #12]
 800cda8:	0011      	movs	r1, r2
 800cdaa:	0018      	movs	r0, r3
 800cdac:	f007 fdfe 	bl	80149ac <HAL_PCD_DataInStageCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */

      if ((wEPVal & USB_EP_DTOG_RX) != 0U)
 800cdb0:	1dbb      	adds	r3, r7, #6
 800cdb2:	881a      	ldrh	r2, [r3, #0]
 800cdb4:	2380      	movs	r3, #128	; 0x80
 800cdb6:	01db      	lsls	r3, r3, #7
 800cdb8:	4013      	ands	r3, r2
 800cdba:	d100      	bne.n	800cdbe <HAL_PCD_EP_DB_Transmit+0x1a6>
 800cdbc:	e2d4      	b.n	800d368 <HAL_PCD_EP_DB_Transmit+0x750>
      {
        PCD_FreeUserBuffer(hpcd->Instance, ep->num, 1U);
 800cdbe:	68fb      	ldr	r3, [r7, #12]
 800cdc0:	681b      	ldr	r3, [r3, #0]
 800cdc2:	001a      	movs	r2, r3
 800cdc4:	68bb      	ldr	r3, [r7, #8]
 800cdc6:	781b      	ldrb	r3, [r3, #0]
 800cdc8:	009b      	lsls	r3, r3, #2
 800cdca:	18d3      	adds	r3, r2, r3
 800cdcc:	881b      	ldrh	r3, [r3, #0]
 800cdce:	b29a      	uxth	r2, r3
 800cdd0:	2012      	movs	r0, #18
 800cdd2:	183b      	adds	r3, r7, r0
 800cdd4:	4979      	ldr	r1, [pc, #484]	; (800cfbc <HAL_PCD_EP_DB_Transmit+0x3a4>)
 800cdd6:	400a      	ands	r2, r1
 800cdd8:	801a      	strh	r2, [r3, #0]
 800cdda:	68fb      	ldr	r3, [r7, #12]
 800cddc:	681b      	ldr	r3, [r3, #0]
 800cdde:	001a      	movs	r2, r3
 800cde0:	68bb      	ldr	r3, [r7, #8]
 800cde2:	781b      	ldrb	r3, [r3, #0]
 800cde4:	009b      	lsls	r3, r3, #2
 800cde6:	18d3      	adds	r3, r2, r3
 800cde8:	183a      	adds	r2, r7, r0
 800cdea:	8812      	ldrh	r2, [r2, #0]
 800cdec:	4974      	ldr	r1, [pc, #464]	; (800cfc0 <HAL_PCD_EP_DB_Transmit+0x3a8>)
 800cdee:	430a      	orrs	r2, r1
 800cdf0:	b292      	uxth	r2, r2
 800cdf2:	801a      	strh	r2, [r3, #0]
 800cdf4:	e2b8      	b.n	800d368 <HAL_PCD_EP_DB_Transmit+0x750>
      }
    }
    else /* Transfer is not yet Done */
    {
      /* need to Free USB Buff */
      if ((wEPVal & USB_EP_DTOG_RX) != 0U)
 800cdf6:	1dbb      	adds	r3, r7, #6
 800cdf8:	881a      	ldrh	r2, [r3, #0]
 800cdfa:	2380      	movs	r3, #128	; 0x80
 800cdfc:	01db      	lsls	r3, r3, #7
 800cdfe:	4013      	ands	r3, r2
 800ce00:	d01a      	beq.n	800ce38 <HAL_PCD_EP_DB_Transmit+0x220>
      {
        PCD_FreeUserBuffer(hpcd->Instance, ep->num, 1U);
 800ce02:	68fb      	ldr	r3, [r7, #12]
 800ce04:	681b      	ldr	r3, [r3, #0]
 800ce06:	001a      	movs	r2, r3
 800ce08:	68bb      	ldr	r3, [r7, #8]
 800ce0a:	781b      	ldrb	r3, [r3, #0]
 800ce0c:	009b      	lsls	r3, r3, #2
 800ce0e:	18d3      	adds	r3, r2, r3
 800ce10:	881b      	ldrh	r3, [r3, #0]
 800ce12:	b29a      	uxth	r2, r3
 800ce14:	2044      	movs	r0, #68	; 0x44
 800ce16:	183b      	adds	r3, r7, r0
 800ce18:	4968      	ldr	r1, [pc, #416]	; (800cfbc <HAL_PCD_EP_DB_Transmit+0x3a4>)
 800ce1a:	400a      	ands	r2, r1
 800ce1c:	801a      	strh	r2, [r3, #0]
 800ce1e:	68fb      	ldr	r3, [r7, #12]
 800ce20:	681b      	ldr	r3, [r3, #0]
 800ce22:	001a      	movs	r2, r3
 800ce24:	68bb      	ldr	r3, [r7, #8]
 800ce26:	781b      	ldrb	r3, [r3, #0]
 800ce28:	009b      	lsls	r3, r3, #2
 800ce2a:	18d3      	adds	r3, r2, r3
 800ce2c:	183a      	adds	r2, r7, r0
 800ce2e:	8812      	ldrh	r2, [r2, #0]
 800ce30:	4963      	ldr	r1, [pc, #396]	; (800cfc0 <HAL_PCD_EP_DB_Transmit+0x3a8>)
 800ce32:	430a      	orrs	r2, r1
 800ce34:	b292      	uxth	r2, r2
 800ce36:	801a      	strh	r2, [r3, #0]
      }

      /* Still there is data to Fill in the next Buffer */
      if (ep->xfer_fill_db == 1U)
 800ce38:	68bb      	ldr	r3, [r7, #8]
 800ce3a:	2224      	movs	r2, #36	; 0x24
 800ce3c:	5c9b      	ldrb	r3, [r3, r2]
 800ce3e:	2b01      	cmp	r3, #1
 800ce40:	d000      	beq.n	800ce44 <HAL_PCD_EP_DB_Transmit+0x22c>
 800ce42:	e291      	b.n	800d368 <HAL_PCD_EP_DB_Transmit+0x750>
      {
        ep->xfer_buff += TxByteNbre;
 800ce44:	68bb      	ldr	r3, [r7, #8]
 800ce46:	695a      	ldr	r2, [r3, #20]
 800ce48:	214e      	movs	r1, #78	; 0x4e
 800ce4a:	187b      	adds	r3, r7, r1
 800ce4c:	881b      	ldrh	r3, [r3, #0]
 800ce4e:	18d2      	adds	r2, r2, r3
 800ce50:	68bb      	ldr	r3, [r7, #8]
 800ce52:	615a      	str	r2, [r3, #20]
        ep->xfer_count += TxByteNbre;
 800ce54:	68bb      	ldr	r3, [r7, #8]
 800ce56:	69da      	ldr	r2, [r3, #28]
 800ce58:	187b      	adds	r3, r7, r1
 800ce5a:	881b      	ldrh	r3, [r3, #0]
 800ce5c:	18d2      	adds	r2, r2, r3
 800ce5e:	68bb      	ldr	r3, [r7, #8]
 800ce60:	61da      	str	r2, [r3, #28]

        /* Calculate the len of the new buffer to fill */
        if (ep->xfer_len_db >= ep->maxpacket)
 800ce62:	68bb      	ldr	r3, [r7, #8]
 800ce64:	6a1a      	ldr	r2, [r3, #32]
 800ce66:	68bb      	ldr	r3, [r7, #8]
 800ce68:	691b      	ldr	r3, [r3, #16]
 800ce6a:	429a      	cmp	r2, r3
 800ce6c:	d309      	bcc.n	800ce82 <HAL_PCD_EP_DB_Transmit+0x26a>
        {
          len = ep->maxpacket;
 800ce6e:	68bb      	ldr	r3, [r7, #8]
 800ce70:	691b      	ldr	r3, [r3, #16]
 800ce72:	653b      	str	r3, [r7, #80]	; 0x50
          ep->xfer_len_db -= len;
 800ce74:	68bb      	ldr	r3, [r7, #8]
 800ce76:	6a1a      	ldr	r2, [r3, #32]
 800ce78:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800ce7a:	1ad2      	subs	r2, r2, r3
 800ce7c:	68bb      	ldr	r3, [r7, #8]
 800ce7e:	621a      	str	r2, [r3, #32]
 800ce80:	e016      	b.n	800ceb0 <HAL_PCD_EP_DB_Transmit+0x298>
        }
        else if (ep->xfer_len_db == 0U)
 800ce82:	68bb      	ldr	r3, [r7, #8]
 800ce84:	6a1b      	ldr	r3, [r3, #32]
 800ce86:	2b00      	cmp	r3, #0
 800ce88:	d108      	bne.n	800ce9c <HAL_PCD_EP_DB_Transmit+0x284>
        {
          len = TxByteNbre;
 800ce8a:	234e      	movs	r3, #78	; 0x4e
 800ce8c:	18fb      	adds	r3, r7, r3
 800ce8e:	881b      	ldrh	r3, [r3, #0]
 800ce90:	653b      	str	r3, [r7, #80]	; 0x50
          ep->xfer_fill_db = 0U;
 800ce92:	68bb      	ldr	r3, [r7, #8]
 800ce94:	2224      	movs	r2, #36	; 0x24
 800ce96:	2100      	movs	r1, #0
 800ce98:	5499      	strb	r1, [r3, r2]
 800ce9a:	e009      	b.n	800ceb0 <HAL_PCD_EP_DB_Transmit+0x298>
        }
        else
        {
          ep->xfer_fill_db = 0U;
 800ce9c:	68bb      	ldr	r3, [r7, #8]
 800ce9e:	2224      	movs	r2, #36	; 0x24
 800cea0:	2100      	movs	r1, #0
 800cea2:	5499      	strb	r1, [r3, r2]
          len = ep->xfer_len_db;
 800cea4:	68bb      	ldr	r3, [r7, #8]
 800cea6:	6a1b      	ldr	r3, [r3, #32]
 800cea8:	653b      	str	r3, [r7, #80]	; 0x50
          ep->xfer_len_db = 0U;
 800ceaa:	68bb      	ldr	r3, [r7, #8]
 800ceac:	2200      	movs	r2, #0
 800ceae:	621a      	str	r2, [r3, #32]
        }

        /* Write remaining Data to Buffer */
        /* Set the Double buffer counter for pma buffer1 */
        PCD_SET_EP_DBUF0_CNT(hpcd->Instance, ep->num, ep->is_in, len);
 800ceb0:	68bb      	ldr	r3, [r7, #8]
 800ceb2:	785b      	ldrb	r3, [r3, #1]
 800ceb4:	2b00      	cmp	r3, #0
 800ceb6:	d150      	bne.n	800cf5a <HAL_PCD_EP_DB_Transmit+0x342>
 800ceb8:	68fb      	ldr	r3, [r7, #12]
 800ceba:	681b      	ldr	r3, [r3, #0]
 800cebc:	63bb      	str	r3, [r7, #56]	; 0x38
 800cebe:	68fb      	ldr	r3, [r7, #12]
 800cec0:	681b      	ldr	r3, [r3, #0]
 800cec2:	2250      	movs	r2, #80	; 0x50
 800cec4:	5a9b      	ldrh	r3, [r3, r2]
 800cec6:	b29b      	uxth	r3, r3
 800cec8:	001a      	movs	r2, r3
 800ceca:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800cecc:	189b      	adds	r3, r3, r2
 800cece:	63bb      	str	r3, [r7, #56]	; 0x38
 800ced0:	68bb      	ldr	r3, [r7, #8]
 800ced2:	781b      	ldrb	r3, [r3, #0]
 800ced4:	00da      	lsls	r2, r3, #3
 800ced6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800ced8:	18d3      	adds	r3, r2, r3
 800ceda:	4a34      	ldr	r2, [pc, #208]	; (800cfac <HAL_PCD_EP_DB_Transmit+0x394>)
 800cedc:	4694      	mov	ip, r2
 800cede:	4463      	add	r3, ip
 800cee0:	637b      	str	r3, [r7, #52]	; 0x34
 800cee2:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800cee4:	2b00      	cmp	r3, #0
 800cee6:	d110      	bne.n	800cf0a <HAL_PCD_EP_DB_Transmit+0x2f2>
 800cee8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800ceea:	881b      	ldrh	r3, [r3, #0]
 800ceec:	b29b      	uxth	r3, r3
 800ceee:	4a30      	ldr	r2, [pc, #192]	; (800cfb0 <HAL_PCD_EP_DB_Transmit+0x398>)
 800cef0:	4013      	ands	r3, r2
 800cef2:	b29a      	uxth	r2, r3
 800cef4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800cef6:	801a      	strh	r2, [r3, #0]
 800cef8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800cefa:	881b      	ldrh	r3, [r3, #0]
 800cefc:	b29b      	uxth	r3, r3
 800cefe:	4a2d      	ldr	r2, [pc, #180]	; (800cfb4 <HAL_PCD_EP_DB_Transmit+0x39c>)
 800cf00:	4313      	orrs	r3, r2
 800cf02:	b29a      	uxth	r2, r3
 800cf04:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800cf06:	801a      	strh	r2, [r3, #0]
 800cf08:	e044      	b.n	800cf94 <HAL_PCD_EP_DB_Transmit+0x37c>
 800cf0a:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800cf0c:	2b3e      	cmp	r3, #62	; 0x3e
 800cf0e:	d810      	bhi.n	800cf32 <HAL_PCD_EP_DB_Transmit+0x31a>
 800cf10:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800cf12:	085b      	lsrs	r3, r3, #1
 800cf14:	64bb      	str	r3, [r7, #72]	; 0x48
 800cf16:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800cf18:	2201      	movs	r2, #1
 800cf1a:	4013      	ands	r3, r2
 800cf1c:	d002      	beq.n	800cf24 <HAL_PCD_EP_DB_Transmit+0x30c>
 800cf1e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800cf20:	3301      	adds	r3, #1
 800cf22:	64bb      	str	r3, [r7, #72]	; 0x48
 800cf24:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800cf26:	b29b      	uxth	r3, r3
 800cf28:	029b      	lsls	r3, r3, #10
 800cf2a:	b29a      	uxth	r2, r3
 800cf2c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800cf2e:	801a      	strh	r2, [r3, #0]
 800cf30:	e030      	b.n	800cf94 <HAL_PCD_EP_DB_Transmit+0x37c>
 800cf32:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800cf34:	095b      	lsrs	r3, r3, #5
 800cf36:	64bb      	str	r3, [r7, #72]	; 0x48
 800cf38:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800cf3a:	221f      	movs	r2, #31
 800cf3c:	4013      	ands	r3, r2
 800cf3e:	d102      	bne.n	800cf46 <HAL_PCD_EP_DB_Transmit+0x32e>
 800cf40:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800cf42:	3b01      	subs	r3, #1
 800cf44:	64bb      	str	r3, [r7, #72]	; 0x48
 800cf46:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800cf48:	b29b      	uxth	r3, r3
 800cf4a:	029b      	lsls	r3, r3, #10
 800cf4c:	b29b      	uxth	r3, r3
 800cf4e:	4a19      	ldr	r2, [pc, #100]	; (800cfb4 <HAL_PCD_EP_DB_Transmit+0x39c>)
 800cf50:	4313      	orrs	r3, r2
 800cf52:	b29a      	uxth	r2, r3
 800cf54:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800cf56:	801a      	strh	r2, [r3, #0]
 800cf58:	e01c      	b.n	800cf94 <HAL_PCD_EP_DB_Transmit+0x37c>
 800cf5a:	68bb      	ldr	r3, [r7, #8]
 800cf5c:	785b      	ldrb	r3, [r3, #1]
 800cf5e:	2b01      	cmp	r3, #1
 800cf60:	d118      	bne.n	800cf94 <HAL_PCD_EP_DB_Transmit+0x37c>
 800cf62:	68fb      	ldr	r3, [r7, #12]
 800cf64:	681b      	ldr	r3, [r3, #0]
 800cf66:	643b      	str	r3, [r7, #64]	; 0x40
 800cf68:	68fb      	ldr	r3, [r7, #12]
 800cf6a:	681b      	ldr	r3, [r3, #0]
 800cf6c:	2250      	movs	r2, #80	; 0x50
 800cf6e:	5a9b      	ldrh	r3, [r3, r2]
 800cf70:	b29b      	uxth	r3, r3
 800cf72:	001a      	movs	r2, r3
 800cf74:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800cf76:	189b      	adds	r3, r3, r2
 800cf78:	643b      	str	r3, [r7, #64]	; 0x40
 800cf7a:	68bb      	ldr	r3, [r7, #8]
 800cf7c:	781b      	ldrb	r3, [r3, #0]
 800cf7e:	00da      	lsls	r2, r3, #3
 800cf80:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800cf82:	18d3      	adds	r3, r2, r3
 800cf84:	4a09      	ldr	r2, [pc, #36]	; (800cfac <HAL_PCD_EP_DB_Transmit+0x394>)
 800cf86:	4694      	mov	ip, r2
 800cf88:	4463      	add	r3, ip
 800cf8a:	63fb      	str	r3, [r7, #60]	; 0x3c
 800cf8c:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800cf8e:	b29a      	uxth	r2, r3
 800cf90:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800cf92:	801a      	strh	r2, [r3, #0]

        /* Copy user buffer to USB PMA */
        USB_WritePMA(hpcd->Instance, ep->xfer_buff,  ep->pmaaddr0, (uint16_t)len);
 800cf94:	68fb      	ldr	r3, [r7, #12]
 800cf96:	6818      	ldr	r0, [r3, #0]
 800cf98:	68bb      	ldr	r3, [r7, #8]
 800cf9a:	6959      	ldr	r1, [r3, #20]
 800cf9c:	68bb      	ldr	r3, [r7, #8]
 800cf9e:	891a      	ldrh	r2, [r3, #8]
 800cfa0:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800cfa2:	b29b      	uxth	r3, r3
 800cfa4:	f004 fc86 	bl	80118b4 <USB_WritePMA>
 800cfa8:	e1de      	b.n	800d368 <HAL_PCD_EP_DB_Transmit+0x750>
 800cfaa:	46c0      	nop			; (mov r8, r8)
 800cfac:	00000402 	.word	0x00000402
 800cfb0:	ffff83ff 	.word	0xffff83ff
 800cfb4:	ffff8000 	.word	0xffff8000
 800cfb8:	00000406 	.word	0x00000406
 800cfbc:	ffff8f8f 	.word	0xffff8f8f
 800cfc0:	ffffc080 	.word	0xffffc080
    }
  }
  else /* Data Buffer1 ACK received */
  {
    /* multi-packet on the NON control IN endpoint */
    TxByteNbre = (uint16_t)PCD_GET_EP_DBUF1_CNT(hpcd->Instance, ep->num);
 800cfc4:	68fb      	ldr	r3, [r7, #12]
 800cfc6:	681b      	ldr	r3, [r3, #0]
 800cfc8:	2250      	movs	r2, #80	; 0x50
 800cfca:	5a9b      	ldrh	r3, [r3, r2]
 800cfcc:	b29b      	uxth	r3, r3
 800cfce:	001a      	movs	r2, r3
 800cfd0:	68bb      	ldr	r3, [r7, #8]
 800cfd2:	781b      	ldrb	r3, [r3, #0]
 800cfd4:	00db      	lsls	r3, r3, #3
 800cfd6:	18d2      	adds	r2, r2, r3
 800cfd8:	68fb      	ldr	r3, [r7, #12]
 800cfda:	681b      	ldr	r3, [r3, #0]
 800cfdc:	18d3      	adds	r3, r2, r3
 800cfde:	4aca      	ldr	r2, [pc, #808]	; (800d308 <HAL_PCD_EP_DB_Transmit+0x6f0>)
 800cfe0:	4694      	mov	ip, r2
 800cfe2:	4463      	add	r3, ip
 800cfe4:	881a      	ldrh	r2, [r3, #0]
 800cfe6:	214e      	movs	r1, #78	; 0x4e
 800cfe8:	187b      	adds	r3, r7, r1
 800cfea:	0592      	lsls	r2, r2, #22
 800cfec:	0d92      	lsrs	r2, r2, #22
 800cfee:	801a      	strh	r2, [r3, #0]

    if (ep->xfer_len >= TxByteNbre)
 800cff0:	68bb      	ldr	r3, [r7, #8]
 800cff2:	699a      	ldr	r2, [r3, #24]
 800cff4:	187b      	adds	r3, r7, r1
 800cff6:	881b      	ldrh	r3, [r3, #0]
 800cff8:	429a      	cmp	r2, r3
 800cffa:	d307      	bcc.n	800d00c <HAL_PCD_EP_DB_Transmit+0x3f4>
    {
      ep->xfer_len -= TxByteNbre;
 800cffc:	68bb      	ldr	r3, [r7, #8]
 800cffe:	699a      	ldr	r2, [r3, #24]
 800d000:	187b      	adds	r3, r7, r1
 800d002:	881b      	ldrh	r3, [r3, #0]
 800d004:	1ad2      	subs	r2, r2, r3
 800d006:	68bb      	ldr	r3, [r7, #8]
 800d008:	619a      	str	r2, [r3, #24]
 800d00a:	e002      	b.n	800d012 <HAL_PCD_EP_DB_Transmit+0x3fa>
    }
    else
    {
      ep->xfer_len = 0U;
 800d00c:	68bb      	ldr	r3, [r7, #8]
 800d00e:	2200      	movs	r2, #0
 800d010:	619a      	str	r2, [r3, #24]
    }

    /* Transfer is completed */
    if (ep->xfer_len == 0U)
 800d012:	68bb      	ldr	r3, [r7, #8]
 800d014:	699b      	ldr	r3, [r3, #24]
 800d016:	2b00      	cmp	r3, #0
 800d018:	d000      	beq.n	800d01c <HAL_PCD_EP_DB_Transmit+0x404>
 800d01a:	e0c0      	b.n	800d19e <HAL_PCD_EP_DB_Transmit+0x586>
    {
      PCD_SET_EP_DBUF0_CNT(hpcd->Instance, ep->num, ep->is_in, 0U);
 800d01c:	68bb      	ldr	r3, [r7, #8]
 800d01e:	785b      	ldrb	r3, [r3, #1]
 800d020:	2b00      	cmp	r3, #0
 800d022:	d125      	bne.n	800d070 <HAL_PCD_EP_DB_Transmit+0x458>
 800d024:	68fb      	ldr	r3, [r7, #12]
 800d026:	681b      	ldr	r3, [r3, #0]
 800d028:	66fb      	str	r3, [r7, #108]	; 0x6c
 800d02a:	68fb      	ldr	r3, [r7, #12]
 800d02c:	681b      	ldr	r3, [r3, #0]
 800d02e:	2250      	movs	r2, #80	; 0x50
 800d030:	5a9b      	ldrh	r3, [r3, r2]
 800d032:	b29b      	uxth	r3, r3
 800d034:	001a      	movs	r2, r3
 800d036:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800d038:	189b      	adds	r3, r3, r2
 800d03a:	66fb      	str	r3, [r7, #108]	; 0x6c
 800d03c:	68bb      	ldr	r3, [r7, #8]
 800d03e:	781b      	ldrb	r3, [r3, #0]
 800d040:	00da      	lsls	r2, r3, #3
 800d042:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800d044:	18d3      	adds	r3, r2, r3
 800d046:	4ab1      	ldr	r2, [pc, #708]	; (800d30c <HAL_PCD_EP_DB_Transmit+0x6f4>)
 800d048:	4694      	mov	ip, r2
 800d04a:	4463      	add	r3, ip
 800d04c:	66bb      	str	r3, [r7, #104]	; 0x68
 800d04e:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800d050:	881b      	ldrh	r3, [r3, #0]
 800d052:	b29b      	uxth	r3, r3
 800d054:	4aae      	ldr	r2, [pc, #696]	; (800d310 <HAL_PCD_EP_DB_Transmit+0x6f8>)
 800d056:	4013      	ands	r3, r2
 800d058:	b29a      	uxth	r2, r3
 800d05a:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800d05c:	801a      	strh	r2, [r3, #0]
 800d05e:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800d060:	881b      	ldrh	r3, [r3, #0]
 800d062:	b29b      	uxth	r3, r3
 800d064:	4aab      	ldr	r2, [pc, #684]	; (800d314 <HAL_PCD_EP_DB_Transmit+0x6fc>)
 800d066:	4313      	orrs	r3, r2
 800d068:	b29a      	uxth	r2, r3
 800d06a:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800d06c:	801a      	strh	r2, [r3, #0]
 800d06e:	e01b      	b.n	800d0a8 <HAL_PCD_EP_DB_Transmit+0x490>
 800d070:	68bb      	ldr	r3, [r7, #8]
 800d072:	785b      	ldrb	r3, [r3, #1]
 800d074:	2b01      	cmp	r3, #1
 800d076:	d117      	bne.n	800d0a8 <HAL_PCD_EP_DB_Transmit+0x490>
 800d078:	68fb      	ldr	r3, [r7, #12]
 800d07a:	681b      	ldr	r3, [r3, #0]
 800d07c:	677b      	str	r3, [r7, #116]	; 0x74
 800d07e:	68fb      	ldr	r3, [r7, #12]
 800d080:	681b      	ldr	r3, [r3, #0]
 800d082:	2250      	movs	r2, #80	; 0x50
 800d084:	5a9b      	ldrh	r3, [r3, r2]
 800d086:	b29b      	uxth	r3, r3
 800d088:	001a      	movs	r2, r3
 800d08a:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800d08c:	189b      	adds	r3, r3, r2
 800d08e:	677b      	str	r3, [r7, #116]	; 0x74
 800d090:	68bb      	ldr	r3, [r7, #8]
 800d092:	781b      	ldrb	r3, [r3, #0]
 800d094:	00da      	lsls	r2, r3, #3
 800d096:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800d098:	18d3      	adds	r3, r2, r3
 800d09a:	4a9c      	ldr	r2, [pc, #624]	; (800d30c <HAL_PCD_EP_DB_Transmit+0x6f4>)
 800d09c:	4694      	mov	ip, r2
 800d09e:	4463      	add	r3, ip
 800d0a0:	673b      	str	r3, [r7, #112]	; 0x70
 800d0a2:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 800d0a4:	2200      	movs	r2, #0
 800d0a6:	801a      	strh	r2, [r3, #0]
      PCD_SET_EP_DBUF1_CNT(hpcd->Instance, ep->num, ep->is_in, 0U);
 800d0a8:	68fb      	ldr	r3, [r7, #12]
 800d0aa:	681b      	ldr	r3, [r3, #0]
 800d0ac:	67bb      	str	r3, [r7, #120]	; 0x78
 800d0ae:	68bb      	ldr	r3, [r7, #8]
 800d0b0:	785b      	ldrb	r3, [r3, #1]
 800d0b2:	2b00      	cmp	r3, #0
 800d0b4:	d130      	bne.n	800d118 <HAL_PCD_EP_DB_Transmit+0x500>
 800d0b6:	68fb      	ldr	r3, [r7, #12]
 800d0b8:	681b      	ldr	r3, [r3, #0]
 800d0ba:	2180      	movs	r1, #128	; 0x80
 800d0bc:	187a      	adds	r2, r7, r1
 800d0be:	6013      	str	r3, [r2, #0]
 800d0c0:	68fb      	ldr	r3, [r7, #12]
 800d0c2:	681b      	ldr	r3, [r3, #0]
 800d0c4:	2250      	movs	r2, #80	; 0x50
 800d0c6:	5a9b      	ldrh	r3, [r3, r2]
 800d0c8:	b29b      	uxth	r3, r3
 800d0ca:	001a      	movs	r2, r3
 800d0cc:	187b      	adds	r3, r7, r1
 800d0ce:	681b      	ldr	r3, [r3, #0]
 800d0d0:	189b      	adds	r3, r3, r2
 800d0d2:	187a      	adds	r2, r7, r1
 800d0d4:	6013      	str	r3, [r2, #0]
 800d0d6:	68bb      	ldr	r3, [r7, #8]
 800d0d8:	781b      	ldrb	r3, [r3, #0]
 800d0da:	00da      	lsls	r2, r3, #3
 800d0dc:	187b      	adds	r3, r7, r1
 800d0de:	681b      	ldr	r3, [r3, #0]
 800d0e0:	18d3      	adds	r3, r2, r3
 800d0e2:	4a89      	ldr	r2, [pc, #548]	; (800d308 <HAL_PCD_EP_DB_Transmit+0x6f0>)
 800d0e4:	4694      	mov	ip, r2
 800d0e6:	4463      	add	r3, ip
 800d0e8:	2184      	movs	r1, #132	; 0x84
 800d0ea:	187a      	adds	r2, r7, r1
 800d0ec:	6013      	str	r3, [r2, #0]
 800d0ee:	187b      	adds	r3, r7, r1
 800d0f0:	681b      	ldr	r3, [r3, #0]
 800d0f2:	881b      	ldrh	r3, [r3, #0]
 800d0f4:	b29b      	uxth	r3, r3
 800d0f6:	4a86      	ldr	r2, [pc, #536]	; (800d310 <HAL_PCD_EP_DB_Transmit+0x6f8>)
 800d0f8:	4013      	ands	r3, r2
 800d0fa:	b29a      	uxth	r2, r3
 800d0fc:	187b      	adds	r3, r7, r1
 800d0fe:	681b      	ldr	r3, [r3, #0]
 800d100:	801a      	strh	r2, [r3, #0]
 800d102:	187b      	adds	r3, r7, r1
 800d104:	681b      	ldr	r3, [r3, #0]
 800d106:	881b      	ldrh	r3, [r3, #0]
 800d108:	b29b      	uxth	r3, r3
 800d10a:	4a82      	ldr	r2, [pc, #520]	; (800d314 <HAL_PCD_EP_DB_Transmit+0x6fc>)
 800d10c:	4313      	orrs	r3, r2
 800d10e:	b29a      	uxth	r2, r3
 800d110:	187b      	adds	r3, r7, r1
 800d112:	681b      	ldr	r3, [r3, #0]
 800d114:	801a      	strh	r2, [r3, #0]
 800d116:	e018      	b.n	800d14a <HAL_PCD_EP_DB_Transmit+0x532>
 800d118:	68bb      	ldr	r3, [r7, #8]
 800d11a:	785b      	ldrb	r3, [r3, #1]
 800d11c:	2b01      	cmp	r3, #1
 800d11e:	d114      	bne.n	800d14a <HAL_PCD_EP_DB_Transmit+0x532>
 800d120:	68fb      	ldr	r3, [r7, #12]
 800d122:	681b      	ldr	r3, [r3, #0]
 800d124:	2250      	movs	r2, #80	; 0x50
 800d126:	5a9b      	ldrh	r3, [r3, r2]
 800d128:	b29b      	uxth	r3, r3
 800d12a:	001a      	movs	r2, r3
 800d12c:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 800d12e:	189b      	adds	r3, r3, r2
 800d130:	67bb      	str	r3, [r7, #120]	; 0x78
 800d132:	68bb      	ldr	r3, [r7, #8]
 800d134:	781b      	ldrb	r3, [r3, #0]
 800d136:	00da      	lsls	r2, r3, #3
 800d138:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 800d13a:	18d3      	adds	r3, r2, r3
 800d13c:	4a72      	ldr	r2, [pc, #456]	; (800d308 <HAL_PCD_EP_DB_Transmit+0x6f0>)
 800d13e:	4694      	mov	ip, r2
 800d140:	4463      	add	r3, ip
 800d142:	67fb      	str	r3, [r7, #124]	; 0x7c
 800d144:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 800d146:	2200      	movs	r2, #0
 800d148:	801a      	strh	r2, [r3, #0]

      /* TX COMPLETE */
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
      hpcd->DataInStageCallback(hpcd, ep->num);
#else
      HAL_PCD_DataInStageCallback(hpcd, ep->num);
 800d14a:	68bb      	ldr	r3, [r7, #8]
 800d14c:	781a      	ldrb	r2, [r3, #0]
 800d14e:	68fb      	ldr	r3, [r7, #12]
 800d150:	0011      	movs	r1, r2
 800d152:	0018      	movs	r0, r3
 800d154:	f007 fc2a 	bl	80149ac <HAL_PCD_DataInStageCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */

      /* need to Free USB Buff */
      if ((wEPVal & USB_EP_DTOG_RX) == 0U)
 800d158:	1dbb      	adds	r3, r7, #6
 800d15a:	881a      	ldrh	r2, [r3, #0]
 800d15c:	2380      	movs	r3, #128	; 0x80
 800d15e:	01db      	lsls	r3, r3, #7
 800d160:	4013      	ands	r3, r2
 800d162:	d000      	beq.n	800d166 <HAL_PCD_EP_DB_Transmit+0x54e>
 800d164:	e100      	b.n	800d368 <HAL_PCD_EP_DB_Transmit+0x750>
      {
        PCD_FreeUserBuffer(hpcd->Instance, ep->num, 1U);
 800d166:	68fb      	ldr	r3, [r7, #12]
 800d168:	681b      	ldr	r3, [r3, #0]
 800d16a:	001a      	movs	r2, r3
 800d16c:	68bb      	ldr	r3, [r7, #8]
 800d16e:	781b      	ldrb	r3, [r3, #0]
 800d170:	009b      	lsls	r3, r3, #2
 800d172:	18d3      	adds	r3, r2, r3
 800d174:	881b      	ldrh	r3, [r3, #0]
 800d176:	b29a      	uxth	r2, r3
 800d178:	2046      	movs	r0, #70	; 0x46
 800d17a:	183b      	adds	r3, r7, r0
 800d17c:	4966      	ldr	r1, [pc, #408]	; (800d318 <HAL_PCD_EP_DB_Transmit+0x700>)
 800d17e:	400a      	ands	r2, r1
 800d180:	801a      	strh	r2, [r3, #0]
 800d182:	68fb      	ldr	r3, [r7, #12]
 800d184:	681b      	ldr	r3, [r3, #0]
 800d186:	001a      	movs	r2, r3
 800d188:	68bb      	ldr	r3, [r7, #8]
 800d18a:	781b      	ldrb	r3, [r3, #0]
 800d18c:	009b      	lsls	r3, r3, #2
 800d18e:	18d3      	adds	r3, r2, r3
 800d190:	183a      	adds	r2, r7, r0
 800d192:	8812      	ldrh	r2, [r2, #0]
 800d194:	4961      	ldr	r1, [pc, #388]	; (800d31c <HAL_PCD_EP_DB_Transmit+0x704>)
 800d196:	430a      	orrs	r2, r1
 800d198:	b292      	uxth	r2, r2
 800d19a:	801a      	strh	r2, [r3, #0]
 800d19c:	e0e4      	b.n	800d368 <HAL_PCD_EP_DB_Transmit+0x750>
      }
    }
    else /* Transfer is not yet Done */
    {
      /* need to Free USB Buff */
      if ((wEPVal & USB_EP_DTOG_RX) == 0U)
 800d19e:	1dbb      	adds	r3, r7, #6
 800d1a0:	881a      	ldrh	r2, [r3, #0]
 800d1a2:	2380      	movs	r3, #128	; 0x80
 800d1a4:	01db      	lsls	r3, r3, #7
 800d1a6:	4013      	ands	r3, r2
 800d1a8:	d11a      	bne.n	800d1e0 <HAL_PCD_EP_DB_Transmit+0x5c8>
      {
        PCD_FreeUserBuffer(hpcd->Instance, ep->num, 1U);
 800d1aa:	68fb      	ldr	r3, [r7, #12]
 800d1ac:	681b      	ldr	r3, [r3, #0]
 800d1ae:	001a      	movs	r2, r3
 800d1b0:	68bb      	ldr	r3, [r7, #8]
 800d1b2:	781b      	ldrb	r3, [r3, #0]
 800d1b4:	009b      	lsls	r3, r3, #2
 800d1b6:	18d3      	adds	r3, r2, r3
 800d1b8:	881b      	ldrh	r3, [r3, #0]
 800d1ba:	b29a      	uxth	r2, r3
 800d1bc:	204c      	movs	r0, #76	; 0x4c
 800d1be:	183b      	adds	r3, r7, r0
 800d1c0:	4955      	ldr	r1, [pc, #340]	; (800d318 <HAL_PCD_EP_DB_Transmit+0x700>)
 800d1c2:	400a      	ands	r2, r1
 800d1c4:	801a      	strh	r2, [r3, #0]
 800d1c6:	68fb      	ldr	r3, [r7, #12]
 800d1c8:	681b      	ldr	r3, [r3, #0]
 800d1ca:	001a      	movs	r2, r3
 800d1cc:	68bb      	ldr	r3, [r7, #8]
 800d1ce:	781b      	ldrb	r3, [r3, #0]
 800d1d0:	009b      	lsls	r3, r3, #2
 800d1d2:	18d3      	adds	r3, r2, r3
 800d1d4:	183a      	adds	r2, r7, r0
 800d1d6:	8812      	ldrh	r2, [r2, #0]
 800d1d8:	4950      	ldr	r1, [pc, #320]	; (800d31c <HAL_PCD_EP_DB_Transmit+0x704>)
 800d1da:	430a      	orrs	r2, r1
 800d1dc:	b292      	uxth	r2, r2
 800d1de:	801a      	strh	r2, [r3, #0]
      }

      /* Still there is data to Fill in the next Buffer */
      if (ep->xfer_fill_db == 1U)
 800d1e0:	68bb      	ldr	r3, [r7, #8]
 800d1e2:	2224      	movs	r2, #36	; 0x24
 800d1e4:	5c9b      	ldrb	r3, [r3, r2]
 800d1e6:	2b01      	cmp	r3, #1
 800d1e8:	d000      	beq.n	800d1ec <HAL_PCD_EP_DB_Transmit+0x5d4>
 800d1ea:	e0bd      	b.n	800d368 <HAL_PCD_EP_DB_Transmit+0x750>
      {
        ep->xfer_buff += TxByteNbre;
 800d1ec:	68bb      	ldr	r3, [r7, #8]
 800d1ee:	695a      	ldr	r2, [r3, #20]
 800d1f0:	214e      	movs	r1, #78	; 0x4e
 800d1f2:	187b      	adds	r3, r7, r1
 800d1f4:	881b      	ldrh	r3, [r3, #0]
 800d1f6:	18d2      	adds	r2, r2, r3
 800d1f8:	68bb      	ldr	r3, [r7, #8]
 800d1fa:	615a      	str	r2, [r3, #20]
        ep->xfer_count += TxByteNbre;
 800d1fc:	68bb      	ldr	r3, [r7, #8]
 800d1fe:	69da      	ldr	r2, [r3, #28]
 800d200:	187b      	adds	r3, r7, r1
 800d202:	881b      	ldrh	r3, [r3, #0]
 800d204:	18d2      	adds	r2, r2, r3
 800d206:	68bb      	ldr	r3, [r7, #8]
 800d208:	61da      	str	r2, [r3, #28]

        /* Calculate the len of the new buffer to fill */
        if (ep->xfer_len_db >= ep->maxpacket)
 800d20a:	68bb      	ldr	r3, [r7, #8]
 800d20c:	6a1a      	ldr	r2, [r3, #32]
 800d20e:	68bb      	ldr	r3, [r7, #8]
 800d210:	691b      	ldr	r3, [r3, #16]
 800d212:	429a      	cmp	r2, r3
 800d214:	d309      	bcc.n	800d22a <HAL_PCD_EP_DB_Transmit+0x612>
        {
          len = ep->maxpacket;
 800d216:	68bb      	ldr	r3, [r7, #8]
 800d218:	691b      	ldr	r3, [r3, #16]
 800d21a:	653b      	str	r3, [r7, #80]	; 0x50
          ep->xfer_len_db -= len;
 800d21c:	68bb      	ldr	r3, [r7, #8]
 800d21e:	6a1a      	ldr	r2, [r3, #32]
 800d220:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800d222:	1ad2      	subs	r2, r2, r3
 800d224:	68bb      	ldr	r3, [r7, #8]
 800d226:	621a      	str	r2, [r3, #32]
 800d228:	e016      	b.n	800d258 <HAL_PCD_EP_DB_Transmit+0x640>
        }
        else if (ep->xfer_len_db == 0U)
 800d22a:	68bb      	ldr	r3, [r7, #8]
 800d22c:	6a1b      	ldr	r3, [r3, #32]
 800d22e:	2b00      	cmp	r3, #0
 800d230:	d108      	bne.n	800d244 <HAL_PCD_EP_DB_Transmit+0x62c>
        {
          len = TxByteNbre;
 800d232:	234e      	movs	r3, #78	; 0x4e
 800d234:	18fb      	adds	r3, r7, r3
 800d236:	881b      	ldrh	r3, [r3, #0]
 800d238:	653b      	str	r3, [r7, #80]	; 0x50
          ep->xfer_fill_db = 0U;
 800d23a:	68bb      	ldr	r3, [r7, #8]
 800d23c:	2224      	movs	r2, #36	; 0x24
 800d23e:	2100      	movs	r1, #0
 800d240:	5499      	strb	r1, [r3, r2]
 800d242:	e009      	b.n	800d258 <HAL_PCD_EP_DB_Transmit+0x640>
        }
        else
        {
          len = ep->xfer_len_db;
 800d244:	68bb      	ldr	r3, [r7, #8]
 800d246:	6a1b      	ldr	r3, [r3, #32]
 800d248:	653b      	str	r3, [r7, #80]	; 0x50
          ep->xfer_len_db = 0U;
 800d24a:	68bb      	ldr	r3, [r7, #8]
 800d24c:	2200      	movs	r2, #0
 800d24e:	621a      	str	r2, [r3, #32]
          ep->xfer_fill_db = 0;
 800d250:	68bb      	ldr	r3, [r7, #8]
 800d252:	2224      	movs	r2, #36	; 0x24
 800d254:	2100      	movs	r1, #0
 800d256:	5499      	strb	r1, [r3, r2]
        }

        /* Set the Double buffer counter for pmabuffer1 */
        PCD_SET_EP_DBUF1_CNT(hpcd->Instance, ep->num, ep->is_in, len);
 800d258:	68fb      	ldr	r3, [r7, #12]
 800d25a:	681b      	ldr	r3, [r3, #0]
 800d25c:	667b      	str	r3, [r7, #100]	; 0x64
 800d25e:	68bb      	ldr	r3, [r7, #8]
 800d260:	785b      	ldrb	r3, [r3, #1]
 800d262:	2b00      	cmp	r3, #0
 800d264:	d15c      	bne.n	800d320 <HAL_PCD_EP_DB_Transmit+0x708>
 800d266:	68fb      	ldr	r3, [r7, #12]
 800d268:	681b      	ldr	r3, [r3, #0]
 800d26a:	65fb      	str	r3, [r7, #92]	; 0x5c
 800d26c:	68fb      	ldr	r3, [r7, #12]
 800d26e:	681b      	ldr	r3, [r3, #0]
 800d270:	2250      	movs	r2, #80	; 0x50
 800d272:	5a9b      	ldrh	r3, [r3, r2]
 800d274:	b29b      	uxth	r3, r3
 800d276:	001a      	movs	r2, r3
 800d278:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800d27a:	189b      	adds	r3, r3, r2
 800d27c:	65fb      	str	r3, [r7, #92]	; 0x5c
 800d27e:	68bb      	ldr	r3, [r7, #8]
 800d280:	781b      	ldrb	r3, [r3, #0]
 800d282:	00da      	lsls	r2, r3, #3
 800d284:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800d286:	18d3      	adds	r3, r2, r3
 800d288:	4a1f      	ldr	r2, [pc, #124]	; (800d308 <HAL_PCD_EP_DB_Transmit+0x6f0>)
 800d28a:	4694      	mov	ip, r2
 800d28c:	4463      	add	r3, ip
 800d28e:	65bb      	str	r3, [r7, #88]	; 0x58
 800d290:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800d292:	2b00      	cmp	r3, #0
 800d294:	d110      	bne.n	800d2b8 <HAL_PCD_EP_DB_Transmit+0x6a0>
 800d296:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800d298:	881b      	ldrh	r3, [r3, #0]
 800d29a:	b29b      	uxth	r3, r3
 800d29c:	4a1c      	ldr	r2, [pc, #112]	; (800d310 <HAL_PCD_EP_DB_Transmit+0x6f8>)
 800d29e:	4013      	ands	r3, r2
 800d2a0:	b29a      	uxth	r2, r3
 800d2a2:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800d2a4:	801a      	strh	r2, [r3, #0]
 800d2a6:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800d2a8:	881b      	ldrh	r3, [r3, #0]
 800d2aa:	b29b      	uxth	r3, r3
 800d2ac:	4a19      	ldr	r2, [pc, #100]	; (800d314 <HAL_PCD_EP_DB_Transmit+0x6fc>)
 800d2ae:	4313      	orrs	r3, r2
 800d2b0:	b29a      	uxth	r2, r3
 800d2b2:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800d2b4:	801a      	strh	r2, [r3, #0]
 800d2b6:	e04d      	b.n	800d354 <HAL_PCD_EP_DB_Transmit+0x73c>
 800d2b8:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800d2ba:	2b3e      	cmp	r3, #62	; 0x3e
 800d2bc:	d810      	bhi.n	800d2e0 <HAL_PCD_EP_DB_Transmit+0x6c8>
 800d2be:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800d2c0:	085b      	lsrs	r3, r3, #1
 800d2c2:	657b      	str	r3, [r7, #84]	; 0x54
 800d2c4:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800d2c6:	2201      	movs	r2, #1
 800d2c8:	4013      	ands	r3, r2
 800d2ca:	d002      	beq.n	800d2d2 <HAL_PCD_EP_DB_Transmit+0x6ba>
 800d2cc:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800d2ce:	3301      	adds	r3, #1
 800d2d0:	657b      	str	r3, [r7, #84]	; 0x54
 800d2d2:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800d2d4:	b29b      	uxth	r3, r3
 800d2d6:	029b      	lsls	r3, r3, #10
 800d2d8:	b29a      	uxth	r2, r3
 800d2da:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800d2dc:	801a      	strh	r2, [r3, #0]
 800d2de:	e039      	b.n	800d354 <HAL_PCD_EP_DB_Transmit+0x73c>
 800d2e0:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800d2e2:	095b      	lsrs	r3, r3, #5
 800d2e4:	657b      	str	r3, [r7, #84]	; 0x54
 800d2e6:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800d2e8:	221f      	movs	r2, #31
 800d2ea:	4013      	ands	r3, r2
 800d2ec:	d102      	bne.n	800d2f4 <HAL_PCD_EP_DB_Transmit+0x6dc>
 800d2ee:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800d2f0:	3b01      	subs	r3, #1
 800d2f2:	657b      	str	r3, [r7, #84]	; 0x54
 800d2f4:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800d2f6:	b29b      	uxth	r3, r3
 800d2f8:	029b      	lsls	r3, r3, #10
 800d2fa:	b29b      	uxth	r3, r3
 800d2fc:	4a05      	ldr	r2, [pc, #20]	; (800d314 <HAL_PCD_EP_DB_Transmit+0x6fc>)
 800d2fe:	4313      	orrs	r3, r2
 800d300:	b29a      	uxth	r2, r3
 800d302:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800d304:	801a      	strh	r2, [r3, #0]
 800d306:	e025      	b.n	800d354 <HAL_PCD_EP_DB_Transmit+0x73c>
 800d308:	00000406 	.word	0x00000406
 800d30c:	00000402 	.word	0x00000402
 800d310:	ffff83ff 	.word	0xffff83ff
 800d314:	ffff8000 	.word	0xffff8000
 800d318:	ffff8f8f 	.word	0xffff8f8f
 800d31c:	ffffc080 	.word	0xffffc080
 800d320:	68bb      	ldr	r3, [r7, #8]
 800d322:	785b      	ldrb	r3, [r3, #1]
 800d324:	2b01      	cmp	r3, #1
 800d326:	d115      	bne.n	800d354 <HAL_PCD_EP_DB_Transmit+0x73c>
 800d328:	68fb      	ldr	r3, [r7, #12]
 800d32a:	681b      	ldr	r3, [r3, #0]
 800d32c:	2250      	movs	r2, #80	; 0x50
 800d32e:	5a9b      	ldrh	r3, [r3, r2]
 800d330:	b29b      	uxth	r3, r3
 800d332:	001a      	movs	r2, r3
 800d334:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800d336:	189b      	adds	r3, r3, r2
 800d338:	667b      	str	r3, [r7, #100]	; 0x64
 800d33a:	68bb      	ldr	r3, [r7, #8]
 800d33c:	781b      	ldrb	r3, [r3, #0]
 800d33e:	00da      	lsls	r2, r3, #3
 800d340:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800d342:	18d3      	adds	r3, r2, r3
 800d344:	4a1e      	ldr	r2, [pc, #120]	; (800d3c0 <HAL_PCD_EP_DB_Transmit+0x7a8>)
 800d346:	4694      	mov	ip, r2
 800d348:	4463      	add	r3, ip
 800d34a:	663b      	str	r3, [r7, #96]	; 0x60
 800d34c:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800d34e:	b29a      	uxth	r2, r3
 800d350:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800d352:	801a      	strh	r2, [r3, #0]

        /* Copy the user buffer to USB PMA */
        USB_WritePMA(hpcd->Instance, ep->xfer_buff,  ep->pmaaddr1, (uint16_t)len);
 800d354:	68fb      	ldr	r3, [r7, #12]
 800d356:	6818      	ldr	r0, [r3, #0]
 800d358:	68bb      	ldr	r3, [r7, #8]
 800d35a:	6959      	ldr	r1, [r3, #20]
 800d35c:	68bb      	ldr	r3, [r7, #8]
 800d35e:	895a      	ldrh	r2, [r3, #10]
 800d360:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800d362:	b29b      	uxth	r3, r3
 800d364:	f004 faa6 	bl	80118b4 <USB_WritePMA>
      }
    }
  }

  /*enable endpoint IN*/
  PCD_SET_EP_TX_STATUS(hpcd->Instance, ep->num, USB_EP_TX_VALID);
 800d368:	68fb      	ldr	r3, [r7, #12]
 800d36a:	681b      	ldr	r3, [r3, #0]
 800d36c:	001a      	movs	r2, r3
 800d36e:	68bb      	ldr	r3, [r7, #8]
 800d370:	781b      	ldrb	r3, [r3, #0]
 800d372:	009b      	lsls	r3, r3, #2
 800d374:	18d3      	adds	r3, r2, r3
 800d376:	881b      	ldrh	r3, [r3, #0]
 800d378:	b29a      	uxth	r2, r3
 800d37a:	2010      	movs	r0, #16
 800d37c:	183b      	adds	r3, r7, r0
 800d37e:	4911      	ldr	r1, [pc, #68]	; (800d3c4 <HAL_PCD_EP_DB_Transmit+0x7ac>)
 800d380:	400a      	ands	r2, r1
 800d382:	801a      	strh	r2, [r3, #0]
 800d384:	183b      	adds	r3, r7, r0
 800d386:	183a      	adds	r2, r7, r0
 800d388:	8812      	ldrh	r2, [r2, #0]
 800d38a:	2110      	movs	r1, #16
 800d38c:	404a      	eors	r2, r1
 800d38e:	801a      	strh	r2, [r3, #0]
 800d390:	183b      	adds	r3, r7, r0
 800d392:	183a      	adds	r2, r7, r0
 800d394:	8812      	ldrh	r2, [r2, #0]
 800d396:	2120      	movs	r1, #32
 800d398:	404a      	eors	r2, r1
 800d39a:	801a      	strh	r2, [r3, #0]
 800d39c:	68fb      	ldr	r3, [r7, #12]
 800d39e:	681b      	ldr	r3, [r3, #0]
 800d3a0:	001a      	movs	r2, r3
 800d3a2:	68bb      	ldr	r3, [r7, #8]
 800d3a4:	781b      	ldrb	r3, [r3, #0]
 800d3a6:	009b      	lsls	r3, r3, #2
 800d3a8:	18d3      	adds	r3, r2, r3
 800d3aa:	183a      	adds	r2, r7, r0
 800d3ac:	8812      	ldrh	r2, [r2, #0]
 800d3ae:	4906      	ldr	r1, [pc, #24]	; (800d3c8 <HAL_PCD_EP_DB_Transmit+0x7b0>)
 800d3b0:	430a      	orrs	r2, r1
 800d3b2:	b292      	uxth	r2, r2
 800d3b4:	801a      	strh	r2, [r3, #0]

  return HAL_OK;
 800d3b6:	2300      	movs	r3, #0
}
 800d3b8:	0018      	movs	r0, r3
 800d3ba:	46bd      	mov	sp, r7
 800d3bc:	b022      	add	sp, #136	; 0x88
 800d3be:	bd80      	pop	{r7, pc}
 800d3c0:	00000406 	.word	0x00000406
 800d3c4:	ffff8fbf 	.word	0xffff8fbf
 800d3c8:	ffff8080 	.word	0xffff8080

0800d3cc <HAL_PCDEx_PMAConfig>:
  * @retval HAL status
  */

HAL_StatusTypeDef  HAL_PCDEx_PMAConfig(PCD_HandleTypeDef *hpcd, uint16_t ep_addr,
                                       uint16_t ep_kind, uint32_t pmaadress)
{
 800d3cc:	b590      	push	{r4, r7, lr}
 800d3ce:	b087      	sub	sp, #28
 800d3d0:	af00      	add	r7, sp, #0
 800d3d2:	60f8      	str	r0, [r7, #12]
 800d3d4:	0008      	movs	r0, r1
 800d3d6:	0011      	movs	r1, r2
 800d3d8:	607b      	str	r3, [r7, #4]
 800d3da:	240a      	movs	r4, #10
 800d3dc:	193b      	adds	r3, r7, r4
 800d3de:	1c02      	adds	r2, r0, #0
 800d3e0:	801a      	strh	r2, [r3, #0]
 800d3e2:	2308      	movs	r3, #8
 800d3e4:	18fb      	adds	r3, r7, r3
 800d3e6:	1c0a      	adds	r2, r1, #0
 800d3e8:	801a      	strh	r2, [r3, #0]
  PCD_EPTypeDef *ep;

  /* initialize ep structure*/
  if ((0x80U & ep_addr) == 0x80U)
 800d3ea:	0021      	movs	r1, r4
 800d3ec:	187b      	adds	r3, r7, r1
 800d3ee:	881b      	ldrh	r3, [r3, #0]
 800d3f0:	2280      	movs	r2, #128	; 0x80
 800d3f2:	4013      	ands	r3, r2
 800d3f4:	b29b      	uxth	r3, r3
 800d3f6:	2b00      	cmp	r3, #0
 800d3f8:	d00c      	beq.n	800d414 <HAL_PCDEx_PMAConfig+0x48>
  {
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 800d3fa:	187b      	adds	r3, r7, r1
 800d3fc:	881b      	ldrh	r3, [r3, #0]
 800d3fe:	2207      	movs	r2, #7
 800d400:	4013      	ands	r3, r2
 800d402:	1c5a      	adds	r2, r3, #1
 800d404:	0013      	movs	r3, r2
 800d406:	009b      	lsls	r3, r3, #2
 800d408:	189b      	adds	r3, r3, r2
 800d40a:	00db      	lsls	r3, r3, #3
 800d40c:	68fa      	ldr	r2, [r7, #12]
 800d40e:	18d3      	adds	r3, r2, r3
 800d410:	617b      	str	r3, [r7, #20]
 800d412:	e00b      	b.n	800d42c <HAL_PCDEx_PMAConfig+0x60>
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr];
 800d414:	230a      	movs	r3, #10
 800d416:	18fb      	adds	r3, r7, r3
 800d418:	881a      	ldrh	r2, [r3, #0]
 800d41a:	0013      	movs	r3, r2
 800d41c:	009b      	lsls	r3, r3, #2
 800d41e:	189b      	adds	r3, r3, r2
 800d420:	00db      	lsls	r3, r3, #3
 800d422:	3369      	adds	r3, #105	; 0x69
 800d424:	33ff      	adds	r3, #255	; 0xff
 800d426:	68fa      	ldr	r2, [r7, #12]
 800d428:	18d3      	adds	r3, r2, r3
 800d42a:	617b      	str	r3, [r7, #20]
  }

  /* Here we check if the endpoint is single or double Buffer*/
  if (ep_kind == PCD_SNG_BUF)
 800d42c:	2308      	movs	r3, #8
 800d42e:	18fb      	adds	r3, r7, r3
 800d430:	881b      	ldrh	r3, [r3, #0]
 800d432:	2b00      	cmp	r3, #0
 800d434:	d107      	bne.n	800d446 <HAL_PCDEx_PMAConfig+0x7a>
  {
    /* Single Buffer */
    ep->doublebuffer = 0U;
 800d436:	697b      	ldr	r3, [r7, #20]
 800d438:	2200      	movs	r2, #0
 800d43a:	731a      	strb	r2, [r3, #12]
    /* Configure the PMA */
    ep->pmaadress = (uint16_t)pmaadress;
 800d43c:	687b      	ldr	r3, [r7, #4]
 800d43e:	b29a      	uxth	r2, r3
 800d440:	697b      	ldr	r3, [r7, #20]
 800d442:	80da      	strh	r2, [r3, #6]
 800d444:	e00b      	b.n	800d45e <HAL_PCDEx_PMAConfig+0x92>
  }
  else /* USB_DBL_BUF */
  {
    /* Double Buffer Endpoint */
    ep->doublebuffer = 1U;
 800d446:	697b      	ldr	r3, [r7, #20]
 800d448:	2201      	movs	r2, #1
 800d44a:	731a      	strb	r2, [r3, #12]
    /* Configure the PMA */
    ep->pmaaddr0 = (uint16_t)(pmaadress & 0xFFFFU);
 800d44c:	687b      	ldr	r3, [r7, #4]
 800d44e:	b29a      	uxth	r2, r3
 800d450:	697b      	ldr	r3, [r7, #20]
 800d452:	811a      	strh	r2, [r3, #8]
    ep->pmaaddr1 = (uint16_t)((pmaadress & 0xFFFF0000U) >> 16);
 800d454:	687b      	ldr	r3, [r7, #4]
 800d456:	0c1b      	lsrs	r3, r3, #16
 800d458:	b29a      	uxth	r2, r3
 800d45a:	697b      	ldr	r3, [r7, #20]
 800d45c:	815a      	strh	r2, [r3, #10]
  }

  return HAL_OK;
 800d45e:	2300      	movs	r3, #0
}
 800d460:	0018      	movs	r0, r3
 800d462:	46bd      	mov	sp, r7
 800d464:	b007      	add	sp, #28
 800d466:	bd90      	pop	{r4, r7, pc}

0800d468 <HAL_PCDEx_ActivateLPM>:
  * @brief  Activate LPM feature.
  * @param  hpcd PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCDEx_ActivateLPM(PCD_HandleTypeDef *hpcd)
{
 800d468:	b580      	push	{r7, lr}
 800d46a:	b084      	sub	sp, #16
 800d46c:	af00      	add	r7, sp, #0
 800d46e:	6078      	str	r0, [r7, #4]

  USB_TypeDef *USBx = hpcd->Instance;
 800d470:	687b      	ldr	r3, [r7, #4]
 800d472:	681b      	ldr	r3, [r3, #0]
 800d474:	60fb      	str	r3, [r7, #12]
  hpcd->lpm_active = 1U;
 800d476:	687a      	ldr	r2, [r7, #4]
 800d478:	23ba      	movs	r3, #186	; 0xba
 800d47a:	009b      	lsls	r3, r3, #2
 800d47c:	2101      	movs	r1, #1
 800d47e:	50d1      	str	r1, [r2, r3]
  hpcd->LPM_State = LPM_L0;
 800d480:	687a      	ldr	r2, [r7, #4]
 800d482:	23b8      	movs	r3, #184	; 0xb8
 800d484:	009b      	lsls	r3, r3, #2
 800d486:	2100      	movs	r1, #0
 800d488:	54d1      	strb	r1, [r2, r3]

  USBx->LPMCSR |= USB_LPMCSR_LMPEN;
 800d48a:	68fb      	ldr	r3, [r7, #12]
 800d48c:	2254      	movs	r2, #84	; 0x54
 800d48e:	5a9b      	ldrh	r3, [r3, r2]
 800d490:	b29b      	uxth	r3, r3
 800d492:	2201      	movs	r2, #1
 800d494:	4313      	orrs	r3, r2
 800d496:	b299      	uxth	r1, r3
 800d498:	68fb      	ldr	r3, [r7, #12]
 800d49a:	2254      	movs	r2, #84	; 0x54
 800d49c:	5299      	strh	r1, [r3, r2]
  USBx->LPMCSR |= USB_LPMCSR_LPMACK;
 800d49e:	68fb      	ldr	r3, [r7, #12]
 800d4a0:	2254      	movs	r2, #84	; 0x54
 800d4a2:	5a9b      	ldrh	r3, [r3, r2]
 800d4a4:	b29b      	uxth	r3, r3
 800d4a6:	2202      	movs	r2, #2
 800d4a8:	4313      	orrs	r3, r2
 800d4aa:	b299      	uxth	r1, r3
 800d4ac:	68fb      	ldr	r3, [r7, #12]
 800d4ae:	2254      	movs	r2, #84	; 0x54
 800d4b0:	5299      	strh	r1, [r3, r2]

  return HAL_OK;
 800d4b2:	2300      	movs	r3, #0
}
 800d4b4:	0018      	movs	r0, r3
 800d4b6:	46bd      	mov	sp, r7
 800d4b8:	b004      	add	sp, #16
 800d4ba:	bd80      	pop	{r7, pc}

0800d4bc <HAL_PCDEx_LPM_Callback>:
  * @param  hpcd PCD handle
  * @param  msg LPM message
  * @retval HAL status
  */
__weak void HAL_PCDEx_LPM_Callback(PCD_HandleTypeDef *hpcd, PCD_LPM_MsgTypeDef msg)
{
 800d4bc:	b580      	push	{r7, lr}
 800d4be:	b082      	sub	sp, #8
 800d4c0:	af00      	add	r7, sp, #0
 800d4c2:	6078      	str	r0, [r7, #4]
 800d4c4:	000a      	movs	r2, r1
 800d4c6:	1cfb      	adds	r3, r7, #3
 800d4c8:	701a      	strb	r2, [r3, #0]
  UNUSED(msg);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_PCDEx_LPM_Callback could be implemented in the user file
   */
}
 800d4ca:	46c0      	nop			; (mov r8, r8)
 800d4cc:	46bd      	mov	sp, r7
 800d4ce:	b002      	add	sp, #8
 800d4d0:	bd80      	pop	{r7, pc}
	...

0800d4d4 <HAL_RCC_OscConfig>:
  *         supported by this macro. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 800d4d4:	b580      	push	{r7, lr}
 800d4d6:	b088      	sub	sp, #32
 800d4d8:	af00      	add	r7, sp, #0
 800d4da:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;
  uint32_t pll_config;
  uint32_t pll_config2;

  /* Check Null pointer */
  if(RCC_OscInitStruct == NULL)
 800d4dc:	687b      	ldr	r3, [r7, #4]
 800d4de:	2b00      	cmp	r3, #0
 800d4e0:	d102      	bne.n	800d4e8 <HAL_RCC_OscConfig+0x14>
  {
    return HAL_ERROR;
 800d4e2:	2301      	movs	r3, #1
 800d4e4:	f000 fb76 	bl	800dbd4 <HAL_RCC_OscConfig+0x700>

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));

  /*------------------------------- HSE Configuration ------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 800d4e8:	687b      	ldr	r3, [r7, #4]
 800d4ea:	681b      	ldr	r3, [r3, #0]
 800d4ec:	2201      	movs	r2, #1
 800d4ee:	4013      	ands	r3, r2
 800d4f0:	d100      	bne.n	800d4f4 <HAL_RCC_OscConfig+0x20>
 800d4f2:	e08e      	b.n	800d612 <HAL_RCC_OscConfig+0x13e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));

    /* When the HSE is used as system clock or clock source for PLL in these cases it is not allowed to be disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSE) 
 800d4f4:	4bc5      	ldr	r3, [pc, #788]	; (800d80c <HAL_RCC_OscConfig+0x338>)
 800d4f6:	685b      	ldr	r3, [r3, #4]
 800d4f8:	220c      	movs	r2, #12
 800d4fa:	4013      	ands	r3, r2
 800d4fc:	2b04      	cmp	r3, #4
 800d4fe:	d00e      	beq.n	800d51e <HAL_RCC_OscConfig+0x4a>
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSE)))
 800d500:	4bc2      	ldr	r3, [pc, #776]	; (800d80c <HAL_RCC_OscConfig+0x338>)
 800d502:	685b      	ldr	r3, [r3, #4]
 800d504:	220c      	movs	r2, #12
 800d506:	4013      	ands	r3, r2
 800d508:	2b08      	cmp	r3, #8
 800d50a:	d117      	bne.n	800d53c <HAL_RCC_OscConfig+0x68>
 800d50c:	4bbf      	ldr	r3, [pc, #764]	; (800d80c <HAL_RCC_OscConfig+0x338>)
 800d50e:	685a      	ldr	r2, [r3, #4]
 800d510:	23c0      	movs	r3, #192	; 0xc0
 800d512:	025b      	lsls	r3, r3, #9
 800d514:	401a      	ands	r2, r3
 800d516:	2380      	movs	r3, #128	; 0x80
 800d518:	025b      	lsls	r3, r3, #9
 800d51a:	429a      	cmp	r2, r3
 800d51c:	d10e      	bne.n	800d53c <HAL_RCC_OscConfig+0x68>
    {
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 800d51e:	4bbb      	ldr	r3, [pc, #748]	; (800d80c <HAL_RCC_OscConfig+0x338>)
 800d520:	681a      	ldr	r2, [r3, #0]
 800d522:	2380      	movs	r3, #128	; 0x80
 800d524:	029b      	lsls	r3, r3, #10
 800d526:	4013      	ands	r3, r2
 800d528:	d100      	bne.n	800d52c <HAL_RCC_OscConfig+0x58>
 800d52a:	e071      	b.n	800d610 <HAL_RCC_OscConfig+0x13c>
 800d52c:	687b      	ldr	r3, [r7, #4]
 800d52e:	685b      	ldr	r3, [r3, #4]
 800d530:	2b00      	cmp	r3, #0
 800d532:	d000      	beq.n	800d536 <HAL_RCC_OscConfig+0x62>
 800d534:	e06c      	b.n	800d610 <HAL_RCC_OscConfig+0x13c>
      {
        return HAL_ERROR;
 800d536:	2301      	movs	r3, #1
 800d538:	f000 fb4c 	bl	800dbd4 <HAL_RCC_OscConfig+0x700>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 800d53c:	687b      	ldr	r3, [r7, #4]
 800d53e:	685b      	ldr	r3, [r3, #4]
 800d540:	2b01      	cmp	r3, #1
 800d542:	d107      	bne.n	800d554 <HAL_RCC_OscConfig+0x80>
 800d544:	4bb1      	ldr	r3, [pc, #708]	; (800d80c <HAL_RCC_OscConfig+0x338>)
 800d546:	681a      	ldr	r2, [r3, #0]
 800d548:	4bb0      	ldr	r3, [pc, #704]	; (800d80c <HAL_RCC_OscConfig+0x338>)
 800d54a:	2180      	movs	r1, #128	; 0x80
 800d54c:	0249      	lsls	r1, r1, #9
 800d54e:	430a      	orrs	r2, r1
 800d550:	601a      	str	r2, [r3, #0]
 800d552:	e02f      	b.n	800d5b4 <HAL_RCC_OscConfig+0xe0>
 800d554:	687b      	ldr	r3, [r7, #4]
 800d556:	685b      	ldr	r3, [r3, #4]
 800d558:	2b00      	cmp	r3, #0
 800d55a:	d10c      	bne.n	800d576 <HAL_RCC_OscConfig+0xa2>
 800d55c:	4bab      	ldr	r3, [pc, #684]	; (800d80c <HAL_RCC_OscConfig+0x338>)
 800d55e:	681a      	ldr	r2, [r3, #0]
 800d560:	4baa      	ldr	r3, [pc, #680]	; (800d80c <HAL_RCC_OscConfig+0x338>)
 800d562:	49ab      	ldr	r1, [pc, #684]	; (800d810 <HAL_RCC_OscConfig+0x33c>)
 800d564:	400a      	ands	r2, r1
 800d566:	601a      	str	r2, [r3, #0]
 800d568:	4ba8      	ldr	r3, [pc, #672]	; (800d80c <HAL_RCC_OscConfig+0x338>)
 800d56a:	681a      	ldr	r2, [r3, #0]
 800d56c:	4ba7      	ldr	r3, [pc, #668]	; (800d80c <HAL_RCC_OscConfig+0x338>)
 800d56e:	49a9      	ldr	r1, [pc, #676]	; (800d814 <HAL_RCC_OscConfig+0x340>)
 800d570:	400a      	ands	r2, r1
 800d572:	601a      	str	r2, [r3, #0]
 800d574:	e01e      	b.n	800d5b4 <HAL_RCC_OscConfig+0xe0>
 800d576:	687b      	ldr	r3, [r7, #4]
 800d578:	685b      	ldr	r3, [r3, #4]
 800d57a:	2b05      	cmp	r3, #5
 800d57c:	d10e      	bne.n	800d59c <HAL_RCC_OscConfig+0xc8>
 800d57e:	4ba3      	ldr	r3, [pc, #652]	; (800d80c <HAL_RCC_OscConfig+0x338>)
 800d580:	681a      	ldr	r2, [r3, #0]
 800d582:	4ba2      	ldr	r3, [pc, #648]	; (800d80c <HAL_RCC_OscConfig+0x338>)
 800d584:	2180      	movs	r1, #128	; 0x80
 800d586:	02c9      	lsls	r1, r1, #11
 800d588:	430a      	orrs	r2, r1
 800d58a:	601a      	str	r2, [r3, #0]
 800d58c:	4b9f      	ldr	r3, [pc, #636]	; (800d80c <HAL_RCC_OscConfig+0x338>)
 800d58e:	681a      	ldr	r2, [r3, #0]
 800d590:	4b9e      	ldr	r3, [pc, #632]	; (800d80c <HAL_RCC_OscConfig+0x338>)
 800d592:	2180      	movs	r1, #128	; 0x80
 800d594:	0249      	lsls	r1, r1, #9
 800d596:	430a      	orrs	r2, r1
 800d598:	601a      	str	r2, [r3, #0]
 800d59a:	e00b      	b.n	800d5b4 <HAL_RCC_OscConfig+0xe0>
 800d59c:	4b9b      	ldr	r3, [pc, #620]	; (800d80c <HAL_RCC_OscConfig+0x338>)
 800d59e:	681a      	ldr	r2, [r3, #0]
 800d5a0:	4b9a      	ldr	r3, [pc, #616]	; (800d80c <HAL_RCC_OscConfig+0x338>)
 800d5a2:	499b      	ldr	r1, [pc, #620]	; (800d810 <HAL_RCC_OscConfig+0x33c>)
 800d5a4:	400a      	ands	r2, r1
 800d5a6:	601a      	str	r2, [r3, #0]
 800d5a8:	4b98      	ldr	r3, [pc, #608]	; (800d80c <HAL_RCC_OscConfig+0x338>)
 800d5aa:	681a      	ldr	r2, [r3, #0]
 800d5ac:	4b97      	ldr	r3, [pc, #604]	; (800d80c <HAL_RCC_OscConfig+0x338>)
 800d5ae:	4999      	ldr	r1, [pc, #612]	; (800d814 <HAL_RCC_OscConfig+0x340>)
 800d5b0:	400a      	ands	r2, r1
 800d5b2:	601a      	str	r2, [r3, #0]
      

       /* Check the HSE State */
      if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 800d5b4:	687b      	ldr	r3, [r7, #4]
 800d5b6:	685b      	ldr	r3, [r3, #4]
 800d5b8:	2b00      	cmp	r3, #0
 800d5ba:	d014      	beq.n	800d5e6 <HAL_RCC_OscConfig+0x112>
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 800d5bc:	f7fd fdde 	bl	800b17c <HAL_GetTick>
 800d5c0:	0003      	movs	r3, r0
 800d5c2:	61bb      	str	r3, [r7, #24]
        
        /* Wait till HSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800d5c4:	e008      	b.n	800d5d8 <HAL_RCC_OscConfig+0x104>
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 800d5c6:	f7fd fdd9 	bl	800b17c <HAL_GetTick>
 800d5ca:	0002      	movs	r2, r0
 800d5cc:	69bb      	ldr	r3, [r7, #24]
 800d5ce:	1ad3      	subs	r3, r2, r3
 800d5d0:	2b64      	cmp	r3, #100	; 0x64
 800d5d2:	d901      	bls.n	800d5d8 <HAL_RCC_OscConfig+0x104>
          {
            return HAL_TIMEOUT;
 800d5d4:	2303      	movs	r3, #3
 800d5d6:	e2fd      	b.n	800dbd4 <HAL_RCC_OscConfig+0x700>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800d5d8:	4b8c      	ldr	r3, [pc, #560]	; (800d80c <HAL_RCC_OscConfig+0x338>)
 800d5da:	681a      	ldr	r2, [r3, #0]
 800d5dc:	2380      	movs	r3, #128	; 0x80
 800d5de:	029b      	lsls	r3, r3, #10
 800d5e0:	4013      	ands	r3, r2
 800d5e2:	d0f0      	beq.n	800d5c6 <HAL_RCC_OscConfig+0xf2>
 800d5e4:	e015      	b.n	800d612 <HAL_RCC_OscConfig+0x13e>
        }
      }
      else
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 800d5e6:	f7fd fdc9 	bl	800b17c <HAL_GetTick>
 800d5ea:	0003      	movs	r3, r0
 800d5ec:	61bb      	str	r3, [r7, #24]
        
        /* Wait till HSE is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 800d5ee:	e008      	b.n	800d602 <HAL_RCC_OscConfig+0x12e>
        {
           if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 800d5f0:	f7fd fdc4 	bl	800b17c <HAL_GetTick>
 800d5f4:	0002      	movs	r2, r0
 800d5f6:	69bb      	ldr	r3, [r7, #24]
 800d5f8:	1ad3      	subs	r3, r2, r3
 800d5fa:	2b64      	cmp	r3, #100	; 0x64
 800d5fc:	d901      	bls.n	800d602 <HAL_RCC_OscConfig+0x12e>
          {
            return HAL_TIMEOUT;
 800d5fe:	2303      	movs	r3, #3
 800d600:	e2e8      	b.n	800dbd4 <HAL_RCC_OscConfig+0x700>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 800d602:	4b82      	ldr	r3, [pc, #520]	; (800d80c <HAL_RCC_OscConfig+0x338>)
 800d604:	681a      	ldr	r2, [r3, #0]
 800d606:	2380      	movs	r3, #128	; 0x80
 800d608:	029b      	lsls	r3, r3, #10
 800d60a:	4013      	ands	r3, r2
 800d60c:	d1f0      	bne.n	800d5f0 <HAL_RCC_OscConfig+0x11c>
 800d60e:	e000      	b.n	800d612 <HAL_RCC_OscConfig+0x13e>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 800d610:	46c0      	nop			; (mov r8, r8)
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 800d612:	687b      	ldr	r3, [r7, #4]
 800d614:	681b      	ldr	r3, [r3, #0]
 800d616:	2202      	movs	r2, #2
 800d618:	4013      	ands	r3, r2
 800d61a:	d100      	bne.n	800d61e <HAL_RCC_OscConfig+0x14a>
 800d61c:	e06c      	b.n	800d6f8 <HAL_RCC_OscConfig+0x224>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));
    
    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */ 
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI) 
 800d61e:	4b7b      	ldr	r3, [pc, #492]	; (800d80c <HAL_RCC_OscConfig+0x338>)
 800d620:	685b      	ldr	r3, [r3, #4]
 800d622:	220c      	movs	r2, #12
 800d624:	4013      	ands	r3, r2
 800d626:	d00e      	beq.n	800d646 <HAL_RCC_OscConfig+0x172>
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI)))
 800d628:	4b78      	ldr	r3, [pc, #480]	; (800d80c <HAL_RCC_OscConfig+0x338>)
 800d62a:	685b      	ldr	r3, [r3, #4]
 800d62c:	220c      	movs	r2, #12
 800d62e:	4013      	ands	r3, r2
 800d630:	2b08      	cmp	r3, #8
 800d632:	d11f      	bne.n	800d674 <HAL_RCC_OscConfig+0x1a0>
 800d634:	4b75      	ldr	r3, [pc, #468]	; (800d80c <HAL_RCC_OscConfig+0x338>)
 800d636:	685a      	ldr	r2, [r3, #4]
 800d638:	23c0      	movs	r3, #192	; 0xc0
 800d63a:	025b      	lsls	r3, r3, #9
 800d63c:	401a      	ands	r2, r3
 800d63e:	2380      	movs	r3, #128	; 0x80
 800d640:	021b      	lsls	r3, r3, #8
 800d642:	429a      	cmp	r2, r3
 800d644:	d116      	bne.n	800d674 <HAL_RCC_OscConfig+0x1a0>
    {
      /* When HSI is used as system clock it will not disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 800d646:	4b71      	ldr	r3, [pc, #452]	; (800d80c <HAL_RCC_OscConfig+0x338>)
 800d648:	681b      	ldr	r3, [r3, #0]
 800d64a:	2202      	movs	r2, #2
 800d64c:	4013      	ands	r3, r2
 800d64e:	d005      	beq.n	800d65c <HAL_RCC_OscConfig+0x188>
 800d650:	687b      	ldr	r3, [r7, #4]
 800d652:	68db      	ldr	r3, [r3, #12]
 800d654:	2b01      	cmp	r3, #1
 800d656:	d001      	beq.n	800d65c <HAL_RCC_OscConfig+0x188>
      {
        return HAL_ERROR;
 800d658:	2301      	movs	r3, #1
 800d65a:	e2bb      	b.n	800dbd4 <HAL_RCC_OscConfig+0x700>
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 800d65c:	4b6b      	ldr	r3, [pc, #428]	; (800d80c <HAL_RCC_OscConfig+0x338>)
 800d65e:	681b      	ldr	r3, [r3, #0]
 800d660:	22f8      	movs	r2, #248	; 0xf8
 800d662:	4393      	bics	r3, r2
 800d664:	0019      	movs	r1, r3
 800d666:	687b      	ldr	r3, [r7, #4]
 800d668:	691b      	ldr	r3, [r3, #16]
 800d66a:	00da      	lsls	r2, r3, #3
 800d66c:	4b67      	ldr	r3, [pc, #412]	; (800d80c <HAL_RCC_OscConfig+0x338>)
 800d66e:	430a      	orrs	r2, r1
 800d670:	601a      	str	r2, [r3, #0]
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 800d672:	e041      	b.n	800d6f8 <HAL_RCC_OscConfig+0x224>
      }
    }
    else
    {
      /* Check the HSI State */
      if(RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
 800d674:	687b      	ldr	r3, [r7, #4]
 800d676:	68db      	ldr	r3, [r3, #12]
 800d678:	2b00      	cmp	r3, #0
 800d67a:	d024      	beq.n	800d6c6 <HAL_RCC_OscConfig+0x1f2>
      {
       /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
 800d67c:	4b63      	ldr	r3, [pc, #396]	; (800d80c <HAL_RCC_OscConfig+0x338>)
 800d67e:	681a      	ldr	r2, [r3, #0]
 800d680:	4b62      	ldr	r3, [pc, #392]	; (800d80c <HAL_RCC_OscConfig+0x338>)
 800d682:	2101      	movs	r1, #1
 800d684:	430a      	orrs	r2, r1
 800d686:	601a      	str	r2, [r3, #0]
        
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 800d688:	f7fd fd78 	bl	800b17c <HAL_GetTick>
 800d68c:	0003      	movs	r3, r0
 800d68e:	61bb      	str	r3, [r7, #24]
        
        /* Wait till HSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 800d690:	e008      	b.n	800d6a4 <HAL_RCC_OscConfig+0x1d0>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 800d692:	f7fd fd73 	bl	800b17c <HAL_GetTick>
 800d696:	0002      	movs	r2, r0
 800d698:	69bb      	ldr	r3, [r7, #24]
 800d69a:	1ad3      	subs	r3, r2, r3
 800d69c:	2b02      	cmp	r3, #2
 800d69e:	d901      	bls.n	800d6a4 <HAL_RCC_OscConfig+0x1d0>
          {
            return HAL_TIMEOUT;
 800d6a0:	2303      	movs	r3, #3
 800d6a2:	e297      	b.n	800dbd4 <HAL_RCC_OscConfig+0x700>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 800d6a4:	4b59      	ldr	r3, [pc, #356]	; (800d80c <HAL_RCC_OscConfig+0x338>)
 800d6a6:	681b      	ldr	r3, [r3, #0]
 800d6a8:	2202      	movs	r2, #2
 800d6aa:	4013      	ands	r3, r2
 800d6ac:	d0f1      	beq.n	800d692 <HAL_RCC_OscConfig+0x1be>
          }
        }
                
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 800d6ae:	4b57      	ldr	r3, [pc, #348]	; (800d80c <HAL_RCC_OscConfig+0x338>)
 800d6b0:	681b      	ldr	r3, [r3, #0]
 800d6b2:	22f8      	movs	r2, #248	; 0xf8
 800d6b4:	4393      	bics	r3, r2
 800d6b6:	0019      	movs	r1, r3
 800d6b8:	687b      	ldr	r3, [r7, #4]
 800d6ba:	691b      	ldr	r3, [r3, #16]
 800d6bc:	00da      	lsls	r2, r3, #3
 800d6be:	4b53      	ldr	r3, [pc, #332]	; (800d80c <HAL_RCC_OscConfig+0x338>)
 800d6c0:	430a      	orrs	r2, r1
 800d6c2:	601a      	str	r2, [r3, #0]
 800d6c4:	e018      	b.n	800d6f8 <HAL_RCC_OscConfig+0x224>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
 800d6c6:	4b51      	ldr	r3, [pc, #324]	; (800d80c <HAL_RCC_OscConfig+0x338>)
 800d6c8:	681a      	ldr	r2, [r3, #0]
 800d6ca:	4b50      	ldr	r3, [pc, #320]	; (800d80c <HAL_RCC_OscConfig+0x338>)
 800d6cc:	2101      	movs	r1, #1
 800d6ce:	438a      	bics	r2, r1
 800d6d0:	601a      	str	r2, [r3, #0]
        
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 800d6d2:	f7fd fd53 	bl	800b17c <HAL_GetTick>
 800d6d6:	0003      	movs	r3, r0
 800d6d8:	61bb      	str	r3, [r7, #24]
        
        /* Wait till HSI is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 800d6da:	e008      	b.n	800d6ee <HAL_RCC_OscConfig+0x21a>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 800d6dc:	f7fd fd4e 	bl	800b17c <HAL_GetTick>
 800d6e0:	0002      	movs	r2, r0
 800d6e2:	69bb      	ldr	r3, [r7, #24]
 800d6e4:	1ad3      	subs	r3, r2, r3
 800d6e6:	2b02      	cmp	r3, #2
 800d6e8:	d901      	bls.n	800d6ee <HAL_RCC_OscConfig+0x21a>
          {
            return HAL_TIMEOUT;
 800d6ea:	2303      	movs	r3, #3
 800d6ec:	e272      	b.n	800dbd4 <HAL_RCC_OscConfig+0x700>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 800d6ee:	4b47      	ldr	r3, [pc, #284]	; (800d80c <HAL_RCC_OscConfig+0x338>)
 800d6f0:	681b      	ldr	r3, [r3, #0]
 800d6f2:	2202      	movs	r2, #2
 800d6f4:	4013      	ands	r3, r2
 800d6f6:	d1f1      	bne.n	800d6dc <HAL_RCC_OscConfig+0x208>
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 800d6f8:	687b      	ldr	r3, [r7, #4]
 800d6fa:	681b      	ldr	r3, [r3, #0]
 800d6fc:	2208      	movs	r2, #8
 800d6fe:	4013      	ands	r3, r2
 800d700:	d036      	beq.n	800d770 <HAL_RCC_OscConfig+0x29c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));
    
    /* Check the LSI State */
    if(RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 800d702:	687b      	ldr	r3, [r7, #4]
 800d704:	69db      	ldr	r3, [r3, #28]
 800d706:	2b00      	cmp	r3, #0
 800d708:	d019      	beq.n	800d73e <HAL_RCC_OscConfig+0x26a>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 800d70a:	4b40      	ldr	r3, [pc, #256]	; (800d80c <HAL_RCC_OscConfig+0x338>)
 800d70c:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800d70e:	4b3f      	ldr	r3, [pc, #252]	; (800d80c <HAL_RCC_OscConfig+0x338>)
 800d710:	2101      	movs	r1, #1
 800d712:	430a      	orrs	r2, r1
 800d714:	625a      	str	r2, [r3, #36]	; 0x24
      
      /* Get Start Tick */
      tickstart = HAL_GetTick();
 800d716:	f7fd fd31 	bl	800b17c <HAL_GetTick>
 800d71a:	0003      	movs	r3, r0
 800d71c:	61bb      	str	r3, [r7, #24]
      
      /* Wait till LSI is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 800d71e:	e008      	b.n	800d732 <HAL_RCC_OscConfig+0x25e>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 800d720:	f7fd fd2c 	bl	800b17c <HAL_GetTick>
 800d724:	0002      	movs	r2, r0
 800d726:	69bb      	ldr	r3, [r7, #24]
 800d728:	1ad3      	subs	r3, r2, r3
 800d72a:	2b02      	cmp	r3, #2
 800d72c:	d901      	bls.n	800d732 <HAL_RCC_OscConfig+0x25e>
        {
          return HAL_TIMEOUT;
 800d72e:	2303      	movs	r3, #3
 800d730:	e250      	b.n	800dbd4 <HAL_RCC_OscConfig+0x700>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 800d732:	4b36      	ldr	r3, [pc, #216]	; (800d80c <HAL_RCC_OscConfig+0x338>)
 800d734:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800d736:	2202      	movs	r2, #2
 800d738:	4013      	ands	r3, r2
 800d73a:	d0f1      	beq.n	800d720 <HAL_RCC_OscConfig+0x24c>
 800d73c:	e018      	b.n	800d770 <HAL_RCC_OscConfig+0x29c>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
 800d73e:	4b33      	ldr	r3, [pc, #204]	; (800d80c <HAL_RCC_OscConfig+0x338>)
 800d740:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800d742:	4b32      	ldr	r3, [pc, #200]	; (800d80c <HAL_RCC_OscConfig+0x338>)
 800d744:	2101      	movs	r1, #1
 800d746:	438a      	bics	r2, r1
 800d748:	625a      	str	r2, [r3, #36]	; 0x24
      
      /* Get Start Tick */
      tickstart = HAL_GetTick();
 800d74a:	f7fd fd17 	bl	800b17c <HAL_GetTick>
 800d74e:	0003      	movs	r3, r0
 800d750:	61bb      	str	r3, [r7, #24]
      
      /* Wait till LSI is disabled */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 800d752:	e008      	b.n	800d766 <HAL_RCC_OscConfig+0x292>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 800d754:	f7fd fd12 	bl	800b17c <HAL_GetTick>
 800d758:	0002      	movs	r2, r0
 800d75a:	69bb      	ldr	r3, [r7, #24]
 800d75c:	1ad3      	subs	r3, r2, r3
 800d75e:	2b02      	cmp	r3, #2
 800d760:	d901      	bls.n	800d766 <HAL_RCC_OscConfig+0x292>
        {
          return HAL_TIMEOUT;
 800d762:	2303      	movs	r3, #3
 800d764:	e236      	b.n	800dbd4 <HAL_RCC_OscConfig+0x700>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 800d766:	4b29      	ldr	r3, [pc, #164]	; (800d80c <HAL_RCC_OscConfig+0x338>)
 800d768:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800d76a:	2202      	movs	r2, #2
 800d76c:	4013      	ands	r3, r2
 800d76e:	d1f1      	bne.n	800d754 <HAL_RCC_OscConfig+0x280>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 800d770:	687b      	ldr	r3, [r7, #4]
 800d772:	681b      	ldr	r3, [r3, #0]
 800d774:	2204      	movs	r2, #4
 800d776:	4013      	ands	r3, r2
 800d778:	d100      	bne.n	800d77c <HAL_RCC_OscConfig+0x2a8>
 800d77a:	e0b5      	b.n	800d8e8 <HAL_RCC_OscConfig+0x414>
  {
    FlagStatus       pwrclkchanged = RESET;
 800d77c:	201f      	movs	r0, #31
 800d77e:	183b      	adds	r3, r7, r0
 800d780:	2200      	movs	r2, #0
 800d782:	701a      	strb	r2, [r3, #0]
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Update LSE configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain of necessary */
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 800d784:	4b21      	ldr	r3, [pc, #132]	; (800d80c <HAL_RCC_OscConfig+0x338>)
 800d786:	69da      	ldr	r2, [r3, #28]
 800d788:	2380      	movs	r3, #128	; 0x80
 800d78a:	055b      	lsls	r3, r3, #21
 800d78c:	4013      	ands	r3, r2
 800d78e:	d110      	bne.n	800d7b2 <HAL_RCC_OscConfig+0x2de>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 800d790:	4b1e      	ldr	r3, [pc, #120]	; (800d80c <HAL_RCC_OscConfig+0x338>)
 800d792:	69da      	ldr	r2, [r3, #28]
 800d794:	4b1d      	ldr	r3, [pc, #116]	; (800d80c <HAL_RCC_OscConfig+0x338>)
 800d796:	2180      	movs	r1, #128	; 0x80
 800d798:	0549      	lsls	r1, r1, #21
 800d79a:	430a      	orrs	r2, r1
 800d79c:	61da      	str	r2, [r3, #28]
 800d79e:	4b1b      	ldr	r3, [pc, #108]	; (800d80c <HAL_RCC_OscConfig+0x338>)
 800d7a0:	69da      	ldr	r2, [r3, #28]
 800d7a2:	2380      	movs	r3, #128	; 0x80
 800d7a4:	055b      	lsls	r3, r3, #21
 800d7a6:	4013      	ands	r3, r2
 800d7a8:	60fb      	str	r3, [r7, #12]
 800d7aa:	68fb      	ldr	r3, [r7, #12]
      pwrclkchanged = SET;
 800d7ac:	183b      	adds	r3, r7, r0
 800d7ae:	2201      	movs	r2, #1
 800d7b0:	701a      	strb	r2, [r3, #0]
    }
    
    if(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 800d7b2:	4b19      	ldr	r3, [pc, #100]	; (800d818 <HAL_RCC_OscConfig+0x344>)
 800d7b4:	681a      	ldr	r2, [r3, #0]
 800d7b6:	2380      	movs	r3, #128	; 0x80
 800d7b8:	005b      	lsls	r3, r3, #1
 800d7ba:	4013      	ands	r3, r2
 800d7bc:	d11a      	bne.n	800d7f4 <HAL_RCC_OscConfig+0x320>
    {
      /* Enable write access to Backup domain */
      SET_BIT(PWR->CR, PWR_CR_DBP);
 800d7be:	4b16      	ldr	r3, [pc, #88]	; (800d818 <HAL_RCC_OscConfig+0x344>)
 800d7c0:	681a      	ldr	r2, [r3, #0]
 800d7c2:	4b15      	ldr	r3, [pc, #84]	; (800d818 <HAL_RCC_OscConfig+0x344>)
 800d7c4:	2180      	movs	r1, #128	; 0x80
 800d7c6:	0049      	lsls	r1, r1, #1
 800d7c8:	430a      	orrs	r2, r1
 800d7ca:	601a      	str	r2, [r3, #0]
      
      /* Wait for Backup domain Write protection disable */
      tickstart = HAL_GetTick();
 800d7cc:	f7fd fcd6 	bl	800b17c <HAL_GetTick>
 800d7d0:	0003      	movs	r3, r0
 800d7d2:	61bb      	str	r3, [r7, #24]

      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 800d7d4:	e008      	b.n	800d7e8 <HAL_RCC_OscConfig+0x314>
      {
        if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 800d7d6:	f7fd fcd1 	bl	800b17c <HAL_GetTick>
 800d7da:	0002      	movs	r2, r0
 800d7dc:	69bb      	ldr	r3, [r7, #24]
 800d7de:	1ad3      	subs	r3, r2, r3
 800d7e0:	2b64      	cmp	r3, #100	; 0x64
 800d7e2:	d901      	bls.n	800d7e8 <HAL_RCC_OscConfig+0x314>
        {
          return HAL_TIMEOUT;
 800d7e4:	2303      	movs	r3, #3
 800d7e6:	e1f5      	b.n	800dbd4 <HAL_RCC_OscConfig+0x700>
      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 800d7e8:	4b0b      	ldr	r3, [pc, #44]	; (800d818 <HAL_RCC_OscConfig+0x344>)
 800d7ea:	681a      	ldr	r2, [r3, #0]
 800d7ec:	2380      	movs	r3, #128	; 0x80
 800d7ee:	005b      	lsls	r3, r3, #1
 800d7f0:	4013      	ands	r3, r2
 800d7f2:	d0f0      	beq.n	800d7d6 <HAL_RCC_OscConfig+0x302>
        }
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 800d7f4:	687b      	ldr	r3, [r7, #4]
 800d7f6:	689b      	ldr	r3, [r3, #8]
 800d7f8:	2b01      	cmp	r3, #1
 800d7fa:	d10f      	bne.n	800d81c <HAL_RCC_OscConfig+0x348>
 800d7fc:	4b03      	ldr	r3, [pc, #12]	; (800d80c <HAL_RCC_OscConfig+0x338>)
 800d7fe:	6a1a      	ldr	r2, [r3, #32]
 800d800:	4b02      	ldr	r3, [pc, #8]	; (800d80c <HAL_RCC_OscConfig+0x338>)
 800d802:	2101      	movs	r1, #1
 800d804:	430a      	orrs	r2, r1
 800d806:	621a      	str	r2, [r3, #32]
 800d808:	e036      	b.n	800d878 <HAL_RCC_OscConfig+0x3a4>
 800d80a:	46c0      	nop			; (mov r8, r8)
 800d80c:	40021000 	.word	0x40021000
 800d810:	fffeffff 	.word	0xfffeffff
 800d814:	fffbffff 	.word	0xfffbffff
 800d818:	40007000 	.word	0x40007000
 800d81c:	687b      	ldr	r3, [r7, #4]
 800d81e:	689b      	ldr	r3, [r3, #8]
 800d820:	2b00      	cmp	r3, #0
 800d822:	d10c      	bne.n	800d83e <HAL_RCC_OscConfig+0x36a>
 800d824:	4bca      	ldr	r3, [pc, #808]	; (800db50 <HAL_RCC_OscConfig+0x67c>)
 800d826:	6a1a      	ldr	r2, [r3, #32]
 800d828:	4bc9      	ldr	r3, [pc, #804]	; (800db50 <HAL_RCC_OscConfig+0x67c>)
 800d82a:	2101      	movs	r1, #1
 800d82c:	438a      	bics	r2, r1
 800d82e:	621a      	str	r2, [r3, #32]
 800d830:	4bc7      	ldr	r3, [pc, #796]	; (800db50 <HAL_RCC_OscConfig+0x67c>)
 800d832:	6a1a      	ldr	r2, [r3, #32]
 800d834:	4bc6      	ldr	r3, [pc, #792]	; (800db50 <HAL_RCC_OscConfig+0x67c>)
 800d836:	2104      	movs	r1, #4
 800d838:	438a      	bics	r2, r1
 800d83a:	621a      	str	r2, [r3, #32]
 800d83c:	e01c      	b.n	800d878 <HAL_RCC_OscConfig+0x3a4>
 800d83e:	687b      	ldr	r3, [r7, #4]
 800d840:	689b      	ldr	r3, [r3, #8]
 800d842:	2b05      	cmp	r3, #5
 800d844:	d10c      	bne.n	800d860 <HAL_RCC_OscConfig+0x38c>
 800d846:	4bc2      	ldr	r3, [pc, #776]	; (800db50 <HAL_RCC_OscConfig+0x67c>)
 800d848:	6a1a      	ldr	r2, [r3, #32]
 800d84a:	4bc1      	ldr	r3, [pc, #772]	; (800db50 <HAL_RCC_OscConfig+0x67c>)
 800d84c:	2104      	movs	r1, #4
 800d84e:	430a      	orrs	r2, r1
 800d850:	621a      	str	r2, [r3, #32]
 800d852:	4bbf      	ldr	r3, [pc, #764]	; (800db50 <HAL_RCC_OscConfig+0x67c>)
 800d854:	6a1a      	ldr	r2, [r3, #32]
 800d856:	4bbe      	ldr	r3, [pc, #760]	; (800db50 <HAL_RCC_OscConfig+0x67c>)
 800d858:	2101      	movs	r1, #1
 800d85a:	430a      	orrs	r2, r1
 800d85c:	621a      	str	r2, [r3, #32]
 800d85e:	e00b      	b.n	800d878 <HAL_RCC_OscConfig+0x3a4>
 800d860:	4bbb      	ldr	r3, [pc, #748]	; (800db50 <HAL_RCC_OscConfig+0x67c>)
 800d862:	6a1a      	ldr	r2, [r3, #32]
 800d864:	4bba      	ldr	r3, [pc, #744]	; (800db50 <HAL_RCC_OscConfig+0x67c>)
 800d866:	2101      	movs	r1, #1
 800d868:	438a      	bics	r2, r1
 800d86a:	621a      	str	r2, [r3, #32]
 800d86c:	4bb8      	ldr	r3, [pc, #736]	; (800db50 <HAL_RCC_OscConfig+0x67c>)
 800d86e:	6a1a      	ldr	r2, [r3, #32]
 800d870:	4bb7      	ldr	r3, [pc, #732]	; (800db50 <HAL_RCC_OscConfig+0x67c>)
 800d872:	2104      	movs	r1, #4
 800d874:	438a      	bics	r2, r1
 800d876:	621a      	str	r2, [r3, #32]
    /* Check the LSE State */
    if(RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
 800d878:	687b      	ldr	r3, [r7, #4]
 800d87a:	689b      	ldr	r3, [r3, #8]
 800d87c:	2b00      	cmp	r3, #0
 800d87e:	d014      	beq.n	800d8aa <HAL_RCC_OscConfig+0x3d6>
    {
      /* Get Start Tick */
      tickstart = HAL_GetTick();
 800d880:	f7fd fc7c 	bl	800b17c <HAL_GetTick>
 800d884:	0003      	movs	r3, r0
 800d886:	61bb      	str	r3, [r7, #24]
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 800d888:	e009      	b.n	800d89e <HAL_RCC_OscConfig+0x3ca>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 800d88a:	f7fd fc77 	bl	800b17c <HAL_GetTick>
 800d88e:	0002      	movs	r2, r0
 800d890:	69bb      	ldr	r3, [r7, #24]
 800d892:	1ad3      	subs	r3, r2, r3
 800d894:	4aaf      	ldr	r2, [pc, #700]	; (800db54 <HAL_RCC_OscConfig+0x680>)
 800d896:	4293      	cmp	r3, r2
 800d898:	d901      	bls.n	800d89e <HAL_RCC_OscConfig+0x3ca>
        {
          return HAL_TIMEOUT;
 800d89a:	2303      	movs	r3, #3
 800d89c:	e19a      	b.n	800dbd4 <HAL_RCC_OscConfig+0x700>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 800d89e:	4bac      	ldr	r3, [pc, #688]	; (800db50 <HAL_RCC_OscConfig+0x67c>)
 800d8a0:	6a1b      	ldr	r3, [r3, #32]
 800d8a2:	2202      	movs	r2, #2
 800d8a4:	4013      	ands	r3, r2
 800d8a6:	d0f0      	beq.n	800d88a <HAL_RCC_OscConfig+0x3b6>
 800d8a8:	e013      	b.n	800d8d2 <HAL_RCC_OscConfig+0x3fe>
      }
    }
    else
    {
      /* Get Start Tick */
      tickstart = HAL_GetTick();
 800d8aa:	f7fd fc67 	bl	800b17c <HAL_GetTick>
 800d8ae:	0003      	movs	r3, r0
 800d8b0:	61bb      	str	r3, [r7, #24]
      
      /* Wait till LSE is disabled */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 800d8b2:	e009      	b.n	800d8c8 <HAL_RCC_OscConfig+0x3f4>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 800d8b4:	f7fd fc62 	bl	800b17c <HAL_GetTick>
 800d8b8:	0002      	movs	r2, r0
 800d8ba:	69bb      	ldr	r3, [r7, #24]
 800d8bc:	1ad3      	subs	r3, r2, r3
 800d8be:	4aa5      	ldr	r2, [pc, #660]	; (800db54 <HAL_RCC_OscConfig+0x680>)
 800d8c0:	4293      	cmp	r3, r2
 800d8c2:	d901      	bls.n	800d8c8 <HAL_RCC_OscConfig+0x3f4>
        {
          return HAL_TIMEOUT;
 800d8c4:	2303      	movs	r3, #3
 800d8c6:	e185      	b.n	800dbd4 <HAL_RCC_OscConfig+0x700>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 800d8c8:	4ba1      	ldr	r3, [pc, #644]	; (800db50 <HAL_RCC_OscConfig+0x67c>)
 800d8ca:	6a1b      	ldr	r3, [r3, #32]
 800d8cc:	2202      	movs	r2, #2
 800d8ce:	4013      	ands	r3, r2
 800d8d0:	d1f0      	bne.n	800d8b4 <HAL_RCC_OscConfig+0x3e0>
        }
      }
    }

    /* Require to disable power clock if necessary */
    if(pwrclkchanged == SET)
 800d8d2:	231f      	movs	r3, #31
 800d8d4:	18fb      	adds	r3, r7, r3
 800d8d6:	781b      	ldrb	r3, [r3, #0]
 800d8d8:	2b01      	cmp	r3, #1
 800d8da:	d105      	bne.n	800d8e8 <HAL_RCC_OscConfig+0x414>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 800d8dc:	4b9c      	ldr	r3, [pc, #624]	; (800db50 <HAL_RCC_OscConfig+0x67c>)
 800d8de:	69da      	ldr	r2, [r3, #28]
 800d8e0:	4b9b      	ldr	r3, [pc, #620]	; (800db50 <HAL_RCC_OscConfig+0x67c>)
 800d8e2:	499d      	ldr	r1, [pc, #628]	; (800db58 <HAL_RCC_OscConfig+0x684>)
 800d8e4:	400a      	ands	r2, r1
 800d8e6:	61da      	str	r2, [r3, #28]
    }
  }

  /*----------------------------- HSI14 Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI14) == RCC_OSCILLATORTYPE_HSI14)
 800d8e8:	687b      	ldr	r3, [r7, #4]
 800d8ea:	681b      	ldr	r3, [r3, #0]
 800d8ec:	2210      	movs	r2, #16
 800d8ee:	4013      	ands	r3, r2
 800d8f0:	d063      	beq.n	800d9ba <HAL_RCC_OscConfig+0x4e6>
    /* Check the parameters */
    assert_param(IS_RCC_HSI14(RCC_OscInitStruct->HSI14State));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSI14CalibrationValue));

    /* Check the HSI14 State */
    if(RCC_OscInitStruct->HSI14State == RCC_HSI14_ON)
 800d8f2:	687b      	ldr	r3, [r7, #4]
 800d8f4:	695b      	ldr	r3, [r3, #20]
 800d8f6:	2b01      	cmp	r3, #1
 800d8f8:	d12a      	bne.n	800d950 <HAL_RCC_OscConfig+0x47c>
    {
      /* Disable ADC control of the Internal High Speed oscillator HSI14 */
      __HAL_RCC_HSI14ADC_DISABLE();
 800d8fa:	4b95      	ldr	r3, [pc, #596]	; (800db50 <HAL_RCC_OscConfig+0x67c>)
 800d8fc:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800d8fe:	4b94      	ldr	r3, [pc, #592]	; (800db50 <HAL_RCC_OscConfig+0x67c>)
 800d900:	2104      	movs	r1, #4
 800d902:	430a      	orrs	r2, r1
 800d904:	635a      	str	r2, [r3, #52]	; 0x34

      /* Enable the Internal High Speed oscillator (HSI). */
      __HAL_RCC_HSI14_ENABLE();
 800d906:	4b92      	ldr	r3, [pc, #584]	; (800db50 <HAL_RCC_OscConfig+0x67c>)
 800d908:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800d90a:	4b91      	ldr	r3, [pc, #580]	; (800db50 <HAL_RCC_OscConfig+0x67c>)
 800d90c:	2101      	movs	r1, #1
 800d90e:	430a      	orrs	r2, r1
 800d910:	635a      	str	r2, [r3, #52]	; 0x34

      /* Get Start Tick */
      tickstart = HAL_GetTick();
 800d912:	f7fd fc33 	bl	800b17c <HAL_GetTick>
 800d916:	0003      	movs	r3, r0
 800d918:	61bb      	str	r3, [r7, #24]
      
      /* Wait till HSI is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI14RDY) == RESET)
 800d91a:	e008      	b.n	800d92e <HAL_RCC_OscConfig+0x45a>
      {
        if((HAL_GetTick() - tickstart) > HSI14_TIMEOUT_VALUE)
 800d91c:	f7fd fc2e 	bl	800b17c <HAL_GetTick>
 800d920:	0002      	movs	r2, r0
 800d922:	69bb      	ldr	r3, [r7, #24]
 800d924:	1ad3      	subs	r3, r2, r3
 800d926:	2b02      	cmp	r3, #2
 800d928:	d901      	bls.n	800d92e <HAL_RCC_OscConfig+0x45a>
        {
          return HAL_TIMEOUT;
 800d92a:	2303      	movs	r3, #3
 800d92c:	e152      	b.n	800dbd4 <HAL_RCC_OscConfig+0x700>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI14RDY) == RESET)
 800d92e:	4b88      	ldr	r3, [pc, #544]	; (800db50 <HAL_RCC_OscConfig+0x67c>)
 800d930:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800d932:	2202      	movs	r2, #2
 800d934:	4013      	ands	r3, r2
 800d936:	d0f1      	beq.n	800d91c <HAL_RCC_OscConfig+0x448>
        }      
      } 

      /* Adjusts the Internal High Speed oscillator 14Mhz (HSI14) calibration value. */
      __HAL_RCC_HSI14_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSI14CalibrationValue);
 800d938:	4b85      	ldr	r3, [pc, #532]	; (800db50 <HAL_RCC_OscConfig+0x67c>)
 800d93a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800d93c:	22f8      	movs	r2, #248	; 0xf8
 800d93e:	4393      	bics	r3, r2
 800d940:	0019      	movs	r1, r3
 800d942:	687b      	ldr	r3, [r7, #4]
 800d944:	699b      	ldr	r3, [r3, #24]
 800d946:	00da      	lsls	r2, r3, #3
 800d948:	4b81      	ldr	r3, [pc, #516]	; (800db50 <HAL_RCC_OscConfig+0x67c>)
 800d94a:	430a      	orrs	r2, r1
 800d94c:	635a      	str	r2, [r3, #52]	; 0x34
 800d94e:	e034      	b.n	800d9ba <HAL_RCC_OscConfig+0x4e6>
    }
    else if(RCC_OscInitStruct->HSI14State == RCC_HSI14_ADC_CONTROL)
 800d950:	687b      	ldr	r3, [r7, #4]
 800d952:	695b      	ldr	r3, [r3, #20]
 800d954:	3305      	adds	r3, #5
 800d956:	d111      	bne.n	800d97c <HAL_RCC_OscConfig+0x4a8>
    {
      /* Enable ADC control of the Internal High Speed oscillator HSI14 */
      __HAL_RCC_HSI14ADC_ENABLE();
 800d958:	4b7d      	ldr	r3, [pc, #500]	; (800db50 <HAL_RCC_OscConfig+0x67c>)
 800d95a:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800d95c:	4b7c      	ldr	r3, [pc, #496]	; (800db50 <HAL_RCC_OscConfig+0x67c>)
 800d95e:	2104      	movs	r1, #4
 800d960:	438a      	bics	r2, r1
 800d962:	635a      	str	r2, [r3, #52]	; 0x34

      /* Adjusts the Internal High Speed oscillator 14Mhz (HSI14) calibration value. */
      __HAL_RCC_HSI14_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSI14CalibrationValue);
 800d964:	4b7a      	ldr	r3, [pc, #488]	; (800db50 <HAL_RCC_OscConfig+0x67c>)
 800d966:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800d968:	22f8      	movs	r2, #248	; 0xf8
 800d96a:	4393      	bics	r3, r2
 800d96c:	0019      	movs	r1, r3
 800d96e:	687b      	ldr	r3, [r7, #4]
 800d970:	699b      	ldr	r3, [r3, #24]
 800d972:	00da      	lsls	r2, r3, #3
 800d974:	4b76      	ldr	r3, [pc, #472]	; (800db50 <HAL_RCC_OscConfig+0x67c>)
 800d976:	430a      	orrs	r2, r1
 800d978:	635a      	str	r2, [r3, #52]	; 0x34
 800d97a:	e01e      	b.n	800d9ba <HAL_RCC_OscConfig+0x4e6>
    }
    else
    {
      /* Disable ADC control of the Internal High Speed oscillator HSI14 */
      __HAL_RCC_HSI14ADC_DISABLE();
 800d97c:	4b74      	ldr	r3, [pc, #464]	; (800db50 <HAL_RCC_OscConfig+0x67c>)
 800d97e:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800d980:	4b73      	ldr	r3, [pc, #460]	; (800db50 <HAL_RCC_OscConfig+0x67c>)
 800d982:	2104      	movs	r1, #4
 800d984:	430a      	orrs	r2, r1
 800d986:	635a      	str	r2, [r3, #52]	; 0x34

      /* Disable the Internal High Speed oscillator (HSI). */
      __HAL_RCC_HSI14_DISABLE();
 800d988:	4b71      	ldr	r3, [pc, #452]	; (800db50 <HAL_RCC_OscConfig+0x67c>)
 800d98a:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800d98c:	4b70      	ldr	r3, [pc, #448]	; (800db50 <HAL_RCC_OscConfig+0x67c>)
 800d98e:	2101      	movs	r1, #1
 800d990:	438a      	bics	r2, r1
 800d992:	635a      	str	r2, [r3, #52]	; 0x34

      /* Get Start Tick */
      tickstart = HAL_GetTick();
 800d994:	f7fd fbf2 	bl	800b17c <HAL_GetTick>
 800d998:	0003      	movs	r3, r0
 800d99a:	61bb      	str	r3, [r7, #24]
      
      /* Wait till HSI is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI14RDY) != RESET)
 800d99c:	e008      	b.n	800d9b0 <HAL_RCC_OscConfig+0x4dc>
      {
        if((HAL_GetTick() - tickstart) > HSI14_TIMEOUT_VALUE)
 800d99e:	f7fd fbed 	bl	800b17c <HAL_GetTick>
 800d9a2:	0002      	movs	r2, r0
 800d9a4:	69bb      	ldr	r3, [r7, #24]
 800d9a6:	1ad3      	subs	r3, r2, r3
 800d9a8:	2b02      	cmp	r3, #2
 800d9aa:	d901      	bls.n	800d9b0 <HAL_RCC_OscConfig+0x4dc>
        {
          return HAL_TIMEOUT;
 800d9ac:	2303      	movs	r3, #3
 800d9ae:	e111      	b.n	800dbd4 <HAL_RCC_OscConfig+0x700>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI14RDY) != RESET)
 800d9b0:	4b67      	ldr	r3, [pc, #412]	; (800db50 <HAL_RCC_OscConfig+0x67c>)
 800d9b2:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800d9b4:	2202      	movs	r2, #2
 800d9b6:	4013      	ands	r3, r2
 800d9b8:	d1f1      	bne.n	800d99e <HAL_RCC_OscConfig+0x4ca>
    }
  }

#if defined(RCC_HSI48_SUPPORT)
  /*----------------------------- HSI48 Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI48) == RCC_OSCILLATORTYPE_HSI48)
 800d9ba:	687b      	ldr	r3, [r7, #4]
 800d9bc:	681b      	ldr	r3, [r3, #0]
 800d9be:	2220      	movs	r2, #32
 800d9c0:	4013      	ands	r3, r2
 800d9c2:	d05c      	beq.n	800da7e <HAL_RCC_OscConfig+0x5aa>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSI48(RCC_OscInitStruct->HSI48State));

    /* When the HSI48 is used as system clock it is not allowed to be disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI48) ||
 800d9c4:	4b62      	ldr	r3, [pc, #392]	; (800db50 <HAL_RCC_OscConfig+0x67c>)
 800d9c6:	685b      	ldr	r3, [r3, #4]
 800d9c8:	220c      	movs	r2, #12
 800d9ca:	4013      	ands	r3, r2
 800d9cc:	2b0c      	cmp	r3, #12
 800d9ce:	d00e      	beq.n	800d9ee <HAL_RCC_OscConfig+0x51a>
       ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI48)))
 800d9d0:	4b5f      	ldr	r3, [pc, #380]	; (800db50 <HAL_RCC_OscConfig+0x67c>)
 800d9d2:	685b      	ldr	r3, [r3, #4]
 800d9d4:	220c      	movs	r2, #12
 800d9d6:	4013      	ands	r3, r2
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI48) ||
 800d9d8:	2b08      	cmp	r3, #8
 800d9da:	d114      	bne.n	800da06 <HAL_RCC_OscConfig+0x532>
       ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI48)))
 800d9dc:	4b5c      	ldr	r3, [pc, #368]	; (800db50 <HAL_RCC_OscConfig+0x67c>)
 800d9de:	685a      	ldr	r2, [r3, #4]
 800d9e0:	23c0      	movs	r3, #192	; 0xc0
 800d9e2:	025b      	lsls	r3, r3, #9
 800d9e4:	401a      	ands	r2, r3
 800d9e6:	23c0      	movs	r3, #192	; 0xc0
 800d9e8:	025b      	lsls	r3, r3, #9
 800d9ea:	429a      	cmp	r2, r3
 800d9ec:	d10b      	bne.n	800da06 <HAL_RCC_OscConfig+0x532>
    {
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) != RESET) && (RCC_OscInitStruct->HSI48State != RCC_HSI48_ON))
 800d9ee:	4b58      	ldr	r3, [pc, #352]	; (800db50 <HAL_RCC_OscConfig+0x67c>)
 800d9f0:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800d9f2:	2380      	movs	r3, #128	; 0x80
 800d9f4:	025b      	lsls	r3, r3, #9
 800d9f6:	4013      	ands	r3, r2
 800d9f8:	d040      	beq.n	800da7c <HAL_RCC_OscConfig+0x5a8>
 800d9fa:	687b      	ldr	r3, [r7, #4]
 800d9fc:	6a1b      	ldr	r3, [r3, #32]
 800d9fe:	2b01      	cmp	r3, #1
 800da00:	d03c      	beq.n	800da7c <HAL_RCC_OscConfig+0x5a8>
      {
        return HAL_ERROR;
 800da02:	2301      	movs	r3, #1
 800da04:	e0e6      	b.n	800dbd4 <HAL_RCC_OscConfig+0x700>
      }
    }
    else
    {
      /* Check the HSI48 State */
      if(RCC_OscInitStruct->HSI48State != RCC_HSI48_OFF)
 800da06:	687b      	ldr	r3, [r7, #4]
 800da08:	6a1b      	ldr	r3, [r3, #32]
 800da0a:	2b00      	cmp	r3, #0
 800da0c:	d01b      	beq.n	800da46 <HAL_RCC_OscConfig+0x572>
      {
        /* Enable the Internal High Speed oscillator (HSI48). */
        __HAL_RCC_HSI48_ENABLE();
 800da0e:	4b50      	ldr	r3, [pc, #320]	; (800db50 <HAL_RCC_OscConfig+0x67c>)
 800da10:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800da12:	4b4f      	ldr	r3, [pc, #316]	; (800db50 <HAL_RCC_OscConfig+0x67c>)
 800da14:	2180      	movs	r1, #128	; 0x80
 800da16:	0249      	lsls	r1, r1, #9
 800da18:	430a      	orrs	r2, r1
 800da1a:	635a      	str	r2, [r3, #52]	; 0x34

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 800da1c:	f7fd fbae 	bl	800b17c <HAL_GetTick>
 800da20:	0003      	movs	r3, r0
 800da22:	61bb      	str	r3, [r7, #24]
      
        /* Wait till HSI48 is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) == RESET)
 800da24:	e008      	b.n	800da38 <HAL_RCC_OscConfig+0x564>
        {
          if((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
 800da26:	f7fd fba9 	bl	800b17c <HAL_GetTick>
 800da2a:	0002      	movs	r2, r0
 800da2c:	69bb      	ldr	r3, [r7, #24]
 800da2e:	1ad3      	subs	r3, r2, r3
 800da30:	2b02      	cmp	r3, #2
 800da32:	d901      	bls.n	800da38 <HAL_RCC_OscConfig+0x564>
          {
            return HAL_TIMEOUT;
 800da34:	2303      	movs	r3, #3
 800da36:	e0cd      	b.n	800dbd4 <HAL_RCC_OscConfig+0x700>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) == RESET)
 800da38:	4b45      	ldr	r3, [pc, #276]	; (800db50 <HAL_RCC_OscConfig+0x67c>)
 800da3a:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800da3c:	2380      	movs	r3, #128	; 0x80
 800da3e:	025b      	lsls	r3, r3, #9
 800da40:	4013      	ands	r3, r2
 800da42:	d0f0      	beq.n	800da26 <HAL_RCC_OscConfig+0x552>
 800da44:	e01b      	b.n	800da7e <HAL_RCC_OscConfig+0x5aa>
        } 
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI48). */
        __HAL_RCC_HSI48_DISABLE();
 800da46:	4b42      	ldr	r3, [pc, #264]	; (800db50 <HAL_RCC_OscConfig+0x67c>)
 800da48:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800da4a:	4b41      	ldr	r3, [pc, #260]	; (800db50 <HAL_RCC_OscConfig+0x67c>)
 800da4c:	4943      	ldr	r1, [pc, #268]	; (800db5c <HAL_RCC_OscConfig+0x688>)
 800da4e:	400a      	ands	r2, r1
 800da50:	635a      	str	r2, [r3, #52]	; 0x34

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 800da52:	f7fd fb93 	bl	800b17c <HAL_GetTick>
 800da56:	0003      	movs	r3, r0
 800da58:	61bb      	str	r3, [r7, #24]
      
        /* Wait till HSI48 is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) != RESET)
 800da5a:	e008      	b.n	800da6e <HAL_RCC_OscConfig+0x59a>
        {
          if((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
 800da5c:	f7fd fb8e 	bl	800b17c <HAL_GetTick>
 800da60:	0002      	movs	r2, r0
 800da62:	69bb      	ldr	r3, [r7, #24]
 800da64:	1ad3      	subs	r3, r2, r3
 800da66:	2b02      	cmp	r3, #2
 800da68:	d901      	bls.n	800da6e <HAL_RCC_OscConfig+0x59a>
          {
            return HAL_TIMEOUT;
 800da6a:	2303      	movs	r3, #3
 800da6c:	e0b2      	b.n	800dbd4 <HAL_RCC_OscConfig+0x700>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) != RESET)
 800da6e:	4b38      	ldr	r3, [pc, #224]	; (800db50 <HAL_RCC_OscConfig+0x67c>)
 800da70:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800da72:	2380      	movs	r3, #128	; 0x80
 800da74:	025b      	lsls	r3, r3, #9
 800da76:	4013      	ands	r3, r2
 800da78:	d1f0      	bne.n	800da5c <HAL_RCC_OscConfig+0x588>
 800da7a:	e000      	b.n	800da7e <HAL_RCC_OscConfig+0x5aa>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) != RESET) && (RCC_OscInitStruct->HSI48State != RCC_HSI48_ON))
 800da7c:	46c0      	nop			; (mov r8, r8)
#endif /* RCC_HSI48_SUPPORT */
       
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 800da7e:	687b      	ldr	r3, [r7, #4]
 800da80:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800da82:	2b00      	cmp	r3, #0
 800da84:	d100      	bne.n	800da88 <HAL_RCC_OscConfig+0x5b4>
 800da86:	e0a4      	b.n	800dbd2 <HAL_RCC_OscConfig+0x6fe>
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 800da88:	4b31      	ldr	r3, [pc, #196]	; (800db50 <HAL_RCC_OscConfig+0x67c>)
 800da8a:	685b      	ldr	r3, [r3, #4]
 800da8c:	220c      	movs	r2, #12
 800da8e:	4013      	ands	r3, r2
 800da90:	2b08      	cmp	r3, #8
 800da92:	d100      	bne.n	800da96 <HAL_RCC_OscConfig+0x5c2>
 800da94:	e078      	b.n	800db88 <HAL_RCC_OscConfig+0x6b4>
    { 
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 800da96:	687b      	ldr	r3, [r7, #4]
 800da98:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800da9a:	2b02      	cmp	r3, #2
 800da9c:	d14c      	bne.n	800db38 <HAL_RCC_OscConfig+0x664>
        assert_param(IS_RCC_PLLSOURCE(RCC_OscInitStruct->PLL.PLLSource));
        assert_param(IS_RCC_PLL_MUL(RCC_OscInitStruct->PLL.PLLMUL));
        assert_param(IS_RCC_PREDIV(RCC_OscInitStruct->PLL.PREDIV));
  
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 800da9e:	4b2c      	ldr	r3, [pc, #176]	; (800db50 <HAL_RCC_OscConfig+0x67c>)
 800daa0:	681a      	ldr	r2, [r3, #0]
 800daa2:	4b2b      	ldr	r3, [pc, #172]	; (800db50 <HAL_RCC_OscConfig+0x67c>)
 800daa4:	492e      	ldr	r1, [pc, #184]	; (800db60 <HAL_RCC_OscConfig+0x68c>)
 800daa6:	400a      	ands	r2, r1
 800daa8:	601a      	str	r2, [r3, #0]
        
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 800daaa:	f7fd fb67 	bl	800b17c <HAL_GetTick>
 800daae:	0003      	movs	r3, r0
 800dab0:	61bb      	str	r3, [r7, #24]
        
        /* Wait till PLL is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 800dab2:	e008      	b.n	800dac6 <HAL_RCC_OscConfig+0x5f2>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 800dab4:	f7fd fb62 	bl	800b17c <HAL_GetTick>
 800dab8:	0002      	movs	r2, r0
 800daba:	69bb      	ldr	r3, [r7, #24]
 800dabc:	1ad3      	subs	r3, r2, r3
 800dabe:	2b02      	cmp	r3, #2
 800dac0:	d901      	bls.n	800dac6 <HAL_RCC_OscConfig+0x5f2>
          {
            return HAL_TIMEOUT;
 800dac2:	2303      	movs	r3, #3
 800dac4:	e086      	b.n	800dbd4 <HAL_RCC_OscConfig+0x700>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 800dac6:	4b22      	ldr	r3, [pc, #136]	; (800db50 <HAL_RCC_OscConfig+0x67c>)
 800dac8:	681a      	ldr	r2, [r3, #0]
 800daca:	2380      	movs	r3, #128	; 0x80
 800dacc:	049b      	lsls	r3, r3, #18
 800dace:	4013      	ands	r3, r2
 800dad0:	d1f0      	bne.n	800dab4 <HAL_RCC_OscConfig+0x5e0>
          }
        }

        /* Configure the main PLL clock source, predivider and multiplication factor. */
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 800dad2:	4b1f      	ldr	r3, [pc, #124]	; (800db50 <HAL_RCC_OscConfig+0x67c>)
 800dad4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800dad6:	220f      	movs	r2, #15
 800dad8:	4393      	bics	r3, r2
 800dada:	0019      	movs	r1, r3
 800dadc:	687b      	ldr	r3, [r7, #4]
 800dade:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800dae0:	4b1b      	ldr	r3, [pc, #108]	; (800db50 <HAL_RCC_OscConfig+0x67c>)
 800dae2:	430a      	orrs	r2, r1
 800dae4:	62da      	str	r2, [r3, #44]	; 0x2c
 800dae6:	4b1a      	ldr	r3, [pc, #104]	; (800db50 <HAL_RCC_OscConfig+0x67c>)
 800dae8:	685b      	ldr	r3, [r3, #4]
 800daea:	4a1e      	ldr	r2, [pc, #120]	; (800db64 <HAL_RCC_OscConfig+0x690>)
 800daec:	4013      	ands	r3, r2
 800daee:	0019      	movs	r1, r3
 800daf0:	687b      	ldr	r3, [r7, #4]
 800daf2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800daf4:	687b      	ldr	r3, [r7, #4]
 800daf6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800daf8:	431a      	orrs	r2, r3
 800dafa:	4b15      	ldr	r3, [pc, #84]	; (800db50 <HAL_RCC_OscConfig+0x67c>)
 800dafc:	430a      	orrs	r2, r1
 800dafe:	605a      	str	r2, [r3, #4]
                             RCC_OscInitStruct->PLL.PREDIV,
                             RCC_OscInitStruct->PLL.PLLMUL);
        /* Enable the main PLL. */
        __HAL_RCC_PLL_ENABLE();
 800db00:	4b13      	ldr	r3, [pc, #76]	; (800db50 <HAL_RCC_OscConfig+0x67c>)
 800db02:	681a      	ldr	r2, [r3, #0]
 800db04:	4b12      	ldr	r3, [pc, #72]	; (800db50 <HAL_RCC_OscConfig+0x67c>)
 800db06:	2180      	movs	r1, #128	; 0x80
 800db08:	0449      	lsls	r1, r1, #17
 800db0a:	430a      	orrs	r2, r1
 800db0c:	601a      	str	r2, [r3, #0]
        
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 800db0e:	f7fd fb35 	bl	800b17c <HAL_GetTick>
 800db12:	0003      	movs	r3, r0
 800db14:	61bb      	str	r3, [r7, #24]
        
        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  == RESET)
 800db16:	e008      	b.n	800db2a <HAL_RCC_OscConfig+0x656>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 800db18:	f7fd fb30 	bl	800b17c <HAL_GetTick>
 800db1c:	0002      	movs	r2, r0
 800db1e:	69bb      	ldr	r3, [r7, #24]
 800db20:	1ad3      	subs	r3, r2, r3
 800db22:	2b02      	cmp	r3, #2
 800db24:	d901      	bls.n	800db2a <HAL_RCC_OscConfig+0x656>
          {
            return HAL_TIMEOUT;
 800db26:	2303      	movs	r3, #3
 800db28:	e054      	b.n	800dbd4 <HAL_RCC_OscConfig+0x700>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  == RESET)
 800db2a:	4b09      	ldr	r3, [pc, #36]	; (800db50 <HAL_RCC_OscConfig+0x67c>)
 800db2c:	681a      	ldr	r2, [r3, #0]
 800db2e:	2380      	movs	r3, #128	; 0x80
 800db30:	049b      	lsls	r3, r3, #18
 800db32:	4013      	ands	r3, r2
 800db34:	d0f0      	beq.n	800db18 <HAL_RCC_OscConfig+0x644>
 800db36:	e04c      	b.n	800dbd2 <HAL_RCC_OscConfig+0x6fe>
        }
      }
      else
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 800db38:	4b05      	ldr	r3, [pc, #20]	; (800db50 <HAL_RCC_OscConfig+0x67c>)
 800db3a:	681a      	ldr	r2, [r3, #0]
 800db3c:	4b04      	ldr	r3, [pc, #16]	; (800db50 <HAL_RCC_OscConfig+0x67c>)
 800db3e:	4908      	ldr	r1, [pc, #32]	; (800db60 <HAL_RCC_OscConfig+0x68c>)
 800db40:	400a      	ands	r2, r1
 800db42:	601a      	str	r2, [r3, #0]
 
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 800db44:	f7fd fb1a 	bl	800b17c <HAL_GetTick>
 800db48:	0003      	movs	r3, r0
 800db4a:	61bb      	str	r3, [r7, #24]
        
        /* Wait till PLL is disabled */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 800db4c:	e015      	b.n	800db7a <HAL_RCC_OscConfig+0x6a6>
 800db4e:	46c0      	nop			; (mov r8, r8)
 800db50:	40021000 	.word	0x40021000
 800db54:	00001388 	.word	0x00001388
 800db58:	efffffff 	.word	0xefffffff
 800db5c:	fffeffff 	.word	0xfffeffff
 800db60:	feffffff 	.word	0xfeffffff
 800db64:	ffc27fff 	.word	0xffc27fff
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 800db68:	f7fd fb08 	bl	800b17c <HAL_GetTick>
 800db6c:	0002      	movs	r2, r0
 800db6e:	69bb      	ldr	r3, [r7, #24]
 800db70:	1ad3      	subs	r3, r2, r3
 800db72:	2b02      	cmp	r3, #2
 800db74:	d901      	bls.n	800db7a <HAL_RCC_OscConfig+0x6a6>
          {
            return HAL_TIMEOUT;
 800db76:	2303      	movs	r3, #3
 800db78:	e02c      	b.n	800dbd4 <HAL_RCC_OscConfig+0x700>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 800db7a:	4b18      	ldr	r3, [pc, #96]	; (800dbdc <HAL_RCC_OscConfig+0x708>)
 800db7c:	681a      	ldr	r2, [r3, #0]
 800db7e:	2380      	movs	r3, #128	; 0x80
 800db80:	049b      	lsls	r3, r3, #18
 800db82:	4013      	ands	r3, r2
 800db84:	d1f0      	bne.n	800db68 <HAL_RCC_OscConfig+0x694>
 800db86:	e024      	b.n	800dbd2 <HAL_RCC_OscConfig+0x6fe>
      }
    }
    else
    {
      /* Check if there is a request to disable the PLL used as System clock source */
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF)
 800db88:	687b      	ldr	r3, [r7, #4]
 800db8a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800db8c:	2b01      	cmp	r3, #1
 800db8e:	d101      	bne.n	800db94 <HAL_RCC_OscConfig+0x6c0>
      {
        return HAL_ERROR;
 800db90:	2301      	movs	r3, #1
 800db92:	e01f      	b.n	800dbd4 <HAL_RCC_OscConfig+0x700>
      }
      else
      {
        /* Do not return HAL_ERROR if request repeats the current configuration */
        pll_config  = RCC->CFGR;
 800db94:	4b11      	ldr	r3, [pc, #68]	; (800dbdc <HAL_RCC_OscConfig+0x708>)
 800db96:	685b      	ldr	r3, [r3, #4]
 800db98:	617b      	str	r3, [r7, #20]
        pll_config2 = RCC->CFGR2;
 800db9a:	4b10      	ldr	r3, [pc, #64]	; (800dbdc <HAL_RCC_OscConfig+0x708>)
 800db9c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800db9e:	613b      	str	r3, [r7, #16]
        if((READ_BIT(pll_config,  RCC_CFGR_PLLSRC)  != RCC_OscInitStruct->PLL.PLLSource) ||
 800dba0:	697a      	ldr	r2, [r7, #20]
 800dba2:	23c0      	movs	r3, #192	; 0xc0
 800dba4:	025b      	lsls	r3, r3, #9
 800dba6:	401a      	ands	r2, r3
 800dba8:	687b      	ldr	r3, [r7, #4]
 800dbaa:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800dbac:	429a      	cmp	r2, r3
 800dbae:	d10e      	bne.n	800dbce <HAL_RCC_OscConfig+0x6fa>
           (READ_BIT(pll_config2, RCC_CFGR2_PREDIV) != RCC_OscInitStruct->PLL.PREDIV)    ||
 800dbb0:	693b      	ldr	r3, [r7, #16]
 800dbb2:	220f      	movs	r2, #15
 800dbb4:	401a      	ands	r2, r3
 800dbb6:	687b      	ldr	r3, [r7, #4]
 800dbb8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
        if((READ_BIT(pll_config,  RCC_CFGR_PLLSRC)  != RCC_OscInitStruct->PLL.PLLSource) ||
 800dbba:	429a      	cmp	r2, r3
 800dbbc:	d107      	bne.n	800dbce <HAL_RCC_OscConfig+0x6fa>
           (READ_BIT(pll_config,  RCC_CFGR_PLLMUL)  != RCC_OscInitStruct->PLL.PLLMUL))
 800dbbe:	697a      	ldr	r2, [r7, #20]
 800dbc0:	23f0      	movs	r3, #240	; 0xf0
 800dbc2:	039b      	lsls	r3, r3, #14
 800dbc4:	401a      	ands	r2, r3
 800dbc6:	687b      	ldr	r3, [r7, #4]
 800dbc8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
           (READ_BIT(pll_config2, RCC_CFGR2_PREDIV) != RCC_OscInitStruct->PLL.PREDIV)    ||
 800dbca:	429a      	cmp	r2, r3
 800dbcc:	d001      	beq.n	800dbd2 <HAL_RCC_OscConfig+0x6fe>
        {
          return HAL_ERROR;
 800dbce:	2301      	movs	r3, #1
 800dbd0:	e000      	b.n	800dbd4 <HAL_RCC_OscConfig+0x700>
        }
      }
    }
  }

  return HAL_OK;
 800dbd2:	2300      	movs	r3, #0
}
 800dbd4:	0018      	movs	r0, r3
 800dbd6:	46bd      	mov	sp, r7
 800dbd8:	b008      	add	sp, #32
 800dbda:	bd80      	pop	{r7, pc}
 800dbdc:	40021000 	.word	0x40021000

0800dbe0 <HAL_RCC_ClockConfig>:
  *         You can use @ref HAL_RCC_GetClockConfig() function to know which clock is
  *         currently used as system clock source.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
 800dbe0:	b580      	push	{r7, lr}
 800dbe2:	b084      	sub	sp, #16
 800dbe4:	af00      	add	r7, sp, #0
 800dbe6:	6078      	str	r0, [r7, #4]
 800dbe8:	6039      	str	r1, [r7, #0]
  uint32_t tickstart;

  /* Check Null pointer */
  if(RCC_ClkInitStruct == NULL)
 800dbea:	687b      	ldr	r3, [r7, #4]
 800dbec:	2b00      	cmp	r3, #0
 800dbee:	d101      	bne.n	800dbf4 <HAL_RCC_ClockConfig+0x14>
  {
    return HAL_ERROR;
 800dbf0:	2301      	movs	r3, #1
 800dbf2:	e0bf      	b.n	800dd74 <HAL_RCC_ClockConfig+0x194>
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY) 
  must be correctly programmed according to the frequency of the CPU clock 
    (HCLK) of the device. */

  /* Increasing the number of wait states because of higher CPU frequency */
  if(FLatency > __HAL_FLASH_GET_LATENCY())
 800dbf4:	4b61      	ldr	r3, [pc, #388]	; (800dd7c <HAL_RCC_ClockConfig+0x19c>)
 800dbf6:	681b      	ldr	r3, [r3, #0]
 800dbf8:	2201      	movs	r2, #1
 800dbfa:	4013      	ands	r3, r2
 800dbfc:	683a      	ldr	r2, [r7, #0]
 800dbfe:	429a      	cmp	r2, r3
 800dc00:	d911      	bls.n	800dc26 <HAL_RCC_ClockConfig+0x46>
  {    
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 800dc02:	4b5e      	ldr	r3, [pc, #376]	; (800dd7c <HAL_RCC_ClockConfig+0x19c>)
 800dc04:	681b      	ldr	r3, [r3, #0]
 800dc06:	2201      	movs	r2, #1
 800dc08:	4393      	bics	r3, r2
 800dc0a:	0019      	movs	r1, r3
 800dc0c:	4b5b      	ldr	r3, [pc, #364]	; (800dd7c <HAL_RCC_ClockConfig+0x19c>)
 800dc0e:	683a      	ldr	r2, [r7, #0]
 800dc10:	430a      	orrs	r2, r1
 800dc12:	601a      	str	r2, [r3, #0]
    
    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 800dc14:	4b59      	ldr	r3, [pc, #356]	; (800dd7c <HAL_RCC_ClockConfig+0x19c>)
 800dc16:	681b      	ldr	r3, [r3, #0]
 800dc18:	2201      	movs	r2, #1
 800dc1a:	4013      	ands	r3, r2
 800dc1c:	683a      	ldr	r2, [r7, #0]
 800dc1e:	429a      	cmp	r2, r3
 800dc20:	d001      	beq.n	800dc26 <HAL_RCC_ClockConfig+0x46>
    {
      return HAL_ERROR;
 800dc22:	2301      	movs	r3, #1
 800dc24:	e0a6      	b.n	800dd74 <HAL_RCC_ClockConfig+0x194>
    }
  }

  /*-------------------------- HCLK Configuration --------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 800dc26:	687b      	ldr	r3, [r7, #4]
 800dc28:	681b      	ldr	r3, [r3, #0]
 800dc2a:	2202      	movs	r2, #2
 800dc2c:	4013      	ands	r3, r2
 800dc2e:	d015      	beq.n	800dc5c <HAL_RCC_ClockConfig+0x7c>
  {
    /* Set the highest APB divider in order to ensure that we do not go through
       a non-spec phase whatever we decrease or increase HCLK. */
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 800dc30:	687b      	ldr	r3, [r7, #4]
 800dc32:	681b      	ldr	r3, [r3, #0]
 800dc34:	2204      	movs	r2, #4
 800dc36:	4013      	ands	r3, r2
 800dc38:	d006      	beq.n	800dc48 <HAL_RCC_ClockConfig+0x68>
    {
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE, RCC_HCLK_DIV16);
 800dc3a:	4b51      	ldr	r3, [pc, #324]	; (800dd80 <HAL_RCC_ClockConfig+0x1a0>)
 800dc3c:	685a      	ldr	r2, [r3, #4]
 800dc3e:	4b50      	ldr	r3, [pc, #320]	; (800dd80 <HAL_RCC_ClockConfig+0x1a0>)
 800dc40:	21e0      	movs	r1, #224	; 0xe0
 800dc42:	00c9      	lsls	r1, r1, #3
 800dc44:	430a      	orrs	r2, r1
 800dc46:	605a      	str	r2, [r3, #4]
    }

    /* Set the new HCLK clock divider */
    assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 800dc48:	4b4d      	ldr	r3, [pc, #308]	; (800dd80 <HAL_RCC_ClockConfig+0x1a0>)
 800dc4a:	685b      	ldr	r3, [r3, #4]
 800dc4c:	22f0      	movs	r2, #240	; 0xf0
 800dc4e:	4393      	bics	r3, r2
 800dc50:	0019      	movs	r1, r3
 800dc52:	687b      	ldr	r3, [r7, #4]
 800dc54:	689a      	ldr	r2, [r3, #8]
 800dc56:	4b4a      	ldr	r3, [pc, #296]	; (800dd80 <HAL_RCC_ClockConfig+0x1a0>)
 800dc58:	430a      	orrs	r2, r1
 800dc5a:	605a      	str	r2, [r3, #4]
  }

  /*------------------------- SYSCLK Configuration ---------------------------*/ 
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 800dc5c:	687b      	ldr	r3, [r7, #4]
 800dc5e:	681b      	ldr	r3, [r3, #0]
 800dc60:	2201      	movs	r2, #1
 800dc62:	4013      	ands	r3, r2
 800dc64:	d04c      	beq.n	800dd00 <HAL_RCC_ClockConfig+0x120>
  {
    assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
    
    /* HSE is selected as System Clock Source */
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 800dc66:	687b      	ldr	r3, [r7, #4]
 800dc68:	685b      	ldr	r3, [r3, #4]
 800dc6a:	2b01      	cmp	r3, #1
 800dc6c:	d107      	bne.n	800dc7e <HAL_RCC_ClockConfig+0x9e>
    {
      /* Check the HSE ready flag */  
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800dc6e:	4b44      	ldr	r3, [pc, #272]	; (800dd80 <HAL_RCC_ClockConfig+0x1a0>)
 800dc70:	681a      	ldr	r2, [r3, #0]
 800dc72:	2380      	movs	r3, #128	; 0x80
 800dc74:	029b      	lsls	r3, r3, #10
 800dc76:	4013      	ands	r3, r2
 800dc78:	d120      	bne.n	800dcbc <HAL_RCC_ClockConfig+0xdc>
      {
        return HAL_ERROR;
 800dc7a:	2301      	movs	r3, #1
 800dc7c:	e07a      	b.n	800dd74 <HAL_RCC_ClockConfig+0x194>
      }
    }
    /* PLL is selected as System Clock Source */
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 800dc7e:	687b      	ldr	r3, [r7, #4]
 800dc80:	685b      	ldr	r3, [r3, #4]
 800dc82:	2b02      	cmp	r3, #2
 800dc84:	d107      	bne.n	800dc96 <HAL_RCC_ClockConfig+0xb6>
    {
      /* Check the PLL ready flag */  
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 800dc86:	4b3e      	ldr	r3, [pc, #248]	; (800dd80 <HAL_RCC_ClockConfig+0x1a0>)
 800dc88:	681a      	ldr	r2, [r3, #0]
 800dc8a:	2380      	movs	r3, #128	; 0x80
 800dc8c:	049b      	lsls	r3, r3, #18
 800dc8e:	4013      	ands	r3, r2
 800dc90:	d114      	bne.n	800dcbc <HAL_RCC_ClockConfig+0xdc>
      {
        return HAL_ERROR;
 800dc92:	2301      	movs	r3, #1
 800dc94:	e06e      	b.n	800dd74 <HAL_RCC_ClockConfig+0x194>
      }
    }
#if defined(RCC_CFGR_SWS_HSI48)
    /* HSI48 is selected as System Clock Source */
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSI48)
 800dc96:	687b      	ldr	r3, [r7, #4]
 800dc98:	685b      	ldr	r3, [r3, #4]
 800dc9a:	2b03      	cmp	r3, #3
 800dc9c:	d107      	bne.n	800dcae <HAL_RCC_ClockConfig+0xce>
    {
      /* Check the HSI48 ready flag */
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) == RESET)
 800dc9e:	4b38      	ldr	r3, [pc, #224]	; (800dd80 <HAL_RCC_ClockConfig+0x1a0>)
 800dca0:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800dca2:	2380      	movs	r3, #128	; 0x80
 800dca4:	025b      	lsls	r3, r3, #9
 800dca6:	4013      	ands	r3, r2
 800dca8:	d108      	bne.n	800dcbc <HAL_RCC_ClockConfig+0xdc>
      {
        return HAL_ERROR;
 800dcaa:	2301      	movs	r3, #1
 800dcac:	e062      	b.n	800dd74 <HAL_RCC_ClockConfig+0x194>
#endif /* RCC_CFGR_SWS_HSI48 */
    /* HSI is selected as System Clock Source */
    else
    {
      /* Check the HSI ready flag */  
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 800dcae:	4b34      	ldr	r3, [pc, #208]	; (800dd80 <HAL_RCC_ClockConfig+0x1a0>)
 800dcb0:	681b      	ldr	r3, [r3, #0]
 800dcb2:	2202      	movs	r2, #2
 800dcb4:	4013      	ands	r3, r2
 800dcb6:	d101      	bne.n	800dcbc <HAL_RCC_ClockConfig+0xdc>
      {
        return HAL_ERROR;
 800dcb8:	2301      	movs	r3, #1
 800dcba:	e05b      	b.n	800dd74 <HAL_RCC_ClockConfig+0x194>
      }
    }
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 800dcbc:	4b30      	ldr	r3, [pc, #192]	; (800dd80 <HAL_RCC_ClockConfig+0x1a0>)
 800dcbe:	685b      	ldr	r3, [r3, #4]
 800dcc0:	2203      	movs	r2, #3
 800dcc2:	4393      	bics	r3, r2
 800dcc4:	0019      	movs	r1, r3
 800dcc6:	687b      	ldr	r3, [r7, #4]
 800dcc8:	685a      	ldr	r2, [r3, #4]
 800dcca:	4b2d      	ldr	r3, [pc, #180]	; (800dd80 <HAL_RCC_ClockConfig+0x1a0>)
 800dccc:	430a      	orrs	r2, r1
 800dcce:	605a      	str	r2, [r3, #4]

    /* Get Start Tick */
    tickstart = HAL_GetTick();
 800dcd0:	f7fd fa54 	bl	800b17c <HAL_GetTick>
 800dcd4:	0003      	movs	r3, r0
 800dcd6:	60fb      	str	r3, [r7, #12]
    
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 800dcd8:	e009      	b.n	800dcee <HAL_RCC_ClockConfig+0x10e>
    {
      if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 800dcda:	f7fd fa4f 	bl	800b17c <HAL_GetTick>
 800dcde:	0002      	movs	r2, r0
 800dce0:	68fb      	ldr	r3, [r7, #12]
 800dce2:	1ad3      	subs	r3, r2, r3
 800dce4:	4a27      	ldr	r2, [pc, #156]	; (800dd84 <HAL_RCC_ClockConfig+0x1a4>)
 800dce6:	4293      	cmp	r3, r2
 800dce8:	d901      	bls.n	800dcee <HAL_RCC_ClockConfig+0x10e>
      {
        return HAL_TIMEOUT;
 800dcea:	2303      	movs	r3, #3
 800dcec:	e042      	b.n	800dd74 <HAL_RCC_ClockConfig+0x194>
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 800dcee:	4b24      	ldr	r3, [pc, #144]	; (800dd80 <HAL_RCC_ClockConfig+0x1a0>)
 800dcf0:	685b      	ldr	r3, [r3, #4]
 800dcf2:	220c      	movs	r2, #12
 800dcf4:	401a      	ands	r2, r3
 800dcf6:	687b      	ldr	r3, [r7, #4]
 800dcf8:	685b      	ldr	r3, [r3, #4]
 800dcfa:	009b      	lsls	r3, r3, #2
 800dcfc:	429a      	cmp	r2, r3
 800dcfe:	d1ec      	bne.n	800dcda <HAL_RCC_ClockConfig+0xfa>
      }
    }
  }

  /* Decreasing the number of wait states because of lower CPU frequency */
  if(FLatency < __HAL_FLASH_GET_LATENCY())
 800dd00:	4b1e      	ldr	r3, [pc, #120]	; (800dd7c <HAL_RCC_ClockConfig+0x19c>)
 800dd02:	681b      	ldr	r3, [r3, #0]
 800dd04:	2201      	movs	r2, #1
 800dd06:	4013      	ands	r3, r2
 800dd08:	683a      	ldr	r2, [r7, #0]
 800dd0a:	429a      	cmp	r2, r3
 800dd0c:	d211      	bcs.n	800dd32 <HAL_RCC_ClockConfig+0x152>
  {    
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 800dd0e:	4b1b      	ldr	r3, [pc, #108]	; (800dd7c <HAL_RCC_ClockConfig+0x19c>)
 800dd10:	681b      	ldr	r3, [r3, #0]
 800dd12:	2201      	movs	r2, #1
 800dd14:	4393      	bics	r3, r2
 800dd16:	0019      	movs	r1, r3
 800dd18:	4b18      	ldr	r3, [pc, #96]	; (800dd7c <HAL_RCC_ClockConfig+0x19c>)
 800dd1a:	683a      	ldr	r2, [r7, #0]
 800dd1c:	430a      	orrs	r2, r1
 800dd1e:	601a      	str	r2, [r3, #0]
    
    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 800dd20:	4b16      	ldr	r3, [pc, #88]	; (800dd7c <HAL_RCC_ClockConfig+0x19c>)
 800dd22:	681b      	ldr	r3, [r3, #0]
 800dd24:	2201      	movs	r2, #1
 800dd26:	4013      	ands	r3, r2
 800dd28:	683a      	ldr	r2, [r7, #0]
 800dd2a:	429a      	cmp	r2, r3
 800dd2c:	d001      	beq.n	800dd32 <HAL_RCC_ClockConfig+0x152>
    {
      return HAL_ERROR;
 800dd2e:	2301      	movs	r3, #1
 800dd30:	e020      	b.n	800dd74 <HAL_RCC_ClockConfig+0x194>
    }
  }    

  /*-------------------------- PCLK1 Configuration ---------------------------*/ 
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 800dd32:	687b      	ldr	r3, [r7, #4]
 800dd34:	681b      	ldr	r3, [r3, #0]
 800dd36:	2204      	movs	r2, #4
 800dd38:	4013      	ands	r3, r2
 800dd3a:	d009      	beq.n	800dd50 <HAL_RCC_ClockConfig+0x170>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE, RCC_ClkInitStruct->APB1CLKDivider);
 800dd3c:	4b10      	ldr	r3, [pc, #64]	; (800dd80 <HAL_RCC_ClockConfig+0x1a0>)
 800dd3e:	685b      	ldr	r3, [r3, #4]
 800dd40:	4a11      	ldr	r2, [pc, #68]	; (800dd88 <HAL_RCC_ClockConfig+0x1a8>)
 800dd42:	4013      	ands	r3, r2
 800dd44:	0019      	movs	r1, r3
 800dd46:	687b      	ldr	r3, [r7, #4]
 800dd48:	68da      	ldr	r2, [r3, #12]
 800dd4a:	4b0d      	ldr	r3, [pc, #52]	; (800dd80 <HAL_RCC_ClockConfig+0x1a0>)
 800dd4c:	430a      	orrs	r2, r1
 800dd4e:	605a      	str	r2, [r3, #4]
  }
  
  /* Update the SystemCoreClock global variable */
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> RCC_CFGR_HPRE_BITNUMBER];
 800dd50:	f000 f820 	bl	800dd94 <HAL_RCC_GetSysClockFreq>
 800dd54:	0001      	movs	r1, r0
 800dd56:	4b0a      	ldr	r3, [pc, #40]	; (800dd80 <HAL_RCC_ClockConfig+0x1a0>)
 800dd58:	685b      	ldr	r3, [r3, #4]
 800dd5a:	091b      	lsrs	r3, r3, #4
 800dd5c:	220f      	movs	r2, #15
 800dd5e:	4013      	ands	r3, r2
 800dd60:	4a0a      	ldr	r2, [pc, #40]	; (800dd8c <HAL_RCC_ClockConfig+0x1ac>)
 800dd62:	5cd3      	ldrb	r3, [r2, r3]
 800dd64:	000a      	movs	r2, r1
 800dd66:	40da      	lsrs	r2, r3
 800dd68:	4b09      	ldr	r3, [pc, #36]	; (800dd90 <HAL_RCC_ClockConfig+0x1b0>)
 800dd6a:	601a      	str	r2, [r3, #0]

  /* Configure the source of time base considering new system clocks settings*/
  HAL_InitTick (TICK_INT_PRIORITY);
 800dd6c:	2003      	movs	r0, #3
 800dd6e:	f7fd f9bf 	bl	800b0f0 <HAL_InitTick>
  
  return HAL_OK;
 800dd72:	2300      	movs	r3, #0
}
 800dd74:	0018      	movs	r0, r3
 800dd76:	46bd      	mov	sp, r7
 800dd78:	b004      	add	sp, #16
 800dd7a:	bd80      	pop	{r7, pc}
 800dd7c:	40022000 	.word	0x40022000
 800dd80:	40021000 	.word	0x40021000
 800dd84:	00001388 	.word	0x00001388
 800dd88:	fffff8ff 	.word	0xfffff8ff
 800dd8c:	08015d3c 	.word	0x08015d3c
 800dd90:	2000015c 	.word	0x2000015c

0800dd94 <HAL_RCC_GetSysClockFreq>:
  *         right SYSCLK value. Otherwise, any configuration based on this function will be incorrect.
  *         
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
 800dd94:	b590      	push	{r4, r7, lr}
 800dd96:	b08f      	sub	sp, #60	; 0x3c
 800dd98:	af00      	add	r7, sp, #0
  const uint8_t aPLLMULFactorTable[16] = { 2U,  3U,  4U,  5U,  6U,  7U,  8U,  9U,
 800dd9a:	2314      	movs	r3, #20
 800dd9c:	18fb      	adds	r3, r7, r3
 800dd9e:	4a38      	ldr	r2, [pc, #224]	; (800de80 <HAL_RCC_GetSysClockFreq+0xec>)
 800dda0:	ca13      	ldmia	r2!, {r0, r1, r4}
 800dda2:	c313      	stmia	r3!, {r0, r1, r4}
 800dda4:	6812      	ldr	r2, [r2, #0]
 800dda6:	601a      	str	r2, [r3, #0]
                                         10U, 11U, 12U, 13U, 14U, 15U, 16U, 16U};
  const uint8_t aPredivFactorTable[16] = { 1U, 2U,  3U,  4U,  5U,  6U,  7U,  8U,
 800dda8:	1d3b      	adds	r3, r7, #4
 800ddaa:	4a36      	ldr	r2, [pc, #216]	; (800de84 <HAL_RCC_GetSysClockFreq+0xf0>)
 800ddac:	ca13      	ldmia	r2!, {r0, r1, r4}
 800ddae:	c313      	stmia	r3!, {r0, r1, r4}
 800ddb0:	6812      	ldr	r2, [r2, #0]
 800ddb2:	601a      	str	r2, [r3, #0]
                                           9U,10U, 11U, 12U, 13U, 14U, 15U, 16U};

  uint32_t tmpreg = 0U, prediv = 0U, pllclk = 0U, pllmul = 0U;
 800ddb4:	2300      	movs	r3, #0
 800ddb6:	62fb      	str	r3, [r7, #44]	; 0x2c
 800ddb8:	2300      	movs	r3, #0
 800ddba:	62bb      	str	r3, [r7, #40]	; 0x28
 800ddbc:	2300      	movs	r3, #0
 800ddbe:	637b      	str	r3, [r7, #52]	; 0x34
 800ddc0:	2300      	movs	r3, #0
 800ddc2:	627b      	str	r3, [r7, #36]	; 0x24
  uint32_t sysclockfreq = 0U;
 800ddc4:	2300      	movs	r3, #0
 800ddc6:	633b      	str	r3, [r7, #48]	; 0x30
  
  tmpreg = RCC->CFGR;
 800ddc8:	4b2f      	ldr	r3, [pc, #188]	; (800de88 <HAL_RCC_GetSysClockFreq+0xf4>)
 800ddca:	685b      	ldr	r3, [r3, #4]
 800ddcc:	62fb      	str	r3, [r7, #44]	; 0x2c
  
  /* Get SYSCLK source -------------------------------------------------------*/
  switch (tmpreg & RCC_CFGR_SWS)
 800ddce:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ddd0:	220c      	movs	r2, #12
 800ddd2:	4013      	ands	r3, r2
 800ddd4:	2b0c      	cmp	r3, #12
 800ddd6:	d047      	beq.n	800de68 <HAL_RCC_GetSysClockFreq+0xd4>
 800ddd8:	d849      	bhi.n	800de6e <HAL_RCC_GetSysClockFreq+0xda>
 800ddda:	2b04      	cmp	r3, #4
 800dddc:	d002      	beq.n	800dde4 <HAL_RCC_GetSysClockFreq+0x50>
 800ddde:	2b08      	cmp	r3, #8
 800dde0:	d003      	beq.n	800ddea <HAL_RCC_GetSysClockFreq+0x56>
 800dde2:	e044      	b.n	800de6e <HAL_RCC_GetSysClockFreq+0xda>
  {
    case RCC_SYSCLKSOURCE_STATUS_HSE:  /* HSE used as system clock */
    {
      sysclockfreq = HSE_VALUE;
 800dde4:	4b29      	ldr	r3, [pc, #164]	; (800de8c <HAL_RCC_GetSysClockFreq+0xf8>)
 800dde6:	633b      	str	r3, [r7, #48]	; 0x30
      break;
 800dde8:	e044      	b.n	800de74 <HAL_RCC_GetSysClockFreq+0xe0>
    }
    case RCC_SYSCLKSOURCE_STATUS_PLLCLK:  /* PLL used as system clock */
    {
      pllmul = aPLLMULFactorTable[(uint32_t)(tmpreg & RCC_CFGR_PLLMUL) >> RCC_CFGR_PLLMUL_BITNUMBER];
 800ddea:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ddec:	0c9b      	lsrs	r3, r3, #18
 800ddee:	220f      	movs	r2, #15
 800ddf0:	4013      	ands	r3, r2
 800ddf2:	2214      	movs	r2, #20
 800ddf4:	18ba      	adds	r2, r7, r2
 800ddf6:	5cd3      	ldrb	r3, [r2, r3]
 800ddf8:	627b      	str	r3, [r7, #36]	; 0x24
      prediv = aPredivFactorTable[(uint32_t)(RCC->CFGR2 & RCC_CFGR2_PREDIV) >> RCC_CFGR2_PREDIV_BITNUMBER];
 800ddfa:	4b23      	ldr	r3, [pc, #140]	; (800de88 <HAL_RCC_GetSysClockFreq+0xf4>)
 800ddfc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800ddfe:	220f      	movs	r2, #15
 800de00:	4013      	ands	r3, r2
 800de02:	1d3a      	adds	r2, r7, #4
 800de04:	5cd3      	ldrb	r3, [r2, r3]
 800de06:	62bb      	str	r3, [r7, #40]	; 0x28
      if ((tmpreg & RCC_CFGR_PLLSRC) == RCC_PLLSOURCE_HSE)
 800de08:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800de0a:	23c0      	movs	r3, #192	; 0xc0
 800de0c:	025b      	lsls	r3, r3, #9
 800de0e:	401a      	ands	r2, r3
 800de10:	2380      	movs	r3, #128	; 0x80
 800de12:	025b      	lsls	r3, r3, #9
 800de14:	429a      	cmp	r2, r3
 800de16:	d109      	bne.n	800de2c <HAL_RCC_GetSysClockFreq+0x98>
      {
        /* HSE used as PLL clock source : PLLCLK = HSE/PREDIV * PLLMUL */
        pllclk = (uint32_t)((uint64_t) HSE_VALUE / (uint64_t) (prediv)) * ((uint64_t) pllmul);
 800de18:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 800de1a:	481c      	ldr	r0, [pc, #112]	; (800de8c <HAL_RCC_GetSysClockFreq+0xf8>)
 800de1c:	f7fb f986 	bl	800912c <__udivsi3>
 800de20:	0003      	movs	r3, r0
 800de22:	001a      	movs	r2, r3
 800de24:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800de26:	4353      	muls	r3, r2
 800de28:	637b      	str	r3, [r7, #52]	; 0x34
 800de2a:	e01a      	b.n	800de62 <HAL_RCC_GetSysClockFreq+0xce>
      }
#if defined(RCC_CFGR_PLLSRC_HSI48_PREDIV)
      else if ((tmpreg & RCC_CFGR_PLLSRC) == RCC_PLLSOURCE_HSI48)
 800de2c:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800de2e:	23c0      	movs	r3, #192	; 0xc0
 800de30:	025b      	lsls	r3, r3, #9
 800de32:	401a      	ands	r2, r3
 800de34:	23c0      	movs	r3, #192	; 0xc0
 800de36:	025b      	lsls	r3, r3, #9
 800de38:	429a      	cmp	r2, r3
 800de3a:	d109      	bne.n	800de50 <HAL_RCC_GetSysClockFreq+0xbc>
      {
        /* HSI48 used as PLL clock source : PLLCLK = HSI48/PREDIV * PLLMUL */
        pllclk = (uint32_t)((uint64_t) HSI48_VALUE / (uint64_t) (prediv)) * ((uint64_t) pllmul);
 800de3c:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 800de3e:	4814      	ldr	r0, [pc, #80]	; (800de90 <HAL_RCC_GetSysClockFreq+0xfc>)
 800de40:	f7fb f974 	bl	800912c <__udivsi3>
 800de44:	0003      	movs	r3, r0
 800de46:	001a      	movs	r2, r3
 800de48:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800de4a:	4353      	muls	r3, r2
 800de4c:	637b      	str	r3, [r7, #52]	; 0x34
 800de4e:	e008      	b.n	800de62 <HAL_RCC_GetSysClockFreq+0xce>
#endif /* RCC_CFGR_PLLSRC_HSI48_PREDIV */
      else
      {
#if  (defined(STM32F042x6) || defined(STM32F048xx) || defined(STM32F070x6) || defined(STM32F071xB) || defined(STM32F072xB) || defined(STM32F078xx) || defined(STM32F070xB) || defined(STM32F091xC) || defined(STM32F098xx) || defined(STM32F030xC))
        /* HSI used as PLL clock source : PLLCLK = HSI/PREDIV * PLLMUL */
        pllclk = (uint32_t)((uint64_t) HSI_VALUE / (uint64_t) (prediv)) * ((uint64_t) pllmul);
 800de50:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 800de52:	480e      	ldr	r0, [pc, #56]	; (800de8c <HAL_RCC_GetSysClockFreq+0xf8>)
 800de54:	f7fb f96a 	bl	800912c <__udivsi3>
 800de58:	0003      	movs	r3, r0
 800de5a:	001a      	movs	r2, r3
 800de5c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800de5e:	4353      	muls	r3, r2
 800de60:	637b      	str	r3, [r7, #52]	; 0x34
#else
        /* HSI used as PLL clock source : PLLCLK = HSI/2 * PLLMUL */
        pllclk = (uint32_t)((uint64_t) (HSI_VALUE >> 1U) * ((uint64_t) pllmul));
#endif
      }
      sysclockfreq = pllclk;
 800de62:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800de64:	633b      	str	r3, [r7, #48]	; 0x30
      break;
 800de66:	e005      	b.n	800de74 <HAL_RCC_GetSysClockFreq+0xe0>
    }
#if defined(RCC_CFGR_SWS_HSI48)
    case RCC_SYSCLKSOURCE_STATUS_HSI48:    /* HSI48 used as system clock source */
    {
      sysclockfreq = HSI48_VALUE;
 800de68:	4b09      	ldr	r3, [pc, #36]	; (800de90 <HAL_RCC_GetSysClockFreq+0xfc>)
 800de6a:	633b      	str	r3, [r7, #48]	; 0x30
      break;
 800de6c:	e002      	b.n	800de74 <HAL_RCC_GetSysClockFreq+0xe0>
    }
#endif /* RCC_CFGR_SWS_HSI48 */
    case RCC_SYSCLKSOURCE_STATUS_HSI:  /* HSI used as system clock source */
    default: /* HSI used as system clock */
    {
      sysclockfreq = HSI_VALUE;
 800de6e:	4b07      	ldr	r3, [pc, #28]	; (800de8c <HAL_RCC_GetSysClockFreq+0xf8>)
 800de70:	633b      	str	r3, [r7, #48]	; 0x30
      break;
 800de72:	46c0      	nop			; (mov r8, r8)
    }
  }
  return sysclockfreq;
 800de74:	6b3b      	ldr	r3, [r7, #48]	; 0x30
}
 800de76:	0018      	movs	r0, r3
 800de78:	46bd      	mov	sp, r7
 800de7a:	b00f      	add	sp, #60	; 0x3c
 800de7c:	bd90      	pop	{r4, r7, pc}
 800de7e:	46c0      	nop			; (mov r8, r8)
 800de80:	08015c84 	.word	0x08015c84
 800de84:	08015c94 	.word	0x08015c94
 800de88:	40021000 	.word	0x40021000
 800de8c:	007a1200 	.word	0x007a1200
 800de90:	02dc6c00 	.word	0x02dc6c00

0800de94 <HAL_RCC_GetHCLKFreq>:
  * @note   The SystemCoreClock CMSIS variable is used to store System Clock Frequency 
  *         and updated within this function
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
 800de94:	b580      	push	{r7, lr}
 800de96:	af00      	add	r7, sp, #0
  return SystemCoreClock;
 800de98:	4b02      	ldr	r3, [pc, #8]	; (800dea4 <HAL_RCC_GetHCLKFreq+0x10>)
 800de9a:	681b      	ldr	r3, [r3, #0]
}
 800de9c:	0018      	movs	r0, r3
 800de9e:	46bd      	mov	sp, r7
 800dea0:	bd80      	pop	{r7, pc}
 800dea2:	46c0      	nop			; (mov r8, r8)
 800dea4:	2000015c 	.word	0x2000015c

0800dea8 <HAL_RCC_GetPCLK1Freq>:
  * @note   Each time PCLK1 changes, this function must be called to update the
  *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
 800dea8:	b580      	push	{r7, lr}
 800deaa:	af00      	add	r7, sp, #0
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE) >> RCC_CFGR_PPRE_BITNUMBER]);
 800deac:	f7ff fff2 	bl	800de94 <HAL_RCC_GetHCLKFreq>
 800deb0:	0001      	movs	r1, r0
 800deb2:	4b06      	ldr	r3, [pc, #24]	; (800decc <HAL_RCC_GetPCLK1Freq+0x24>)
 800deb4:	685b      	ldr	r3, [r3, #4]
 800deb6:	0a1b      	lsrs	r3, r3, #8
 800deb8:	2207      	movs	r2, #7
 800deba:	4013      	ands	r3, r2
 800debc:	4a04      	ldr	r2, [pc, #16]	; (800ded0 <HAL_RCC_GetPCLK1Freq+0x28>)
 800debe:	5cd3      	ldrb	r3, [r2, r3]
 800dec0:	40d9      	lsrs	r1, r3
 800dec2:	000b      	movs	r3, r1
}    
 800dec4:	0018      	movs	r0, r3
 800dec6:	46bd      	mov	sp, r7
 800dec8:	bd80      	pop	{r7, pc}
 800deca:	46c0      	nop			; (mov r8, r8)
 800decc:	40021000 	.word	0x40021000
 800ded0:	08015d4c 	.word	0x08015d4c

0800ded4 <HAL_RCCEx_PeriphCLKConfig>:
  *         the backup registers) and RCC_BDCR register are set to their reset values.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 800ded4:	b580      	push	{r7, lr}
 800ded6:	b086      	sub	sp, #24
 800ded8:	af00      	add	r7, sp, #0
 800deda:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = 0U;
 800dedc:	2300      	movs	r3, #0
 800dede:	613b      	str	r3, [r7, #16]
  uint32_t temp_reg = 0U;
 800dee0:	2300      	movs	r3, #0
 800dee2:	60fb      	str	r3, [r7, #12]

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));
  
  /*---------------------------- RTC configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == (RCC_PERIPHCLK_RTC))
 800dee4:	687b      	ldr	r3, [r7, #4]
 800dee6:	681a      	ldr	r2, [r3, #0]
 800dee8:	2380      	movs	r3, #128	; 0x80
 800deea:	025b      	lsls	r3, r3, #9
 800deec:	4013      	ands	r3, r2
 800deee:	d100      	bne.n	800def2 <HAL_RCCEx_PeriphCLKConfig+0x1e>
 800def0:	e08e      	b.n	800e010 <HAL_RCCEx_PeriphCLKConfig+0x13c>
  {
    /* check for RTC Parameters used to output RTCCLK */
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));
    
    FlagStatus       pwrclkchanged = RESET;
 800def2:	2017      	movs	r0, #23
 800def4:	183b      	adds	r3, r7, r0
 800def6:	2200      	movs	r2, #0
 800def8:	701a      	strb	r2, [r3, #0]

    /* As soon as function is called to change RTC clock source, activation of the 
       power domain is done. */
    /* Requires to enable write access to Backup Domain of necessary */
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 800defa:	4b6e      	ldr	r3, [pc, #440]	; (800e0b4 <HAL_RCCEx_PeriphCLKConfig+0x1e0>)
 800defc:	69da      	ldr	r2, [r3, #28]
 800defe:	2380      	movs	r3, #128	; 0x80
 800df00:	055b      	lsls	r3, r3, #21
 800df02:	4013      	ands	r3, r2
 800df04:	d110      	bne.n	800df28 <HAL_RCCEx_PeriphCLKConfig+0x54>
    {
    __HAL_RCC_PWR_CLK_ENABLE();
 800df06:	4b6b      	ldr	r3, [pc, #428]	; (800e0b4 <HAL_RCCEx_PeriphCLKConfig+0x1e0>)
 800df08:	69da      	ldr	r2, [r3, #28]
 800df0a:	4b6a      	ldr	r3, [pc, #424]	; (800e0b4 <HAL_RCCEx_PeriphCLKConfig+0x1e0>)
 800df0c:	2180      	movs	r1, #128	; 0x80
 800df0e:	0549      	lsls	r1, r1, #21
 800df10:	430a      	orrs	r2, r1
 800df12:	61da      	str	r2, [r3, #28]
 800df14:	4b67      	ldr	r3, [pc, #412]	; (800e0b4 <HAL_RCCEx_PeriphCLKConfig+0x1e0>)
 800df16:	69da      	ldr	r2, [r3, #28]
 800df18:	2380      	movs	r3, #128	; 0x80
 800df1a:	055b      	lsls	r3, r3, #21
 800df1c:	4013      	ands	r3, r2
 800df1e:	60bb      	str	r3, [r7, #8]
 800df20:	68bb      	ldr	r3, [r7, #8]
      pwrclkchanged = SET;
 800df22:	183b      	adds	r3, r7, r0
 800df24:	2201      	movs	r2, #1
 800df26:	701a      	strb	r2, [r3, #0]
    }
    
    if(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 800df28:	4b63      	ldr	r3, [pc, #396]	; (800e0b8 <HAL_RCCEx_PeriphCLKConfig+0x1e4>)
 800df2a:	681a      	ldr	r2, [r3, #0]
 800df2c:	2380      	movs	r3, #128	; 0x80
 800df2e:	005b      	lsls	r3, r3, #1
 800df30:	4013      	ands	r3, r2
 800df32:	d11a      	bne.n	800df6a <HAL_RCCEx_PeriphCLKConfig+0x96>
    {
      /* Enable write access to Backup domain */
      SET_BIT(PWR->CR, PWR_CR_DBP);
 800df34:	4b60      	ldr	r3, [pc, #384]	; (800e0b8 <HAL_RCCEx_PeriphCLKConfig+0x1e4>)
 800df36:	681a      	ldr	r2, [r3, #0]
 800df38:	4b5f      	ldr	r3, [pc, #380]	; (800e0b8 <HAL_RCCEx_PeriphCLKConfig+0x1e4>)
 800df3a:	2180      	movs	r1, #128	; 0x80
 800df3c:	0049      	lsls	r1, r1, #1
 800df3e:	430a      	orrs	r2, r1
 800df40:	601a      	str	r2, [r3, #0]
      
      /* Wait for Backup domain Write protection disable */
      tickstart = HAL_GetTick();
 800df42:	f7fd f91b 	bl	800b17c <HAL_GetTick>
 800df46:	0003      	movs	r3, r0
 800df48:	613b      	str	r3, [r7, #16]
      
      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 800df4a:	e008      	b.n	800df5e <HAL_RCCEx_PeriphCLKConfig+0x8a>
      {
        if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 800df4c:	f7fd f916 	bl	800b17c <HAL_GetTick>
 800df50:	0002      	movs	r2, r0
 800df52:	693b      	ldr	r3, [r7, #16]
 800df54:	1ad3      	subs	r3, r2, r3
 800df56:	2b64      	cmp	r3, #100	; 0x64
 800df58:	d901      	bls.n	800df5e <HAL_RCCEx_PeriphCLKConfig+0x8a>
        {
          return HAL_TIMEOUT;
 800df5a:	2303      	movs	r3, #3
 800df5c:	e0a6      	b.n	800e0ac <HAL_RCCEx_PeriphCLKConfig+0x1d8>
      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 800df5e:	4b56      	ldr	r3, [pc, #344]	; (800e0b8 <HAL_RCCEx_PeriphCLKConfig+0x1e4>)
 800df60:	681a      	ldr	r2, [r3, #0]
 800df62:	2380      	movs	r3, #128	; 0x80
 800df64:	005b      	lsls	r3, r3, #1
 800df66:	4013      	ands	r3, r2
 800df68:	d0f0      	beq.n	800df4c <HAL_RCCEx_PeriphCLKConfig+0x78>
        }
      }
    }
    
    /* Reset the Backup domain only if the RTC Clock source selection is modified from reset value */ 
    temp_reg = (RCC->BDCR & RCC_BDCR_RTCSEL);
 800df6a:	4b52      	ldr	r3, [pc, #328]	; (800e0b4 <HAL_RCCEx_PeriphCLKConfig+0x1e0>)
 800df6c:	6a1a      	ldr	r2, [r3, #32]
 800df6e:	23c0      	movs	r3, #192	; 0xc0
 800df70:	009b      	lsls	r3, r3, #2
 800df72:	4013      	ands	r3, r2
 800df74:	60fb      	str	r3, [r7, #12]
    if((temp_reg != 0x00000000U) && (temp_reg != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL)))
 800df76:	68fb      	ldr	r3, [r7, #12]
 800df78:	2b00      	cmp	r3, #0
 800df7a:	d034      	beq.n	800dfe6 <HAL_RCCEx_PeriphCLKConfig+0x112>
 800df7c:	687b      	ldr	r3, [r7, #4]
 800df7e:	685a      	ldr	r2, [r3, #4]
 800df80:	23c0      	movs	r3, #192	; 0xc0
 800df82:	009b      	lsls	r3, r3, #2
 800df84:	4013      	ands	r3, r2
 800df86:	68fa      	ldr	r2, [r7, #12]
 800df88:	429a      	cmp	r2, r3
 800df8a:	d02c      	beq.n	800dfe6 <HAL_RCCEx_PeriphCLKConfig+0x112>
    {
      /* Store the content of BDCR register before the reset of Backup Domain */
      temp_reg = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 800df8c:	4b49      	ldr	r3, [pc, #292]	; (800e0b4 <HAL_RCCEx_PeriphCLKConfig+0x1e0>)
 800df8e:	6a1b      	ldr	r3, [r3, #32]
 800df90:	4a4a      	ldr	r2, [pc, #296]	; (800e0bc <HAL_RCCEx_PeriphCLKConfig+0x1e8>)
 800df92:	4013      	ands	r3, r2
 800df94:	60fb      	str	r3, [r7, #12]
      /* RTC Clock selection can be changed only if the Backup Domain is reset */
      __HAL_RCC_BACKUPRESET_FORCE();
 800df96:	4b47      	ldr	r3, [pc, #284]	; (800e0b4 <HAL_RCCEx_PeriphCLKConfig+0x1e0>)
 800df98:	6a1a      	ldr	r2, [r3, #32]
 800df9a:	4b46      	ldr	r3, [pc, #280]	; (800e0b4 <HAL_RCCEx_PeriphCLKConfig+0x1e0>)
 800df9c:	2180      	movs	r1, #128	; 0x80
 800df9e:	0249      	lsls	r1, r1, #9
 800dfa0:	430a      	orrs	r2, r1
 800dfa2:	621a      	str	r2, [r3, #32]
      __HAL_RCC_BACKUPRESET_RELEASE();
 800dfa4:	4b43      	ldr	r3, [pc, #268]	; (800e0b4 <HAL_RCCEx_PeriphCLKConfig+0x1e0>)
 800dfa6:	6a1a      	ldr	r2, [r3, #32]
 800dfa8:	4b42      	ldr	r3, [pc, #264]	; (800e0b4 <HAL_RCCEx_PeriphCLKConfig+0x1e0>)
 800dfaa:	4945      	ldr	r1, [pc, #276]	; (800e0c0 <HAL_RCCEx_PeriphCLKConfig+0x1ec>)
 800dfac:	400a      	ands	r2, r1
 800dfae:	621a      	str	r2, [r3, #32]
      /* Restore the Content of BDCR register */
      RCC->BDCR = temp_reg;
 800dfb0:	4b40      	ldr	r3, [pc, #256]	; (800e0b4 <HAL_RCCEx_PeriphCLKConfig+0x1e0>)
 800dfb2:	68fa      	ldr	r2, [r7, #12]
 800dfb4:	621a      	str	r2, [r3, #32]
      
      /* Wait for LSERDY if LSE was enabled */
      if (HAL_IS_BIT_SET(temp_reg, RCC_BDCR_LSEON))
 800dfb6:	68fb      	ldr	r3, [r7, #12]
 800dfb8:	2201      	movs	r2, #1
 800dfba:	4013      	ands	r3, r2
 800dfbc:	d013      	beq.n	800dfe6 <HAL_RCCEx_PeriphCLKConfig+0x112>
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 800dfbe:	f7fd f8dd 	bl	800b17c <HAL_GetTick>
 800dfc2:	0003      	movs	r3, r0
 800dfc4:	613b      	str	r3, [r7, #16]
        
        /* Wait till LSE is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 800dfc6:	e009      	b.n	800dfdc <HAL_RCCEx_PeriphCLKConfig+0x108>
        {
          if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 800dfc8:	f7fd f8d8 	bl	800b17c <HAL_GetTick>
 800dfcc:	0002      	movs	r2, r0
 800dfce:	693b      	ldr	r3, [r7, #16]
 800dfd0:	1ad3      	subs	r3, r2, r3
 800dfd2:	4a3c      	ldr	r2, [pc, #240]	; (800e0c4 <HAL_RCCEx_PeriphCLKConfig+0x1f0>)
 800dfd4:	4293      	cmp	r3, r2
 800dfd6:	d901      	bls.n	800dfdc <HAL_RCCEx_PeriphCLKConfig+0x108>
          {
            return HAL_TIMEOUT;
 800dfd8:	2303      	movs	r3, #3
 800dfda:	e067      	b.n	800e0ac <HAL_RCCEx_PeriphCLKConfig+0x1d8>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 800dfdc:	4b35      	ldr	r3, [pc, #212]	; (800e0b4 <HAL_RCCEx_PeriphCLKConfig+0x1e0>)
 800dfde:	6a1b      	ldr	r3, [r3, #32]
 800dfe0:	2202      	movs	r2, #2
 800dfe2:	4013      	ands	r3, r2
 800dfe4:	d0f0      	beq.n	800dfc8 <HAL_RCCEx_PeriphCLKConfig+0xf4>
          }
        }
      }
    }
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 800dfe6:	4b33      	ldr	r3, [pc, #204]	; (800e0b4 <HAL_RCCEx_PeriphCLKConfig+0x1e0>)
 800dfe8:	6a1b      	ldr	r3, [r3, #32]
 800dfea:	4a34      	ldr	r2, [pc, #208]	; (800e0bc <HAL_RCCEx_PeriphCLKConfig+0x1e8>)
 800dfec:	4013      	ands	r3, r2
 800dfee:	0019      	movs	r1, r3
 800dff0:	687b      	ldr	r3, [r7, #4]
 800dff2:	685a      	ldr	r2, [r3, #4]
 800dff4:	4b2f      	ldr	r3, [pc, #188]	; (800e0b4 <HAL_RCCEx_PeriphCLKConfig+0x1e0>)
 800dff6:	430a      	orrs	r2, r1
 800dff8:	621a      	str	r2, [r3, #32]

    /* Require to disable power clock if necessary */
    if(pwrclkchanged == SET)
 800dffa:	2317      	movs	r3, #23
 800dffc:	18fb      	adds	r3, r7, r3
 800dffe:	781b      	ldrb	r3, [r3, #0]
 800e000:	2b01      	cmp	r3, #1
 800e002:	d105      	bne.n	800e010 <HAL_RCCEx_PeriphCLKConfig+0x13c>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 800e004:	4b2b      	ldr	r3, [pc, #172]	; (800e0b4 <HAL_RCCEx_PeriphCLKConfig+0x1e0>)
 800e006:	69da      	ldr	r2, [r3, #28]
 800e008:	4b2a      	ldr	r3, [pc, #168]	; (800e0b4 <HAL_RCCEx_PeriphCLKConfig+0x1e0>)
 800e00a:	492f      	ldr	r1, [pc, #188]	; (800e0c8 <HAL_RCCEx_PeriphCLKConfig+0x1f4>)
 800e00c:	400a      	ands	r2, r1
 800e00e:	61da      	str	r2, [r3, #28]
    }
  }

  /*------------------------------- USART1 Configuration ------------------------*/ 
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
 800e010:	687b      	ldr	r3, [r7, #4]
 800e012:	681b      	ldr	r3, [r3, #0]
 800e014:	2201      	movs	r2, #1
 800e016:	4013      	ands	r3, r2
 800e018:	d009      	beq.n	800e02e <HAL_RCCEx_PeriphCLKConfig+0x15a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));
    
    /* Configure the USART1 clock source */
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
 800e01a:	4b26      	ldr	r3, [pc, #152]	; (800e0b4 <HAL_RCCEx_PeriphCLKConfig+0x1e0>)
 800e01c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800e01e:	2203      	movs	r2, #3
 800e020:	4393      	bics	r3, r2
 800e022:	0019      	movs	r1, r3
 800e024:	687b      	ldr	r3, [r7, #4]
 800e026:	689a      	ldr	r2, [r3, #8]
 800e028:	4b22      	ldr	r3, [pc, #136]	; (800e0b4 <HAL_RCCEx_PeriphCLKConfig+0x1e0>)
 800e02a:	430a      	orrs	r2, r1
 800e02c:	631a      	str	r2, [r3, #48]	; 0x30
  }
  
#if defined(STM32F071xB) || defined(STM32F072xB) || defined(STM32F078xx)\
 || defined(STM32F091xC) || defined(STM32F098xx)
  /*----------------------------- USART2 Configuration --------------------------*/ 
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
 800e02e:	687b      	ldr	r3, [r7, #4]
 800e030:	681b      	ldr	r3, [r3, #0]
 800e032:	2202      	movs	r2, #2
 800e034:	4013      	ands	r3, r2
 800e036:	d009      	beq.n	800e04c <HAL_RCCEx_PeriphCLKConfig+0x178>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART2CLKSOURCE(PeriphClkInit->Usart2ClockSelection));
    
    /* Configure the USART2 clock source */
    __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);
 800e038:	4b1e      	ldr	r3, [pc, #120]	; (800e0b4 <HAL_RCCEx_PeriphCLKConfig+0x1e0>)
 800e03a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800e03c:	4a23      	ldr	r2, [pc, #140]	; (800e0cc <HAL_RCCEx_PeriphCLKConfig+0x1f8>)
 800e03e:	4013      	ands	r3, r2
 800e040:	0019      	movs	r1, r3
 800e042:	687b      	ldr	r3, [r7, #4]
 800e044:	68da      	ldr	r2, [r3, #12]
 800e046:	4b1b      	ldr	r3, [pc, #108]	; (800e0b4 <HAL_RCCEx_PeriphCLKConfig+0x1e0>)
 800e048:	430a      	orrs	r2, r1
 800e04a:	631a      	str	r2, [r3, #48]	; 0x30
    __HAL_RCC_USART3_CONFIG(PeriphClkInit->Usart3ClockSelection);
  }
#endif /* STM32F091xC || STM32F098xx */  

  /*------------------------------ I2C1 Configuration ------------------------*/ 
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
 800e04c:	687b      	ldr	r3, [r7, #4]
 800e04e:	681b      	ldr	r3, [r3, #0]
 800e050:	2220      	movs	r2, #32
 800e052:	4013      	ands	r3, r2
 800e054:	d009      	beq.n	800e06a <HAL_RCCEx_PeriphCLKConfig+0x196>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C1CLKSOURCE(PeriphClkInit->I2c1ClockSelection));
    
    /* Configure the I2C1 clock source */
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
 800e056:	4b17      	ldr	r3, [pc, #92]	; (800e0b4 <HAL_RCCEx_PeriphCLKConfig+0x1e0>)
 800e058:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800e05a:	2210      	movs	r2, #16
 800e05c:	4393      	bics	r3, r2
 800e05e:	0019      	movs	r1, r3
 800e060:	687b      	ldr	r3, [r7, #4]
 800e062:	691a      	ldr	r2, [r3, #16]
 800e064:	4b13      	ldr	r3, [pc, #76]	; (800e0b4 <HAL_RCCEx_PeriphCLKConfig+0x1e0>)
 800e066:	430a      	orrs	r2, r1
 800e068:	631a      	str	r2, [r3, #48]	; 0x30
  }

#if defined(STM32F042x6) || defined(STM32F048xx) || defined(STM32F072xB) || defined(STM32F078xx) || defined(STM32F070xB) || defined(STM32F070x6)
  /*------------------------------ USB Configuration ------------------------*/ 
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == RCC_PERIPHCLK_USB)
 800e06a:	687b      	ldr	r3, [r7, #4]
 800e06c:	681a      	ldr	r2, [r3, #0]
 800e06e:	2380      	movs	r3, #128	; 0x80
 800e070:	029b      	lsls	r3, r3, #10
 800e072:	4013      	ands	r3, r2
 800e074:	d009      	beq.n	800e08a <HAL_RCCEx_PeriphCLKConfig+0x1b6>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USBCLKSOURCE(PeriphClkInit->UsbClockSelection));
    
    /* Configure the USB clock source */
    __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
 800e076:	4b0f      	ldr	r3, [pc, #60]	; (800e0b4 <HAL_RCCEx_PeriphCLKConfig+0x1e0>)
 800e078:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800e07a:	2280      	movs	r2, #128	; 0x80
 800e07c:	4393      	bics	r3, r2
 800e07e:	0019      	movs	r1, r3
 800e080:	687b      	ldr	r3, [r7, #4]
 800e082:	699a      	ldr	r2, [r3, #24]
 800e084:	4b0b      	ldr	r3, [pc, #44]	; (800e0b4 <HAL_RCCEx_PeriphCLKConfig+0x1e0>)
 800e086:	430a      	orrs	r2, r1
 800e088:	631a      	str	r2, [r3, #48]	; 0x30
#if defined(STM32F042x6) || defined(STM32F048xx)\
 || defined(STM32F051x8) || defined(STM32F058xx)\
 || defined(STM32F071xB) || defined(STM32F072xB) || defined(STM32F078xx)\
 || defined(STM32F091xC) || defined(STM32F098xx)
  /*------------------------------ CEC clock Configuration -------------------*/ 
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CEC) == RCC_PERIPHCLK_CEC)
 800e08a:	687b      	ldr	r3, [r7, #4]
 800e08c:	681a      	ldr	r2, [r3, #0]
 800e08e:	2380      	movs	r3, #128	; 0x80
 800e090:	00db      	lsls	r3, r3, #3
 800e092:	4013      	ands	r3, r2
 800e094:	d009      	beq.n	800e0aa <HAL_RCCEx_PeriphCLKConfig+0x1d6>
  {
    /* Check the parameters */
    assert_param(IS_RCC_CECCLKSOURCE(PeriphClkInit->CecClockSelection));
    
    /* Configure the CEC clock source */
    __HAL_RCC_CEC_CONFIG(PeriphClkInit->CecClockSelection);
 800e096:	4b07      	ldr	r3, [pc, #28]	; (800e0b4 <HAL_RCCEx_PeriphCLKConfig+0x1e0>)
 800e098:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800e09a:	2240      	movs	r2, #64	; 0x40
 800e09c:	4393      	bics	r3, r2
 800e09e:	0019      	movs	r1, r3
 800e0a0:	687b      	ldr	r3, [r7, #4]
 800e0a2:	695a      	ldr	r2, [r3, #20]
 800e0a4:	4b03      	ldr	r3, [pc, #12]	; (800e0b4 <HAL_RCCEx_PeriphCLKConfig+0x1e0>)
 800e0a6:	430a      	orrs	r2, r1
 800e0a8:	631a      	str	r2, [r3, #48]	; 0x30
#endif /* STM32F042x6 || STM32F048xx ||                */
       /* STM32F051x8 || STM32F058xx ||                */
       /* STM32F071xB || STM32F072xB || STM32F078xx || */
       /* STM32F091xC || STM32F098xx */
  
  return HAL_OK;
 800e0aa:	2300      	movs	r3, #0
}
 800e0ac:	0018      	movs	r0, r3
 800e0ae:	46bd      	mov	sp, r7
 800e0b0:	b006      	add	sp, #24
 800e0b2:	bd80      	pop	{r7, pc}
 800e0b4:	40021000 	.word	0x40021000
 800e0b8:	40007000 	.word	0x40007000
 800e0bc:	fffffcff 	.word	0xfffffcff
 800e0c0:	fffeffff 	.word	0xfffeffff
 800e0c4:	00001388 	.word	0x00001388
 800e0c8:	efffffff 	.word	0xefffffff
 800e0cc:	fffcffff 	.word	0xfffcffff

0800e0d0 <HAL_SPI_Init>:
  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Init(SPI_HandleTypeDef *hspi)
{
 800e0d0:	b580      	push	{r7, lr}
 800e0d2:	b084      	sub	sp, #16
 800e0d4:	af00      	add	r7, sp, #0
 800e0d6:	6078      	str	r0, [r7, #4]
  uint32_t frxth;

  /* Check the SPI handle allocation */
  if (hspi == NULL)
 800e0d8:	687b      	ldr	r3, [r7, #4]
 800e0da:	2b00      	cmp	r3, #0
 800e0dc:	d101      	bne.n	800e0e2 <HAL_SPI_Init+0x12>
  {
    return HAL_ERROR;
 800e0de:	2301      	movs	r3, #1
 800e0e0:	e0a8      	b.n	800e234 <HAL_SPI_Init+0x164>
  assert_param(IS_SPI_NSS(hspi->Init.NSS));
  assert_param(IS_SPI_NSSP(hspi->Init.NSSPMode));
  assert_param(IS_SPI_BAUDRATE_PRESCALER(hspi->Init.BaudRatePrescaler));
  assert_param(IS_SPI_FIRST_BIT(hspi->Init.FirstBit));
  assert_param(IS_SPI_TIMODE(hspi->Init.TIMode));
  if (hspi->Init.TIMode == SPI_TIMODE_DISABLE)
 800e0e2:	687b      	ldr	r3, [r7, #4]
 800e0e4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800e0e6:	2b00      	cmp	r3, #0
 800e0e8:	d109      	bne.n	800e0fe <HAL_SPI_Init+0x2e>
  {
    assert_param(IS_SPI_CPOL(hspi->Init.CLKPolarity));
    assert_param(IS_SPI_CPHA(hspi->Init.CLKPhase));

    if (hspi->Init.Mode == SPI_MODE_MASTER)
 800e0ea:	687b      	ldr	r3, [r7, #4]
 800e0ec:	685a      	ldr	r2, [r3, #4]
 800e0ee:	2382      	movs	r3, #130	; 0x82
 800e0f0:	005b      	lsls	r3, r3, #1
 800e0f2:	429a      	cmp	r2, r3
 800e0f4:	d009      	beq.n	800e10a <HAL_SPI_Init+0x3a>
      assert_param(IS_SPI_BAUDRATE_PRESCALER(hspi->Init.BaudRatePrescaler));
    }
    else
    {
      /* Baudrate prescaler not use in Motoraola Slave mode. force to default value */
      hspi->Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_2;
 800e0f6:	687b      	ldr	r3, [r7, #4]
 800e0f8:	2200      	movs	r2, #0
 800e0fa:	61da      	str	r2, [r3, #28]
 800e0fc:	e005      	b.n	800e10a <HAL_SPI_Init+0x3a>
  else
  {
    assert_param(IS_SPI_BAUDRATE_PRESCALER(hspi->Init.BaudRatePrescaler));

    /* Force polarity and phase to TI protocaol requirements */
    hspi->Init.CLKPolarity = SPI_POLARITY_LOW;
 800e0fe:	687b      	ldr	r3, [r7, #4]
 800e100:	2200      	movs	r2, #0
 800e102:	611a      	str	r2, [r3, #16]
    hspi->Init.CLKPhase    = SPI_PHASE_1EDGE;
 800e104:	687b      	ldr	r3, [r7, #4]
 800e106:	2200      	movs	r2, #0
 800e108:	615a      	str	r2, [r3, #20]
  {
    assert_param(IS_SPI_CRC_POLYNOMIAL(hspi->Init.CRCPolynomial));
    assert_param(IS_SPI_CRC_LENGTH(hspi->Init.CRCLength));
  }
#else
  hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 800e10a:	687b      	ldr	r3, [r7, #4]
 800e10c:	2200      	movs	r2, #0
 800e10e:	629a      	str	r2, [r3, #40]	; 0x28
#endif /* USE_SPI_CRC */

  if (hspi->State == HAL_SPI_STATE_RESET)
 800e110:	687b      	ldr	r3, [r7, #4]
 800e112:	225d      	movs	r2, #93	; 0x5d
 800e114:	5c9b      	ldrb	r3, [r3, r2]
 800e116:	b2db      	uxtb	r3, r3
 800e118:	2b00      	cmp	r3, #0
 800e11a:	d107      	bne.n	800e12c <HAL_SPI_Init+0x5c>
  {
    /* Allocate lock resource and initialize it */
    hspi->Lock = HAL_UNLOCKED;
 800e11c:	687b      	ldr	r3, [r7, #4]
 800e11e:	225c      	movs	r2, #92	; 0x5c
 800e120:	2100      	movs	r1, #0
 800e122:	5499      	strb	r1, [r3, r2]

    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    hspi->MspInitCallback(hspi);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_SPI_MspInit(hspi);
 800e124:	687b      	ldr	r3, [r7, #4]
 800e126:	0018      	movs	r0, r3
 800e128:	f7fc fe46 	bl	800adb8 <HAL_SPI_MspInit>
#endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
  }

  hspi->State = HAL_SPI_STATE_BUSY;
 800e12c:	687b      	ldr	r3, [r7, #4]
 800e12e:	225d      	movs	r2, #93	; 0x5d
 800e130:	2102      	movs	r1, #2
 800e132:	5499      	strb	r1, [r3, r2]

  /* Disable the selected SPI peripheral */
  __HAL_SPI_DISABLE(hspi);
 800e134:	687b      	ldr	r3, [r7, #4]
 800e136:	681b      	ldr	r3, [r3, #0]
 800e138:	681a      	ldr	r2, [r3, #0]
 800e13a:	687b      	ldr	r3, [r7, #4]
 800e13c:	681b      	ldr	r3, [r3, #0]
 800e13e:	2140      	movs	r1, #64	; 0x40
 800e140:	438a      	bics	r2, r1
 800e142:	601a      	str	r2, [r3, #0]

  /* Align by default the rs fifo threshold on the data size */
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 800e144:	687b      	ldr	r3, [r7, #4]
 800e146:	68da      	ldr	r2, [r3, #12]
 800e148:	23e0      	movs	r3, #224	; 0xe0
 800e14a:	00db      	lsls	r3, r3, #3
 800e14c:	429a      	cmp	r2, r3
 800e14e:	d902      	bls.n	800e156 <HAL_SPI_Init+0x86>
  {
    frxth = SPI_RXFIFO_THRESHOLD_HF;
 800e150:	2300      	movs	r3, #0
 800e152:	60fb      	str	r3, [r7, #12]
 800e154:	e002      	b.n	800e15c <HAL_SPI_Init+0x8c>
  }
  else
  {
    frxth = SPI_RXFIFO_THRESHOLD_QF;
 800e156:	2380      	movs	r3, #128	; 0x80
 800e158:	015b      	lsls	r3, r3, #5
 800e15a:	60fb      	str	r3, [r7, #12]
  }

  /* CRC calculation is valid only for 16Bit and 8 Bit */
  if ((hspi->Init.DataSize != SPI_DATASIZE_16BIT) && (hspi->Init.DataSize != SPI_DATASIZE_8BIT))
 800e15c:	687b      	ldr	r3, [r7, #4]
 800e15e:	68da      	ldr	r2, [r3, #12]
 800e160:	23f0      	movs	r3, #240	; 0xf0
 800e162:	011b      	lsls	r3, r3, #4
 800e164:	429a      	cmp	r2, r3
 800e166:	d008      	beq.n	800e17a <HAL_SPI_Init+0xaa>
 800e168:	687b      	ldr	r3, [r7, #4]
 800e16a:	68da      	ldr	r2, [r3, #12]
 800e16c:	23e0      	movs	r3, #224	; 0xe0
 800e16e:	00db      	lsls	r3, r3, #3
 800e170:	429a      	cmp	r2, r3
 800e172:	d002      	beq.n	800e17a <HAL_SPI_Init+0xaa>
  {
    /* CRC must be disabled */
    hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 800e174:	687b      	ldr	r3, [r7, #4]
 800e176:	2200      	movs	r2, #0
 800e178:	629a      	str	r2, [r3, #40]	; 0x28
  }

  /*----------------------- SPIx CR1 & CR2 Configuration ---------------------*/
  /* Configure : SPI Mode, Communication Mode, Clock polarity and phase, NSS management,
  Communication speed, First bit and CRC calculation state */
  WRITE_REG(hspi->Instance->CR1, ((hspi->Init.Mode & (SPI_CR1_MSTR | SPI_CR1_SSI)) |
 800e17a:	687b      	ldr	r3, [r7, #4]
 800e17c:	685a      	ldr	r2, [r3, #4]
 800e17e:	2382      	movs	r3, #130	; 0x82
 800e180:	005b      	lsls	r3, r3, #1
 800e182:	401a      	ands	r2, r3
 800e184:	687b      	ldr	r3, [r7, #4]
 800e186:	6899      	ldr	r1, [r3, #8]
 800e188:	2384      	movs	r3, #132	; 0x84
 800e18a:	021b      	lsls	r3, r3, #8
 800e18c:	400b      	ands	r3, r1
 800e18e:	431a      	orrs	r2, r3
 800e190:	687b      	ldr	r3, [r7, #4]
 800e192:	691b      	ldr	r3, [r3, #16]
 800e194:	2102      	movs	r1, #2
 800e196:	400b      	ands	r3, r1
 800e198:	431a      	orrs	r2, r3
 800e19a:	687b      	ldr	r3, [r7, #4]
 800e19c:	695b      	ldr	r3, [r3, #20]
 800e19e:	2101      	movs	r1, #1
 800e1a0:	400b      	ands	r3, r1
 800e1a2:	431a      	orrs	r2, r3
 800e1a4:	687b      	ldr	r3, [r7, #4]
 800e1a6:	6999      	ldr	r1, [r3, #24]
 800e1a8:	2380      	movs	r3, #128	; 0x80
 800e1aa:	009b      	lsls	r3, r3, #2
 800e1ac:	400b      	ands	r3, r1
 800e1ae:	431a      	orrs	r2, r3
 800e1b0:	687b      	ldr	r3, [r7, #4]
 800e1b2:	69db      	ldr	r3, [r3, #28]
 800e1b4:	2138      	movs	r1, #56	; 0x38
 800e1b6:	400b      	ands	r3, r1
 800e1b8:	431a      	orrs	r2, r3
 800e1ba:	687b      	ldr	r3, [r7, #4]
 800e1bc:	6a1b      	ldr	r3, [r3, #32]
 800e1be:	2180      	movs	r1, #128	; 0x80
 800e1c0:	400b      	ands	r3, r1
 800e1c2:	431a      	orrs	r2, r3
 800e1c4:	0011      	movs	r1, r2
 800e1c6:	687b      	ldr	r3, [r7, #4]
 800e1c8:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800e1ca:	2380      	movs	r3, #128	; 0x80
 800e1cc:	019b      	lsls	r3, r3, #6
 800e1ce:	401a      	ands	r2, r3
 800e1d0:	687b      	ldr	r3, [r7, #4]
 800e1d2:	681b      	ldr	r3, [r3, #0]
 800e1d4:	430a      	orrs	r2, r1
 800e1d6:	601a      	str	r2, [r3, #0]
    }
  }
#endif /* USE_SPI_CRC */

  /* Configure : NSS management, TI Mode, NSS Pulse, Data size and Rx Fifo threshold */
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) |
 800e1d8:	687b      	ldr	r3, [r7, #4]
 800e1da:	699b      	ldr	r3, [r3, #24]
 800e1dc:	0c1b      	lsrs	r3, r3, #16
 800e1de:	2204      	movs	r2, #4
 800e1e0:	401a      	ands	r2, r3
 800e1e2:	687b      	ldr	r3, [r7, #4]
 800e1e4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800e1e6:	2110      	movs	r1, #16
 800e1e8:	400b      	ands	r3, r1
 800e1ea:	431a      	orrs	r2, r3
 800e1ec:	687b      	ldr	r3, [r7, #4]
 800e1ee:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800e1f0:	2108      	movs	r1, #8
 800e1f2:	400b      	ands	r3, r1
 800e1f4:	431a      	orrs	r2, r3
 800e1f6:	687b      	ldr	r3, [r7, #4]
 800e1f8:	68d9      	ldr	r1, [r3, #12]
 800e1fa:	23f0      	movs	r3, #240	; 0xf0
 800e1fc:	011b      	lsls	r3, r3, #4
 800e1fe:	400b      	ands	r3, r1
 800e200:	431a      	orrs	r2, r3
 800e202:	0011      	movs	r1, r2
 800e204:	68fa      	ldr	r2, [r7, #12]
 800e206:	2380      	movs	r3, #128	; 0x80
 800e208:	015b      	lsls	r3, r3, #5
 800e20a:	401a      	ands	r2, r3
 800e20c:	687b      	ldr	r3, [r7, #4]
 800e20e:	681b      	ldr	r3, [r3, #0]
 800e210:	430a      	orrs	r2, r1
 800e212:	605a      	str	r2, [r3, #4]
  }
#endif /* USE_SPI_CRC */

#if defined(SPI_I2SCFGR_I2SMOD)
  /* Activate the SPI mode (Make sure that I2SMOD bit in I2SCFGR register is reset) */
  CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
 800e214:	687b      	ldr	r3, [r7, #4]
 800e216:	681b      	ldr	r3, [r3, #0]
 800e218:	69da      	ldr	r2, [r3, #28]
 800e21a:	687b      	ldr	r3, [r7, #4]
 800e21c:	681b      	ldr	r3, [r3, #0]
 800e21e:	4907      	ldr	r1, [pc, #28]	; (800e23c <HAL_SPI_Init+0x16c>)
 800e220:	400a      	ands	r2, r1
 800e222:	61da      	str	r2, [r3, #28]
#endif /* SPI_I2SCFGR_I2SMOD */

  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 800e224:	687b      	ldr	r3, [r7, #4]
 800e226:	2200      	movs	r2, #0
 800e228:	661a      	str	r2, [r3, #96]	; 0x60
  hspi->State     = HAL_SPI_STATE_READY;
 800e22a:	687b      	ldr	r3, [r7, #4]
 800e22c:	225d      	movs	r2, #93	; 0x5d
 800e22e:	2101      	movs	r1, #1
 800e230:	5499      	strb	r1, [r3, r2]

  return HAL_OK;
 800e232:	2300      	movs	r3, #0
}
 800e234:	0018      	movs	r0, r3
 800e236:	46bd      	mov	sp, r7
 800e238:	b004      	add	sp, #16
 800e23a:	bd80      	pop	{r7, pc}
 800e23c:	fffff7ff 	.word	0xfffff7ff

0800e240 <HAL_UART_Init>:
  *        parameters in the UART_InitTypeDef and initialize the associated handle.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
{
 800e240:	b580      	push	{r7, lr}
 800e242:	b082      	sub	sp, #8
 800e244:	af00      	add	r7, sp, #0
 800e246:	6078      	str	r0, [r7, #4]
  /* Check the UART handle allocation */
  if (huart == NULL)
 800e248:	687b      	ldr	r3, [r7, #4]
 800e24a:	2b00      	cmp	r3, #0
 800e24c:	d101      	bne.n	800e252 <HAL_UART_Init+0x12>
  {
    return HAL_ERROR;
 800e24e:	2301      	movs	r3, #1
 800e250:	e044      	b.n	800e2dc <HAL_UART_Init+0x9c>
  {
    /* Check the parameters */
    assert_param(IS_UART_INSTANCE(huart->Instance));
  }

  if (huart->gState == HAL_UART_STATE_RESET)
 800e252:	687b      	ldr	r3, [r7, #4]
 800e254:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800e256:	2b00      	cmp	r3, #0
 800e258:	d107      	bne.n	800e26a <HAL_UART_Init+0x2a>
  {
    /* Allocate lock resource and initialize it */
    huart->Lock = HAL_UNLOCKED;
 800e25a:	687b      	ldr	r3, [r7, #4]
 800e25c:	2274      	movs	r2, #116	; 0x74
 800e25e:	2100      	movs	r1, #0
 800e260:	5499      	strb	r1, [r3, r2]

    /* Init the low level hardware */
    huart->MspInitCallback(huart);
#else
    /* Init the low level hardware : GPIO, CLOCK */
    HAL_UART_MspInit(huart);
 800e262:	687b      	ldr	r3, [r7, #4]
 800e264:	0018      	movs	r0, r3
 800e266:	f7fc fdf5 	bl	800ae54 <HAL_UART_MspInit>
#endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
  }

  huart->gState = HAL_UART_STATE_BUSY;
 800e26a:	687b      	ldr	r3, [r7, #4]
 800e26c:	2224      	movs	r2, #36	; 0x24
 800e26e:	679a      	str	r2, [r3, #120]	; 0x78

  __HAL_UART_DISABLE(huart);
 800e270:	687b      	ldr	r3, [r7, #4]
 800e272:	681b      	ldr	r3, [r3, #0]
 800e274:	681a      	ldr	r2, [r3, #0]
 800e276:	687b      	ldr	r3, [r7, #4]
 800e278:	681b      	ldr	r3, [r3, #0]
 800e27a:	2101      	movs	r1, #1
 800e27c:	438a      	bics	r2, r1
 800e27e:	601a      	str	r2, [r3, #0]

  /* Set the UART Communication parameters */
  if (UART_SetConfig(huart) == HAL_ERROR)
 800e280:	687b      	ldr	r3, [r7, #4]
 800e282:	0018      	movs	r0, r3
 800e284:	f000 fcb8 	bl	800ebf8 <UART_SetConfig>
 800e288:	0003      	movs	r3, r0
 800e28a:	2b01      	cmp	r3, #1
 800e28c:	d101      	bne.n	800e292 <HAL_UART_Init+0x52>
  {
    return HAL_ERROR;
 800e28e:	2301      	movs	r3, #1
 800e290:	e024      	b.n	800e2dc <HAL_UART_Init+0x9c>
  }

  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
 800e292:	687b      	ldr	r3, [r7, #4]
 800e294:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800e296:	2b00      	cmp	r3, #0
 800e298:	d003      	beq.n	800e2a2 <HAL_UART_Init+0x62>
  {
    UART_AdvFeatureConfig(huart);
 800e29a:	687b      	ldr	r3, [r7, #4]
 800e29c:	0018      	movs	r0, r3
 800e29e:	f000 fe33 	bl	800ef08 <UART_AdvFeatureConfig>

  /* In asynchronous mode, the following bits must be kept cleared:
  - LINEN (if LIN is supported) and CLKEN bits in the USART_CR2 register,
  - SCEN (if Smartcard is supported), HDSEL and IREN (if IrDA is supported)  bits in the USART_CR3 register.*/
#if defined (USART_CR2_LINEN)
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 800e2a2:	687b      	ldr	r3, [r7, #4]
 800e2a4:	681b      	ldr	r3, [r3, #0]
 800e2a6:	685a      	ldr	r2, [r3, #4]
 800e2a8:	687b      	ldr	r3, [r7, #4]
 800e2aa:	681b      	ldr	r3, [r3, #0]
 800e2ac:	490d      	ldr	r1, [pc, #52]	; (800e2e4 <HAL_UART_Init+0xa4>)
 800e2ae:	400a      	ands	r2, r1
 800e2b0:	605a      	str	r2, [r3, #4]
#else
  CLEAR_BIT(huart->Instance->CR2, USART_CR2_CLKEN);
#endif /* USART_CR2_LINEN */
#if defined (USART_CR3_SCEN)
#if defined (USART_CR3_IREN)
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 800e2b2:	687b      	ldr	r3, [r7, #4]
 800e2b4:	681b      	ldr	r3, [r3, #0]
 800e2b6:	689a      	ldr	r2, [r3, #8]
 800e2b8:	687b      	ldr	r3, [r7, #4]
 800e2ba:	681b      	ldr	r3, [r3, #0]
 800e2bc:	212a      	movs	r1, #42	; 0x2a
 800e2be:	438a      	bics	r2, r1
 800e2c0:	609a      	str	r2, [r3, #8]
#else
  CLEAR_BIT(huart->Instance->CR3, USART_CR3_HDSEL);
#endif /* USART_CR3_IREN*/
#endif /* USART_CR3_SCEN */

  __HAL_UART_ENABLE(huart);
 800e2c2:	687b      	ldr	r3, [r7, #4]
 800e2c4:	681b      	ldr	r3, [r3, #0]
 800e2c6:	681a      	ldr	r2, [r3, #0]
 800e2c8:	687b      	ldr	r3, [r7, #4]
 800e2ca:	681b      	ldr	r3, [r3, #0]
 800e2cc:	2101      	movs	r1, #1
 800e2ce:	430a      	orrs	r2, r1
 800e2d0:	601a      	str	r2, [r3, #0]

  /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
  return (UART_CheckIdleState(huart));
 800e2d2:	687b      	ldr	r3, [r7, #4]
 800e2d4:	0018      	movs	r0, r3
 800e2d6:	f000 fecb 	bl	800f070 <UART_CheckIdleState>
 800e2da:	0003      	movs	r3, r0
}
 800e2dc:	0018      	movs	r0, r3
 800e2de:	46bd      	mov	sp, r7
 800e2e0:	b002      	add	sp, #8
 800e2e2:	bd80      	pop	{r7, pc}
 800e2e4:	ffffb7ff 	.word	0xffffb7ff

0800e2e8 <HAL_UART_Transmit>:
  * @param Size    Amount of data elements (u8 or u16) to be sent.
  * @param Timeout Timeout duration.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 800e2e8:	b580      	push	{r7, lr}
 800e2ea:	b08a      	sub	sp, #40	; 0x28
 800e2ec:	af02      	add	r7, sp, #8
 800e2ee:	60f8      	str	r0, [r7, #12]
 800e2f0:	60b9      	str	r1, [r7, #8]
 800e2f2:	603b      	str	r3, [r7, #0]
 800e2f4:	1dbb      	adds	r3, r7, #6
 800e2f6:	801a      	strh	r2, [r3, #0]
  uint8_t  *pdata8bits;
  uint16_t *pdata16bits;
  uint32_t tickstart;

  /* Check that a Tx process is not already ongoing */
  if (huart->gState == HAL_UART_STATE_READY)
 800e2f8:	68fb      	ldr	r3, [r7, #12]
 800e2fa:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800e2fc:	2b20      	cmp	r3, #32
 800e2fe:	d000      	beq.n	800e302 <HAL_UART_Transmit+0x1a>
 800e300:	e096      	b.n	800e430 <HAL_UART_Transmit+0x148>
  {
    if ((pData == NULL) || (Size == 0U))
 800e302:	68bb      	ldr	r3, [r7, #8]
 800e304:	2b00      	cmp	r3, #0
 800e306:	d003      	beq.n	800e310 <HAL_UART_Transmit+0x28>
 800e308:	1dbb      	adds	r3, r7, #6
 800e30a:	881b      	ldrh	r3, [r3, #0]
 800e30c:	2b00      	cmp	r3, #0
 800e30e:	d101      	bne.n	800e314 <HAL_UART_Transmit+0x2c>
    {
      return  HAL_ERROR;
 800e310:	2301      	movs	r3, #1
 800e312:	e08e      	b.n	800e432 <HAL_UART_Transmit+0x14a>
    }

    /* In case of 9bits/No Parity transfer, pData buffer provided as input parameter
       should be aligned on a u16 frontier, as data to be filled into TDR will be
       handled through a u16 cast. */
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 800e314:	68fb      	ldr	r3, [r7, #12]
 800e316:	689a      	ldr	r2, [r3, #8]
 800e318:	2380      	movs	r3, #128	; 0x80
 800e31a:	015b      	lsls	r3, r3, #5
 800e31c:	429a      	cmp	r2, r3
 800e31e:	d109      	bne.n	800e334 <HAL_UART_Transmit+0x4c>
 800e320:	68fb      	ldr	r3, [r7, #12]
 800e322:	691b      	ldr	r3, [r3, #16]
 800e324:	2b00      	cmp	r3, #0
 800e326:	d105      	bne.n	800e334 <HAL_UART_Transmit+0x4c>
    {
      if ((((uint32_t)pData) & 1U) != 0U)
 800e328:	68bb      	ldr	r3, [r7, #8]
 800e32a:	2201      	movs	r2, #1
 800e32c:	4013      	ands	r3, r2
 800e32e:	d001      	beq.n	800e334 <HAL_UART_Transmit+0x4c>
      {
        return  HAL_ERROR;
 800e330:	2301      	movs	r3, #1
 800e332:	e07e      	b.n	800e432 <HAL_UART_Transmit+0x14a>
      }
    }

    __HAL_LOCK(huart);
 800e334:	68fb      	ldr	r3, [r7, #12]
 800e336:	2274      	movs	r2, #116	; 0x74
 800e338:	5c9b      	ldrb	r3, [r3, r2]
 800e33a:	2b01      	cmp	r3, #1
 800e33c:	d101      	bne.n	800e342 <HAL_UART_Transmit+0x5a>
 800e33e:	2302      	movs	r3, #2
 800e340:	e077      	b.n	800e432 <HAL_UART_Transmit+0x14a>
 800e342:	68fb      	ldr	r3, [r7, #12]
 800e344:	2274      	movs	r2, #116	; 0x74
 800e346:	2101      	movs	r1, #1
 800e348:	5499      	strb	r1, [r3, r2]

    huart->ErrorCode = HAL_UART_ERROR_NONE;
 800e34a:	68fb      	ldr	r3, [r7, #12]
 800e34c:	2280      	movs	r2, #128	; 0x80
 800e34e:	2100      	movs	r1, #0
 800e350:	5099      	str	r1, [r3, r2]
    huart->gState = HAL_UART_STATE_BUSY_TX;
 800e352:	68fb      	ldr	r3, [r7, #12]
 800e354:	2221      	movs	r2, #33	; 0x21
 800e356:	679a      	str	r2, [r3, #120]	; 0x78

    /* Init tickstart for timeout management */
    tickstart = HAL_GetTick();
 800e358:	f7fc ff10 	bl	800b17c <HAL_GetTick>
 800e35c:	0003      	movs	r3, r0
 800e35e:	617b      	str	r3, [r7, #20]

    huart->TxXferSize  = Size;
 800e360:	68fb      	ldr	r3, [r7, #12]
 800e362:	1dba      	adds	r2, r7, #6
 800e364:	2150      	movs	r1, #80	; 0x50
 800e366:	8812      	ldrh	r2, [r2, #0]
 800e368:	525a      	strh	r2, [r3, r1]
    huart->TxXferCount = Size;
 800e36a:	68fb      	ldr	r3, [r7, #12]
 800e36c:	1dba      	adds	r2, r7, #6
 800e36e:	2152      	movs	r1, #82	; 0x52
 800e370:	8812      	ldrh	r2, [r2, #0]
 800e372:	525a      	strh	r2, [r3, r1]

    /* In case of 9bits/No Parity transfer, pData needs to be handled as a uint16_t pointer */
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 800e374:	68fb      	ldr	r3, [r7, #12]
 800e376:	689a      	ldr	r2, [r3, #8]
 800e378:	2380      	movs	r3, #128	; 0x80
 800e37a:	015b      	lsls	r3, r3, #5
 800e37c:	429a      	cmp	r2, r3
 800e37e:	d108      	bne.n	800e392 <HAL_UART_Transmit+0xaa>
 800e380:	68fb      	ldr	r3, [r7, #12]
 800e382:	691b      	ldr	r3, [r3, #16]
 800e384:	2b00      	cmp	r3, #0
 800e386:	d104      	bne.n	800e392 <HAL_UART_Transmit+0xaa>
    {
      pdata8bits  = NULL;
 800e388:	2300      	movs	r3, #0
 800e38a:	61fb      	str	r3, [r7, #28]
      pdata16bits = (uint16_t *) pData;
 800e38c:	68bb      	ldr	r3, [r7, #8]
 800e38e:	61bb      	str	r3, [r7, #24]
 800e390:	e003      	b.n	800e39a <HAL_UART_Transmit+0xb2>
    }
    else
    {
      pdata8bits  = pData;
 800e392:	68bb      	ldr	r3, [r7, #8]
 800e394:	61fb      	str	r3, [r7, #28]
      pdata16bits = NULL;
 800e396:	2300      	movs	r3, #0
 800e398:	61bb      	str	r3, [r7, #24]
    }

    __HAL_UNLOCK(huart);
 800e39a:	68fb      	ldr	r3, [r7, #12]
 800e39c:	2274      	movs	r2, #116	; 0x74
 800e39e:	2100      	movs	r1, #0
 800e3a0:	5499      	strb	r1, [r3, r2]

    while (huart->TxXferCount > 0U)
 800e3a2:	e02d      	b.n	800e400 <HAL_UART_Transmit+0x118>
    {
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
 800e3a4:	697a      	ldr	r2, [r7, #20]
 800e3a6:	68f8      	ldr	r0, [r7, #12]
 800e3a8:	683b      	ldr	r3, [r7, #0]
 800e3aa:	9300      	str	r3, [sp, #0]
 800e3ac:	0013      	movs	r3, r2
 800e3ae:	2200      	movs	r2, #0
 800e3b0:	2180      	movs	r1, #128	; 0x80
 800e3b2:	f000 fea5 	bl	800f100 <UART_WaitOnFlagUntilTimeout>
 800e3b6:	1e03      	subs	r3, r0, #0
 800e3b8:	d001      	beq.n	800e3be <HAL_UART_Transmit+0xd6>
      {
        return HAL_TIMEOUT;
 800e3ba:	2303      	movs	r3, #3
 800e3bc:	e039      	b.n	800e432 <HAL_UART_Transmit+0x14a>
      }
      if (pdata8bits == NULL)
 800e3be:	69fb      	ldr	r3, [r7, #28]
 800e3c0:	2b00      	cmp	r3, #0
 800e3c2:	d10b      	bne.n	800e3dc <HAL_UART_Transmit+0xf4>
      {
        huart->Instance->TDR = (uint16_t)(*pdata16bits & 0x01FFU);
 800e3c4:	69bb      	ldr	r3, [r7, #24]
 800e3c6:	881a      	ldrh	r2, [r3, #0]
 800e3c8:	68fb      	ldr	r3, [r7, #12]
 800e3ca:	681b      	ldr	r3, [r3, #0]
 800e3cc:	05d2      	lsls	r2, r2, #23
 800e3ce:	0dd2      	lsrs	r2, r2, #23
 800e3d0:	b292      	uxth	r2, r2
 800e3d2:	851a      	strh	r2, [r3, #40]	; 0x28
        pdata16bits++;
 800e3d4:	69bb      	ldr	r3, [r7, #24]
 800e3d6:	3302      	adds	r3, #2
 800e3d8:	61bb      	str	r3, [r7, #24]
 800e3da:	e008      	b.n	800e3ee <HAL_UART_Transmit+0x106>
      }
      else
      {
        huart->Instance->TDR = (uint8_t)(*pdata8bits & 0xFFU);
 800e3dc:	69fb      	ldr	r3, [r7, #28]
 800e3de:	781a      	ldrb	r2, [r3, #0]
 800e3e0:	68fb      	ldr	r3, [r7, #12]
 800e3e2:	681b      	ldr	r3, [r3, #0]
 800e3e4:	b292      	uxth	r2, r2
 800e3e6:	851a      	strh	r2, [r3, #40]	; 0x28
        pdata8bits++;
 800e3e8:	69fb      	ldr	r3, [r7, #28]
 800e3ea:	3301      	adds	r3, #1
 800e3ec:	61fb      	str	r3, [r7, #28]
      }
      huart->TxXferCount--;
 800e3ee:	68fb      	ldr	r3, [r7, #12]
 800e3f0:	2252      	movs	r2, #82	; 0x52
 800e3f2:	5a9b      	ldrh	r3, [r3, r2]
 800e3f4:	b29b      	uxth	r3, r3
 800e3f6:	3b01      	subs	r3, #1
 800e3f8:	b299      	uxth	r1, r3
 800e3fa:	68fb      	ldr	r3, [r7, #12]
 800e3fc:	2252      	movs	r2, #82	; 0x52
 800e3fe:	5299      	strh	r1, [r3, r2]
    while (huart->TxXferCount > 0U)
 800e400:	68fb      	ldr	r3, [r7, #12]
 800e402:	2252      	movs	r2, #82	; 0x52
 800e404:	5a9b      	ldrh	r3, [r3, r2]
 800e406:	b29b      	uxth	r3, r3
 800e408:	2b00      	cmp	r3, #0
 800e40a:	d1cb      	bne.n	800e3a4 <HAL_UART_Transmit+0xbc>
    }

    if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
 800e40c:	697a      	ldr	r2, [r7, #20]
 800e40e:	68f8      	ldr	r0, [r7, #12]
 800e410:	683b      	ldr	r3, [r7, #0]
 800e412:	9300      	str	r3, [sp, #0]
 800e414:	0013      	movs	r3, r2
 800e416:	2200      	movs	r2, #0
 800e418:	2140      	movs	r1, #64	; 0x40
 800e41a:	f000 fe71 	bl	800f100 <UART_WaitOnFlagUntilTimeout>
 800e41e:	1e03      	subs	r3, r0, #0
 800e420:	d001      	beq.n	800e426 <HAL_UART_Transmit+0x13e>
    {
      return HAL_TIMEOUT;
 800e422:	2303      	movs	r3, #3
 800e424:	e005      	b.n	800e432 <HAL_UART_Transmit+0x14a>
    }

    /* At end of Tx process, restore huart->gState to Ready */
    huart->gState = HAL_UART_STATE_READY;
 800e426:	68fb      	ldr	r3, [r7, #12]
 800e428:	2220      	movs	r2, #32
 800e42a:	679a      	str	r2, [r3, #120]	; 0x78

    return HAL_OK;
 800e42c:	2300      	movs	r3, #0
 800e42e:	e000      	b.n	800e432 <HAL_UART_Transmit+0x14a>
  }
  else
  {
    return HAL_BUSY;
 800e430:	2302      	movs	r3, #2
  }
}
 800e432:	0018      	movs	r0, r3
 800e434:	46bd      	mov	sp, r7
 800e436:	b008      	add	sp, #32
 800e438:	bd80      	pop	{r7, pc}
	...

0800e43c <HAL_UART_Transmit_IT>:
  * @param pData Pointer to data buffer (u8 or u16 data elements).
  * @param Size  Amount of data elements (u8 or u16) to be sent.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Transmit_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
{
 800e43c:	b580      	push	{r7, lr}
 800e43e:	b088      	sub	sp, #32
 800e440:	af00      	add	r7, sp, #0
 800e442:	60f8      	str	r0, [r7, #12]
 800e444:	60b9      	str	r1, [r7, #8]
 800e446:	1dbb      	adds	r3, r7, #6
 800e448:	801a      	strh	r2, [r3, #0]
  /* Check that a Tx process is not already ongoing */
  if (huart->gState == HAL_UART_STATE_READY)
 800e44a:	68fb      	ldr	r3, [r7, #12]
 800e44c:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800e44e:	2b20      	cmp	r3, #32
 800e450:	d000      	beq.n	800e454 <HAL_UART_Transmit_IT+0x18>
 800e452:	e06a      	b.n	800e52a <HAL_UART_Transmit_IT+0xee>
  {
    if ((pData == NULL) || (Size == 0U))
 800e454:	68bb      	ldr	r3, [r7, #8]
 800e456:	2b00      	cmp	r3, #0
 800e458:	d003      	beq.n	800e462 <HAL_UART_Transmit_IT+0x26>
 800e45a:	1dbb      	adds	r3, r7, #6
 800e45c:	881b      	ldrh	r3, [r3, #0]
 800e45e:	2b00      	cmp	r3, #0
 800e460:	d101      	bne.n	800e466 <HAL_UART_Transmit_IT+0x2a>
    {
      return HAL_ERROR;
 800e462:	2301      	movs	r3, #1
 800e464:	e062      	b.n	800e52c <HAL_UART_Transmit_IT+0xf0>
    }

    /* In case of 9bits/No Parity transfer, pData buffer provided as input parameter
       should be aligned on a u16 frontier, as data to be filled into TDR will be
       handled through a u16 cast. */
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 800e466:	68fb      	ldr	r3, [r7, #12]
 800e468:	689a      	ldr	r2, [r3, #8]
 800e46a:	2380      	movs	r3, #128	; 0x80
 800e46c:	015b      	lsls	r3, r3, #5
 800e46e:	429a      	cmp	r2, r3
 800e470:	d109      	bne.n	800e486 <HAL_UART_Transmit_IT+0x4a>
 800e472:	68fb      	ldr	r3, [r7, #12]
 800e474:	691b      	ldr	r3, [r3, #16]
 800e476:	2b00      	cmp	r3, #0
 800e478:	d105      	bne.n	800e486 <HAL_UART_Transmit_IT+0x4a>
    {
      if ((((uint32_t)pData) & 1U) != 0U)
 800e47a:	68bb      	ldr	r3, [r7, #8]
 800e47c:	2201      	movs	r2, #1
 800e47e:	4013      	ands	r3, r2
 800e480:	d001      	beq.n	800e486 <HAL_UART_Transmit_IT+0x4a>
      {
        return  HAL_ERROR;
 800e482:	2301      	movs	r3, #1
 800e484:	e052      	b.n	800e52c <HAL_UART_Transmit_IT+0xf0>
      }
    }

    __HAL_LOCK(huart);
 800e486:	68fb      	ldr	r3, [r7, #12]
 800e488:	2274      	movs	r2, #116	; 0x74
 800e48a:	5c9b      	ldrb	r3, [r3, r2]
 800e48c:	2b01      	cmp	r3, #1
 800e48e:	d101      	bne.n	800e494 <HAL_UART_Transmit_IT+0x58>
 800e490:	2302      	movs	r3, #2
 800e492:	e04b      	b.n	800e52c <HAL_UART_Transmit_IT+0xf0>
 800e494:	68fb      	ldr	r3, [r7, #12]
 800e496:	2274      	movs	r2, #116	; 0x74
 800e498:	2101      	movs	r1, #1
 800e49a:	5499      	strb	r1, [r3, r2]

    huart->pTxBuffPtr  = pData;
 800e49c:	68fb      	ldr	r3, [r7, #12]
 800e49e:	68ba      	ldr	r2, [r7, #8]
 800e4a0:	64da      	str	r2, [r3, #76]	; 0x4c
    huart->TxXferSize  = Size;
 800e4a2:	68fb      	ldr	r3, [r7, #12]
 800e4a4:	1dba      	adds	r2, r7, #6
 800e4a6:	2150      	movs	r1, #80	; 0x50
 800e4a8:	8812      	ldrh	r2, [r2, #0]
 800e4aa:	525a      	strh	r2, [r3, r1]
    huart->TxXferCount = Size;
 800e4ac:	68fb      	ldr	r3, [r7, #12]
 800e4ae:	1dba      	adds	r2, r7, #6
 800e4b0:	2152      	movs	r1, #82	; 0x52
 800e4b2:	8812      	ldrh	r2, [r2, #0]
 800e4b4:	525a      	strh	r2, [r3, r1]
    huart->TxISR       = NULL;
 800e4b6:	68fb      	ldr	r3, [r7, #12]
 800e4b8:	2200      	movs	r2, #0
 800e4ba:	669a      	str	r2, [r3, #104]	; 0x68

    huart->ErrorCode = HAL_UART_ERROR_NONE;
 800e4bc:	68fb      	ldr	r3, [r7, #12]
 800e4be:	2280      	movs	r2, #128	; 0x80
 800e4c0:	2100      	movs	r1, #0
 800e4c2:	5099      	str	r1, [r3, r2]
    huart->gState = HAL_UART_STATE_BUSY_TX;
 800e4c4:	68fb      	ldr	r3, [r7, #12]
 800e4c6:	2221      	movs	r2, #33	; 0x21
 800e4c8:	679a      	str	r2, [r3, #120]	; 0x78

    /* Set the Tx ISR function pointer according to the data word length */
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 800e4ca:	68fb      	ldr	r3, [r7, #12]
 800e4cc:	689a      	ldr	r2, [r3, #8]
 800e4ce:	2380      	movs	r3, #128	; 0x80
 800e4d0:	015b      	lsls	r3, r3, #5
 800e4d2:	429a      	cmp	r2, r3
 800e4d4:	d107      	bne.n	800e4e6 <HAL_UART_Transmit_IT+0xaa>
 800e4d6:	68fb      	ldr	r3, [r7, #12]
 800e4d8:	691b      	ldr	r3, [r3, #16]
 800e4da:	2b00      	cmp	r3, #0
 800e4dc:	d103      	bne.n	800e4e6 <HAL_UART_Transmit_IT+0xaa>
    {
      huart->TxISR = UART_TxISR_16BIT;
 800e4de:	68fb      	ldr	r3, [r7, #12]
 800e4e0:	4a14      	ldr	r2, [pc, #80]	; (800e534 <HAL_UART_Transmit_IT+0xf8>)
 800e4e2:	669a      	str	r2, [r3, #104]	; 0x68
 800e4e4:	e002      	b.n	800e4ec <HAL_UART_Transmit_IT+0xb0>
    }
    else
    {
      huart->TxISR = UART_TxISR_8BIT;
 800e4e6:	68fb      	ldr	r3, [r7, #12]
 800e4e8:	4a13      	ldr	r2, [pc, #76]	; (800e538 <HAL_UART_Transmit_IT+0xfc>)
 800e4ea:	669a      	str	r2, [r3, #104]	; 0x68
    }

    __HAL_UNLOCK(huart);
 800e4ec:	68fb      	ldr	r3, [r7, #12]
 800e4ee:	2274      	movs	r2, #116	; 0x74
 800e4f0:	2100      	movs	r1, #0
 800e4f2:	5499      	strb	r1, [r3, r2]
 */
__STATIC_FORCEINLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800e4f4:	f3ef 8310 	mrs	r3, PRIMASK
 800e4f8:	613b      	str	r3, [r7, #16]
  return(result);
 800e4fa:	693b      	ldr	r3, [r7, #16]

    /* Enable the Transmit Data Register Empty interrupt */
    ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_TXEIE);
 800e4fc:	61fb      	str	r3, [r7, #28]
 800e4fe:	2301      	movs	r3, #1
 800e500:	617b      	str	r3, [r7, #20]
  \details Assigns the given value to the Priority Mask Register.
  \param [in]    priMask  Priority Mask
 */
__STATIC_FORCEINLINE void __set_PRIMASK(uint32_t priMask)
{
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800e502:	697b      	ldr	r3, [r7, #20]
 800e504:	f383 8810 	msr	PRIMASK, r3
}
 800e508:	46c0      	nop			; (mov r8, r8)
 800e50a:	68fb      	ldr	r3, [r7, #12]
 800e50c:	681b      	ldr	r3, [r3, #0]
 800e50e:	681a      	ldr	r2, [r3, #0]
 800e510:	68fb      	ldr	r3, [r7, #12]
 800e512:	681b      	ldr	r3, [r3, #0]
 800e514:	2180      	movs	r1, #128	; 0x80
 800e516:	430a      	orrs	r2, r1
 800e518:	601a      	str	r2, [r3, #0]
 800e51a:	69fb      	ldr	r3, [r7, #28]
 800e51c:	61bb      	str	r3, [r7, #24]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800e51e:	69bb      	ldr	r3, [r7, #24]
 800e520:	f383 8810 	msr	PRIMASK, r3
}
 800e524:	46c0      	nop			; (mov r8, r8)

    return HAL_OK;
 800e526:	2300      	movs	r3, #0
 800e528:	e000      	b.n	800e52c <HAL_UART_Transmit_IT+0xf0>
  }
  else
  {
    return HAL_BUSY;
 800e52a:	2302      	movs	r3, #2
  }
}
 800e52c:	0018      	movs	r0, r3
 800e52e:	46bd      	mov	sp, r7
 800e530:	b008      	add	sp, #32
 800e532:	bd80      	pop	{r7, pc}
 800e534:	0800f58f 	.word	0x0800f58f
 800e538:	0800f4db 	.word	0x0800f4db

0800e53c <HAL_UART_Receive_IT>:
  * @param pData Pointer to data buffer (u8 or u16 data elements).
  * @param Size  Amount of data elements (u8 or u16) to be received.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
{
 800e53c:	b580      	push	{r7, lr}
 800e53e:	b088      	sub	sp, #32
 800e540:	af00      	add	r7, sp, #0
 800e542:	60f8      	str	r0, [r7, #12]
 800e544:	60b9      	str	r1, [r7, #8]
 800e546:	1dbb      	adds	r3, r7, #6
 800e548:	801a      	strh	r2, [r3, #0]
  /* Check that a Rx process is not already ongoing */
  if (huart->RxState == HAL_UART_STATE_READY)
 800e54a:	68fb      	ldr	r3, [r7, #12]
 800e54c:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800e54e:	2b20      	cmp	r3, #32
 800e550:	d150      	bne.n	800e5f4 <HAL_UART_Receive_IT+0xb8>
  {
    if ((pData == NULL) || (Size == 0U))
 800e552:	68bb      	ldr	r3, [r7, #8]
 800e554:	2b00      	cmp	r3, #0
 800e556:	d003      	beq.n	800e560 <HAL_UART_Receive_IT+0x24>
 800e558:	1dbb      	adds	r3, r7, #6
 800e55a:	881b      	ldrh	r3, [r3, #0]
 800e55c:	2b00      	cmp	r3, #0
 800e55e:	d101      	bne.n	800e564 <HAL_UART_Receive_IT+0x28>
    {
      return HAL_ERROR;
 800e560:	2301      	movs	r3, #1
 800e562:	e048      	b.n	800e5f6 <HAL_UART_Receive_IT+0xba>
    }

    /* In case of 9bits/No Parity transfer, pData buffer provided as input parameter
       should be aligned on a u16 frontier, as data to be received from RDR will be
       handled through a u16 cast. */
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 800e564:	68fb      	ldr	r3, [r7, #12]
 800e566:	689a      	ldr	r2, [r3, #8]
 800e568:	2380      	movs	r3, #128	; 0x80
 800e56a:	015b      	lsls	r3, r3, #5
 800e56c:	429a      	cmp	r2, r3
 800e56e:	d109      	bne.n	800e584 <HAL_UART_Receive_IT+0x48>
 800e570:	68fb      	ldr	r3, [r7, #12]
 800e572:	691b      	ldr	r3, [r3, #16]
 800e574:	2b00      	cmp	r3, #0
 800e576:	d105      	bne.n	800e584 <HAL_UART_Receive_IT+0x48>
    {
      if ((((uint32_t)pData) & 1U) != 0U)
 800e578:	68bb      	ldr	r3, [r7, #8]
 800e57a:	2201      	movs	r2, #1
 800e57c:	4013      	ands	r3, r2
 800e57e:	d001      	beq.n	800e584 <HAL_UART_Receive_IT+0x48>
      {
        return  HAL_ERROR;
 800e580:	2301      	movs	r3, #1
 800e582:	e038      	b.n	800e5f6 <HAL_UART_Receive_IT+0xba>
      }
    }

    __HAL_LOCK(huart);
 800e584:	68fb      	ldr	r3, [r7, #12]
 800e586:	2274      	movs	r2, #116	; 0x74
 800e588:	5c9b      	ldrb	r3, [r3, r2]
 800e58a:	2b01      	cmp	r3, #1
 800e58c:	d101      	bne.n	800e592 <HAL_UART_Receive_IT+0x56>
 800e58e:	2302      	movs	r3, #2
 800e590:	e031      	b.n	800e5f6 <HAL_UART_Receive_IT+0xba>
 800e592:	68fb      	ldr	r3, [r7, #12]
 800e594:	2274      	movs	r2, #116	; 0x74
 800e596:	2101      	movs	r1, #1
 800e598:	5499      	strb	r1, [r3, r2]

    /* Set Reception type to Standard reception */
    huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 800e59a:	68fb      	ldr	r3, [r7, #12]
 800e59c:	2200      	movs	r2, #0
 800e59e:	661a      	str	r2, [r3, #96]	; 0x60

    /* Check that USART RTOEN bit is set */
    if (READ_BIT(huart->Instance->CR2, USART_CR2_RTOEN) != 0U)
 800e5a0:	68fb      	ldr	r3, [r7, #12]
 800e5a2:	681b      	ldr	r3, [r3, #0]
 800e5a4:	685a      	ldr	r2, [r3, #4]
 800e5a6:	2380      	movs	r3, #128	; 0x80
 800e5a8:	041b      	lsls	r3, r3, #16
 800e5aa:	4013      	ands	r3, r2
 800e5ac:	d019      	beq.n	800e5e2 <HAL_UART_Receive_IT+0xa6>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800e5ae:	f3ef 8310 	mrs	r3, PRIMASK
 800e5b2:	613b      	str	r3, [r7, #16]
  return(result);
 800e5b4:	693b      	ldr	r3, [r7, #16]
    {
      /* Enable the UART Receiver Timeout Interrupt */
      ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_RTOIE);
 800e5b6:	61fb      	str	r3, [r7, #28]
 800e5b8:	2301      	movs	r3, #1
 800e5ba:	617b      	str	r3, [r7, #20]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800e5bc:	697b      	ldr	r3, [r7, #20]
 800e5be:	f383 8810 	msr	PRIMASK, r3
}
 800e5c2:	46c0      	nop			; (mov r8, r8)
 800e5c4:	68fb      	ldr	r3, [r7, #12]
 800e5c6:	681b      	ldr	r3, [r3, #0]
 800e5c8:	681a      	ldr	r2, [r3, #0]
 800e5ca:	68fb      	ldr	r3, [r7, #12]
 800e5cc:	681b      	ldr	r3, [r3, #0]
 800e5ce:	2180      	movs	r1, #128	; 0x80
 800e5d0:	04c9      	lsls	r1, r1, #19
 800e5d2:	430a      	orrs	r2, r1
 800e5d4:	601a      	str	r2, [r3, #0]
 800e5d6:	69fb      	ldr	r3, [r7, #28]
 800e5d8:	61bb      	str	r3, [r7, #24]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800e5da:	69bb      	ldr	r3, [r7, #24]
 800e5dc:	f383 8810 	msr	PRIMASK, r3
}
 800e5e0:	46c0      	nop			; (mov r8, r8)
    }

    return (UART_Start_Receive_IT(huart, pData, Size));
 800e5e2:	1dbb      	adds	r3, r7, #6
 800e5e4:	881a      	ldrh	r2, [r3, #0]
 800e5e6:	68b9      	ldr	r1, [r7, #8]
 800e5e8:	68fb      	ldr	r3, [r7, #12]
 800e5ea:	0018      	movs	r0, r3
 800e5ec:	f000 fe4c 	bl	800f288 <UART_Start_Receive_IT>
 800e5f0:	0003      	movs	r3, r0
 800e5f2:	e000      	b.n	800e5f6 <HAL_UART_Receive_IT+0xba>
  }
  else
  {
    return HAL_BUSY;
 800e5f4:	2302      	movs	r3, #2
  }
}
 800e5f6:	0018      	movs	r0, r3
 800e5f8:	46bd      	mov	sp, r7
 800e5fa:	b008      	add	sp, #32
 800e5fc:	bd80      	pop	{r7, pc}
	...

0800e600 <HAL_UART_IRQHandler>:
  * @brief Handle UART interrupt request.
  * @param huart UART handle.
  * @retval None
  */
void HAL_UART_IRQHandler(UART_HandleTypeDef *huart)
{
 800e600:	b590      	push	{r4, r7, lr}
 800e602:	b0ab      	sub	sp, #172	; 0xac
 800e604:	af00      	add	r7, sp, #0
 800e606:	6078      	str	r0, [r7, #4]
  uint32_t isrflags   = READ_REG(huart->Instance->ISR);
 800e608:	687b      	ldr	r3, [r7, #4]
 800e60a:	681b      	ldr	r3, [r3, #0]
 800e60c:	69db      	ldr	r3, [r3, #28]
 800e60e:	22a4      	movs	r2, #164	; 0xa4
 800e610:	18b9      	adds	r1, r7, r2
 800e612:	600b      	str	r3, [r1, #0]
  uint32_t cr1its     = READ_REG(huart->Instance->CR1);
 800e614:	687b      	ldr	r3, [r7, #4]
 800e616:	681b      	ldr	r3, [r3, #0]
 800e618:	681b      	ldr	r3, [r3, #0]
 800e61a:	20a0      	movs	r0, #160	; 0xa0
 800e61c:	1839      	adds	r1, r7, r0
 800e61e:	600b      	str	r3, [r1, #0]
  uint32_t cr3its     = READ_REG(huart->Instance->CR3);
 800e620:	687b      	ldr	r3, [r7, #4]
 800e622:	681b      	ldr	r3, [r3, #0]
 800e624:	689b      	ldr	r3, [r3, #8]
 800e626:	219c      	movs	r1, #156	; 0x9c
 800e628:	1879      	adds	r1, r7, r1
 800e62a:	600b      	str	r3, [r1, #0]

  uint32_t errorflags;
  uint32_t errorcode;

  /* If no error occurs */
  errorflags = (isrflags & (uint32_t)(USART_ISR_PE | USART_ISR_FE | USART_ISR_ORE | USART_ISR_NE | USART_ISR_RTOF));
 800e62c:	0011      	movs	r1, r2
 800e62e:	18bb      	adds	r3, r7, r2
 800e630:	681b      	ldr	r3, [r3, #0]
 800e632:	4a99      	ldr	r2, [pc, #612]	; (800e898 <HAL_UART_IRQHandler+0x298>)
 800e634:	4013      	ands	r3, r2
 800e636:	2298      	movs	r2, #152	; 0x98
 800e638:	18bc      	adds	r4, r7, r2
 800e63a:	6023      	str	r3, [r4, #0]
  if (errorflags == 0U)
 800e63c:	18bb      	adds	r3, r7, r2
 800e63e:	681b      	ldr	r3, [r3, #0]
 800e640:	2b00      	cmp	r3, #0
 800e642:	d114      	bne.n	800e66e <HAL_UART_IRQHandler+0x6e>
  {
    /* UART in mode Receiver ---------------------------------------------------*/
    if (((isrflags & USART_ISR_RXNE) != 0U)
 800e644:	187b      	adds	r3, r7, r1
 800e646:	681b      	ldr	r3, [r3, #0]
 800e648:	2220      	movs	r2, #32
 800e64a:	4013      	ands	r3, r2
 800e64c:	d00f      	beq.n	800e66e <HAL_UART_IRQHandler+0x6e>
        && ((cr1its & USART_CR1_RXNEIE) != 0U))
 800e64e:	183b      	adds	r3, r7, r0
 800e650:	681b      	ldr	r3, [r3, #0]
 800e652:	2220      	movs	r2, #32
 800e654:	4013      	ands	r3, r2
 800e656:	d00a      	beq.n	800e66e <HAL_UART_IRQHandler+0x6e>
    {
      if (huart->RxISR != NULL)
 800e658:	687b      	ldr	r3, [r7, #4]
 800e65a:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 800e65c:	2b00      	cmp	r3, #0
 800e65e:	d100      	bne.n	800e662 <HAL_UART_IRQHandler+0x62>
 800e660:	e296      	b.n	800eb90 <HAL_UART_IRQHandler+0x590>
      {
        huart->RxISR(huart);
 800e662:	687b      	ldr	r3, [r7, #4]
 800e664:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 800e666:	687a      	ldr	r2, [r7, #4]
 800e668:	0010      	movs	r0, r2
 800e66a:	4798      	blx	r3
      }
      return;
 800e66c:	e290      	b.n	800eb90 <HAL_UART_IRQHandler+0x590>
    }
  }

  /* If some errors occur */
  if ((errorflags != 0U)
 800e66e:	2398      	movs	r3, #152	; 0x98
 800e670:	18fb      	adds	r3, r7, r3
 800e672:	681b      	ldr	r3, [r3, #0]
 800e674:	2b00      	cmp	r3, #0
 800e676:	d100      	bne.n	800e67a <HAL_UART_IRQHandler+0x7a>
 800e678:	e114      	b.n	800e8a4 <HAL_UART_IRQHandler+0x2a4>
      && (((cr3its & USART_CR3_EIE) != 0U)
 800e67a:	239c      	movs	r3, #156	; 0x9c
 800e67c:	18fb      	adds	r3, r7, r3
 800e67e:	681b      	ldr	r3, [r3, #0]
 800e680:	2201      	movs	r2, #1
 800e682:	4013      	ands	r3, r2
 800e684:	d106      	bne.n	800e694 <HAL_UART_IRQHandler+0x94>
          || ((cr1its & (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_RTOIE)) != 0U)))
 800e686:	23a0      	movs	r3, #160	; 0xa0
 800e688:	18fb      	adds	r3, r7, r3
 800e68a:	681b      	ldr	r3, [r3, #0]
 800e68c:	4a83      	ldr	r2, [pc, #524]	; (800e89c <HAL_UART_IRQHandler+0x29c>)
 800e68e:	4013      	ands	r3, r2
 800e690:	d100      	bne.n	800e694 <HAL_UART_IRQHandler+0x94>
 800e692:	e107      	b.n	800e8a4 <HAL_UART_IRQHandler+0x2a4>
  {
    /* UART parity error interrupt occurred -------------------------------------*/
    if (((isrflags & USART_ISR_PE) != 0U) && ((cr1its & USART_CR1_PEIE) != 0U))
 800e694:	23a4      	movs	r3, #164	; 0xa4
 800e696:	18fb      	adds	r3, r7, r3
 800e698:	681b      	ldr	r3, [r3, #0]
 800e69a:	2201      	movs	r2, #1
 800e69c:	4013      	ands	r3, r2
 800e69e:	d012      	beq.n	800e6c6 <HAL_UART_IRQHandler+0xc6>
 800e6a0:	23a0      	movs	r3, #160	; 0xa0
 800e6a2:	18fb      	adds	r3, r7, r3
 800e6a4:	681a      	ldr	r2, [r3, #0]
 800e6a6:	2380      	movs	r3, #128	; 0x80
 800e6a8:	005b      	lsls	r3, r3, #1
 800e6aa:	4013      	ands	r3, r2
 800e6ac:	d00b      	beq.n	800e6c6 <HAL_UART_IRQHandler+0xc6>
    {
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_PEF);
 800e6ae:	687b      	ldr	r3, [r7, #4]
 800e6b0:	681b      	ldr	r3, [r3, #0]
 800e6b2:	2201      	movs	r2, #1
 800e6b4:	621a      	str	r2, [r3, #32]

      huart->ErrorCode |= HAL_UART_ERROR_PE;
 800e6b6:	687b      	ldr	r3, [r7, #4]
 800e6b8:	2280      	movs	r2, #128	; 0x80
 800e6ba:	589b      	ldr	r3, [r3, r2]
 800e6bc:	2201      	movs	r2, #1
 800e6be:	431a      	orrs	r2, r3
 800e6c0:	687b      	ldr	r3, [r7, #4]
 800e6c2:	2180      	movs	r1, #128	; 0x80
 800e6c4:	505a      	str	r2, [r3, r1]
    }

    /* UART frame error interrupt occurred --------------------------------------*/
    if (((isrflags & USART_ISR_FE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 800e6c6:	23a4      	movs	r3, #164	; 0xa4
 800e6c8:	18fb      	adds	r3, r7, r3
 800e6ca:	681b      	ldr	r3, [r3, #0]
 800e6cc:	2202      	movs	r2, #2
 800e6ce:	4013      	ands	r3, r2
 800e6d0:	d011      	beq.n	800e6f6 <HAL_UART_IRQHandler+0xf6>
 800e6d2:	239c      	movs	r3, #156	; 0x9c
 800e6d4:	18fb      	adds	r3, r7, r3
 800e6d6:	681b      	ldr	r3, [r3, #0]
 800e6d8:	2201      	movs	r2, #1
 800e6da:	4013      	ands	r3, r2
 800e6dc:	d00b      	beq.n	800e6f6 <HAL_UART_IRQHandler+0xf6>
    {
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_FEF);
 800e6de:	687b      	ldr	r3, [r7, #4]
 800e6e0:	681b      	ldr	r3, [r3, #0]
 800e6e2:	2202      	movs	r2, #2
 800e6e4:	621a      	str	r2, [r3, #32]

      huart->ErrorCode |= HAL_UART_ERROR_FE;
 800e6e6:	687b      	ldr	r3, [r7, #4]
 800e6e8:	2280      	movs	r2, #128	; 0x80
 800e6ea:	589b      	ldr	r3, [r3, r2]
 800e6ec:	2204      	movs	r2, #4
 800e6ee:	431a      	orrs	r2, r3
 800e6f0:	687b      	ldr	r3, [r7, #4]
 800e6f2:	2180      	movs	r1, #128	; 0x80
 800e6f4:	505a      	str	r2, [r3, r1]
    }

    /* UART noise error interrupt occurred --------------------------------------*/
    if (((isrflags & USART_ISR_NE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 800e6f6:	23a4      	movs	r3, #164	; 0xa4
 800e6f8:	18fb      	adds	r3, r7, r3
 800e6fa:	681b      	ldr	r3, [r3, #0]
 800e6fc:	2204      	movs	r2, #4
 800e6fe:	4013      	ands	r3, r2
 800e700:	d011      	beq.n	800e726 <HAL_UART_IRQHandler+0x126>
 800e702:	239c      	movs	r3, #156	; 0x9c
 800e704:	18fb      	adds	r3, r7, r3
 800e706:	681b      	ldr	r3, [r3, #0]
 800e708:	2201      	movs	r2, #1
 800e70a:	4013      	ands	r3, r2
 800e70c:	d00b      	beq.n	800e726 <HAL_UART_IRQHandler+0x126>
    {
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_NEF);
 800e70e:	687b      	ldr	r3, [r7, #4]
 800e710:	681b      	ldr	r3, [r3, #0]
 800e712:	2204      	movs	r2, #4
 800e714:	621a      	str	r2, [r3, #32]

      huart->ErrorCode |= HAL_UART_ERROR_NE;
 800e716:	687b      	ldr	r3, [r7, #4]
 800e718:	2280      	movs	r2, #128	; 0x80
 800e71a:	589b      	ldr	r3, [r3, r2]
 800e71c:	2202      	movs	r2, #2
 800e71e:	431a      	orrs	r2, r3
 800e720:	687b      	ldr	r3, [r7, #4]
 800e722:	2180      	movs	r1, #128	; 0x80
 800e724:	505a      	str	r2, [r3, r1]
    }

    /* UART Over-Run interrupt occurred -----------------------------------------*/
    if (((isrflags & USART_ISR_ORE) != 0U)
 800e726:	23a4      	movs	r3, #164	; 0xa4
 800e728:	18fb      	adds	r3, r7, r3
 800e72a:	681b      	ldr	r3, [r3, #0]
 800e72c:	2208      	movs	r2, #8
 800e72e:	4013      	ands	r3, r2
 800e730:	d017      	beq.n	800e762 <HAL_UART_IRQHandler+0x162>
        && (((cr1its & USART_CR1_RXNEIE) != 0U) ||
 800e732:	23a0      	movs	r3, #160	; 0xa0
 800e734:	18fb      	adds	r3, r7, r3
 800e736:	681b      	ldr	r3, [r3, #0]
 800e738:	2220      	movs	r2, #32
 800e73a:	4013      	ands	r3, r2
 800e73c:	d105      	bne.n	800e74a <HAL_UART_IRQHandler+0x14a>
            ((cr3its & USART_CR3_EIE) != 0U)))
 800e73e:	239c      	movs	r3, #156	; 0x9c
 800e740:	18fb      	adds	r3, r7, r3
 800e742:	681b      	ldr	r3, [r3, #0]
 800e744:	2201      	movs	r2, #1
 800e746:	4013      	ands	r3, r2
        && (((cr1its & USART_CR1_RXNEIE) != 0U) ||
 800e748:	d00b      	beq.n	800e762 <HAL_UART_IRQHandler+0x162>
    {
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF);
 800e74a:	687b      	ldr	r3, [r7, #4]
 800e74c:	681b      	ldr	r3, [r3, #0]
 800e74e:	2208      	movs	r2, #8
 800e750:	621a      	str	r2, [r3, #32]

      huart->ErrorCode |= HAL_UART_ERROR_ORE;
 800e752:	687b      	ldr	r3, [r7, #4]
 800e754:	2280      	movs	r2, #128	; 0x80
 800e756:	589b      	ldr	r3, [r3, r2]
 800e758:	2208      	movs	r2, #8
 800e75a:	431a      	orrs	r2, r3
 800e75c:	687b      	ldr	r3, [r7, #4]
 800e75e:	2180      	movs	r1, #128	; 0x80
 800e760:	505a      	str	r2, [r3, r1]
    }

    /* UART Receiver Timeout interrupt occurred ---------------------------------*/
    if (((isrflags & USART_ISR_RTOF) != 0U) && ((cr1its & USART_CR1_RTOIE) != 0U))
 800e762:	23a4      	movs	r3, #164	; 0xa4
 800e764:	18fb      	adds	r3, r7, r3
 800e766:	681a      	ldr	r2, [r3, #0]
 800e768:	2380      	movs	r3, #128	; 0x80
 800e76a:	011b      	lsls	r3, r3, #4
 800e76c:	4013      	ands	r3, r2
 800e76e:	d013      	beq.n	800e798 <HAL_UART_IRQHandler+0x198>
 800e770:	23a0      	movs	r3, #160	; 0xa0
 800e772:	18fb      	adds	r3, r7, r3
 800e774:	681a      	ldr	r2, [r3, #0]
 800e776:	2380      	movs	r3, #128	; 0x80
 800e778:	04db      	lsls	r3, r3, #19
 800e77a:	4013      	ands	r3, r2
 800e77c:	d00c      	beq.n	800e798 <HAL_UART_IRQHandler+0x198>
    {
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
 800e77e:	687b      	ldr	r3, [r7, #4]
 800e780:	681b      	ldr	r3, [r3, #0]
 800e782:	2280      	movs	r2, #128	; 0x80
 800e784:	0112      	lsls	r2, r2, #4
 800e786:	621a      	str	r2, [r3, #32]

      huart->ErrorCode |= HAL_UART_ERROR_RTO;
 800e788:	687b      	ldr	r3, [r7, #4]
 800e78a:	2280      	movs	r2, #128	; 0x80
 800e78c:	589b      	ldr	r3, [r3, r2]
 800e78e:	2220      	movs	r2, #32
 800e790:	431a      	orrs	r2, r3
 800e792:	687b      	ldr	r3, [r7, #4]
 800e794:	2180      	movs	r1, #128	; 0x80
 800e796:	505a      	str	r2, [r3, r1]
    }

    /* Call UART Error Call back function if need be ----------------------------*/
    if (huart->ErrorCode != HAL_UART_ERROR_NONE)
 800e798:	687b      	ldr	r3, [r7, #4]
 800e79a:	2280      	movs	r2, #128	; 0x80
 800e79c:	589b      	ldr	r3, [r3, r2]
 800e79e:	2b00      	cmp	r3, #0
 800e7a0:	d100      	bne.n	800e7a4 <HAL_UART_IRQHandler+0x1a4>
 800e7a2:	e1f7      	b.n	800eb94 <HAL_UART_IRQHandler+0x594>
    {
      /* UART in mode Receiver --------------------------------------------------*/
      if (((isrflags & USART_ISR_RXNE) != 0U)
 800e7a4:	23a4      	movs	r3, #164	; 0xa4
 800e7a6:	18fb      	adds	r3, r7, r3
 800e7a8:	681b      	ldr	r3, [r3, #0]
 800e7aa:	2220      	movs	r2, #32
 800e7ac:	4013      	ands	r3, r2
 800e7ae:	d00e      	beq.n	800e7ce <HAL_UART_IRQHandler+0x1ce>
          && ((cr1its & USART_CR1_RXNEIE) != 0U))
 800e7b0:	23a0      	movs	r3, #160	; 0xa0
 800e7b2:	18fb      	adds	r3, r7, r3
 800e7b4:	681b      	ldr	r3, [r3, #0]
 800e7b6:	2220      	movs	r2, #32
 800e7b8:	4013      	ands	r3, r2
 800e7ba:	d008      	beq.n	800e7ce <HAL_UART_IRQHandler+0x1ce>
      {
        if (huart->RxISR != NULL)
 800e7bc:	687b      	ldr	r3, [r7, #4]
 800e7be:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 800e7c0:	2b00      	cmp	r3, #0
 800e7c2:	d004      	beq.n	800e7ce <HAL_UART_IRQHandler+0x1ce>
        {
          huart->RxISR(huart);
 800e7c4:	687b      	ldr	r3, [r7, #4]
 800e7c6:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 800e7c8:	687a      	ldr	r2, [r7, #4]
 800e7ca:	0010      	movs	r0, r2
 800e7cc:	4798      	blx	r3
      /* If Error is to be considered as blocking :
          - Receiver Timeout error in Reception
          - Overrun error in Reception
          - any error occurs in DMA mode reception
      */
      errorcode = huart->ErrorCode;
 800e7ce:	687b      	ldr	r3, [r7, #4]
 800e7d0:	2280      	movs	r2, #128	; 0x80
 800e7d2:	589b      	ldr	r3, [r3, r2]
 800e7d4:	2194      	movs	r1, #148	; 0x94
 800e7d6:	187a      	adds	r2, r7, r1
 800e7d8:	6013      	str	r3, [r2, #0]
      if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) ||
 800e7da:	687b      	ldr	r3, [r7, #4]
 800e7dc:	681b      	ldr	r3, [r3, #0]
 800e7de:	689b      	ldr	r3, [r3, #8]
 800e7e0:	2240      	movs	r2, #64	; 0x40
 800e7e2:	4013      	ands	r3, r2
 800e7e4:	2b40      	cmp	r3, #64	; 0x40
 800e7e6:	d004      	beq.n	800e7f2 <HAL_UART_IRQHandler+0x1f2>
          ((errorcode & (HAL_UART_ERROR_RTO | HAL_UART_ERROR_ORE)) != 0U))
 800e7e8:	187b      	adds	r3, r7, r1
 800e7ea:	681b      	ldr	r3, [r3, #0]
 800e7ec:	2228      	movs	r2, #40	; 0x28
 800e7ee:	4013      	ands	r3, r2
      if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) ||
 800e7f0:	d047      	beq.n	800e882 <HAL_UART_IRQHandler+0x282>
      {
        /* Blocking error : transfer is aborted
           Set the UART state ready to be able to start again the process,
           Disable Rx Interrupts, and disable Rx DMA request, if ongoing */
        UART_EndRxTransfer(huart);
 800e7f2:	687b      	ldr	r3, [r7, #4]
 800e7f4:	0018      	movs	r0, r3
 800e7f6:	f000 fdf7 	bl	800f3e8 <UART_EndRxTransfer>

        /* Disable the UART DMA Rx request if enabled */
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 800e7fa:	687b      	ldr	r3, [r7, #4]
 800e7fc:	681b      	ldr	r3, [r3, #0]
 800e7fe:	689b      	ldr	r3, [r3, #8]
 800e800:	2240      	movs	r2, #64	; 0x40
 800e802:	4013      	ands	r3, r2
 800e804:	2b40      	cmp	r3, #64	; 0x40
 800e806:	d137      	bne.n	800e878 <HAL_UART_IRQHandler+0x278>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800e808:	f3ef 8310 	mrs	r3, PRIMASK
 800e80c:	663b      	str	r3, [r7, #96]	; 0x60
  return(result);
 800e80e:	6e3b      	ldr	r3, [r7, #96]	; 0x60
        {
          ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 800e810:	2090      	movs	r0, #144	; 0x90
 800e812:	183a      	adds	r2, r7, r0
 800e814:	6013      	str	r3, [r2, #0]
 800e816:	2301      	movs	r3, #1
 800e818:	667b      	str	r3, [r7, #100]	; 0x64
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800e81a:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800e81c:	f383 8810 	msr	PRIMASK, r3
}
 800e820:	46c0      	nop			; (mov r8, r8)
 800e822:	687b      	ldr	r3, [r7, #4]
 800e824:	681b      	ldr	r3, [r3, #0]
 800e826:	689a      	ldr	r2, [r3, #8]
 800e828:	687b      	ldr	r3, [r7, #4]
 800e82a:	681b      	ldr	r3, [r3, #0]
 800e82c:	2140      	movs	r1, #64	; 0x40
 800e82e:	438a      	bics	r2, r1
 800e830:	609a      	str	r2, [r3, #8]
 800e832:	183b      	adds	r3, r7, r0
 800e834:	681b      	ldr	r3, [r3, #0]
 800e836:	66bb      	str	r3, [r7, #104]	; 0x68
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800e838:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800e83a:	f383 8810 	msr	PRIMASK, r3
}
 800e83e:	46c0      	nop			; (mov r8, r8)

          /* Abort the UART DMA Rx channel */
          if (huart->hdmarx != NULL)
 800e840:	687b      	ldr	r3, [r7, #4]
 800e842:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800e844:	2b00      	cmp	r3, #0
 800e846:	d012      	beq.n	800e86e <HAL_UART_IRQHandler+0x26e>
          {
            /* Set the UART DMA Abort callback :
               will lead to call HAL_UART_ErrorCallback() at end of DMA abort procedure */
            huart->hdmarx->XferAbortCallback = UART_DMAAbortOnError;
 800e848:	687b      	ldr	r3, [r7, #4]
 800e84a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800e84c:	4a14      	ldr	r2, [pc, #80]	; (800e8a0 <HAL_UART_IRQHandler+0x2a0>)
 800e84e:	635a      	str	r2, [r3, #52]	; 0x34

            /* Abort DMA RX */
            if (HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
 800e850:	687b      	ldr	r3, [r7, #4]
 800e852:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800e854:	0018      	movs	r0, r3
 800e856:	f7fc fdd5 	bl	800b404 <HAL_DMA_Abort_IT>
 800e85a:	1e03      	subs	r3, r0, #0
 800e85c:	d01a      	beq.n	800e894 <HAL_UART_IRQHandler+0x294>
            {
              /* Call Directly huart->hdmarx->XferAbortCallback function in case of error */
              huart->hdmarx->XferAbortCallback(huart->hdmarx);
 800e85e:	687b      	ldr	r3, [r7, #4]
 800e860:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800e862:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800e864:	687b      	ldr	r3, [r7, #4]
 800e866:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800e868:	0018      	movs	r0, r3
 800e86a:	4790      	blx	r2
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 800e86c:	e012      	b.n	800e894 <HAL_UART_IRQHandler+0x294>
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
            /*Call registered error callback*/
            huart->ErrorCallback(huart);
#else
            /*Call legacy weak error callback*/
            HAL_UART_ErrorCallback(huart);
 800e86e:	687b      	ldr	r3, [r7, #4]
 800e870:	0018      	movs	r0, r3
 800e872:	f000 f9ad 	bl	800ebd0 <HAL_UART_ErrorCallback>
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 800e876:	e00d      	b.n	800e894 <HAL_UART_IRQHandler+0x294>
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
          /*Call registered error callback*/
          huart->ErrorCallback(huart);
#else
          /*Call legacy weak error callback*/
          HAL_UART_ErrorCallback(huart);
 800e878:	687b      	ldr	r3, [r7, #4]
 800e87a:	0018      	movs	r0, r3
 800e87c:	f000 f9a8 	bl	800ebd0 <HAL_UART_ErrorCallback>
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 800e880:	e008      	b.n	800e894 <HAL_UART_IRQHandler+0x294>
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
        /*Call registered error callback*/
        huart->ErrorCallback(huart);
#else
        /*Call legacy weak error callback*/
        HAL_UART_ErrorCallback(huart);
 800e882:	687b      	ldr	r3, [r7, #4]
 800e884:	0018      	movs	r0, r3
 800e886:	f000 f9a3 	bl	800ebd0 <HAL_UART_ErrorCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
        huart->ErrorCode = HAL_UART_ERROR_NONE;
 800e88a:	687b      	ldr	r3, [r7, #4]
 800e88c:	2280      	movs	r2, #128	; 0x80
 800e88e:	2100      	movs	r1, #0
 800e890:	5099      	str	r1, [r3, r2]
      }
    }
    return;
 800e892:	e17f      	b.n	800eb94 <HAL_UART_IRQHandler+0x594>
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 800e894:	46c0      	nop			; (mov r8, r8)
    return;
 800e896:	e17d      	b.n	800eb94 <HAL_UART_IRQHandler+0x594>
 800e898:	0000080f 	.word	0x0000080f
 800e89c:	04000120 	.word	0x04000120
 800e8a0:	0800f4ad 	.word	0x0800f4ad

  } /* End if some error occurs */

  /* Check current reception Mode :
     If Reception till IDLE event has been selected : */
  if ((huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 800e8a4:	687b      	ldr	r3, [r7, #4]
 800e8a6:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 800e8a8:	2b01      	cmp	r3, #1
 800e8aa:	d000      	beq.n	800e8ae <HAL_UART_IRQHandler+0x2ae>
 800e8ac:	e131      	b.n	800eb12 <HAL_UART_IRQHandler+0x512>
      && ((isrflags & USART_ISR_IDLE) != 0U)
 800e8ae:	23a4      	movs	r3, #164	; 0xa4
 800e8b0:	18fb      	adds	r3, r7, r3
 800e8b2:	681b      	ldr	r3, [r3, #0]
 800e8b4:	2210      	movs	r2, #16
 800e8b6:	4013      	ands	r3, r2
 800e8b8:	d100      	bne.n	800e8bc <HAL_UART_IRQHandler+0x2bc>
 800e8ba:	e12a      	b.n	800eb12 <HAL_UART_IRQHandler+0x512>
      && ((cr1its & USART_ISR_IDLE) != 0U))
 800e8bc:	23a0      	movs	r3, #160	; 0xa0
 800e8be:	18fb      	adds	r3, r7, r3
 800e8c0:	681b      	ldr	r3, [r3, #0]
 800e8c2:	2210      	movs	r2, #16
 800e8c4:	4013      	ands	r3, r2
 800e8c6:	d100      	bne.n	800e8ca <HAL_UART_IRQHandler+0x2ca>
 800e8c8:	e123      	b.n	800eb12 <HAL_UART_IRQHandler+0x512>
  {
    __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_IDLEF);
 800e8ca:	687b      	ldr	r3, [r7, #4]
 800e8cc:	681b      	ldr	r3, [r3, #0]
 800e8ce:	2210      	movs	r2, #16
 800e8d0:	621a      	str	r2, [r3, #32]

    /* Check if DMA mode is enabled in UART */
    if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 800e8d2:	687b      	ldr	r3, [r7, #4]
 800e8d4:	681b      	ldr	r3, [r3, #0]
 800e8d6:	689b      	ldr	r3, [r3, #8]
 800e8d8:	2240      	movs	r2, #64	; 0x40
 800e8da:	4013      	ands	r3, r2
 800e8dc:	2b40      	cmp	r3, #64	; 0x40
 800e8de:	d000      	beq.n	800e8e2 <HAL_UART_IRQHandler+0x2e2>
 800e8e0:	e09b      	b.n	800ea1a <HAL_UART_IRQHandler+0x41a>
    {
      /* DMA mode enabled */
      /* Check received length : If all expected data are received, do nothing,
         (DMA cplt callback will be called).
         Otherwise, if at least one data has already been received, IDLE event is to be notified to user */
      uint16_t nb_remaining_rx_data = (uint16_t) __HAL_DMA_GET_COUNTER(huart->hdmarx);
 800e8e2:	687b      	ldr	r3, [r7, #4]
 800e8e4:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800e8e6:	681b      	ldr	r3, [r3, #0]
 800e8e8:	685a      	ldr	r2, [r3, #4]
 800e8ea:	217e      	movs	r1, #126	; 0x7e
 800e8ec:	187b      	adds	r3, r7, r1
 800e8ee:	801a      	strh	r2, [r3, #0]
      if ((nb_remaining_rx_data > 0U)
 800e8f0:	187b      	adds	r3, r7, r1
 800e8f2:	881b      	ldrh	r3, [r3, #0]
 800e8f4:	2b00      	cmp	r3, #0
 800e8f6:	d100      	bne.n	800e8fa <HAL_UART_IRQHandler+0x2fa>
 800e8f8:	e14e      	b.n	800eb98 <HAL_UART_IRQHandler+0x598>
          && (nb_remaining_rx_data < huart->RxXferSize))
 800e8fa:	687b      	ldr	r3, [r7, #4]
 800e8fc:	2258      	movs	r2, #88	; 0x58
 800e8fe:	5a9b      	ldrh	r3, [r3, r2]
 800e900:	187a      	adds	r2, r7, r1
 800e902:	8812      	ldrh	r2, [r2, #0]
 800e904:	429a      	cmp	r2, r3
 800e906:	d300      	bcc.n	800e90a <HAL_UART_IRQHandler+0x30a>
 800e908:	e146      	b.n	800eb98 <HAL_UART_IRQHandler+0x598>
      {
        /* Reception is not complete */
        huart->RxXferCount = nb_remaining_rx_data;
 800e90a:	687b      	ldr	r3, [r7, #4]
 800e90c:	187a      	adds	r2, r7, r1
 800e90e:	215a      	movs	r1, #90	; 0x5a
 800e910:	8812      	ldrh	r2, [r2, #0]
 800e912:	525a      	strh	r2, [r3, r1]

        /* In Normal mode, end DMA xfer and HAL UART Rx process*/
        if (huart->hdmarx->Init.Mode != DMA_CIRCULAR)
 800e914:	687b      	ldr	r3, [r7, #4]
 800e916:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800e918:	699b      	ldr	r3, [r3, #24]
 800e91a:	2b20      	cmp	r3, #32
 800e91c:	d06e      	beq.n	800e9fc <HAL_UART_IRQHandler+0x3fc>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800e91e:	f3ef 8310 	mrs	r3, PRIMASK
 800e922:	633b      	str	r3, [r7, #48]	; 0x30
  return(result);
 800e924:	6b3b      	ldr	r3, [r7, #48]	; 0x30
        {
          /* Disable PE and ERR (Frame error, noise error, overrun error) interrupts */
          ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 800e926:	67bb      	str	r3, [r7, #120]	; 0x78
 800e928:	2301      	movs	r3, #1
 800e92a:	637b      	str	r3, [r7, #52]	; 0x34
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800e92c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800e92e:	f383 8810 	msr	PRIMASK, r3
}
 800e932:	46c0      	nop			; (mov r8, r8)
 800e934:	687b      	ldr	r3, [r7, #4]
 800e936:	681b      	ldr	r3, [r3, #0]
 800e938:	681a      	ldr	r2, [r3, #0]
 800e93a:	687b      	ldr	r3, [r7, #4]
 800e93c:	681b      	ldr	r3, [r3, #0]
 800e93e:	499a      	ldr	r1, [pc, #616]	; (800eba8 <HAL_UART_IRQHandler+0x5a8>)
 800e940:	400a      	ands	r2, r1
 800e942:	601a      	str	r2, [r3, #0]
 800e944:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 800e946:	63bb      	str	r3, [r7, #56]	; 0x38
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800e948:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800e94a:	f383 8810 	msr	PRIMASK, r3
}
 800e94e:	46c0      	nop			; (mov r8, r8)
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800e950:	f3ef 8310 	mrs	r3, PRIMASK
 800e954:	63fb      	str	r3, [r7, #60]	; 0x3c
  return(result);
 800e956:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
          ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800e958:	677b      	str	r3, [r7, #116]	; 0x74
 800e95a:	2301      	movs	r3, #1
 800e95c:	643b      	str	r3, [r7, #64]	; 0x40
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800e95e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800e960:	f383 8810 	msr	PRIMASK, r3
}
 800e964:	46c0      	nop			; (mov r8, r8)
 800e966:	687b      	ldr	r3, [r7, #4]
 800e968:	681b      	ldr	r3, [r3, #0]
 800e96a:	689a      	ldr	r2, [r3, #8]
 800e96c:	687b      	ldr	r3, [r7, #4]
 800e96e:	681b      	ldr	r3, [r3, #0]
 800e970:	2101      	movs	r1, #1
 800e972:	438a      	bics	r2, r1
 800e974:	609a      	str	r2, [r3, #8]
 800e976:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800e978:	647b      	str	r3, [r7, #68]	; 0x44
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800e97a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800e97c:	f383 8810 	msr	PRIMASK, r3
}
 800e980:	46c0      	nop			; (mov r8, r8)
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800e982:	f3ef 8310 	mrs	r3, PRIMASK
 800e986:	64bb      	str	r3, [r7, #72]	; 0x48
  return(result);
 800e988:	6cbb      	ldr	r3, [r7, #72]	; 0x48

          /* Disable the DMA transfer for the receiver request by resetting the DMAR bit
             in the UART CR3 register */
          ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 800e98a:	673b      	str	r3, [r7, #112]	; 0x70
 800e98c:	2301      	movs	r3, #1
 800e98e:	64fb      	str	r3, [r7, #76]	; 0x4c
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800e990:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800e992:	f383 8810 	msr	PRIMASK, r3
}
 800e996:	46c0      	nop			; (mov r8, r8)
 800e998:	687b      	ldr	r3, [r7, #4]
 800e99a:	681b      	ldr	r3, [r3, #0]
 800e99c:	689a      	ldr	r2, [r3, #8]
 800e99e:	687b      	ldr	r3, [r7, #4]
 800e9a0:	681b      	ldr	r3, [r3, #0]
 800e9a2:	2140      	movs	r1, #64	; 0x40
 800e9a4:	438a      	bics	r2, r1
 800e9a6:	609a      	str	r2, [r3, #8]
 800e9a8:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 800e9aa:	653b      	str	r3, [r7, #80]	; 0x50
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800e9ac:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800e9ae:	f383 8810 	msr	PRIMASK, r3
}
 800e9b2:	46c0      	nop			; (mov r8, r8)

          /* At end of Rx process, restore huart->RxState to Ready */
          huart->RxState = HAL_UART_STATE_READY;
 800e9b4:	687b      	ldr	r3, [r7, #4]
 800e9b6:	2220      	movs	r2, #32
 800e9b8:	67da      	str	r2, [r3, #124]	; 0x7c
          huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 800e9ba:	687b      	ldr	r3, [r7, #4]
 800e9bc:	2200      	movs	r2, #0
 800e9be:	661a      	str	r2, [r3, #96]	; 0x60
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800e9c0:	f3ef 8310 	mrs	r3, PRIMASK
 800e9c4:	657b      	str	r3, [r7, #84]	; 0x54
  return(result);
 800e9c6:	6d7b      	ldr	r3, [r7, #84]	; 0x54

          ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 800e9c8:	66fb      	str	r3, [r7, #108]	; 0x6c
 800e9ca:	2301      	movs	r3, #1
 800e9cc:	65bb      	str	r3, [r7, #88]	; 0x58
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800e9ce:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800e9d0:	f383 8810 	msr	PRIMASK, r3
}
 800e9d4:	46c0      	nop			; (mov r8, r8)
 800e9d6:	687b      	ldr	r3, [r7, #4]
 800e9d8:	681b      	ldr	r3, [r3, #0]
 800e9da:	681a      	ldr	r2, [r3, #0]
 800e9dc:	687b      	ldr	r3, [r7, #4]
 800e9de:	681b      	ldr	r3, [r3, #0]
 800e9e0:	2110      	movs	r1, #16
 800e9e2:	438a      	bics	r2, r1
 800e9e4:	601a      	str	r2, [r3, #0]
 800e9e6:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800e9e8:	65fb      	str	r3, [r7, #92]	; 0x5c
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800e9ea:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800e9ec:	f383 8810 	msr	PRIMASK, r3
}
 800e9f0:	46c0      	nop			; (mov r8, r8)

          /* Last bytes received, so no need as the abort is immediate */
          (void)HAL_DMA_Abort(huart->hdmarx);
 800e9f2:	687b      	ldr	r3, [r7, #4]
 800e9f4:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800e9f6:	0018      	movs	r0, r3
 800e9f8:	f7fc fccc 	bl	800b394 <HAL_DMA_Abort>
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
        /*Call registered Rx Event callback*/
        huart->RxEventCallback(huart, (huart->RxXferSize - huart->RxXferCount));
#else
        /*Call legacy weak Rx Event callback*/
        HAL_UARTEx_RxEventCallback(huart, (huart->RxXferSize - huart->RxXferCount));
 800e9fc:	687b      	ldr	r3, [r7, #4]
 800e9fe:	2258      	movs	r2, #88	; 0x58
 800ea00:	5a9a      	ldrh	r2, [r3, r2]
 800ea02:	687b      	ldr	r3, [r7, #4]
 800ea04:	215a      	movs	r1, #90	; 0x5a
 800ea06:	5a5b      	ldrh	r3, [r3, r1]
 800ea08:	b29b      	uxth	r3, r3
 800ea0a:	1ad3      	subs	r3, r2, r3
 800ea0c:	b29a      	uxth	r2, r3
 800ea0e:	687b      	ldr	r3, [r7, #4]
 800ea10:	0011      	movs	r1, r2
 800ea12:	0018      	movs	r0, r3
 800ea14:	f000 f8e4 	bl	800ebe0 <HAL_UARTEx_RxEventCallback>
#endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
      }
      return;
 800ea18:	e0be      	b.n	800eb98 <HAL_UART_IRQHandler+0x598>
    else
    {
      /* DMA mode not enabled */
      /* Check received length : If all expected data are received, do nothing.
         Otherwise, if at least one data has already been received, IDLE event is to be notified to user */
      uint16_t nb_rx_data = huart->RxXferSize - huart->RxXferCount;
 800ea1a:	687b      	ldr	r3, [r7, #4]
 800ea1c:	2258      	movs	r2, #88	; 0x58
 800ea1e:	5a99      	ldrh	r1, [r3, r2]
 800ea20:	687b      	ldr	r3, [r7, #4]
 800ea22:	225a      	movs	r2, #90	; 0x5a
 800ea24:	5a9b      	ldrh	r3, [r3, r2]
 800ea26:	b29a      	uxth	r2, r3
 800ea28:	208e      	movs	r0, #142	; 0x8e
 800ea2a:	183b      	adds	r3, r7, r0
 800ea2c:	1a8a      	subs	r2, r1, r2
 800ea2e:	801a      	strh	r2, [r3, #0]
      if ((huart->RxXferCount > 0U)
 800ea30:	687b      	ldr	r3, [r7, #4]
 800ea32:	225a      	movs	r2, #90	; 0x5a
 800ea34:	5a9b      	ldrh	r3, [r3, r2]
 800ea36:	b29b      	uxth	r3, r3
 800ea38:	2b00      	cmp	r3, #0
 800ea3a:	d100      	bne.n	800ea3e <HAL_UART_IRQHandler+0x43e>
 800ea3c:	e0ae      	b.n	800eb9c <HAL_UART_IRQHandler+0x59c>
          && (nb_rx_data > 0U))
 800ea3e:	183b      	adds	r3, r7, r0
 800ea40:	881b      	ldrh	r3, [r3, #0]
 800ea42:	2b00      	cmp	r3, #0
 800ea44:	d100      	bne.n	800ea48 <HAL_UART_IRQHandler+0x448>
 800ea46:	e0a9      	b.n	800eb9c <HAL_UART_IRQHandler+0x59c>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800ea48:	f3ef 8310 	mrs	r3, PRIMASK
 800ea4c:	60fb      	str	r3, [r7, #12]
  return(result);
 800ea4e:	68fb      	ldr	r3, [r7, #12]
      {
        /* Disable the UART Parity Error Interrupt and RXNE interrupts */
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 800ea50:	2488      	movs	r4, #136	; 0x88
 800ea52:	193a      	adds	r2, r7, r4
 800ea54:	6013      	str	r3, [r2, #0]
 800ea56:	2301      	movs	r3, #1
 800ea58:	613b      	str	r3, [r7, #16]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800ea5a:	693b      	ldr	r3, [r7, #16]
 800ea5c:	f383 8810 	msr	PRIMASK, r3
}
 800ea60:	46c0      	nop			; (mov r8, r8)
 800ea62:	687b      	ldr	r3, [r7, #4]
 800ea64:	681b      	ldr	r3, [r3, #0]
 800ea66:	681a      	ldr	r2, [r3, #0]
 800ea68:	687b      	ldr	r3, [r7, #4]
 800ea6a:	681b      	ldr	r3, [r3, #0]
 800ea6c:	494f      	ldr	r1, [pc, #316]	; (800ebac <HAL_UART_IRQHandler+0x5ac>)
 800ea6e:	400a      	ands	r2, r1
 800ea70:	601a      	str	r2, [r3, #0]
 800ea72:	193b      	adds	r3, r7, r4
 800ea74:	681b      	ldr	r3, [r3, #0]
 800ea76:	617b      	str	r3, [r7, #20]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800ea78:	697b      	ldr	r3, [r7, #20]
 800ea7a:	f383 8810 	msr	PRIMASK, r3
}
 800ea7e:	46c0      	nop			; (mov r8, r8)
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800ea80:	f3ef 8310 	mrs	r3, PRIMASK
 800ea84:	61bb      	str	r3, [r7, #24]
  return(result);
 800ea86:	69bb      	ldr	r3, [r7, #24]

        /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
        ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800ea88:	2484      	movs	r4, #132	; 0x84
 800ea8a:	193a      	adds	r2, r7, r4
 800ea8c:	6013      	str	r3, [r2, #0]
 800ea8e:	2301      	movs	r3, #1
 800ea90:	61fb      	str	r3, [r7, #28]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800ea92:	69fb      	ldr	r3, [r7, #28]
 800ea94:	f383 8810 	msr	PRIMASK, r3
}
 800ea98:	46c0      	nop			; (mov r8, r8)
 800ea9a:	687b      	ldr	r3, [r7, #4]
 800ea9c:	681b      	ldr	r3, [r3, #0]
 800ea9e:	689a      	ldr	r2, [r3, #8]
 800eaa0:	687b      	ldr	r3, [r7, #4]
 800eaa2:	681b      	ldr	r3, [r3, #0]
 800eaa4:	2101      	movs	r1, #1
 800eaa6:	438a      	bics	r2, r1
 800eaa8:	609a      	str	r2, [r3, #8]
 800eaaa:	193b      	adds	r3, r7, r4
 800eaac:	681b      	ldr	r3, [r3, #0]
 800eaae:	623b      	str	r3, [r7, #32]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800eab0:	6a3b      	ldr	r3, [r7, #32]
 800eab2:	f383 8810 	msr	PRIMASK, r3
}
 800eab6:	46c0      	nop			; (mov r8, r8)

        /* Rx process is completed, restore huart->RxState to Ready */
        huart->RxState = HAL_UART_STATE_READY;
 800eab8:	687b      	ldr	r3, [r7, #4]
 800eaba:	2220      	movs	r2, #32
 800eabc:	67da      	str	r2, [r3, #124]	; 0x7c
        huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 800eabe:	687b      	ldr	r3, [r7, #4]
 800eac0:	2200      	movs	r2, #0
 800eac2:	661a      	str	r2, [r3, #96]	; 0x60

        /* Clear RxISR function pointer */
        huart->RxISR = NULL;
 800eac4:	687b      	ldr	r3, [r7, #4]
 800eac6:	2200      	movs	r2, #0
 800eac8:	665a      	str	r2, [r3, #100]	; 0x64
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800eaca:	f3ef 8310 	mrs	r3, PRIMASK
 800eace:	627b      	str	r3, [r7, #36]	; 0x24
  return(result);
 800ead0:	6a7b      	ldr	r3, [r7, #36]	; 0x24

        ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 800ead2:	2480      	movs	r4, #128	; 0x80
 800ead4:	193a      	adds	r2, r7, r4
 800ead6:	6013      	str	r3, [r2, #0]
 800ead8:	2301      	movs	r3, #1
 800eada:	62bb      	str	r3, [r7, #40]	; 0x28
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800eadc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800eade:	f383 8810 	msr	PRIMASK, r3
}
 800eae2:	46c0      	nop			; (mov r8, r8)
 800eae4:	687b      	ldr	r3, [r7, #4]
 800eae6:	681b      	ldr	r3, [r3, #0]
 800eae8:	681a      	ldr	r2, [r3, #0]
 800eaea:	687b      	ldr	r3, [r7, #4]
 800eaec:	681b      	ldr	r3, [r3, #0]
 800eaee:	2110      	movs	r1, #16
 800eaf0:	438a      	bics	r2, r1
 800eaf2:	601a      	str	r2, [r3, #0]
 800eaf4:	193b      	adds	r3, r7, r4
 800eaf6:	681b      	ldr	r3, [r3, #0]
 800eaf8:	62fb      	str	r3, [r7, #44]	; 0x2c
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800eafa:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800eafc:	f383 8810 	msr	PRIMASK, r3
}
 800eb00:	46c0      	nop			; (mov r8, r8)
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
        /*Call registered Rx complete callback*/
        huart->RxEventCallback(huart, nb_rx_data);
#else
        /*Call legacy weak Rx Event callback*/
        HAL_UARTEx_RxEventCallback(huart, nb_rx_data);
 800eb02:	183b      	adds	r3, r7, r0
 800eb04:	881a      	ldrh	r2, [r3, #0]
 800eb06:	687b      	ldr	r3, [r7, #4]
 800eb08:	0011      	movs	r1, r2
 800eb0a:	0018      	movs	r0, r3
 800eb0c:	f000 f868 	bl	800ebe0 <HAL_UARTEx_RxEventCallback>
#endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
      }
      return;
 800eb10:	e044      	b.n	800eb9c <HAL_UART_IRQHandler+0x59c>
  }
#if defined(USART_CR1_UESM)
#if defined(USART_CR3_WUFIE)

  /* UART wakeup from Stop mode interrupt occurred ---------------------------*/
  if (((isrflags & USART_ISR_WUF) != 0U) && ((cr3its & USART_CR3_WUFIE) != 0U))
 800eb12:	23a4      	movs	r3, #164	; 0xa4
 800eb14:	18fb      	adds	r3, r7, r3
 800eb16:	681a      	ldr	r2, [r3, #0]
 800eb18:	2380      	movs	r3, #128	; 0x80
 800eb1a:	035b      	lsls	r3, r3, #13
 800eb1c:	4013      	ands	r3, r2
 800eb1e:	d010      	beq.n	800eb42 <HAL_UART_IRQHandler+0x542>
 800eb20:	239c      	movs	r3, #156	; 0x9c
 800eb22:	18fb      	adds	r3, r7, r3
 800eb24:	681a      	ldr	r2, [r3, #0]
 800eb26:	2380      	movs	r3, #128	; 0x80
 800eb28:	03db      	lsls	r3, r3, #15
 800eb2a:	4013      	ands	r3, r2
 800eb2c:	d009      	beq.n	800eb42 <HAL_UART_IRQHandler+0x542>
  {
    __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_WUF);
 800eb2e:	687b      	ldr	r3, [r7, #4]
 800eb30:	681b      	ldr	r3, [r3, #0]
 800eb32:	2280      	movs	r2, #128	; 0x80
 800eb34:	0352      	lsls	r2, r2, #13
 800eb36:	621a      	str	r2, [r3, #32]
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
    /* Call registered Wakeup Callback */
    huart->WakeupCallback(huart);
#else
    /* Call legacy weak Wakeup Callback */
    HAL_UARTEx_WakeupCallback(huart);
 800eb38:	687b      	ldr	r3, [r7, #4]
 800eb3a:	0018      	movs	r0, r3
 800eb3c:	f000 ff2e 	bl	800f99c <HAL_UARTEx_WakeupCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
    return;
 800eb40:	e02f      	b.n	800eba2 <HAL_UART_IRQHandler+0x5a2>
  }
#endif /* USART_CR3_WUFIE */
#endif /* USART_CR1_UESM */

  /* UART in mode Transmitter ------------------------------------------------*/
  if (((isrflags & USART_ISR_TXE) != 0U)
 800eb42:	23a4      	movs	r3, #164	; 0xa4
 800eb44:	18fb      	adds	r3, r7, r3
 800eb46:	681b      	ldr	r3, [r3, #0]
 800eb48:	2280      	movs	r2, #128	; 0x80
 800eb4a:	4013      	ands	r3, r2
 800eb4c:	d00f      	beq.n	800eb6e <HAL_UART_IRQHandler+0x56e>
      && ((cr1its & USART_CR1_TXEIE) != 0U))
 800eb4e:	23a0      	movs	r3, #160	; 0xa0
 800eb50:	18fb      	adds	r3, r7, r3
 800eb52:	681b      	ldr	r3, [r3, #0]
 800eb54:	2280      	movs	r2, #128	; 0x80
 800eb56:	4013      	ands	r3, r2
 800eb58:	d009      	beq.n	800eb6e <HAL_UART_IRQHandler+0x56e>
  {
    if (huart->TxISR != NULL)
 800eb5a:	687b      	ldr	r3, [r7, #4]
 800eb5c:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 800eb5e:	2b00      	cmp	r3, #0
 800eb60:	d01e      	beq.n	800eba0 <HAL_UART_IRQHandler+0x5a0>
    {
      huart->TxISR(huart);
 800eb62:	687b      	ldr	r3, [r7, #4]
 800eb64:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 800eb66:	687a      	ldr	r2, [r7, #4]
 800eb68:	0010      	movs	r0, r2
 800eb6a:	4798      	blx	r3
    }
    return;
 800eb6c:	e018      	b.n	800eba0 <HAL_UART_IRQHandler+0x5a0>
  }

  /* UART in mode Transmitter (transmission end) -----------------------------*/
  if (((isrflags & USART_ISR_TC) != 0U) && ((cr1its & USART_CR1_TCIE) != 0U))
 800eb6e:	23a4      	movs	r3, #164	; 0xa4
 800eb70:	18fb      	adds	r3, r7, r3
 800eb72:	681b      	ldr	r3, [r3, #0]
 800eb74:	2240      	movs	r2, #64	; 0x40
 800eb76:	4013      	ands	r3, r2
 800eb78:	d013      	beq.n	800eba2 <HAL_UART_IRQHandler+0x5a2>
 800eb7a:	23a0      	movs	r3, #160	; 0xa0
 800eb7c:	18fb      	adds	r3, r7, r3
 800eb7e:	681b      	ldr	r3, [r3, #0]
 800eb80:	2240      	movs	r2, #64	; 0x40
 800eb82:	4013      	ands	r3, r2
 800eb84:	d00d      	beq.n	800eba2 <HAL_UART_IRQHandler+0x5a2>
  {
    UART_EndTransmit_IT(huart);
 800eb86:	687b      	ldr	r3, [r7, #4]
 800eb88:	0018      	movs	r0, r3
 800eb8a:	f000 fd5e 	bl	800f64a <UART_EndTransmit_IT>
    return;
 800eb8e:	e008      	b.n	800eba2 <HAL_UART_IRQHandler+0x5a2>
      return;
 800eb90:	46c0      	nop			; (mov r8, r8)
 800eb92:	e006      	b.n	800eba2 <HAL_UART_IRQHandler+0x5a2>
    return;
 800eb94:	46c0      	nop			; (mov r8, r8)
 800eb96:	e004      	b.n	800eba2 <HAL_UART_IRQHandler+0x5a2>
      return;
 800eb98:	46c0      	nop			; (mov r8, r8)
 800eb9a:	e002      	b.n	800eba2 <HAL_UART_IRQHandler+0x5a2>
      return;
 800eb9c:	46c0      	nop			; (mov r8, r8)
 800eb9e:	e000      	b.n	800eba2 <HAL_UART_IRQHandler+0x5a2>
    return;
 800eba0:	46c0      	nop			; (mov r8, r8)
  }

}
 800eba2:	46bd      	mov	sp, r7
 800eba4:	b02b      	add	sp, #172	; 0xac
 800eba6:	bd90      	pop	{r4, r7, pc}
 800eba8:	fffffeff 	.word	0xfffffeff
 800ebac:	fffffedf 	.word	0xfffffedf

0800ebb0 <HAL_UART_TxCpltCallback>:
  * @brief Tx Transfer completed callback.
  * @param huart UART handle.
  * @retval None
  */
__weak void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)
{
 800ebb0:	b580      	push	{r7, lr}
 800ebb2:	b082      	sub	sp, #8
 800ebb4:	af00      	add	r7, sp, #0
 800ebb6:	6078      	str	r0, [r7, #4]
  UNUSED(huart);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_UART_TxCpltCallback can be implemented in the user file.
   */
}
 800ebb8:	46c0      	nop			; (mov r8, r8)
 800ebba:	46bd      	mov	sp, r7
 800ebbc:	b002      	add	sp, #8
 800ebbe:	bd80      	pop	{r7, pc}

0800ebc0 <HAL_UART_RxCpltCallback>:
  * @brief  Rx Transfer completed callback.
  * @param  huart UART handle.
  * @retval None
  */
__weak void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
 800ebc0:	b580      	push	{r7, lr}
 800ebc2:	b082      	sub	sp, #8
 800ebc4:	af00      	add	r7, sp, #0
 800ebc6:	6078      	str	r0, [r7, #4]
  UNUSED(huart);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_UART_RxCpltCallback can be implemented in the user file.
   */
}
 800ebc8:	46c0      	nop			; (mov r8, r8)
 800ebca:	46bd      	mov	sp, r7
 800ebcc:	b002      	add	sp, #8
 800ebce:	bd80      	pop	{r7, pc}

0800ebd0 <HAL_UART_ErrorCallback>:
  * @brief  UART error callback.
  * @param  huart UART handle.
  * @retval None
  */
__weak void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart)
{
 800ebd0:	b580      	push	{r7, lr}
 800ebd2:	b082      	sub	sp, #8
 800ebd4:	af00      	add	r7, sp, #0
 800ebd6:	6078      	str	r0, [r7, #4]
  UNUSED(huart);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_UART_ErrorCallback can be implemented in the user file.
   */
}
 800ebd8:	46c0      	nop			; (mov r8, r8)
 800ebda:	46bd      	mov	sp, r7
 800ebdc:	b002      	add	sp, #8
 800ebde:	bd80      	pop	{r7, pc}

0800ebe0 <HAL_UARTEx_RxEventCallback>:
  * @param  Size  Number of data available in application reception buffer (indicates a position in
  *               reception buffer until which, data are available)
  * @retval None
  */
__weak void HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t Size)
{
 800ebe0:	b580      	push	{r7, lr}
 800ebe2:	b082      	sub	sp, #8
 800ebe4:	af00      	add	r7, sp, #0
 800ebe6:	6078      	str	r0, [r7, #4]
 800ebe8:	000a      	movs	r2, r1
 800ebea:	1cbb      	adds	r3, r7, #2
 800ebec:	801a      	strh	r2, [r3, #0]
  UNUSED(Size);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_UARTEx_RxEventCallback can be implemented in the user file.
   */
}
 800ebee:	46c0      	nop			; (mov r8, r8)
 800ebf0:	46bd      	mov	sp, r7
 800ebf2:	b002      	add	sp, #8
 800ebf4:	bd80      	pop	{r7, pc}
	...

0800ebf8 <UART_SetConfig>:
  * @brief Configure the UART peripheral.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_SetConfig(UART_HandleTypeDef *huart)
{
 800ebf8:	b580      	push	{r7, lr}
 800ebfa:	b088      	sub	sp, #32
 800ebfc:	af00      	add	r7, sp, #0
 800ebfe:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg;
  uint16_t brrtemp;
  UART_ClockSourceTypeDef clocksource;
  uint32_t usartdiv;
  HAL_StatusTypeDef ret               = HAL_OK;
 800ec00:	231e      	movs	r3, #30
 800ec02:	18fb      	adds	r3, r7, r3
 800ec04:	2200      	movs	r2, #0
 800ec06:	701a      	strb	r2, [r3, #0]
  *  the UART Word Length, Parity, Mode and oversampling:
  *  set the M bits according to huart->Init.WordLength value
  *  set PCE and PS bits according to huart->Init.Parity value
  *  set TE and RE bits according to huart->Init.Mode value
  *  set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 800ec08:	687b      	ldr	r3, [r7, #4]
 800ec0a:	689a      	ldr	r2, [r3, #8]
 800ec0c:	687b      	ldr	r3, [r7, #4]
 800ec0e:	691b      	ldr	r3, [r3, #16]
 800ec10:	431a      	orrs	r2, r3
 800ec12:	687b      	ldr	r3, [r7, #4]
 800ec14:	695b      	ldr	r3, [r3, #20]
 800ec16:	431a      	orrs	r2, r3
 800ec18:	687b      	ldr	r3, [r7, #4]
 800ec1a:	69db      	ldr	r3, [r3, #28]
 800ec1c:	4313      	orrs	r3, r2
 800ec1e:	617b      	str	r3, [r7, #20]
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 800ec20:	687b      	ldr	r3, [r7, #4]
 800ec22:	681b      	ldr	r3, [r3, #0]
 800ec24:	681b      	ldr	r3, [r3, #0]
 800ec26:	4aaf      	ldr	r2, [pc, #700]	; (800eee4 <UART_SetConfig+0x2ec>)
 800ec28:	4013      	ands	r3, r2
 800ec2a:	0019      	movs	r1, r3
 800ec2c:	687b      	ldr	r3, [r7, #4]
 800ec2e:	681b      	ldr	r3, [r3, #0]
 800ec30:	697a      	ldr	r2, [r7, #20]
 800ec32:	430a      	orrs	r2, r1
 800ec34:	601a      	str	r2, [r3, #0]

  /*-------------------------- USART CR2 Configuration -----------------------*/
  /* Configure the UART Stop Bits: Set STOP[13:12] bits according
  * to huart->Init.StopBits value */
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 800ec36:	687b      	ldr	r3, [r7, #4]
 800ec38:	681b      	ldr	r3, [r3, #0]
 800ec3a:	685b      	ldr	r3, [r3, #4]
 800ec3c:	4aaa      	ldr	r2, [pc, #680]	; (800eee8 <UART_SetConfig+0x2f0>)
 800ec3e:	4013      	ands	r3, r2
 800ec40:	0019      	movs	r1, r3
 800ec42:	687b      	ldr	r3, [r7, #4]
 800ec44:	68da      	ldr	r2, [r3, #12]
 800ec46:	687b      	ldr	r3, [r7, #4]
 800ec48:	681b      	ldr	r3, [r3, #0]
 800ec4a:	430a      	orrs	r2, r1
 800ec4c:	605a      	str	r2, [r3, #4]
  /* Configure
  * - UART HardWare Flow Control: set CTSE and RTSE bits according
  *   to huart->Init.HwFlowCtl value
  * - one-bit sampling method versus three samples' majority rule according
  *   to huart->Init.OneBitSampling (not applicable to LPUART) */
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;
 800ec4e:	687b      	ldr	r3, [r7, #4]
 800ec50:	699b      	ldr	r3, [r3, #24]
 800ec52:	617b      	str	r3, [r7, #20]

  tmpreg |= huart->Init.OneBitSampling;
 800ec54:	687b      	ldr	r3, [r7, #4]
 800ec56:	6a1b      	ldr	r3, [r3, #32]
 800ec58:	697a      	ldr	r2, [r7, #20]
 800ec5a:	4313      	orrs	r3, r2
 800ec5c:	617b      	str	r3, [r7, #20]
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 800ec5e:	687b      	ldr	r3, [r7, #4]
 800ec60:	681b      	ldr	r3, [r3, #0]
 800ec62:	689b      	ldr	r3, [r3, #8]
 800ec64:	4aa1      	ldr	r2, [pc, #644]	; (800eeec <UART_SetConfig+0x2f4>)
 800ec66:	4013      	ands	r3, r2
 800ec68:	0019      	movs	r1, r3
 800ec6a:	687b      	ldr	r3, [r7, #4]
 800ec6c:	681b      	ldr	r3, [r3, #0]
 800ec6e:	697a      	ldr	r2, [r7, #20]
 800ec70:	430a      	orrs	r2, r1
 800ec72:	609a      	str	r2, [r3, #8]


  /*-------------------------- USART BRR Configuration -----------------------*/
  UART_GETCLOCKSOURCE(huart, clocksource);
 800ec74:	687b      	ldr	r3, [r7, #4]
 800ec76:	681b      	ldr	r3, [r3, #0]
 800ec78:	4a9d      	ldr	r2, [pc, #628]	; (800eef0 <UART_SetConfig+0x2f8>)
 800ec7a:	4293      	cmp	r3, r2
 800ec7c:	d127      	bne.n	800ecce <UART_SetConfig+0xd6>
 800ec7e:	4b9d      	ldr	r3, [pc, #628]	; (800eef4 <UART_SetConfig+0x2fc>)
 800ec80:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800ec82:	2203      	movs	r2, #3
 800ec84:	4013      	ands	r3, r2
 800ec86:	2b03      	cmp	r3, #3
 800ec88:	d00d      	beq.n	800eca6 <UART_SetConfig+0xae>
 800ec8a:	d81b      	bhi.n	800ecc4 <UART_SetConfig+0xcc>
 800ec8c:	2b02      	cmp	r3, #2
 800ec8e:	d014      	beq.n	800ecba <UART_SetConfig+0xc2>
 800ec90:	d818      	bhi.n	800ecc4 <UART_SetConfig+0xcc>
 800ec92:	2b00      	cmp	r3, #0
 800ec94:	d002      	beq.n	800ec9c <UART_SetConfig+0xa4>
 800ec96:	2b01      	cmp	r3, #1
 800ec98:	d00a      	beq.n	800ecb0 <UART_SetConfig+0xb8>
 800ec9a:	e013      	b.n	800ecc4 <UART_SetConfig+0xcc>
 800ec9c:	231f      	movs	r3, #31
 800ec9e:	18fb      	adds	r3, r7, r3
 800eca0:	2200      	movs	r2, #0
 800eca2:	701a      	strb	r2, [r3, #0]
 800eca4:	e065      	b.n	800ed72 <UART_SetConfig+0x17a>
 800eca6:	231f      	movs	r3, #31
 800eca8:	18fb      	adds	r3, r7, r3
 800ecaa:	2202      	movs	r2, #2
 800ecac:	701a      	strb	r2, [r3, #0]
 800ecae:	e060      	b.n	800ed72 <UART_SetConfig+0x17a>
 800ecb0:	231f      	movs	r3, #31
 800ecb2:	18fb      	adds	r3, r7, r3
 800ecb4:	2204      	movs	r2, #4
 800ecb6:	701a      	strb	r2, [r3, #0]
 800ecb8:	e05b      	b.n	800ed72 <UART_SetConfig+0x17a>
 800ecba:	231f      	movs	r3, #31
 800ecbc:	18fb      	adds	r3, r7, r3
 800ecbe:	2208      	movs	r2, #8
 800ecc0:	701a      	strb	r2, [r3, #0]
 800ecc2:	e056      	b.n	800ed72 <UART_SetConfig+0x17a>
 800ecc4:	231f      	movs	r3, #31
 800ecc6:	18fb      	adds	r3, r7, r3
 800ecc8:	2210      	movs	r2, #16
 800ecca:	701a      	strb	r2, [r3, #0]
 800eccc:	e051      	b.n	800ed72 <UART_SetConfig+0x17a>
 800ecce:	687b      	ldr	r3, [r7, #4]
 800ecd0:	681b      	ldr	r3, [r3, #0]
 800ecd2:	4a89      	ldr	r2, [pc, #548]	; (800eef8 <UART_SetConfig+0x300>)
 800ecd4:	4293      	cmp	r3, r2
 800ecd6:	d134      	bne.n	800ed42 <UART_SetConfig+0x14a>
 800ecd8:	4b86      	ldr	r3, [pc, #536]	; (800eef4 <UART_SetConfig+0x2fc>)
 800ecda:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800ecdc:	23c0      	movs	r3, #192	; 0xc0
 800ecde:	029b      	lsls	r3, r3, #10
 800ece0:	4013      	ands	r3, r2
 800ece2:	22c0      	movs	r2, #192	; 0xc0
 800ece4:	0292      	lsls	r2, r2, #10
 800ece6:	4293      	cmp	r3, r2
 800ece8:	d017      	beq.n	800ed1a <UART_SetConfig+0x122>
 800ecea:	22c0      	movs	r2, #192	; 0xc0
 800ecec:	0292      	lsls	r2, r2, #10
 800ecee:	4293      	cmp	r3, r2
 800ecf0:	d822      	bhi.n	800ed38 <UART_SetConfig+0x140>
 800ecf2:	2280      	movs	r2, #128	; 0x80
 800ecf4:	0292      	lsls	r2, r2, #10
 800ecf6:	4293      	cmp	r3, r2
 800ecf8:	d019      	beq.n	800ed2e <UART_SetConfig+0x136>
 800ecfa:	2280      	movs	r2, #128	; 0x80
 800ecfc:	0292      	lsls	r2, r2, #10
 800ecfe:	4293      	cmp	r3, r2
 800ed00:	d81a      	bhi.n	800ed38 <UART_SetConfig+0x140>
 800ed02:	2b00      	cmp	r3, #0
 800ed04:	d004      	beq.n	800ed10 <UART_SetConfig+0x118>
 800ed06:	2280      	movs	r2, #128	; 0x80
 800ed08:	0252      	lsls	r2, r2, #9
 800ed0a:	4293      	cmp	r3, r2
 800ed0c:	d00a      	beq.n	800ed24 <UART_SetConfig+0x12c>
 800ed0e:	e013      	b.n	800ed38 <UART_SetConfig+0x140>
 800ed10:	231f      	movs	r3, #31
 800ed12:	18fb      	adds	r3, r7, r3
 800ed14:	2200      	movs	r2, #0
 800ed16:	701a      	strb	r2, [r3, #0]
 800ed18:	e02b      	b.n	800ed72 <UART_SetConfig+0x17a>
 800ed1a:	231f      	movs	r3, #31
 800ed1c:	18fb      	adds	r3, r7, r3
 800ed1e:	2202      	movs	r2, #2
 800ed20:	701a      	strb	r2, [r3, #0]
 800ed22:	e026      	b.n	800ed72 <UART_SetConfig+0x17a>
 800ed24:	231f      	movs	r3, #31
 800ed26:	18fb      	adds	r3, r7, r3
 800ed28:	2204      	movs	r2, #4
 800ed2a:	701a      	strb	r2, [r3, #0]
 800ed2c:	e021      	b.n	800ed72 <UART_SetConfig+0x17a>
 800ed2e:	231f      	movs	r3, #31
 800ed30:	18fb      	adds	r3, r7, r3
 800ed32:	2208      	movs	r2, #8
 800ed34:	701a      	strb	r2, [r3, #0]
 800ed36:	e01c      	b.n	800ed72 <UART_SetConfig+0x17a>
 800ed38:	231f      	movs	r3, #31
 800ed3a:	18fb      	adds	r3, r7, r3
 800ed3c:	2210      	movs	r2, #16
 800ed3e:	701a      	strb	r2, [r3, #0]
 800ed40:	e017      	b.n	800ed72 <UART_SetConfig+0x17a>
 800ed42:	687b      	ldr	r3, [r7, #4]
 800ed44:	681b      	ldr	r3, [r3, #0]
 800ed46:	4a6d      	ldr	r2, [pc, #436]	; (800eefc <UART_SetConfig+0x304>)
 800ed48:	4293      	cmp	r3, r2
 800ed4a:	d104      	bne.n	800ed56 <UART_SetConfig+0x15e>
 800ed4c:	231f      	movs	r3, #31
 800ed4e:	18fb      	adds	r3, r7, r3
 800ed50:	2200      	movs	r2, #0
 800ed52:	701a      	strb	r2, [r3, #0]
 800ed54:	e00d      	b.n	800ed72 <UART_SetConfig+0x17a>
 800ed56:	687b      	ldr	r3, [r7, #4]
 800ed58:	681b      	ldr	r3, [r3, #0]
 800ed5a:	4a69      	ldr	r2, [pc, #420]	; (800ef00 <UART_SetConfig+0x308>)
 800ed5c:	4293      	cmp	r3, r2
 800ed5e:	d104      	bne.n	800ed6a <UART_SetConfig+0x172>
 800ed60:	231f      	movs	r3, #31
 800ed62:	18fb      	adds	r3, r7, r3
 800ed64:	2200      	movs	r2, #0
 800ed66:	701a      	strb	r2, [r3, #0]
 800ed68:	e003      	b.n	800ed72 <UART_SetConfig+0x17a>
 800ed6a:	231f      	movs	r3, #31
 800ed6c:	18fb      	adds	r3, r7, r3
 800ed6e:	2210      	movs	r2, #16
 800ed70:	701a      	strb	r2, [r3, #0]

  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 800ed72:	687b      	ldr	r3, [r7, #4]
 800ed74:	69da      	ldr	r2, [r3, #28]
 800ed76:	2380      	movs	r3, #128	; 0x80
 800ed78:	021b      	lsls	r3, r3, #8
 800ed7a:	429a      	cmp	r2, r3
 800ed7c:	d15d      	bne.n	800ee3a <UART_SetConfig+0x242>
  {
    switch (clocksource)
 800ed7e:	231f      	movs	r3, #31
 800ed80:	18fb      	adds	r3, r7, r3
 800ed82:	781b      	ldrb	r3, [r3, #0]
 800ed84:	2b08      	cmp	r3, #8
 800ed86:	d015      	beq.n	800edb4 <UART_SetConfig+0x1bc>
 800ed88:	dc18      	bgt.n	800edbc <UART_SetConfig+0x1c4>
 800ed8a:	2b04      	cmp	r3, #4
 800ed8c:	d00d      	beq.n	800edaa <UART_SetConfig+0x1b2>
 800ed8e:	dc15      	bgt.n	800edbc <UART_SetConfig+0x1c4>
 800ed90:	2b00      	cmp	r3, #0
 800ed92:	d002      	beq.n	800ed9a <UART_SetConfig+0x1a2>
 800ed94:	2b02      	cmp	r3, #2
 800ed96:	d005      	beq.n	800eda4 <UART_SetConfig+0x1ac>
 800ed98:	e010      	b.n	800edbc <UART_SetConfig+0x1c4>
    {
      case UART_CLOCKSOURCE_PCLK1:
        pclk = HAL_RCC_GetPCLK1Freq();
 800ed9a:	f7ff f885 	bl	800dea8 <HAL_RCC_GetPCLK1Freq>
 800ed9e:	0003      	movs	r3, r0
 800eda0:	61bb      	str	r3, [r7, #24]
        break;
 800eda2:	e012      	b.n	800edca <UART_SetConfig+0x1d2>
      case UART_CLOCKSOURCE_HSI:
        pclk = (uint32_t) HSI_VALUE;
 800eda4:	4b57      	ldr	r3, [pc, #348]	; (800ef04 <UART_SetConfig+0x30c>)
 800eda6:	61bb      	str	r3, [r7, #24]
        break;
 800eda8:	e00f      	b.n	800edca <UART_SetConfig+0x1d2>
      case UART_CLOCKSOURCE_SYSCLK:
        pclk = HAL_RCC_GetSysClockFreq();
 800edaa:	f7fe fff3 	bl	800dd94 <HAL_RCC_GetSysClockFreq>
 800edae:	0003      	movs	r3, r0
 800edb0:	61bb      	str	r3, [r7, #24]
        break;
 800edb2:	e00a      	b.n	800edca <UART_SetConfig+0x1d2>
      case UART_CLOCKSOURCE_LSE:
        pclk = (uint32_t) LSE_VALUE;
 800edb4:	2380      	movs	r3, #128	; 0x80
 800edb6:	021b      	lsls	r3, r3, #8
 800edb8:	61bb      	str	r3, [r7, #24]
        break;
 800edba:	e006      	b.n	800edca <UART_SetConfig+0x1d2>
      default:
        pclk = 0U;
 800edbc:	2300      	movs	r3, #0
 800edbe:	61bb      	str	r3, [r7, #24]
        ret = HAL_ERROR;
 800edc0:	231e      	movs	r3, #30
 800edc2:	18fb      	adds	r3, r7, r3
 800edc4:	2201      	movs	r2, #1
 800edc6:	701a      	strb	r2, [r3, #0]
        break;
 800edc8:	46c0      	nop			; (mov r8, r8)
    }

    /* USARTDIV must be greater than or equal to 0d16 */
    if (pclk != 0U)
 800edca:	69bb      	ldr	r3, [r7, #24]
 800edcc:	2b00      	cmp	r3, #0
 800edce:	d100      	bne.n	800edd2 <UART_SetConfig+0x1da>
 800edd0:	e07b      	b.n	800eeca <UART_SetConfig+0x2d2>
    {
      usartdiv = (uint16_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate));
 800edd2:	69bb      	ldr	r3, [r7, #24]
 800edd4:	005a      	lsls	r2, r3, #1
 800edd6:	687b      	ldr	r3, [r7, #4]
 800edd8:	685b      	ldr	r3, [r3, #4]
 800edda:	085b      	lsrs	r3, r3, #1
 800eddc:	18d2      	adds	r2, r2, r3
 800edde:	687b      	ldr	r3, [r7, #4]
 800ede0:	685b      	ldr	r3, [r3, #4]
 800ede2:	0019      	movs	r1, r3
 800ede4:	0010      	movs	r0, r2
 800ede6:	f7fa f9a1 	bl	800912c <__udivsi3>
 800edea:	0003      	movs	r3, r0
 800edec:	b29b      	uxth	r3, r3
 800edee:	613b      	str	r3, [r7, #16]
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 800edf0:	693b      	ldr	r3, [r7, #16]
 800edf2:	2b0f      	cmp	r3, #15
 800edf4:	d91c      	bls.n	800ee30 <UART_SetConfig+0x238>
 800edf6:	693a      	ldr	r2, [r7, #16]
 800edf8:	2380      	movs	r3, #128	; 0x80
 800edfa:	025b      	lsls	r3, r3, #9
 800edfc:	429a      	cmp	r2, r3
 800edfe:	d217      	bcs.n	800ee30 <UART_SetConfig+0x238>
      {
        brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
 800ee00:	693b      	ldr	r3, [r7, #16]
 800ee02:	b29a      	uxth	r2, r3
 800ee04:	200e      	movs	r0, #14
 800ee06:	183b      	adds	r3, r7, r0
 800ee08:	210f      	movs	r1, #15
 800ee0a:	438a      	bics	r2, r1
 800ee0c:	801a      	strh	r2, [r3, #0]
        brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
 800ee0e:	693b      	ldr	r3, [r7, #16]
 800ee10:	085b      	lsrs	r3, r3, #1
 800ee12:	b29b      	uxth	r3, r3
 800ee14:	2207      	movs	r2, #7
 800ee16:	4013      	ands	r3, r2
 800ee18:	b299      	uxth	r1, r3
 800ee1a:	183b      	adds	r3, r7, r0
 800ee1c:	183a      	adds	r2, r7, r0
 800ee1e:	8812      	ldrh	r2, [r2, #0]
 800ee20:	430a      	orrs	r2, r1
 800ee22:	801a      	strh	r2, [r3, #0]
        huart->Instance->BRR = brrtemp;
 800ee24:	687b      	ldr	r3, [r7, #4]
 800ee26:	681b      	ldr	r3, [r3, #0]
 800ee28:	183a      	adds	r2, r7, r0
 800ee2a:	8812      	ldrh	r2, [r2, #0]
 800ee2c:	60da      	str	r2, [r3, #12]
 800ee2e:	e04c      	b.n	800eeca <UART_SetConfig+0x2d2>
      }
      else
      {
        ret = HAL_ERROR;
 800ee30:	231e      	movs	r3, #30
 800ee32:	18fb      	adds	r3, r7, r3
 800ee34:	2201      	movs	r2, #1
 800ee36:	701a      	strb	r2, [r3, #0]
 800ee38:	e047      	b.n	800eeca <UART_SetConfig+0x2d2>
      }
    }
  }
  else
  {
    switch (clocksource)
 800ee3a:	231f      	movs	r3, #31
 800ee3c:	18fb      	adds	r3, r7, r3
 800ee3e:	781b      	ldrb	r3, [r3, #0]
 800ee40:	2b08      	cmp	r3, #8
 800ee42:	d015      	beq.n	800ee70 <UART_SetConfig+0x278>
 800ee44:	dc18      	bgt.n	800ee78 <UART_SetConfig+0x280>
 800ee46:	2b04      	cmp	r3, #4
 800ee48:	d00d      	beq.n	800ee66 <UART_SetConfig+0x26e>
 800ee4a:	dc15      	bgt.n	800ee78 <UART_SetConfig+0x280>
 800ee4c:	2b00      	cmp	r3, #0
 800ee4e:	d002      	beq.n	800ee56 <UART_SetConfig+0x25e>
 800ee50:	2b02      	cmp	r3, #2
 800ee52:	d005      	beq.n	800ee60 <UART_SetConfig+0x268>
 800ee54:	e010      	b.n	800ee78 <UART_SetConfig+0x280>
    {
      case UART_CLOCKSOURCE_PCLK1:
        pclk = HAL_RCC_GetPCLK1Freq();
 800ee56:	f7ff f827 	bl	800dea8 <HAL_RCC_GetPCLK1Freq>
 800ee5a:	0003      	movs	r3, r0
 800ee5c:	61bb      	str	r3, [r7, #24]
        break;
 800ee5e:	e012      	b.n	800ee86 <UART_SetConfig+0x28e>
      case UART_CLOCKSOURCE_HSI:
        pclk = (uint32_t) HSI_VALUE;
 800ee60:	4b28      	ldr	r3, [pc, #160]	; (800ef04 <UART_SetConfig+0x30c>)
 800ee62:	61bb      	str	r3, [r7, #24]
        break;
 800ee64:	e00f      	b.n	800ee86 <UART_SetConfig+0x28e>
      case UART_CLOCKSOURCE_SYSCLK:
        pclk = HAL_RCC_GetSysClockFreq();
 800ee66:	f7fe ff95 	bl	800dd94 <HAL_RCC_GetSysClockFreq>
 800ee6a:	0003      	movs	r3, r0
 800ee6c:	61bb      	str	r3, [r7, #24]
        break;
 800ee6e:	e00a      	b.n	800ee86 <UART_SetConfig+0x28e>
      case UART_CLOCKSOURCE_LSE:
        pclk = (uint32_t) LSE_VALUE;
 800ee70:	2380      	movs	r3, #128	; 0x80
 800ee72:	021b      	lsls	r3, r3, #8
 800ee74:	61bb      	str	r3, [r7, #24]
        break;
 800ee76:	e006      	b.n	800ee86 <UART_SetConfig+0x28e>
      default:
        pclk = 0U;
 800ee78:	2300      	movs	r3, #0
 800ee7a:	61bb      	str	r3, [r7, #24]
        ret = HAL_ERROR;
 800ee7c:	231e      	movs	r3, #30
 800ee7e:	18fb      	adds	r3, r7, r3
 800ee80:	2201      	movs	r2, #1
 800ee82:	701a      	strb	r2, [r3, #0]
        break;
 800ee84:	46c0      	nop			; (mov r8, r8)
    }

    if (pclk != 0U)
 800ee86:	69bb      	ldr	r3, [r7, #24]
 800ee88:	2b00      	cmp	r3, #0
 800ee8a:	d01e      	beq.n	800eeca <UART_SetConfig+0x2d2>
    {
      /* USARTDIV must be greater than or equal to 0d16 */
      usartdiv = (uint16_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate));
 800ee8c:	687b      	ldr	r3, [r7, #4]
 800ee8e:	685b      	ldr	r3, [r3, #4]
 800ee90:	085a      	lsrs	r2, r3, #1
 800ee92:	69bb      	ldr	r3, [r7, #24]
 800ee94:	18d2      	adds	r2, r2, r3
 800ee96:	687b      	ldr	r3, [r7, #4]
 800ee98:	685b      	ldr	r3, [r3, #4]
 800ee9a:	0019      	movs	r1, r3
 800ee9c:	0010      	movs	r0, r2
 800ee9e:	f7fa f945 	bl	800912c <__udivsi3>
 800eea2:	0003      	movs	r3, r0
 800eea4:	b29b      	uxth	r3, r3
 800eea6:	613b      	str	r3, [r7, #16]
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 800eea8:	693b      	ldr	r3, [r7, #16]
 800eeaa:	2b0f      	cmp	r3, #15
 800eeac:	d909      	bls.n	800eec2 <UART_SetConfig+0x2ca>
 800eeae:	693a      	ldr	r2, [r7, #16]
 800eeb0:	2380      	movs	r3, #128	; 0x80
 800eeb2:	025b      	lsls	r3, r3, #9
 800eeb4:	429a      	cmp	r2, r3
 800eeb6:	d204      	bcs.n	800eec2 <UART_SetConfig+0x2ca>
      {
        huart->Instance->BRR = usartdiv;
 800eeb8:	687b      	ldr	r3, [r7, #4]
 800eeba:	681b      	ldr	r3, [r3, #0]
 800eebc:	693a      	ldr	r2, [r7, #16]
 800eebe:	60da      	str	r2, [r3, #12]
 800eec0:	e003      	b.n	800eeca <UART_SetConfig+0x2d2>
      }
      else
      {
        ret = HAL_ERROR;
 800eec2:	231e      	movs	r3, #30
 800eec4:	18fb      	adds	r3, r7, r3
 800eec6:	2201      	movs	r2, #1
 800eec8:	701a      	strb	r2, [r3, #0]
    }
  }


  /* Clear ISR function pointers */
  huart->RxISR = NULL;
 800eeca:	687b      	ldr	r3, [r7, #4]
 800eecc:	2200      	movs	r2, #0
 800eece:	665a      	str	r2, [r3, #100]	; 0x64
  huart->TxISR = NULL;
 800eed0:	687b      	ldr	r3, [r7, #4]
 800eed2:	2200      	movs	r2, #0
 800eed4:	669a      	str	r2, [r3, #104]	; 0x68

  return ret;
 800eed6:	231e      	movs	r3, #30
 800eed8:	18fb      	adds	r3, r7, r3
 800eeda:	781b      	ldrb	r3, [r3, #0]
}
 800eedc:	0018      	movs	r0, r3
 800eede:	46bd      	mov	sp, r7
 800eee0:	b008      	add	sp, #32
 800eee2:	bd80      	pop	{r7, pc}
 800eee4:	efff69f3 	.word	0xefff69f3
 800eee8:	ffffcfff 	.word	0xffffcfff
 800eeec:	fffff4ff 	.word	0xfffff4ff
 800eef0:	40013800 	.word	0x40013800
 800eef4:	40021000 	.word	0x40021000
 800eef8:	40004400 	.word	0x40004400
 800eefc:	40004800 	.word	0x40004800
 800ef00:	40004c00 	.word	0x40004c00
 800ef04:	007a1200 	.word	0x007a1200

0800ef08 <UART_AdvFeatureConfig>:
  * @brief Configure the UART peripheral advanced features.
  * @param huart UART handle.
  * @retval None
  */
void UART_AdvFeatureConfig(UART_HandleTypeDef *huart)
{
 800ef08:	b580      	push	{r7, lr}
 800ef0a:	b082      	sub	sp, #8
 800ef0c:	af00      	add	r7, sp, #0
 800ef0e:	6078      	str	r0, [r7, #4]
  /* Check whether the set of advanced features to configure is properly set */
  assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));

  /* if required, configure TX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 800ef10:	687b      	ldr	r3, [r7, #4]
 800ef12:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800ef14:	2201      	movs	r2, #1
 800ef16:	4013      	ands	r3, r2
 800ef18:	d00b      	beq.n	800ef32 <UART_AdvFeatureConfig+0x2a>
  {
    assert_param(IS_UART_ADVFEATURE_TXINV(huart->AdvancedInit.TxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
 800ef1a:	687b      	ldr	r3, [r7, #4]
 800ef1c:	681b      	ldr	r3, [r3, #0]
 800ef1e:	685b      	ldr	r3, [r3, #4]
 800ef20:	4a4a      	ldr	r2, [pc, #296]	; (800f04c <UART_AdvFeatureConfig+0x144>)
 800ef22:	4013      	ands	r3, r2
 800ef24:	0019      	movs	r1, r3
 800ef26:	687b      	ldr	r3, [r7, #4]
 800ef28:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800ef2a:	687b      	ldr	r3, [r7, #4]
 800ef2c:	681b      	ldr	r3, [r3, #0]
 800ef2e:	430a      	orrs	r2, r1
 800ef30:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure RX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
 800ef32:	687b      	ldr	r3, [r7, #4]
 800ef34:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800ef36:	2202      	movs	r2, #2
 800ef38:	4013      	ands	r3, r2
 800ef3a:	d00b      	beq.n	800ef54 <UART_AdvFeatureConfig+0x4c>
  {
    assert_param(IS_UART_ADVFEATURE_RXINV(huart->AdvancedInit.RxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
 800ef3c:	687b      	ldr	r3, [r7, #4]
 800ef3e:	681b      	ldr	r3, [r3, #0]
 800ef40:	685b      	ldr	r3, [r3, #4]
 800ef42:	4a43      	ldr	r2, [pc, #268]	; (800f050 <UART_AdvFeatureConfig+0x148>)
 800ef44:	4013      	ands	r3, r2
 800ef46:	0019      	movs	r1, r3
 800ef48:	687b      	ldr	r3, [r7, #4]
 800ef4a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800ef4c:	687b      	ldr	r3, [r7, #4]
 800ef4e:	681b      	ldr	r3, [r3, #0]
 800ef50:	430a      	orrs	r2, r1
 800ef52:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure data inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
 800ef54:	687b      	ldr	r3, [r7, #4]
 800ef56:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800ef58:	2204      	movs	r2, #4
 800ef5a:	4013      	ands	r3, r2
 800ef5c:	d00b      	beq.n	800ef76 <UART_AdvFeatureConfig+0x6e>
  {
    assert_param(IS_UART_ADVFEATURE_DATAINV(huart->AdvancedInit.DataInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
 800ef5e:	687b      	ldr	r3, [r7, #4]
 800ef60:	681b      	ldr	r3, [r3, #0]
 800ef62:	685b      	ldr	r3, [r3, #4]
 800ef64:	4a3b      	ldr	r2, [pc, #236]	; (800f054 <UART_AdvFeatureConfig+0x14c>)
 800ef66:	4013      	ands	r3, r2
 800ef68:	0019      	movs	r1, r3
 800ef6a:	687b      	ldr	r3, [r7, #4]
 800ef6c:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800ef6e:	687b      	ldr	r3, [r7, #4]
 800ef70:	681b      	ldr	r3, [r3, #0]
 800ef72:	430a      	orrs	r2, r1
 800ef74:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure RX/TX pins swap */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
 800ef76:	687b      	ldr	r3, [r7, #4]
 800ef78:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800ef7a:	2208      	movs	r2, #8
 800ef7c:	4013      	ands	r3, r2
 800ef7e:	d00b      	beq.n	800ef98 <UART_AdvFeatureConfig+0x90>
  {
    assert_param(IS_UART_ADVFEATURE_SWAP(huart->AdvancedInit.Swap));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
 800ef80:	687b      	ldr	r3, [r7, #4]
 800ef82:	681b      	ldr	r3, [r3, #0]
 800ef84:	685b      	ldr	r3, [r3, #4]
 800ef86:	4a34      	ldr	r2, [pc, #208]	; (800f058 <UART_AdvFeatureConfig+0x150>)
 800ef88:	4013      	ands	r3, r2
 800ef8a:	0019      	movs	r1, r3
 800ef8c:	687b      	ldr	r3, [r7, #4]
 800ef8e:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800ef90:	687b      	ldr	r3, [r7, #4]
 800ef92:	681b      	ldr	r3, [r3, #0]
 800ef94:	430a      	orrs	r2, r1
 800ef96:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure RX overrun detection disabling */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
 800ef98:	687b      	ldr	r3, [r7, #4]
 800ef9a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800ef9c:	2210      	movs	r2, #16
 800ef9e:	4013      	ands	r3, r2
 800efa0:	d00b      	beq.n	800efba <UART_AdvFeatureConfig+0xb2>
  {
    assert_param(IS_UART_OVERRUN(huart->AdvancedInit.OverrunDisable));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
 800efa2:	687b      	ldr	r3, [r7, #4]
 800efa4:	681b      	ldr	r3, [r3, #0]
 800efa6:	689b      	ldr	r3, [r3, #8]
 800efa8:	4a2c      	ldr	r2, [pc, #176]	; (800f05c <UART_AdvFeatureConfig+0x154>)
 800efaa:	4013      	ands	r3, r2
 800efac:	0019      	movs	r1, r3
 800efae:	687b      	ldr	r3, [r7, #4]
 800efb0:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800efb2:	687b      	ldr	r3, [r7, #4]
 800efb4:	681b      	ldr	r3, [r3, #0]
 800efb6:	430a      	orrs	r2, r1
 800efb8:	609a      	str	r2, [r3, #8]
  }

  /* if required, configure DMA disabling on reception error */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
 800efba:	687b      	ldr	r3, [r7, #4]
 800efbc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800efbe:	2220      	movs	r2, #32
 800efc0:	4013      	ands	r3, r2
 800efc2:	d00b      	beq.n	800efdc <UART_AdvFeatureConfig+0xd4>
  {
    assert_param(IS_UART_ADVFEATURE_DMAONRXERROR(huart->AdvancedInit.DMADisableonRxError));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
 800efc4:	687b      	ldr	r3, [r7, #4]
 800efc6:	681b      	ldr	r3, [r3, #0]
 800efc8:	689b      	ldr	r3, [r3, #8]
 800efca:	4a25      	ldr	r2, [pc, #148]	; (800f060 <UART_AdvFeatureConfig+0x158>)
 800efcc:	4013      	ands	r3, r2
 800efce:	0019      	movs	r1, r3
 800efd0:	687b      	ldr	r3, [r7, #4]
 800efd2:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 800efd4:	687b      	ldr	r3, [r7, #4]
 800efd6:	681b      	ldr	r3, [r3, #0]
 800efd8:	430a      	orrs	r2, r1
 800efda:	609a      	str	r2, [r3, #8]
  }

  /* if required, configure auto Baud rate detection scheme */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
 800efdc:	687b      	ldr	r3, [r7, #4]
 800efde:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800efe0:	2240      	movs	r2, #64	; 0x40
 800efe2:	4013      	ands	r3, r2
 800efe4:	d01d      	beq.n	800f022 <UART_AdvFeatureConfig+0x11a>
  {
    assert_param(IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(huart->Instance));
    assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATE(huart->AdvancedInit.AutoBaudRateEnable));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 800efe6:	687b      	ldr	r3, [r7, #4]
 800efe8:	681b      	ldr	r3, [r3, #0]
 800efea:	685b      	ldr	r3, [r3, #4]
 800efec:	4a1d      	ldr	r2, [pc, #116]	; (800f064 <UART_AdvFeatureConfig+0x15c>)
 800efee:	4013      	ands	r3, r2
 800eff0:	0019      	movs	r1, r3
 800eff2:	687b      	ldr	r3, [r7, #4]
 800eff4:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 800eff6:	687b      	ldr	r3, [r7, #4]
 800eff8:	681b      	ldr	r3, [r3, #0]
 800effa:	430a      	orrs	r2, r1
 800effc:	605a      	str	r2, [r3, #4]
    /* set auto Baudrate detection parameters if detection is enabled */
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 800effe:	687b      	ldr	r3, [r7, #4]
 800f000:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 800f002:	2380      	movs	r3, #128	; 0x80
 800f004:	035b      	lsls	r3, r3, #13
 800f006:	429a      	cmp	r2, r3
 800f008:	d10b      	bne.n	800f022 <UART_AdvFeatureConfig+0x11a>
    {
      assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATEMODE(huart->AdvancedInit.AutoBaudRateMode));
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
 800f00a:	687b      	ldr	r3, [r7, #4]
 800f00c:	681b      	ldr	r3, [r3, #0]
 800f00e:	685b      	ldr	r3, [r3, #4]
 800f010:	4a15      	ldr	r2, [pc, #84]	; (800f068 <UART_AdvFeatureConfig+0x160>)
 800f012:	4013      	ands	r3, r2
 800f014:	0019      	movs	r1, r3
 800f016:	687b      	ldr	r3, [r7, #4]
 800f018:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 800f01a:	687b      	ldr	r3, [r7, #4]
 800f01c:	681b      	ldr	r3, [r3, #0]
 800f01e:	430a      	orrs	r2, r1
 800f020:	605a      	str	r2, [r3, #4]
    }
  }

  /* if required, configure MSB first on communication line */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
 800f022:	687b      	ldr	r3, [r7, #4]
 800f024:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800f026:	2280      	movs	r2, #128	; 0x80
 800f028:	4013      	ands	r3, r2
 800f02a:	d00b      	beq.n	800f044 <UART_AdvFeatureConfig+0x13c>
  {
    assert_param(IS_UART_ADVFEATURE_MSBFIRST(huart->AdvancedInit.MSBFirst));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
 800f02c:	687b      	ldr	r3, [r7, #4]
 800f02e:	681b      	ldr	r3, [r3, #0]
 800f030:	685b      	ldr	r3, [r3, #4]
 800f032:	4a0e      	ldr	r2, [pc, #56]	; (800f06c <UART_AdvFeatureConfig+0x164>)
 800f034:	4013      	ands	r3, r2
 800f036:	0019      	movs	r1, r3
 800f038:	687b      	ldr	r3, [r7, #4]
 800f03a:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 800f03c:	687b      	ldr	r3, [r7, #4]
 800f03e:	681b      	ldr	r3, [r3, #0]
 800f040:	430a      	orrs	r2, r1
 800f042:	605a      	str	r2, [r3, #4]
  }
}
 800f044:	46c0      	nop			; (mov r8, r8)
 800f046:	46bd      	mov	sp, r7
 800f048:	b002      	add	sp, #8
 800f04a:	bd80      	pop	{r7, pc}
 800f04c:	fffdffff 	.word	0xfffdffff
 800f050:	fffeffff 	.word	0xfffeffff
 800f054:	fffbffff 	.word	0xfffbffff
 800f058:	ffff7fff 	.word	0xffff7fff
 800f05c:	ffffefff 	.word	0xffffefff
 800f060:	ffffdfff 	.word	0xffffdfff
 800f064:	ffefffff 	.word	0xffefffff
 800f068:	ff9fffff 	.word	0xff9fffff
 800f06c:	fff7ffff 	.word	0xfff7ffff

0800f070 <UART_CheckIdleState>:
  * @brief Check the UART Idle State.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_CheckIdleState(UART_HandleTypeDef *huart)
{
 800f070:	b580      	push	{r7, lr}
 800f072:	b086      	sub	sp, #24
 800f074:	af02      	add	r7, sp, #8
 800f076:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;

  /* Initialize the UART ErrorCode */
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 800f078:	687b      	ldr	r3, [r7, #4]
 800f07a:	2280      	movs	r2, #128	; 0x80
 800f07c:	2100      	movs	r1, #0
 800f07e:	5099      	str	r1, [r3, r2]

  /* Init tickstart for timeout management */
  tickstart = HAL_GetTick();
 800f080:	f7fc f87c 	bl	800b17c <HAL_GetTick>
 800f084:	0003      	movs	r3, r0
 800f086:	60fb      	str	r3, [r7, #12]

  /* Check if the Transmitter is enabled */
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 800f088:	687b      	ldr	r3, [r7, #4]
 800f08a:	681b      	ldr	r3, [r3, #0]
 800f08c:	681b      	ldr	r3, [r3, #0]
 800f08e:	2208      	movs	r2, #8
 800f090:	4013      	ands	r3, r2
 800f092:	2b08      	cmp	r3, #8
 800f094:	d10c      	bne.n	800f0b0 <UART_CheckIdleState+0x40>
  {
    /* Wait until TEACK flag is set */
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 800f096:	68fb      	ldr	r3, [r7, #12]
 800f098:	2280      	movs	r2, #128	; 0x80
 800f09a:	0391      	lsls	r1, r2, #14
 800f09c:	6878      	ldr	r0, [r7, #4]
 800f09e:	4a17      	ldr	r2, [pc, #92]	; (800f0fc <UART_CheckIdleState+0x8c>)
 800f0a0:	9200      	str	r2, [sp, #0]
 800f0a2:	2200      	movs	r2, #0
 800f0a4:	f000 f82c 	bl	800f100 <UART_WaitOnFlagUntilTimeout>
 800f0a8:	1e03      	subs	r3, r0, #0
 800f0aa:	d001      	beq.n	800f0b0 <UART_CheckIdleState+0x40>
    {
      /* Timeout occurred */
      return HAL_TIMEOUT;
 800f0ac:	2303      	movs	r3, #3
 800f0ae:	e021      	b.n	800f0f4 <UART_CheckIdleState+0x84>
    }
  }

  /* Check if the Receiver is enabled */
  if ((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
 800f0b0:	687b      	ldr	r3, [r7, #4]
 800f0b2:	681b      	ldr	r3, [r3, #0]
 800f0b4:	681b      	ldr	r3, [r3, #0]
 800f0b6:	2204      	movs	r2, #4
 800f0b8:	4013      	ands	r3, r2
 800f0ba:	2b04      	cmp	r3, #4
 800f0bc:	d10c      	bne.n	800f0d8 <UART_CheckIdleState+0x68>
  {
    /* Wait until REACK flag is set */
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 800f0be:	68fb      	ldr	r3, [r7, #12]
 800f0c0:	2280      	movs	r2, #128	; 0x80
 800f0c2:	03d1      	lsls	r1, r2, #15
 800f0c4:	6878      	ldr	r0, [r7, #4]
 800f0c6:	4a0d      	ldr	r2, [pc, #52]	; (800f0fc <UART_CheckIdleState+0x8c>)
 800f0c8:	9200      	str	r2, [sp, #0]
 800f0ca:	2200      	movs	r2, #0
 800f0cc:	f000 f818 	bl	800f100 <UART_WaitOnFlagUntilTimeout>
 800f0d0:	1e03      	subs	r3, r0, #0
 800f0d2:	d001      	beq.n	800f0d8 <UART_CheckIdleState+0x68>
    {
      /* Timeout occurred */
      return HAL_TIMEOUT;
 800f0d4:	2303      	movs	r3, #3
 800f0d6:	e00d      	b.n	800f0f4 <UART_CheckIdleState+0x84>
    }
  }

  /* Initialize the UART State */
  huart->gState = HAL_UART_STATE_READY;
 800f0d8:	687b      	ldr	r3, [r7, #4]
 800f0da:	2220      	movs	r2, #32
 800f0dc:	679a      	str	r2, [r3, #120]	; 0x78
  huart->RxState = HAL_UART_STATE_READY;
 800f0de:	687b      	ldr	r3, [r7, #4]
 800f0e0:	2220      	movs	r2, #32
 800f0e2:	67da      	str	r2, [r3, #124]	; 0x7c
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 800f0e4:	687b      	ldr	r3, [r7, #4]
 800f0e6:	2200      	movs	r2, #0
 800f0e8:	661a      	str	r2, [r3, #96]	; 0x60

  __HAL_UNLOCK(huart);
 800f0ea:	687b      	ldr	r3, [r7, #4]
 800f0ec:	2274      	movs	r2, #116	; 0x74
 800f0ee:	2100      	movs	r1, #0
 800f0f0:	5499      	strb	r1, [r3, r2]

  return HAL_OK;
 800f0f2:	2300      	movs	r3, #0
}
 800f0f4:	0018      	movs	r0, r3
 800f0f6:	46bd      	mov	sp, r7
 800f0f8:	b004      	add	sp, #16
 800f0fa:	bd80      	pop	{r7, pc}
 800f0fc:	01ffffff 	.word	0x01ffffff

0800f100 <UART_WaitOnFlagUntilTimeout>:
  * @param Timeout   Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status,
                                              uint32_t Tickstart, uint32_t Timeout)
{
 800f100:	b580      	push	{r7, lr}
 800f102:	b094      	sub	sp, #80	; 0x50
 800f104:	af00      	add	r7, sp, #0
 800f106:	60f8      	str	r0, [r7, #12]
 800f108:	60b9      	str	r1, [r7, #8]
 800f10a:	603b      	str	r3, [r7, #0]
 800f10c:	1dfb      	adds	r3, r7, #7
 800f10e:	701a      	strb	r2, [r3, #0]
  /* Wait until flag is set */
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 800f110:	e0a3      	b.n	800f25a <UART_WaitOnFlagUntilTimeout+0x15a>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
 800f112:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800f114:	3301      	adds	r3, #1
 800f116:	d100      	bne.n	800f11a <UART_WaitOnFlagUntilTimeout+0x1a>
 800f118:	e09f      	b.n	800f25a <UART_WaitOnFlagUntilTimeout+0x15a>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 800f11a:	f7fc f82f 	bl	800b17c <HAL_GetTick>
 800f11e:	0002      	movs	r2, r0
 800f120:	683b      	ldr	r3, [r7, #0]
 800f122:	1ad3      	subs	r3, r2, r3
 800f124:	6dba      	ldr	r2, [r7, #88]	; 0x58
 800f126:	429a      	cmp	r2, r3
 800f128:	d302      	bcc.n	800f130 <UART_WaitOnFlagUntilTimeout+0x30>
 800f12a:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800f12c:	2b00      	cmp	r3, #0
 800f12e:	d13d      	bne.n	800f1ac <UART_WaitOnFlagUntilTimeout+0xac>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800f130:	f3ef 8310 	mrs	r3, PRIMASK
 800f134:	62bb      	str	r3, [r7, #40]	; 0x28
  return(result);
 800f136:	6abb      	ldr	r3, [r7, #40]	; 0x28
      {
        /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error)
           interrupts for the interrupt process */
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
 800f138:	647b      	str	r3, [r7, #68]	; 0x44
 800f13a:	2301      	movs	r3, #1
 800f13c:	62fb      	str	r3, [r7, #44]	; 0x2c
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800f13e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800f140:	f383 8810 	msr	PRIMASK, r3
}
 800f144:	46c0      	nop			; (mov r8, r8)
 800f146:	68fb      	ldr	r3, [r7, #12]
 800f148:	681b      	ldr	r3, [r3, #0]
 800f14a:	681a      	ldr	r2, [r3, #0]
 800f14c:	68fb      	ldr	r3, [r7, #12]
 800f14e:	681b      	ldr	r3, [r3, #0]
 800f150:	494c      	ldr	r1, [pc, #304]	; (800f284 <UART_WaitOnFlagUntilTimeout+0x184>)
 800f152:	400a      	ands	r2, r1
 800f154:	601a      	str	r2, [r3, #0]
 800f156:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800f158:	633b      	str	r3, [r7, #48]	; 0x30
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800f15a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800f15c:	f383 8810 	msr	PRIMASK, r3
}
 800f160:	46c0      	nop			; (mov r8, r8)
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800f162:	f3ef 8310 	mrs	r3, PRIMASK
 800f166:	637b      	str	r3, [r7, #52]	; 0x34
  return(result);
 800f168:	6b7b      	ldr	r3, [r7, #52]	; 0x34
        ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800f16a:	643b      	str	r3, [r7, #64]	; 0x40
 800f16c:	2301      	movs	r3, #1
 800f16e:	63bb      	str	r3, [r7, #56]	; 0x38
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800f170:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800f172:	f383 8810 	msr	PRIMASK, r3
}
 800f176:	46c0      	nop			; (mov r8, r8)
 800f178:	68fb      	ldr	r3, [r7, #12]
 800f17a:	681b      	ldr	r3, [r3, #0]
 800f17c:	689a      	ldr	r2, [r3, #8]
 800f17e:	68fb      	ldr	r3, [r7, #12]
 800f180:	681b      	ldr	r3, [r3, #0]
 800f182:	2101      	movs	r1, #1
 800f184:	438a      	bics	r2, r1
 800f186:	609a      	str	r2, [r3, #8]
 800f188:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800f18a:	63fb      	str	r3, [r7, #60]	; 0x3c
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800f18c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800f18e:	f383 8810 	msr	PRIMASK, r3
}
 800f192:	46c0      	nop			; (mov r8, r8)

        huart->gState = HAL_UART_STATE_READY;
 800f194:	68fb      	ldr	r3, [r7, #12]
 800f196:	2220      	movs	r2, #32
 800f198:	679a      	str	r2, [r3, #120]	; 0x78
        huart->RxState = HAL_UART_STATE_READY;
 800f19a:	68fb      	ldr	r3, [r7, #12]
 800f19c:	2220      	movs	r2, #32
 800f19e:	67da      	str	r2, [r3, #124]	; 0x7c

        __HAL_UNLOCK(huart);
 800f1a0:	68fb      	ldr	r3, [r7, #12]
 800f1a2:	2274      	movs	r2, #116	; 0x74
 800f1a4:	2100      	movs	r1, #0
 800f1a6:	5499      	strb	r1, [r3, r2]

        return HAL_TIMEOUT;
 800f1a8:	2303      	movs	r3, #3
 800f1aa:	e067      	b.n	800f27c <UART_WaitOnFlagUntilTimeout+0x17c>
      }

      if (READ_BIT(huart->Instance->CR1, USART_CR1_RE) != 0U)
 800f1ac:	68fb      	ldr	r3, [r7, #12]
 800f1ae:	681b      	ldr	r3, [r3, #0]
 800f1b0:	681b      	ldr	r3, [r3, #0]
 800f1b2:	2204      	movs	r2, #4
 800f1b4:	4013      	ands	r3, r2
 800f1b6:	d050      	beq.n	800f25a <UART_WaitOnFlagUntilTimeout+0x15a>
      {
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_RTOF) == SET)
 800f1b8:	68fb      	ldr	r3, [r7, #12]
 800f1ba:	681b      	ldr	r3, [r3, #0]
 800f1bc:	69da      	ldr	r2, [r3, #28]
 800f1be:	2380      	movs	r3, #128	; 0x80
 800f1c0:	011b      	lsls	r3, r3, #4
 800f1c2:	401a      	ands	r2, r3
 800f1c4:	2380      	movs	r3, #128	; 0x80
 800f1c6:	011b      	lsls	r3, r3, #4
 800f1c8:	429a      	cmp	r2, r3
 800f1ca:	d146      	bne.n	800f25a <UART_WaitOnFlagUntilTimeout+0x15a>
        {
          /* Clear Receiver Timeout flag*/
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
 800f1cc:	68fb      	ldr	r3, [r7, #12]
 800f1ce:	681b      	ldr	r3, [r3, #0]
 800f1d0:	2280      	movs	r2, #128	; 0x80
 800f1d2:	0112      	lsls	r2, r2, #4
 800f1d4:	621a      	str	r2, [r3, #32]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800f1d6:	f3ef 8310 	mrs	r3, PRIMASK
 800f1da:	613b      	str	r3, [r7, #16]
  return(result);
 800f1dc:	693b      	ldr	r3, [r7, #16]

          /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error)
             interrupts for the interrupt process */
          ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
 800f1de:	64fb      	str	r3, [r7, #76]	; 0x4c
 800f1e0:	2301      	movs	r3, #1
 800f1e2:	617b      	str	r3, [r7, #20]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800f1e4:	697b      	ldr	r3, [r7, #20]
 800f1e6:	f383 8810 	msr	PRIMASK, r3
}
 800f1ea:	46c0      	nop			; (mov r8, r8)
 800f1ec:	68fb      	ldr	r3, [r7, #12]
 800f1ee:	681b      	ldr	r3, [r3, #0]
 800f1f0:	681a      	ldr	r2, [r3, #0]
 800f1f2:	68fb      	ldr	r3, [r7, #12]
 800f1f4:	681b      	ldr	r3, [r3, #0]
 800f1f6:	4923      	ldr	r1, [pc, #140]	; (800f284 <UART_WaitOnFlagUntilTimeout+0x184>)
 800f1f8:	400a      	ands	r2, r1
 800f1fa:	601a      	str	r2, [r3, #0]
 800f1fc:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800f1fe:	61bb      	str	r3, [r7, #24]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800f200:	69bb      	ldr	r3, [r7, #24]
 800f202:	f383 8810 	msr	PRIMASK, r3
}
 800f206:	46c0      	nop			; (mov r8, r8)
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800f208:	f3ef 8310 	mrs	r3, PRIMASK
 800f20c:	61fb      	str	r3, [r7, #28]
  return(result);
 800f20e:	69fb      	ldr	r3, [r7, #28]
          ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800f210:	64bb      	str	r3, [r7, #72]	; 0x48
 800f212:	2301      	movs	r3, #1
 800f214:	623b      	str	r3, [r7, #32]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800f216:	6a3b      	ldr	r3, [r7, #32]
 800f218:	f383 8810 	msr	PRIMASK, r3
}
 800f21c:	46c0      	nop			; (mov r8, r8)
 800f21e:	68fb      	ldr	r3, [r7, #12]
 800f220:	681b      	ldr	r3, [r3, #0]
 800f222:	689a      	ldr	r2, [r3, #8]
 800f224:	68fb      	ldr	r3, [r7, #12]
 800f226:	681b      	ldr	r3, [r3, #0]
 800f228:	2101      	movs	r1, #1
 800f22a:	438a      	bics	r2, r1
 800f22c:	609a      	str	r2, [r3, #8]
 800f22e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800f230:	627b      	str	r3, [r7, #36]	; 0x24
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800f232:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800f234:	f383 8810 	msr	PRIMASK, r3
}
 800f238:	46c0      	nop			; (mov r8, r8)

          huart->gState = HAL_UART_STATE_READY;
 800f23a:	68fb      	ldr	r3, [r7, #12]
 800f23c:	2220      	movs	r2, #32
 800f23e:	679a      	str	r2, [r3, #120]	; 0x78
          huart->RxState = HAL_UART_STATE_READY;
 800f240:	68fb      	ldr	r3, [r7, #12]
 800f242:	2220      	movs	r2, #32
 800f244:	67da      	str	r2, [r3, #124]	; 0x7c
          huart->ErrorCode = HAL_UART_ERROR_RTO;
 800f246:	68fb      	ldr	r3, [r7, #12]
 800f248:	2280      	movs	r2, #128	; 0x80
 800f24a:	2120      	movs	r1, #32
 800f24c:	5099      	str	r1, [r3, r2]

          /* Process Unlocked */
          __HAL_UNLOCK(huart);
 800f24e:	68fb      	ldr	r3, [r7, #12]
 800f250:	2274      	movs	r2, #116	; 0x74
 800f252:	2100      	movs	r1, #0
 800f254:	5499      	strb	r1, [r3, r2]

          return HAL_TIMEOUT;
 800f256:	2303      	movs	r3, #3
 800f258:	e010      	b.n	800f27c <UART_WaitOnFlagUntilTimeout+0x17c>
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 800f25a:	68fb      	ldr	r3, [r7, #12]
 800f25c:	681b      	ldr	r3, [r3, #0]
 800f25e:	69db      	ldr	r3, [r3, #28]
 800f260:	68ba      	ldr	r2, [r7, #8]
 800f262:	4013      	ands	r3, r2
 800f264:	68ba      	ldr	r2, [r7, #8]
 800f266:	1ad3      	subs	r3, r2, r3
 800f268:	425a      	negs	r2, r3
 800f26a:	4153      	adcs	r3, r2
 800f26c:	b2db      	uxtb	r3, r3
 800f26e:	001a      	movs	r2, r3
 800f270:	1dfb      	adds	r3, r7, #7
 800f272:	781b      	ldrb	r3, [r3, #0]
 800f274:	429a      	cmp	r2, r3
 800f276:	d100      	bne.n	800f27a <UART_WaitOnFlagUntilTimeout+0x17a>
 800f278:	e74b      	b.n	800f112 <UART_WaitOnFlagUntilTimeout+0x12>
        }
      }
    }
  }
  return HAL_OK;
 800f27a:	2300      	movs	r3, #0
}
 800f27c:	0018      	movs	r0, r3
 800f27e:	46bd      	mov	sp, r7
 800f280:	b014      	add	sp, #80	; 0x50
 800f282:	bd80      	pop	{r7, pc}
 800f284:	fffffe5f 	.word	0xfffffe5f

0800f288 <UART_Start_Receive_IT>:
  * @param  pData Pointer to data buffer (u8 or u16 data elements).
  * @param  Size  Amount of data elements (u8 or u16) to be received.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_Start_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
{
 800f288:	b580      	push	{r7, lr}
 800f28a:	b08c      	sub	sp, #48	; 0x30
 800f28c:	af00      	add	r7, sp, #0
 800f28e:	60f8      	str	r0, [r7, #12]
 800f290:	60b9      	str	r1, [r7, #8]
 800f292:	1dbb      	adds	r3, r7, #6
 800f294:	801a      	strh	r2, [r3, #0]
  huart->pRxBuffPtr  = pData;
 800f296:	68fb      	ldr	r3, [r7, #12]
 800f298:	68ba      	ldr	r2, [r7, #8]
 800f29a:	655a      	str	r2, [r3, #84]	; 0x54
  huart->RxXferSize  = Size;
 800f29c:	68fb      	ldr	r3, [r7, #12]
 800f29e:	1dba      	adds	r2, r7, #6
 800f2a0:	2158      	movs	r1, #88	; 0x58
 800f2a2:	8812      	ldrh	r2, [r2, #0]
 800f2a4:	525a      	strh	r2, [r3, r1]
  huart->RxXferCount = Size;
 800f2a6:	68fb      	ldr	r3, [r7, #12]
 800f2a8:	1dba      	adds	r2, r7, #6
 800f2aa:	215a      	movs	r1, #90	; 0x5a
 800f2ac:	8812      	ldrh	r2, [r2, #0]
 800f2ae:	525a      	strh	r2, [r3, r1]
  huart->RxISR       = NULL;
 800f2b0:	68fb      	ldr	r3, [r7, #12]
 800f2b2:	2200      	movs	r2, #0
 800f2b4:	665a      	str	r2, [r3, #100]	; 0x64

  /* Computation of UART mask to apply to RDR register */
  UART_MASK_COMPUTATION(huart);
 800f2b6:	68fb      	ldr	r3, [r7, #12]
 800f2b8:	689a      	ldr	r2, [r3, #8]
 800f2ba:	2380      	movs	r3, #128	; 0x80
 800f2bc:	015b      	lsls	r3, r3, #5
 800f2be:	429a      	cmp	r2, r3
 800f2c0:	d10d      	bne.n	800f2de <UART_Start_Receive_IT+0x56>
 800f2c2:	68fb      	ldr	r3, [r7, #12]
 800f2c4:	691b      	ldr	r3, [r3, #16]
 800f2c6:	2b00      	cmp	r3, #0
 800f2c8:	d104      	bne.n	800f2d4 <UART_Start_Receive_IT+0x4c>
 800f2ca:	68fb      	ldr	r3, [r7, #12]
 800f2cc:	225c      	movs	r2, #92	; 0x5c
 800f2ce:	4943      	ldr	r1, [pc, #268]	; (800f3dc <UART_Start_Receive_IT+0x154>)
 800f2d0:	5299      	strh	r1, [r3, r2]
 800f2d2:	e02e      	b.n	800f332 <UART_Start_Receive_IT+0xaa>
 800f2d4:	68fb      	ldr	r3, [r7, #12]
 800f2d6:	225c      	movs	r2, #92	; 0x5c
 800f2d8:	21ff      	movs	r1, #255	; 0xff
 800f2da:	5299      	strh	r1, [r3, r2]
 800f2dc:	e029      	b.n	800f332 <UART_Start_Receive_IT+0xaa>
 800f2de:	68fb      	ldr	r3, [r7, #12]
 800f2e0:	689b      	ldr	r3, [r3, #8]
 800f2e2:	2b00      	cmp	r3, #0
 800f2e4:	d10d      	bne.n	800f302 <UART_Start_Receive_IT+0x7a>
 800f2e6:	68fb      	ldr	r3, [r7, #12]
 800f2e8:	691b      	ldr	r3, [r3, #16]
 800f2ea:	2b00      	cmp	r3, #0
 800f2ec:	d104      	bne.n	800f2f8 <UART_Start_Receive_IT+0x70>
 800f2ee:	68fb      	ldr	r3, [r7, #12]
 800f2f0:	225c      	movs	r2, #92	; 0x5c
 800f2f2:	21ff      	movs	r1, #255	; 0xff
 800f2f4:	5299      	strh	r1, [r3, r2]
 800f2f6:	e01c      	b.n	800f332 <UART_Start_Receive_IT+0xaa>
 800f2f8:	68fb      	ldr	r3, [r7, #12]
 800f2fa:	225c      	movs	r2, #92	; 0x5c
 800f2fc:	217f      	movs	r1, #127	; 0x7f
 800f2fe:	5299      	strh	r1, [r3, r2]
 800f300:	e017      	b.n	800f332 <UART_Start_Receive_IT+0xaa>
 800f302:	68fb      	ldr	r3, [r7, #12]
 800f304:	689a      	ldr	r2, [r3, #8]
 800f306:	2380      	movs	r3, #128	; 0x80
 800f308:	055b      	lsls	r3, r3, #21
 800f30a:	429a      	cmp	r2, r3
 800f30c:	d10d      	bne.n	800f32a <UART_Start_Receive_IT+0xa2>
 800f30e:	68fb      	ldr	r3, [r7, #12]
 800f310:	691b      	ldr	r3, [r3, #16]
 800f312:	2b00      	cmp	r3, #0
 800f314:	d104      	bne.n	800f320 <UART_Start_Receive_IT+0x98>
 800f316:	68fb      	ldr	r3, [r7, #12]
 800f318:	225c      	movs	r2, #92	; 0x5c
 800f31a:	217f      	movs	r1, #127	; 0x7f
 800f31c:	5299      	strh	r1, [r3, r2]
 800f31e:	e008      	b.n	800f332 <UART_Start_Receive_IT+0xaa>
 800f320:	68fb      	ldr	r3, [r7, #12]
 800f322:	225c      	movs	r2, #92	; 0x5c
 800f324:	213f      	movs	r1, #63	; 0x3f
 800f326:	5299      	strh	r1, [r3, r2]
 800f328:	e003      	b.n	800f332 <UART_Start_Receive_IT+0xaa>
 800f32a:	68fb      	ldr	r3, [r7, #12]
 800f32c:	225c      	movs	r2, #92	; 0x5c
 800f32e:	2100      	movs	r1, #0
 800f330:	5299      	strh	r1, [r3, r2]

  huart->ErrorCode = HAL_UART_ERROR_NONE;
 800f332:	68fb      	ldr	r3, [r7, #12]
 800f334:	2280      	movs	r2, #128	; 0x80
 800f336:	2100      	movs	r1, #0
 800f338:	5099      	str	r1, [r3, r2]
  huart->RxState = HAL_UART_STATE_BUSY_RX;
 800f33a:	68fb      	ldr	r3, [r7, #12]
 800f33c:	2222      	movs	r2, #34	; 0x22
 800f33e:	67da      	str	r2, [r3, #124]	; 0x7c
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800f340:	f3ef 8310 	mrs	r3, PRIMASK
 800f344:	61fb      	str	r3, [r7, #28]
  return(result);
 800f346:	69fb      	ldr	r3, [r7, #28]

  /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
  ATOMIC_SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800f348:	62fb      	str	r3, [r7, #44]	; 0x2c
 800f34a:	2301      	movs	r3, #1
 800f34c:	623b      	str	r3, [r7, #32]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800f34e:	6a3b      	ldr	r3, [r7, #32]
 800f350:	f383 8810 	msr	PRIMASK, r3
}
 800f354:	46c0      	nop			; (mov r8, r8)
 800f356:	68fb      	ldr	r3, [r7, #12]
 800f358:	681b      	ldr	r3, [r3, #0]
 800f35a:	689a      	ldr	r2, [r3, #8]
 800f35c:	68fb      	ldr	r3, [r7, #12]
 800f35e:	681b      	ldr	r3, [r3, #0]
 800f360:	2101      	movs	r1, #1
 800f362:	430a      	orrs	r2, r1
 800f364:	609a      	str	r2, [r3, #8]
 800f366:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800f368:	627b      	str	r3, [r7, #36]	; 0x24
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800f36a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800f36c:	f383 8810 	msr	PRIMASK, r3
}
 800f370:	46c0      	nop			; (mov r8, r8)

  /* Set the Rx ISR function pointer according to the data word length */
  if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 800f372:	68fb      	ldr	r3, [r7, #12]
 800f374:	689a      	ldr	r2, [r3, #8]
 800f376:	2380      	movs	r3, #128	; 0x80
 800f378:	015b      	lsls	r3, r3, #5
 800f37a:	429a      	cmp	r2, r3
 800f37c:	d107      	bne.n	800f38e <UART_Start_Receive_IT+0x106>
 800f37e:	68fb      	ldr	r3, [r7, #12]
 800f380:	691b      	ldr	r3, [r3, #16]
 800f382:	2b00      	cmp	r3, #0
 800f384:	d103      	bne.n	800f38e <UART_Start_Receive_IT+0x106>
  {
    huart->RxISR = UART_RxISR_16BIT;
 800f386:	68fb      	ldr	r3, [r7, #12]
 800f388:	4a15      	ldr	r2, [pc, #84]	; (800f3e0 <UART_Start_Receive_IT+0x158>)
 800f38a:	665a      	str	r2, [r3, #100]	; 0x64
 800f38c:	e002      	b.n	800f394 <UART_Start_Receive_IT+0x10c>
  }
  else
  {
    huart->RxISR = UART_RxISR_8BIT;
 800f38e:	68fb      	ldr	r3, [r7, #12]
 800f390:	4a14      	ldr	r2, [pc, #80]	; (800f3e4 <UART_Start_Receive_IT+0x15c>)
 800f392:	665a      	str	r2, [r3, #100]	; 0x64
  }

  __HAL_UNLOCK(huart);
 800f394:	68fb      	ldr	r3, [r7, #12]
 800f396:	2274      	movs	r2, #116	; 0x74
 800f398:	2100      	movs	r1, #0
 800f39a:	5499      	strb	r1, [r3, r2]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800f39c:	f3ef 8310 	mrs	r3, PRIMASK
 800f3a0:	613b      	str	r3, [r7, #16]
  return(result);
 800f3a2:	693b      	ldr	r3, [r7, #16]

  /* Enable the UART Parity Error interrupt and Data Register Not Empty interrupt */
  ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_PEIE | USART_CR1_RXNEIE);
 800f3a4:	62bb      	str	r3, [r7, #40]	; 0x28
 800f3a6:	2301      	movs	r3, #1
 800f3a8:	617b      	str	r3, [r7, #20]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800f3aa:	697b      	ldr	r3, [r7, #20]
 800f3ac:	f383 8810 	msr	PRIMASK, r3
}
 800f3b0:	46c0      	nop			; (mov r8, r8)
 800f3b2:	68fb      	ldr	r3, [r7, #12]
 800f3b4:	681b      	ldr	r3, [r3, #0]
 800f3b6:	681a      	ldr	r2, [r3, #0]
 800f3b8:	68fb      	ldr	r3, [r7, #12]
 800f3ba:	681b      	ldr	r3, [r3, #0]
 800f3bc:	2190      	movs	r1, #144	; 0x90
 800f3be:	0049      	lsls	r1, r1, #1
 800f3c0:	430a      	orrs	r2, r1
 800f3c2:	601a      	str	r2, [r3, #0]
 800f3c4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800f3c6:	61bb      	str	r3, [r7, #24]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800f3c8:	69bb      	ldr	r3, [r7, #24]
 800f3ca:	f383 8810 	msr	PRIMASK, r3
}
 800f3ce:	46c0      	nop			; (mov r8, r8)
  return HAL_OK;
 800f3d0:	2300      	movs	r3, #0
}
 800f3d2:	0018      	movs	r0, r3
 800f3d4:	46bd      	mov	sp, r7
 800f3d6:	b00c      	add	sp, #48	; 0x30
 800f3d8:	bd80      	pop	{r7, pc}
 800f3da:	46c0      	nop			; (mov r8, r8)
 800f3dc:	000001ff 	.word	0x000001ff
 800f3e0:	0800f835 	.word	0x0800f835
 800f3e4:	0800f6a1 	.word	0x0800f6a1

0800f3e8 <UART_EndRxTransfer>:
  * @brief  End ongoing Rx transfer on UART peripheral (following error detection or Reception completion).
  * @param  huart UART handle.
  * @retval None
  */
static void UART_EndRxTransfer(UART_HandleTypeDef *huart)
{
 800f3e8:	b580      	push	{r7, lr}
 800f3ea:	b08e      	sub	sp, #56	; 0x38
 800f3ec:	af00      	add	r7, sp, #0
 800f3ee:	6078      	str	r0, [r7, #4]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800f3f0:	f3ef 8310 	mrs	r3, PRIMASK
 800f3f4:	617b      	str	r3, [r7, #20]
  return(result);
 800f3f6:	697b      	ldr	r3, [r7, #20]
  /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 800f3f8:	637b      	str	r3, [r7, #52]	; 0x34
 800f3fa:	2301      	movs	r3, #1
 800f3fc:	61bb      	str	r3, [r7, #24]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800f3fe:	69bb      	ldr	r3, [r7, #24]
 800f400:	f383 8810 	msr	PRIMASK, r3
}
 800f404:	46c0      	nop			; (mov r8, r8)
 800f406:	687b      	ldr	r3, [r7, #4]
 800f408:	681b      	ldr	r3, [r3, #0]
 800f40a:	681a      	ldr	r2, [r3, #0]
 800f40c:	687b      	ldr	r3, [r7, #4]
 800f40e:	681b      	ldr	r3, [r3, #0]
 800f410:	4925      	ldr	r1, [pc, #148]	; (800f4a8 <UART_EndRxTransfer+0xc0>)
 800f412:	400a      	ands	r2, r1
 800f414:	601a      	str	r2, [r3, #0]
 800f416:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800f418:	61fb      	str	r3, [r7, #28]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800f41a:	69fb      	ldr	r3, [r7, #28]
 800f41c:	f383 8810 	msr	PRIMASK, r3
}
 800f420:	46c0      	nop			; (mov r8, r8)
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800f422:	f3ef 8310 	mrs	r3, PRIMASK
 800f426:	623b      	str	r3, [r7, #32]
  return(result);
 800f428:	6a3b      	ldr	r3, [r7, #32]
  ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800f42a:	633b      	str	r3, [r7, #48]	; 0x30
 800f42c:	2301      	movs	r3, #1
 800f42e:	627b      	str	r3, [r7, #36]	; 0x24
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800f430:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800f432:	f383 8810 	msr	PRIMASK, r3
}
 800f436:	46c0      	nop			; (mov r8, r8)
 800f438:	687b      	ldr	r3, [r7, #4]
 800f43a:	681b      	ldr	r3, [r3, #0]
 800f43c:	689a      	ldr	r2, [r3, #8]
 800f43e:	687b      	ldr	r3, [r7, #4]
 800f440:	681b      	ldr	r3, [r3, #0]
 800f442:	2101      	movs	r1, #1
 800f444:	438a      	bics	r2, r1
 800f446:	609a      	str	r2, [r3, #8]
 800f448:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800f44a:	62bb      	str	r3, [r7, #40]	; 0x28
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800f44c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800f44e:	f383 8810 	msr	PRIMASK, r3
}
 800f452:	46c0      	nop			; (mov r8, r8)

  /* In case of reception waiting for IDLE event, disable also the IDLE IE interrupt source */
  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 800f454:	687b      	ldr	r3, [r7, #4]
 800f456:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 800f458:	2b01      	cmp	r3, #1
 800f45a:	d118      	bne.n	800f48e <UART_EndRxTransfer+0xa6>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800f45c:	f3ef 8310 	mrs	r3, PRIMASK
 800f460:	60bb      	str	r3, [r7, #8]
  return(result);
 800f462:	68bb      	ldr	r3, [r7, #8]
  {
    ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 800f464:	62fb      	str	r3, [r7, #44]	; 0x2c
 800f466:	2301      	movs	r3, #1
 800f468:	60fb      	str	r3, [r7, #12]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800f46a:	68fb      	ldr	r3, [r7, #12]
 800f46c:	f383 8810 	msr	PRIMASK, r3
}
 800f470:	46c0      	nop			; (mov r8, r8)
 800f472:	687b      	ldr	r3, [r7, #4]
 800f474:	681b      	ldr	r3, [r3, #0]
 800f476:	681a      	ldr	r2, [r3, #0]
 800f478:	687b      	ldr	r3, [r7, #4]
 800f47a:	681b      	ldr	r3, [r3, #0]
 800f47c:	2110      	movs	r1, #16
 800f47e:	438a      	bics	r2, r1
 800f480:	601a      	str	r2, [r3, #0]
 800f482:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800f484:	613b      	str	r3, [r7, #16]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800f486:	693b      	ldr	r3, [r7, #16]
 800f488:	f383 8810 	msr	PRIMASK, r3
}
 800f48c:	46c0      	nop			; (mov r8, r8)
  }

  /* At end of Rx process, restore huart->RxState to Ready */
  huart->RxState = HAL_UART_STATE_READY;
 800f48e:	687b      	ldr	r3, [r7, #4]
 800f490:	2220      	movs	r2, #32
 800f492:	67da      	str	r2, [r3, #124]	; 0x7c
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 800f494:	687b      	ldr	r3, [r7, #4]
 800f496:	2200      	movs	r2, #0
 800f498:	661a      	str	r2, [r3, #96]	; 0x60

  /* Reset RxIsr function pointer */
  huart->RxISR = NULL;
 800f49a:	687b      	ldr	r3, [r7, #4]
 800f49c:	2200      	movs	r2, #0
 800f49e:	665a      	str	r2, [r3, #100]	; 0x64
}
 800f4a0:	46c0      	nop			; (mov r8, r8)
 800f4a2:	46bd      	mov	sp, r7
 800f4a4:	b00e      	add	sp, #56	; 0x38
 800f4a6:	bd80      	pop	{r7, pc}
 800f4a8:	fffffedf 	.word	0xfffffedf

0800f4ac <UART_DMAAbortOnError>:
  *         (To be called at end of DMA Abort procedure following error occurrence).
  * @param  hdma DMA handle.
  * @retval None
  */
static void UART_DMAAbortOnError(DMA_HandleTypeDef *hdma)
{
 800f4ac:	b580      	push	{r7, lr}
 800f4ae:	b084      	sub	sp, #16
 800f4b0:	af00      	add	r7, sp, #0
 800f4b2:	6078      	str	r0, [r7, #4]
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
 800f4b4:	687b      	ldr	r3, [r7, #4]
 800f4b6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800f4b8:	60fb      	str	r3, [r7, #12]
  huart->RxXferCount = 0U;
 800f4ba:	68fb      	ldr	r3, [r7, #12]
 800f4bc:	225a      	movs	r2, #90	; 0x5a
 800f4be:	2100      	movs	r1, #0
 800f4c0:	5299      	strh	r1, [r3, r2]
  huart->TxXferCount = 0U;
 800f4c2:	68fb      	ldr	r3, [r7, #12]
 800f4c4:	2252      	movs	r2, #82	; 0x52
 800f4c6:	2100      	movs	r1, #0
 800f4c8:	5299      	strh	r1, [r3, r2]
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
  /*Call registered error callback*/
  huart->ErrorCallback(huart);
#else
  /*Call legacy weak error callback*/
  HAL_UART_ErrorCallback(huart);
 800f4ca:	68fb      	ldr	r3, [r7, #12]
 800f4cc:	0018      	movs	r0, r3
 800f4ce:	f7ff fb7f 	bl	800ebd0 <HAL_UART_ErrorCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
}
 800f4d2:	46c0      	nop			; (mov r8, r8)
 800f4d4:	46bd      	mov	sp, r7
 800f4d6:	b004      	add	sp, #16
 800f4d8:	bd80      	pop	{r7, pc}

0800f4da <UART_TxISR_8BIT>:
  *         interruptions have been enabled by HAL_UART_Transmit_IT().
  * @param huart UART handle.
  * @retval None
  */
static void UART_TxISR_8BIT(UART_HandleTypeDef *huart)
{
 800f4da:	b580      	push	{r7, lr}
 800f4dc:	b08a      	sub	sp, #40	; 0x28
 800f4de:	af00      	add	r7, sp, #0
 800f4e0:	6078      	str	r0, [r7, #4]
  /* Check that a Tx process is ongoing */
  if (huart->gState == HAL_UART_STATE_BUSY_TX)
 800f4e2:	687b      	ldr	r3, [r7, #4]
 800f4e4:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800f4e6:	2b21      	cmp	r3, #33	; 0x21
 800f4e8:	d14d      	bne.n	800f586 <UART_TxISR_8BIT+0xac>
  {
    if (huart->TxXferCount == 0U)
 800f4ea:	687b      	ldr	r3, [r7, #4]
 800f4ec:	2252      	movs	r2, #82	; 0x52
 800f4ee:	5a9b      	ldrh	r3, [r3, r2]
 800f4f0:	b29b      	uxth	r3, r3
 800f4f2:	2b00      	cmp	r3, #0
 800f4f4:	d132      	bne.n	800f55c <UART_TxISR_8BIT+0x82>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800f4f6:	f3ef 8310 	mrs	r3, PRIMASK
 800f4fa:	60bb      	str	r3, [r7, #8]
  return(result);
 800f4fc:	68bb      	ldr	r3, [r7, #8]
    {
      /* Disable the UART Transmit Data Register Empty Interrupt */
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_TXEIE);
 800f4fe:	627b      	str	r3, [r7, #36]	; 0x24
 800f500:	2301      	movs	r3, #1
 800f502:	60fb      	str	r3, [r7, #12]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800f504:	68fb      	ldr	r3, [r7, #12]
 800f506:	f383 8810 	msr	PRIMASK, r3
}
 800f50a:	46c0      	nop			; (mov r8, r8)
 800f50c:	687b      	ldr	r3, [r7, #4]
 800f50e:	681b      	ldr	r3, [r3, #0]
 800f510:	681a      	ldr	r2, [r3, #0]
 800f512:	687b      	ldr	r3, [r7, #4]
 800f514:	681b      	ldr	r3, [r3, #0]
 800f516:	2180      	movs	r1, #128	; 0x80
 800f518:	438a      	bics	r2, r1
 800f51a:	601a      	str	r2, [r3, #0]
 800f51c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800f51e:	613b      	str	r3, [r7, #16]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800f520:	693b      	ldr	r3, [r7, #16]
 800f522:	f383 8810 	msr	PRIMASK, r3
}
 800f526:	46c0      	nop			; (mov r8, r8)
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800f528:	f3ef 8310 	mrs	r3, PRIMASK
 800f52c:	617b      	str	r3, [r7, #20]
  return(result);
 800f52e:	697b      	ldr	r3, [r7, #20]

      /* Enable the UART Transmit Complete Interrupt */
      ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);
 800f530:	623b      	str	r3, [r7, #32]
 800f532:	2301      	movs	r3, #1
 800f534:	61bb      	str	r3, [r7, #24]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800f536:	69bb      	ldr	r3, [r7, #24]
 800f538:	f383 8810 	msr	PRIMASK, r3
}
 800f53c:	46c0      	nop			; (mov r8, r8)
 800f53e:	687b      	ldr	r3, [r7, #4]
 800f540:	681b      	ldr	r3, [r3, #0]
 800f542:	681a      	ldr	r2, [r3, #0]
 800f544:	687b      	ldr	r3, [r7, #4]
 800f546:	681b      	ldr	r3, [r3, #0]
 800f548:	2140      	movs	r1, #64	; 0x40
 800f54a:	430a      	orrs	r2, r1
 800f54c:	601a      	str	r2, [r3, #0]
 800f54e:	6a3b      	ldr	r3, [r7, #32]
 800f550:	61fb      	str	r3, [r7, #28]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800f552:	69fb      	ldr	r3, [r7, #28]
 800f554:	f383 8810 	msr	PRIMASK, r3
}
 800f558:	46c0      	nop			; (mov r8, r8)
      huart->Instance->TDR = (uint8_t)(*huart->pTxBuffPtr & (uint8_t)0xFF);
      huart->pTxBuffPtr++;
      huart->TxXferCount--;
    }
  }
}
 800f55a:	e014      	b.n	800f586 <UART_TxISR_8BIT+0xac>
      huart->Instance->TDR = (uint8_t)(*huart->pTxBuffPtr & (uint8_t)0xFF);
 800f55c:	687b      	ldr	r3, [r7, #4]
 800f55e:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800f560:	781a      	ldrb	r2, [r3, #0]
 800f562:	687b      	ldr	r3, [r7, #4]
 800f564:	681b      	ldr	r3, [r3, #0]
 800f566:	b292      	uxth	r2, r2
 800f568:	851a      	strh	r2, [r3, #40]	; 0x28
      huart->pTxBuffPtr++;
 800f56a:	687b      	ldr	r3, [r7, #4]
 800f56c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800f56e:	1c5a      	adds	r2, r3, #1
 800f570:	687b      	ldr	r3, [r7, #4]
 800f572:	64da      	str	r2, [r3, #76]	; 0x4c
      huart->TxXferCount--;
 800f574:	687b      	ldr	r3, [r7, #4]
 800f576:	2252      	movs	r2, #82	; 0x52
 800f578:	5a9b      	ldrh	r3, [r3, r2]
 800f57a:	b29b      	uxth	r3, r3
 800f57c:	3b01      	subs	r3, #1
 800f57e:	b299      	uxth	r1, r3
 800f580:	687b      	ldr	r3, [r7, #4]
 800f582:	2252      	movs	r2, #82	; 0x52
 800f584:	5299      	strh	r1, [r3, r2]
}
 800f586:	46c0      	nop			; (mov r8, r8)
 800f588:	46bd      	mov	sp, r7
 800f58a:	b00a      	add	sp, #40	; 0x28
 800f58c:	bd80      	pop	{r7, pc}

0800f58e <UART_TxISR_16BIT>:
  *         interruptions have been enabled by HAL_UART_Transmit_IT().
  * @param huart UART handle.
  * @retval None
  */
static void UART_TxISR_16BIT(UART_HandleTypeDef *huart)
{
 800f58e:	b580      	push	{r7, lr}
 800f590:	b08c      	sub	sp, #48	; 0x30
 800f592:	af00      	add	r7, sp, #0
 800f594:	6078      	str	r0, [r7, #4]
  uint16_t *tmp;

  /* Check that a Tx process is ongoing */
  if (huart->gState == HAL_UART_STATE_BUSY_TX)
 800f596:	687b      	ldr	r3, [r7, #4]
 800f598:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800f59a:	2b21      	cmp	r3, #33	; 0x21
 800f59c:	d151      	bne.n	800f642 <UART_TxISR_16BIT+0xb4>
  {
    if (huart->TxXferCount == 0U)
 800f59e:	687b      	ldr	r3, [r7, #4]
 800f5a0:	2252      	movs	r2, #82	; 0x52
 800f5a2:	5a9b      	ldrh	r3, [r3, r2]
 800f5a4:	b29b      	uxth	r3, r3
 800f5a6:	2b00      	cmp	r3, #0
 800f5a8:	d132      	bne.n	800f610 <UART_TxISR_16BIT+0x82>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800f5aa:	f3ef 8310 	mrs	r3, PRIMASK
 800f5ae:	60fb      	str	r3, [r7, #12]
  return(result);
 800f5b0:	68fb      	ldr	r3, [r7, #12]
    {
      /* Disable the UART Transmit Data Register Empty Interrupt */
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_TXEIE);
 800f5b2:	62bb      	str	r3, [r7, #40]	; 0x28
 800f5b4:	2301      	movs	r3, #1
 800f5b6:	613b      	str	r3, [r7, #16]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800f5b8:	693b      	ldr	r3, [r7, #16]
 800f5ba:	f383 8810 	msr	PRIMASK, r3
}
 800f5be:	46c0      	nop			; (mov r8, r8)
 800f5c0:	687b      	ldr	r3, [r7, #4]
 800f5c2:	681b      	ldr	r3, [r3, #0]
 800f5c4:	681a      	ldr	r2, [r3, #0]
 800f5c6:	687b      	ldr	r3, [r7, #4]
 800f5c8:	681b      	ldr	r3, [r3, #0]
 800f5ca:	2180      	movs	r1, #128	; 0x80
 800f5cc:	438a      	bics	r2, r1
 800f5ce:	601a      	str	r2, [r3, #0]
 800f5d0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800f5d2:	617b      	str	r3, [r7, #20]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800f5d4:	697b      	ldr	r3, [r7, #20]
 800f5d6:	f383 8810 	msr	PRIMASK, r3
}
 800f5da:	46c0      	nop			; (mov r8, r8)
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800f5dc:	f3ef 8310 	mrs	r3, PRIMASK
 800f5e0:	61bb      	str	r3, [r7, #24]
  return(result);
 800f5e2:	69bb      	ldr	r3, [r7, #24]

      /* Enable the UART Transmit Complete Interrupt */
      ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);
 800f5e4:	627b      	str	r3, [r7, #36]	; 0x24
 800f5e6:	2301      	movs	r3, #1
 800f5e8:	61fb      	str	r3, [r7, #28]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800f5ea:	69fb      	ldr	r3, [r7, #28]
 800f5ec:	f383 8810 	msr	PRIMASK, r3
}
 800f5f0:	46c0      	nop			; (mov r8, r8)
 800f5f2:	687b      	ldr	r3, [r7, #4]
 800f5f4:	681b      	ldr	r3, [r3, #0]
 800f5f6:	681a      	ldr	r2, [r3, #0]
 800f5f8:	687b      	ldr	r3, [r7, #4]
 800f5fa:	681b      	ldr	r3, [r3, #0]
 800f5fc:	2140      	movs	r1, #64	; 0x40
 800f5fe:	430a      	orrs	r2, r1
 800f600:	601a      	str	r2, [r3, #0]
 800f602:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800f604:	623b      	str	r3, [r7, #32]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800f606:	6a3b      	ldr	r3, [r7, #32]
 800f608:	f383 8810 	msr	PRIMASK, r3
}
 800f60c:	46c0      	nop			; (mov r8, r8)
      huart->Instance->TDR = (((uint32_t)(*tmp)) & 0x01FFUL);
      huart->pTxBuffPtr += 2U;
      huart->TxXferCount--;
    }
  }
}
 800f60e:	e018      	b.n	800f642 <UART_TxISR_16BIT+0xb4>
      tmp = (uint16_t *) huart->pTxBuffPtr;
 800f610:	687b      	ldr	r3, [r7, #4]
 800f612:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800f614:	62fb      	str	r3, [r7, #44]	; 0x2c
      huart->Instance->TDR = (((uint32_t)(*tmp)) & 0x01FFUL);
 800f616:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800f618:	881a      	ldrh	r2, [r3, #0]
 800f61a:	687b      	ldr	r3, [r7, #4]
 800f61c:	681b      	ldr	r3, [r3, #0]
 800f61e:	05d2      	lsls	r2, r2, #23
 800f620:	0dd2      	lsrs	r2, r2, #23
 800f622:	b292      	uxth	r2, r2
 800f624:	851a      	strh	r2, [r3, #40]	; 0x28
      huart->pTxBuffPtr += 2U;
 800f626:	687b      	ldr	r3, [r7, #4]
 800f628:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800f62a:	1c9a      	adds	r2, r3, #2
 800f62c:	687b      	ldr	r3, [r7, #4]
 800f62e:	64da      	str	r2, [r3, #76]	; 0x4c
      huart->TxXferCount--;
 800f630:	687b      	ldr	r3, [r7, #4]
 800f632:	2252      	movs	r2, #82	; 0x52
 800f634:	5a9b      	ldrh	r3, [r3, r2]
 800f636:	b29b      	uxth	r3, r3
 800f638:	3b01      	subs	r3, #1
 800f63a:	b299      	uxth	r1, r3
 800f63c:	687b      	ldr	r3, [r7, #4]
 800f63e:	2252      	movs	r2, #82	; 0x52
 800f640:	5299      	strh	r1, [r3, r2]
}
 800f642:	46c0      	nop			; (mov r8, r8)
 800f644:	46bd      	mov	sp, r7
 800f646:	b00c      	add	sp, #48	; 0x30
 800f648:	bd80      	pop	{r7, pc}

0800f64a <UART_EndTransmit_IT>:
  * @param  huart pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval None
  */
static void UART_EndTransmit_IT(UART_HandleTypeDef *huart)
{
 800f64a:	b580      	push	{r7, lr}
 800f64c:	b086      	sub	sp, #24
 800f64e:	af00      	add	r7, sp, #0
 800f650:	6078      	str	r0, [r7, #4]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800f652:	f3ef 8310 	mrs	r3, PRIMASK
 800f656:	60bb      	str	r3, [r7, #8]
  return(result);
 800f658:	68bb      	ldr	r3, [r7, #8]
  /* Disable the UART Transmit Complete Interrupt */
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_TCIE);
 800f65a:	617b      	str	r3, [r7, #20]
 800f65c:	2301      	movs	r3, #1
 800f65e:	60fb      	str	r3, [r7, #12]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800f660:	68fb      	ldr	r3, [r7, #12]
 800f662:	f383 8810 	msr	PRIMASK, r3
}
 800f666:	46c0      	nop			; (mov r8, r8)
 800f668:	687b      	ldr	r3, [r7, #4]
 800f66a:	681b      	ldr	r3, [r3, #0]
 800f66c:	681a      	ldr	r2, [r3, #0]
 800f66e:	687b      	ldr	r3, [r7, #4]
 800f670:	681b      	ldr	r3, [r3, #0]
 800f672:	2140      	movs	r1, #64	; 0x40
 800f674:	438a      	bics	r2, r1
 800f676:	601a      	str	r2, [r3, #0]
 800f678:	697b      	ldr	r3, [r7, #20]
 800f67a:	613b      	str	r3, [r7, #16]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800f67c:	693b      	ldr	r3, [r7, #16]
 800f67e:	f383 8810 	msr	PRIMASK, r3
}
 800f682:	46c0      	nop			; (mov r8, r8)

  /* Tx process is ended, restore huart->gState to Ready */
  huart->gState = HAL_UART_STATE_READY;
 800f684:	687b      	ldr	r3, [r7, #4]
 800f686:	2220      	movs	r2, #32
 800f688:	679a      	str	r2, [r3, #120]	; 0x78

  /* Cleat TxISR function pointer */
  huart->TxISR = NULL;
 800f68a:	687b      	ldr	r3, [r7, #4]
 800f68c:	2200      	movs	r2, #0
 800f68e:	669a      	str	r2, [r3, #104]	; 0x68
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
  /*Call registered Tx complete callback*/
  huart->TxCpltCallback(huart);
#else
  /*Call legacy weak Tx complete callback*/
  HAL_UART_TxCpltCallback(huart);
 800f690:	687b      	ldr	r3, [r7, #4]
 800f692:	0018      	movs	r0, r3
 800f694:	f7ff fa8c 	bl	800ebb0 <HAL_UART_TxCpltCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
}
 800f698:	46c0      	nop			; (mov r8, r8)
 800f69a:	46bd      	mov	sp, r7
 800f69c:	b006      	add	sp, #24
 800f69e:	bd80      	pop	{r7, pc}

0800f6a0 <UART_RxISR_8BIT>:
  * @brief RX interrupt handler for 7 or 8 bits data word length .
  * @param huart UART handle.
  * @retval None
  */
static void UART_RxISR_8BIT(UART_HandleTypeDef *huart)
{
 800f6a0:	b590      	push	{r4, r7, lr}
 800f6a2:	b091      	sub	sp, #68	; 0x44
 800f6a4:	af00      	add	r7, sp, #0
 800f6a6:	6078      	str	r0, [r7, #4]
  uint16_t uhMask = huart->Mask;
 800f6a8:	203e      	movs	r0, #62	; 0x3e
 800f6aa:	183b      	adds	r3, r7, r0
 800f6ac:	687a      	ldr	r2, [r7, #4]
 800f6ae:	215c      	movs	r1, #92	; 0x5c
 800f6b0:	5a52      	ldrh	r2, [r2, r1]
 800f6b2:	801a      	strh	r2, [r3, #0]
  uint16_t  uhdata;

  /* Check that a Rx process is ongoing */
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 800f6b4:	687b      	ldr	r3, [r7, #4]
 800f6b6:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800f6b8:	2b22      	cmp	r3, #34	; 0x22
 800f6ba:	d000      	beq.n	800f6be <UART_RxISR_8BIT+0x1e>
 800f6bc:	e0a9      	b.n	800f812 <UART_RxISR_8BIT+0x172>
  {
    uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 800f6be:	687b      	ldr	r3, [r7, #4]
 800f6c0:	681a      	ldr	r2, [r3, #0]
 800f6c2:	243c      	movs	r4, #60	; 0x3c
 800f6c4:	193b      	adds	r3, r7, r4
 800f6c6:	8c92      	ldrh	r2, [r2, #36]	; 0x24
 800f6c8:	801a      	strh	r2, [r3, #0]
    *huart->pRxBuffPtr = (uint8_t)(uhdata & (uint8_t)uhMask);
 800f6ca:	193b      	adds	r3, r7, r4
 800f6cc:	881b      	ldrh	r3, [r3, #0]
 800f6ce:	b2da      	uxtb	r2, r3
 800f6d0:	183b      	adds	r3, r7, r0
 800f6d2:	881b      	ldrh	r3, [r3, #0]
 800f6d4:	b2d9      	uxtb	r1, r3
 800f6d6:	687b      	ldr	r3, [r7, #4]
 800f6d8:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800f6da:	400a      	ands	r2, r1
 800f6dc:	b2d2      	uxtb	r2, r2
 800f6de:	701a      	strb	r2, [r3, #0]
    //huart->pRxBuffPtr++;
    //huart->RxXferCount--;
    if (huart->Instance == USART2) GSM_Receive((uint8_t)(uhdata & (uint8_t)uhMask));
 800f6e0:	687b      	ldr	r3, [r7, #4]
 800f6e2:	681b      	ldr	r3, [r3, #0]
 800f6e4:	4a51      	ldr	r2, [pc, #324]	; (800f82c <UART_RxISR_8BIT+0x18c>)
 800f6e6:	4293      	cmp	r3, r2
 800f6e8:	d10a      	bne.n	800f700 <UART_RxISR_8BIT+0x60>
 800f6ea:	193b      	adds	r3, r7, r4
 800f6ec:	881b      	ldrh	r3, [r3, #0]
 800f6ee:	b2db      	uxtb	r3, r3
 800f6f0:	183a      	adds	r2, r7, r0
 800f6f2:	8812      	ldrh	r2, [r2, #0]
 800f6f4:	b2d2      	uxtb	r2, r2
 800f6f6:	4013      	ands	r3, r2
 800f6f8:	b2db      	uxtb	r3, r3
 800f6fa:	0018      	movs	r0, r3
 800f6fc:	f7f9 fde2 	bl	80092c4 <GSM_Receive>
    if (huart->Instance == USART2) Wifi_Receive((uint8_t)(uhdata & (uint8_t)uhMask));
 800f700:	687b      	ldr	r3, [r7, #4]
 800f702:	681b      	ldr	r3, [r3, #0]
 800f704:	4a49      	ldr	r2, [pc, #292]	; (800f82c <UART_RxISR_8BIT+0x18c>)
 800f706:	4293      	cmp	r3, r2
 800f708:	d10c      	bne.n	800f724 <UART_RxISR_8BIT+0x84>
 800f70a:	233c      	movs	r3, #60	; 0x3c
 800f70c:	18fb      	adds	r3, r7, r3
 800f70e:	881b      	ldrh	r3, [r3, #0]
 800f710:	b2db      	uxtb	r3, r3
 800f712:	223e      	movs	r2, #62	; 0x3e
 800f714:	18ba      	adds	r2, r7, r2
 800f716:	8812      	ldrh	r2, [r2, #0]
 800f718:	b2d2      	uxtb	r2, r2
 800f71a:	4013      	ands	r3, r2
 800f71c:	b2db      	uxtb	r3, r3
 800f71e:	0018      	movs	r0, r3
 800f720:	f7fa fe9e 	bl	800a460 <Wifi_Receive>

    if (huart->RxXferCount == 0U)
 800f724:	687b      	ldr	r3, [r7, #4]
 800f726:	225a      	movs	r2, #90	; 0x5a
 800f728:	5a9b      	ldrh	r3, [r3, r2]
 800f72a:	b29b      	uxth	r3, r3
 800f72c:	2b00      	cmp	r3, #0
 800f72e:	d178      	bne.n	800f822 <UART_RxISR_8BIT+0x182>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800f730:	f3ef 8310 	mrs	r3, PRIMASK
 800f734:	61bb      	str	r3, [r7, #24]
  return(result);
 800f736:	69bb      	ldr	r3, [r7, #24]
    {
      /* Disable the UART Parity Error Interrupt and RXNE interrupts */
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 800f738:	63bb      	str	r3, [r7, #56]	; 0x38
 800f73a:	2301      	movs	r3, #1
 800f73c:	61fb      	str	r3, [r7, #28]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800f73e:	69fb      	ldr	r3, [r7, #28]
 800f740:	f383 8810 	msr	PRIMASK, r3
}
 800f744:	46c0      	nop			; (mov r8, r8)
 800f746:	687b      	ldr	r3, [r7, #4]
 800f748:	681b      	ldr	r3, [r3, #0]
 800f74a:	681a      	ldr	r2, [r3, #0]
 800f74c:	687b      	ldr	r3, [r7, #4]
 800f74e:	681b      	ldr	r3, [r3, #0]
 800f750:	4937      	ldr	r1, [pc, #220]	; (800f830 <UART_RxISR_8BIT+0x190>)
 800f752:	400a      	ands	r2, r1
 800f754:	601a      	str	r2, [r3, #0]
 800f756:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800f758:	623b      	str	r3, [r7, #32]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800f75a:	6a3b      	ldr	r3, [r7, #32]
 800f75c:	f383 8810 	msr	PRIMASK, r3
}
 800f760:	46c0      	nop			; (mov r8, r8)
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800f762:	f3ef 8310 	mrs	r3, PRIMASK
 800f766:	627b      	str	r3, [r7, #36]	; 0x24
  return(result);
 800f768:	6a7b      	ldr	r3, [r7, #36]	; 0x24

      /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
      ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800f76a:	637b      	str	r3, [r7, #52]	; 0x34
 800f76c:	2301      	movs	r3, #1
 800f76e:	62bb      	str	r3, [r7, #40]	; 0x28
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800f770:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800f772:	f383 8810 	msr	PRIMASK, r3
}
 800f776:	46c0      	nop			; (mov r8, r8)
 800f778:	687b      	ldr	r3, [r7, #4]
 800f77a:	681b      	ldr	r3, [r3, #0]
 800f77c:	689a      	ldr	r2, [r3, #8]
 800f77e:	687b      	ldr	r3, [r7, #4]
 800f780:	681b      	ldr	r3, [r3, #0]
 800f782:	2101      	movs	r1, #1
 800f784:	438a      	bics	r2, r1
 800f786:	609a      	str	r2, [r3, #8]
 800f788:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800f78a:	62fb      	str	r3, [r7, #44]	; 0x2c
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800f78c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800f78e:	f383 8810 	msr	PRIMASK, r3
}
 800f792:	46c0      	nop			; (mov r8, r8)

      /* Rx process is completed, restore huart->RxState to Ready */
      huart->RxState = HAL_UART_STATE_READY;
 800f794:	687b      	ldr	r3, [r7, #4]
 800f796:	2220      	movs	r2, #32
 800f798:	67da      	str	r2, [r3, #124]	; 0x7c

      /* Clear RxISR function pointer */
      huart->RxISR = NULL;
 800f79a:	687b      	ldr	r3, [r7, #4]
 800f79c:	2200      	movs	r2, #0
 800f79e:	665a      	str	r2, [r3, #100]	; 0x64

      /* Check current reception Mode :
         If Reception till IDLE event has been selected : */
      if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 800f7a0:	687b      	ldr	r3, [r7, #4]
 800f7a2:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 800f7a4:	2b01      	cmp	r3, #1
 800f7a6:	d12f      	bne.n	800f808 <UART_RxISR_8BIT+0x168>
      {
        /* Set reception type to Standard */
        huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 800f7a8:	687b      	ldr	r3, [r7, #4]
 800f7aa:	2200      	movs	r2, #0
 800f7ac:	661a      	str	r2, [r3, #96]	; 0x60
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800f7ae:	f3ef 8310 	mrs	r3, PRIMASK
 800f7b2:	60fb      	str	r3, [r7, #12]
  return(result);
 800f7b4:	68fb      	ldr	r3, [r7, #12]

        /* Disable IDLE interrupt */
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 800f7b6:	633b      	str	r3, [r7, #48]	; 0x30
 800f7b8:	2301      	movs	r3, #1
 800f7ba:	613b      	str	r3, [r7, #16]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800f7bc:	693b      	ldr	r3, [r7, #16]
 800f7be:	f383 8810 	msr	PRIMASK, r3
}
 800f7c2:	46c0      	nop			; (mov r8, r8)
 800f7c4:	687b      	ldr	r3, [r7, #4]
 800f7c6:	681b      	ldr	r3, [r3, #0]
 800f7c8:	681a      	ldr	r2, [r3, #0]
 800f7ca:	687b      	ldr	r3, [r7, #4]
 800f7cc:	681b      	ldr	r3, [r3, #0]
 800f7ce:	2110      	movs	r1, #16
 800f7d0:	438a      	bics	r2, r1
 800f7d2:	601a      	str	r2, [r3, #0]
 800f7d4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800f7d6:	617b      	str	r3, [r7, #20]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800f7d8:	697b      	ldr	r3, [r7, #20]
 800f7da:	f383 8810 	msr	PRIMASK, r3
}
 800f7de:	46c0      	nop			; (mov r8, r8)

        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE) == SET)
 800f7e0:	687b      	ldr	r3, [r7, #4]
 800f7e2:	681b      	ldr	r3, [r3, #0]
 800f7e4:	69db      	ldr	r3, [r3, #28]
 800f7e6:	2210      	movs	r2, #16
 800f7e8:	4013      	ands	r3, r2
 800f7ea:	2b10      	cmp	r3, #16
 800f7ec:	d103      	bne.n	800f7f6 <UART_RxISR_8BIT+0x156>
        {
          /* Clear IDLE Flag */
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_IDLEF);
 800f7ee:	687b      	ldr	r3, [r7, #4]
 800f7f0:	681b      	ldr	r3, [r3, #0]
 800f7f2:	2210      	movs	r2, #16
 800f7f4:	621a      	str	r2, [r3, #32]
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
        /*Call registered Rx Event callback*/
        huart->RxEventCallback(huart, huart->RxXferSize);
#else
        /*Call legacy weak Rx Event callback*/
        HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 800f7f6:	687b      	ldr	r3, [r7, #4]
 800f7f8:	2258      	movs	r2, #88	; 0x58
 800f7fa:	5a9a      	ldrh	r2, [r3, r2]
 800f7fc:	687b      	ldr	r3, [r7, #4]
 800f7fe:	0011      	movs	r1, r2
 800f800:	0018      	movs	r0, r3
 800f802:	f7ff f9ed 	bl	800ebe0 <HAL_UARTEx_RxEventCallback>
  else
  {
    /* Clear RXNE interrupt flag */
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
  }
}
 800f806:	e00c      	b.n	800f822 <UART_RxISR_8BIT+0x182>
        HAL_UART_RxCpltCallback(huart);
 800f808:	687b      	ldr	r3, [r7, #4]
 800f80a:	0018      	movs	r0, r3
 800f80c:	f7ff f9d8 	bl	800ebc0 <HAL_UART_RxCpltCallback>
}
 800f810:	e007      	b.n	800f822 <UART_RxISR_8BIT+0x182>
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
 800f812:	687b      	ldr	r3, [r7, #4]
 800f814:	681b      	ldr	r3, [r3, #0]
 800f816:	699a      	ldr	r2, [r3, #24]
 800f818:	687b      	ldr	r3, [r7, #4]
 800f81a:	681b      	ldr	r3, [r3, #0]
 800f81c:	2108      	movs	r1, #8
 800f81e:	430a      	orrs	r2, r1
 800f820:	619a      	str	r2, [r3, #24]
}
 800f822:	46c0      	nop			; (mov r8, r8)
 800f824:	46bd      	mov	sp, r7
 800f826:	b011      	add	sp, #68	; 0x44
 800f828:	bd90      	pop	{r4, r7, pc}
 800f82a:	46c0      	nop			; (mov r8, r8)
 800f82c:	40004400 	.word	0x40004400
 800f830:	fffffedf 	.word	0xfffffedf

0800f834 <UART_RxISR_16BIT>:
  *         interruptions have been enabled by HAL_UART_Receive_IT()
  * @param huart UART handle.
  * @retval None
  */
static void UART_RxISR_16BIT(UART_HandleTypeDef *huart)
{
 800f834:	b580      	push	{r7, lr}
 800f836:	b090      	sub	sp, #64	; 0x40
 800f838:	af00      	add	r7, sp, #0
 800f83a:	6078      	str	r0, [r7, #4]
  uint16_t *tmp;
  uint16_t uhMask = huart->Mask;
 800f83c:	203e      	movs	r0, #62	; 0x3e
 800f83e:	183b      	adds	r3, r7, r0
 800f840:	687a      	ldr	r2, [r7, #4]
 800f842:	215c      	movs	r1, #92	; 0x5c
 800f844:	5a52      	ldrh	r2, [r2, r1]
 800f846:	801a      	strh	r2, [r3, #0]
  uint16_t  uhdata;

  /* Check that a Rx process is ongoing */
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 800f848:	687b      	ldr	r3, [r7, #4]
 800f84a:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800f84c:	2b22      	cmp	r3, #34	; 0x22
 800f84e:	d000      	beq.n	800f852 <UART_RxISR_16BIT+0x1e>
 800f850:	e095      	b.n	800f97e <UART_RxISR_16BIT+0x14a>
  {
    uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 800f852:	687b      	ldr	r3, [r7, #4]
 800f854:	681a      	ldr	r2, [r3, #0]
 800f856:	213c      	movs	r1, #60	; 0x3c
 800f858:	187b      	adds	r3, r7, r1
 800f85a:	8c92      	ldrh	r2, [r2, #36]	; 0x24
 800f85c:	801a      	strh	r2, [r3, #0]
    tmp = (uint16_t *) huart->pRxBuffPtr ;
 800f85e:	687b      	ldr	r3, [r7, #4]
 800f860:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800f862:	63bb      	str	r3, [r7, #56]	; 0x38
    *tmp = (uint16_t)(uhdata & uhMask);
 800f864:	187b      	adds	r3, r7, r1
 800f866:	183a      	adds	r2, r7, r0
 800f868:	881b      	ldrh	r3, [r3, #0]
 800f86a:	8812      	ldrh	r2, [r2, #0]
 800f86c:	4013      	ands	r3, r2
 800f86e:	b29a      	uxth	r2, r3
 800f870:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800f872:	801a      	strh	r2, [r3, #0]
    huart->pRxBuffPtr += 2U;
 800f874:	687b      	ldr	r3, [r7, #4]
 800f876:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800f878:	1c9a      	adds	r2, r3, #2
 800f87a:	687b      	ldr	r3, [r7, #4]
 800f87c:	655a      	str	r2, [r3, #84]	; 0x54
    huart->RxXferCount--;
 800f87e:	687b      	ldr	r3, [r7, #4]
 800f880:	225a      	movs	r2, #90	; 0x5a
 800f882:	5a9b      	ldrh	r3, [r3, r2]
 800f884:	b29b      	uxth	r3, r3
 800f886:	3b01      	subs	r3, #1
 800f888:	b299      	uxth	r1, r3
 800f88a:	687b      	ldr	r3, [r7, #4]
 800f88c:	225a      	movs	r2, #90	; 0x5a
 800f88e:	5299      	strh	r1, [r3, r2]

    if (huart->RxXferCount == 0U)
 800f890:	687b      	ldr	r3, [r7, #4]
 800f892:	225a      	movs	r2, #90	; 0x5a
 800f894:	5a9b      	ldrh	r3, [r3, r2]
 800f896:	b29b      	uxth	r3, r3
 800f898:	2b00      	cmp	r3, #0
 800f89a:	d178      	bne.n	800f98e <UART_RxISR_16BIT+0x15a>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800f89c:	f3ef 8310 	mrs	r3, PRIMASK
 800f8a0:	617b      	str	r3, [r7, #20]
  return(result);
 800f8a2:	697b      	ldr	r3, [r7, #20]
    {
      /* Disable the UART Parity Error Interrupt and RXNE interrupt*/
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 800f8a4:	637b      	str	r3, [r7, #52]	; 0x34
 800f8a6:	2301      	movs	r3, #1
 800f8a8:	61bb      	str	r3, [r7, #24]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800f8aa:	69bb      	ldr	r3, [r7, #24]
 800f8ac:	f383 8810 	msr	PRIMASK, r3
}
 800f8b0:	46c0      	nop			; (mov r8, r8)
 800f8b2:	687b      	ldr	r3, [r7, #4]
 800f8b4:	681b      	ldr	r3, [r3, #0]
 800f8b6:	681a      	ldr	r2, [r3, #0]
 800f8b8:	687b      	ldr	r3, [r7, #4]
 800f8ba:	681b      	ldr	r3, [r3, #0]
 800f8bc:	4936      	ldr	r1, [pc, #216]	; (800f998 <UART_RxISR_16BIT+0x164>)
 800f8be:	400a      	ands	r2, r1
 800f8c0:	601a      	str	r2, [r3, #0]
 800f8c2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800f8c4:	61fb      	str	r3, [r7, #28]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800f8c6:	69fb      	ldr	r3, [r7, #28]
 800f8c8:	f383 8810 	msr	PRIMASK, r3
}
 800f8cc:	46c0      	nop			; (mov r8, r8)
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800f8ce:	f3ef 8310 	mrs	r3, PRIMASK
 800f8d2:	623b      	str	r3, [r7, #32]
  return(result);
 800f8d4:	6a3b      	ldr	r3, [r7, #32]

      /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
      ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800f8d6:	633b      	str	r3, [r7, #48]	; 0x30
 800f8d8:	2301      	movs	r3, #1
 800f8da:	627b      	str	r3, [r7, #36]	; 0x24
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800f8dc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800f8de:	f383 8810 	msr	PRIMASK, r3
}
 800f8e2:	46c0      	nop			; (mov r8, r8)
 800f8e4:	687b      	ldr	r3, [r7, #4]
 800f8e6:	681b      	ldr	r3, [r3, #0]
 800f8e8:	689a      	ldr	r2, [r3, #8]
 800f8ea:	687b      	ldr	r3, [r7, #4]
 800f8ec:	681b      	ldr	r3, [r3, #0]
 800f8ee:	2101      	movs	r1, #1
 800f8f0:	438a      	bics	r2, r1
 800f8f2:	609a      	str	r2, [r3, #8]
 800f8f4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800f8f6:	62bb      	str	r3, [r7, #40]	; 0x28
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800f8f8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800f8fa:	f383 8810 	msr	PRIMASK, r3
}
 800f8fe:	46c0      	nop			; (mov r8, r8)

      /* Rx process is completed, restore huart->RxState to Ready */
      huart->RxState = HAL_UART_STATE_READY;
 800f900:	687b      	ldr	r3, [r7, #4]
 800f902:	2220      	movs	r2, #32
 800f904:	67da      	str	r2, [r3, #124]	; 0x7c

      /* Clear RxISR function pointer */
      huart->RxISR = NULL;
 800f906:	687b      	ldr	r3, [r7, #4]
 800f908:	2200      	movs	r2, #0
 800f90a:	665a      	str	r2, [r3, #100]	; 0x64

      /* Check current reception Mode :
         If Reception till IDLE event has been selected : */
      if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 800f90c:	687b      	ldr	r3, [r7, #4]
 800f90e:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 800f910:	2b01      	cmp	r3, #1
 800f912:	d12f      	bne.n	800f974 <UART_RxISR_16BIT+0x140>
      {
        /* Set reception type to Standard */
        huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 800f914:	687b      	ldr	r3, [r7, #4]
 800f916:	2200      	movs	r2, #0
 800f918:	661a      	str	r2, [r3, #96]	; 0x60
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800f91a:	f3ef 8310 	mrs	r3, PRIMASK
 800f91e:	60bb      	str	r3, [r7, #8]
  return(result);
 800f920:	68bb      	ldr	r3, [r7, #8]

        /* Disable IDLE interrupt */
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 800f922:	62fb      	str	r3, [r7, #44]	; 0x2c
 800f924:	2301      	movs	r3, #1
 800f926:	60fb      	str	r3, [r7, #12]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800f928:	68fb      	ldr	r3, [r7, #12]
 800f92a:	f383 8810 	msr	PRIMASK, r3
}
 800f92e:	46c0      	nop			; (mov r8, r8)
 800f930:	687b      	ldr	r3, [r7, #4]
 800f932:	681b      	ldr	r3, [r3, #0]
 800f934:	681a      	ldr	r2, [r3, #0]
 800f936:	687b      	ldr	r3, [r7, #4]
 800f938:	681b      	ldr	r3, [r3, #0]
 800f93a:	2110      	movs	r1, #16
 800f93c:	438a      	bics	r2, r1
 800f93e:	601a      	str	r2, [r3, #0]
 800f940:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800f942:	613b      	str	r3, [r7, #16]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800f944:	693b      	ldr	r3, [r7, #16]
 800f946:	f383 8810 	msr	PRIMASK, r3
}
 800f94a:	46c0      	nop			; (mov r8, r8)

        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE) == SET)
 800f94c:	687b      	ldr	r3, [r7, #4]
 800f94e:	681b      	ldr	r3, [r3, #0]
 800f950:	69db      	ldr	r3, [r3, #28]
 800f952:	2210      	movs	r2, #16
 800f954:	4013      	ands	r3, r2
 800f956:	2b10      	cmp	r3, #16
 800f958:	d103      	bne.n	800f962 <UART_RxISR_16BIT+0x12e>
        {
          /* Clear IDLE Flag */
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_IDLEF);
 800f95a:	687b      	ldr	r3, [r7, #4]
 800f95c:	681b      	ldr	r3, [r3, #0]
 800f95e:	2210      	movs	r2, #16
 800f960:	621a      	str	r2, [r3, #32]
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
        /*Call registered Rx Event callback*/
        huart->RxEventCallback(huart, huart->RxXferSize);
#else
        /*Call legacy weak Rx Event callback*/
        HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 800f962:	687b      	ldr	r3, [r7, #4]
 800f964:	2258      	movs	r2, #88	; 0x58
 800f966:	5a9a      	ldrh	r2, [r3, r2]
 800f968:	687b      	ldr	r3, [r7, #4]
 800f96a:	0011      	movs	r1, r2
 800f96c:	0018      	movs	r0, r3
 800f96e:	f7ff f937 	bl	800ebe0 <HAL_UARTEx_RxEventCallback>
  else
  {
    /* Clear RXNE interrupt flag */
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
  }
}
 800f972:	e00c      	b.n	800f98e <UART_RxISR_16BIT+0x15a>
        HAL_UART_RxCpltCallback(huart);
 800f974:	687b      	ldr	r3, [r7, #4]
 800f976:	0018      	movs	r0, r3
 800f978:	f7ff f922 	bl	800ebc0 <HAL_UART_RxCpltCallback>
}
 800f97c:	e007      	b.n	800f98e <UART_RxISR_16BIT+0x15a>
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
 800f97e:	687b      	ldr	r3, [r7, #4]
 800f980:	681b      	ldr	r3, [r3, #0]
 800f982:	699a      	ldr	r2, [r3, #24]
 800f984:	687b      	ldr	r3, [r7, #4]
 800f986:	681b      	ldr	r3, [r3, #0]
 800f988:	2108      	movs	r1, #8
 800f98a:	430a      	orrs	r2, r1
 800f98c:	619a      	str	r2, [r3, #24]
}
 800f98e:	46c0      	nop			; (mov r8, r8)
 800f990:	46bd      	mov	sp, r7
 800f992:	b010      	add	sp, #64	; 0x40
 800f994:	bd80      	pop	{r7, pc}
 800f996:	46c0      	nop			; (mov r8, r8)
 800f998:	fffffedf 	.word	0xfffffedf

0800f99c <HAL_UARTEx_WakeupCallback>:
  * @brief UART wakeup from Stop mode callback.
  * @param huart UART handle.
  * @retval None
  */
__weak void HAL_UARTEx_WakeupCallback(UART_HandleTypeDef *huart)
{
 800f99c:	b580      	push	{r7, lr}
 800f99e:	b082      	sub	sp, #8
 800f9a0:	af00      	add	r7, sp, #0
 800f9a2:	6078      	str	r0, [r7, #4]
  UNUSED(huart);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_UARTEx_WakeupCallback can be implemented in the user file.
   */
}
 800f9a4:	46c0      	nop			; (mov r8, r8)
 800f9a6:	46bd      	mov	sp, r7
 800f9a8:	b002      	add	sp, #8
 800f9aa:	bd80      	pop	{r7, pc}

0800f9ac <USB_EnableGlobalInt>:
  *         Enables the controller's Global Int in the AHB Config reg
  * @param  USBx Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EnableGlobalInt(USB_TypeDef *USBx)
{
 800f9ac:	b580      	push	{r7, lr}
 800f9ae:	b084      	sub	sp, #16
 800f9b0:	af00      	add	r7, sp, #0
 800f9b2:	6078      	str	r0, [r7, #4]
  uint32_t winterruptmask;

  /* Clear pending interrupts */
  USBx->ISTR = 0U;
 800f9b4:	687b      	ldr	r3, [r7, #4]
 800f9b6:	2244      	movs	r2, #68	; 0x44
 800f9b8:	2100      	movs	r1, #0
 800f9ba:	5299      	strh	r1, [r3, r2]

  /* Set winterruptmask variable */
  winterruptmask = USB_CNTR_CTRM  | USB_CNTR_WKUPM |
 800f9bc:	4b05      	ldr	r3, [pc, #20]	; (800f9d4 <USB_EnableGlobalInt+0x28>)
 800f9be:	60fb      	str	r3, [r7, #12]
                   USB_CNTR_SUSPM | USB_CNTR_ERRM |
                   USB_CNTR_SOFM | USB_CNTR_ESOFM |
                   USB_CNTR_RESETM | USB_CNTR_L1REQM;

  /* Set interrupt mask */
  USBx->CNTR = (uint16_t)winterruptmask;
 800f9c0:	68fb      	ldr	r3, [r7, #12]
 800f9c2:	b299      	uxth	r1, r3
 800f9c4:	687b      	ldr	r3, [r7, #4]
 800f9c6:	2240      	movs	r2, #64	; 0x40
 800f9c8:	5299      	strh	r1, [r3, r2]

  return HAL_OK;
 800f9ca:	2300      	movs	r3, #0
}
 800f9cc:	0018      	movs	r0, r3
 800f9ce:	46bd      	mov	sp, r7
 800f9d0:	b004      	add	sp, #16
 800f9d2:	bd80      	pop	{r7, pc}
 800f9d4:	0000bf80 	.word	0x0000bf80

0800f9d8 <USB_DisableGlobalInt>:
  *         Disable the controller's Global Int in the AHB Config reg
  * @param  USBx Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DisableGlobalInt(USB_TypeDef *USBx)
{
 800f9d8:	b580      	push	{r7, lr}
 800f9da:	b084      	sub	sp, #16
 800f9dc:	af00      	add	r7, sp, #0
 800f9de:	6078      	str	r0, [r7, #4]
  uint32_t winterruptmask;

  /* Set winterruptmask variable */
  winterruptmask = USB_CNTR_CTRM  | USB_CNTR_WKUPM |
 800f9e0:	4b09      	ldr	r3, [pc, #36]	; (800fa08 <USB_DisableGlobalInt+0x30>)
 800f9e2:	60fb      	str	r3, [r7, #12]
                   USB_CNTR_SUSPM | USB_CNTR_ERRM |
                   USB_CNTR_SOFM | USB_CNTR_ESOFM |
                   USB_CNTR_RESETM | USB_CNTR_L1REQM;

  /* Clear interrupt mask */
  USBx->CNTR &= (uint16_t)(~winterruptmask);
 800f9e4:	687b      	ldr	r3, [r7, #4]
 800f9e6:	2240      	movs	r2, #64	; 0x40
 800f9e8:	5a9b      	ldrh	r3, [r3, r2]
 800f9ea:	b29b      	uxth	r3, r3
 800f9ec:	68fa      	ldr	r2, [r7, #12]
 800f9ee:	b292      	uxth	r2, r2
 800f9f0:	43d2      	mvns	r2, r2
 800f9f2:	b292      	uxth	r2, r2
 800f9f4:	4013      	ands	r3, r2
 800f9f6:	b299      	uxth	r1, r3
 800f9f8:	687b      	ldr	r3, [r7, #4]
 800f9fa:	2240      	movs	r2, #64	; 0x40
 800f9fc:	5299      	strh	r1, [r3, r2]

  return HAL_OK;
 800f9fe:	2300      	movs	r3, #0
}
 800fa00:	0018      	movs	r0, r3
 800fa02:	46bd      	mov	sp, r7
 800fa04:	b004      	add	sp, #16
 800fa06:	bd80      	pop	{r7, pc}
 800fa08:	0000bf80 	.word	0x0000bf80

0800fa0c <USB_DevInit>:
  * @param  cfg  pointer to a USB_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DevInit(USB_TypeDef *USBx, USB_CfgTypeDef cfg)
{
 800fa0c:	b084      	sub	sp, #16
 800fa0e:	b590      	push	{r4, r7, lr}
 800fa10:	46c6      	mov	lr, r8
 800fa12:	b500      	push	{lr}
 800fa14:	b082      	sub	sp, #8
 800fa16:	af00      	add	r7, sp, #0
 800fa18:	6078      	str	r0, [r7, #4]
 800fa1a:	2004      	movs	r0, #4
 800fa1c:	2410      	movs	r4, #16
 800fa1e:	46a4      	mov	ip, r4
 800fa20:	2408      	movs	r4, #8
 800fa22:	46a0      	mov	r8, r4
 800fa24:	44b8      	add	r8, r7
 800fa26:	44c4      	add	ip, r8
 800fa28:	4460      	add	r0, ip
 800fa2a:	6001      	str	r1, [r0, #0]
 800fa2c:	6042      	str	r2, [r0, #4]
 800fa2e:	6083      	str	r3, [r0, #8]
  /* Prevent unused argument(s) compilation warning */
  UNUSED(cfg);

  /* Init Device */
  /* CNTR_FRES = 1 */
  USBx->CNTR = (uint16_t)USB_CNTR_FRES;
 800fa30:	687b      	ldr	r3, [r7, #4]
 800fa32:	2240      	movs	r2, #64	; 0x40
 800fa34:	2101      	movs	r1, #1
 800fa36:	5299      	strh	r1, [r3, r2]

  /* CNTR_FRES = 0 */
  USBx->CNTR = 0U;
 800fa38:	687b      	ldr	r3, [r7, #4]
 800fa3a:	2240      	movs	r2, #64	; 0x40
 800fa3c:	2100      	movs	r1, #0
 800fa3e:	5299      	strh	r1, [r3, r2]

  /* Clear pending interrupts */
  USBx->ISTR = 0U;
 800fa40:	687b      	ldr	r3, [r7, #4]
 800fa42:	2244      	movs	r2, #68	; 0x44
 800fa44:	2100      	movs	r1, #0
 800fa46:	5299      	strh	r1, [r3, r2]

  /*Set Btable Address*/
  USBx->BTABLE = BTABLE_ADDRESS;
 800fa48:	687b      	ldr	r3, [r7, #4]
 800fa4a:	2250      	movs	r2, #80	; 0x50
 800fa4c:	2100      	movs	r1, #0
 800fa4e:	5299      	strh	r1, [r3, r2]

  return HAL_OK;
 800fa50:	2300      	movs	r3, #0
}
 800fa52:	0018      	movs	r0, r3
 800fa54:	46bd      	mov	sp, r7
 800fa56:	b002      	add	sp, #8
 800fa58:	bc80      	pop	{r7}
 800fa5a:	46b8      	mov	r8, r7
 800fa5c:	bc90      	pop	{r4, r7}
 800fa5e:	bc08      	pop	{r3}
 800fa60:	b004      	add	sp, #16
 800fa62:	4718      	bx	r3

0800fa64 <USB_ActivateEndpoint>:
  * @param  USBx Selected device
  * @param  ep pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_ActivateEndpoint(USB_TypeDef *USBx, USB_EPTypeDef *ep)
{
 800fa64:	b580      	push	{r7, lr}
 800fa66:	b09c      	sub	sp, #112	; 0x70
 800fa68:	af00      	add	r7, sp, #0
 800fa6a:	6078      	str	r0, [r7, #4]
 800fa6c:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef ret = HAL_OK;
 800fa6e:	236f      	movs	r3, #111	; 0x6f
 800fa70:	18fb      	adds	r3, r7, r3
 800fa72:	2200      	movs	r2, #0
 800fa74:	701a      	strb	r2, [r3, #0]
  uint16_t wEpRegVal;

  wEpRegVal = PCD_GET_ENDPOINT(USBx, ep->num) & USB_EP_T_MASK;
 800fa76:	687a      	ldr	r2, [r7, #4]
 800fa78:	683b      	ldr	r3, [r7, #0]
 800fa7a:	781b      	ldrb	r3, [r3, #0]
 800fa7c:	009b      	lsls	r3, r3, #2
 800fa7e:	18d3      	adds	r3, r2, r3
 800fa80:	881b      	ldrh	r3, [r3, #0]
 800fa82:	b29a      	uxth	r2, r3
 800fa84:	236c      	movs	r3, #108	; 0x6c
 800fa86:	18fb      	adds	r3, r7, r3
 800fa88:	49cf      	ldr	r1, [pc, #828]	; (800fdc8 <USB_ActivateEndpoint+0x364>)
 800fa8a:	400a      	ands	r2, r1
 800fa8c:	801a      	strh	r2, [r3, #0]

  /* initialize Endpoint */
  switch (ep->type)
 800fa8e:	683b      	ldr	r3, [r7, #0]
 800fa90:	78db      	ldrb	r3, [r3, #3]
 800fa92:	2b03      	cmp	r3, #3
 800fa94:	d017      	beq.n	800fac6 <USB_ActivateEndpoint+0x62>
 800fa96:	dc28      	bgt.n	800faea <USB_ActivateEndpoint+0x86>
 800fa98:	2b02      	cmp	r3, #2
 800fa9a:	d00e      	beq.n	800faba <USB_ActivateEndpoint+0x56>
 800fa9c:	dc25      	bgt.n	800faea <USB_ActivateEndpoint+0x86>
 800fa9e:	2b00      	cmp	r3, #0
 800faa0:	d002      	beq.n	800faa8 <USB_ActivateEndpoint+0x44>
 800faa2:	2b01      	cmp	r3, #1
 800faa4:	d018      	beq.n	800fad8 <USB_ActivateEndpoint+0x74>
 800faa6:	e020      	b.n	800faea <USB_ActivateEndpoint+0x86>
  {
    case EP_TYPE_CTRL:
      wEpRegVal |= USB_EP_CONTROL;
 800faa8:	226c      	movs	r2, #108	; 0x6c
 800faaa:	18bb      	adds	r3, r7, r2
 800faac:	18ba      	adds	r2, r7, r2
 800faae:	8812      	ldrh	r2, [r2, #0]
 800fab0:	2180      	movs	r1, #128	; 0x80
 800fab2:	0089      	lsls	r1, r1, #2
 800fab4:	430a      	orrs	r2, r1
 800fab6:	801a      	strh	r2, [r3, #0]
      break;
 800fab8:	e01c      	b.n	800faf4 <USB_ActivateEndpoint+0x90>

    case EP_TYPE_BULK:
      wEpRegVal |= USB_EP_BULK;
 800faba:	226c      	movs	r2, #108	; 0x6c
 800fabc:	18bb      	adds	r3, r7, r2
 800fabe:	18ba      	adds	r2, r7, r2
 800fac0:	8812      	ldrh	r2, [r2, #0]
 800fac2:	801a      	strh	r2, [r3, #0]
      break;
 800fac4:	e016      	b.n	800faf4 <USB_ActivateEndpoint+0x90>

    case EP_TYPE_INTR:
      wEpRegVal |= USB_EP_INTERRUPT;
 800fac6:	226c      	movs	r2, #108	; 0x6c
 800fac8:	18bb      	adds	r3, r7, r2
 800faca:	18ba      	adds	r2, r7, r2
 800facc:	8812      	ldrh	r2, [r2, #0]
 800face:	21c0      	movs	r1, #192	; 0xc0
 800fad0:	00c9      	lsls	r1, r1, #3
 800fad2:	430a      	orrs	r2, r1
 800fad4:	801a      	strh	r2, [r3, #0]
      break;
 800fad6:	e00d      	b.n	800faf4 <USB_ActivateEndpoint+0x90>

    case EP_TYPE_ISOC:
      wEpRegVal |= USB_EP_ISOCHRONOUS;
 800fad8:	226c      	movs	r2, #108	; 0x6c
 800fada:	18bb      	adds	r3, r7, r2
 800fadc:	18ba      	adds	r2, r7, r2
 800fade:	8812      	ldrh	r2, [r2, #0]
 800fae0:	2180      	movs	r1, #128	; 0x80
 800fae2:	00c9      	lsls	r1, r1, #3
 800fae4:	430a      	orrs	r2, r1
 800fae6:	801a      	strh	r2, [r3, #0]
      break;
 800fae8:	e004      	b.n	800faf4 <USB_ActivateEndpoint+0x90>

    default:
      ret = HAL_ERROR;
 800faea:	236f      	movs	r3, #111	; 0x6f
 800faec:	18fb      	adds	r3, r7, r3
 800faee:	2201      	movs	r2, #1
 800faf0:	701a      	strb	r2, [r3, #0]
      break;
 800faf2:	46c0      	nop			; (mov r8, r8)
  }

  PCD_SET_ENDPOINT(USBx, ep->num, (wEpRegVal | USB_EP_CTR_RX | USB_EP_CTR_TX));
 800faf4:	687a      	ldr	r2, [r7, #4]
 800faf6:	683b      	ldr	r3, [r7, #0]
 800faf8:	781b      	ldrb	r3, [r3, #0]
 800fafa:	009b      	lsls	r3, r3, #2
 800fafc:	18d3      	adds	r3, r2, r3
 800fafe:	226c      	movs	r2, #108	; 0x6c
 800fb00:	18ba      	adds	r2, r7, r2
 800fb02:	8812      	ldrh	r2, [r2, #0]
 800fb04:	49b1      	ldr	r1, [pc, #708]	; (800fdcc <USB_ActivateEndpoint+0x368>)
 800fb06:	430a      	orrs	r2, r1
 800fb08:	b292      	uxth	r2, r2
 800fb0a:	801a      	strh	r2, [r3, #0]

  PCD_SET_EP_ADDRESS(USBx, ep->num, ep->num);
 800fb0c:	687a      	ldr	r2, [r7, #4]
 800fb0e:	683b      	ldr	r3, [r7, #0]
 800fb10:	781b      	ldrb	r3, [r3, #0]
 800fb12:	009b      	lsls	r3, r3, #2
 800fb14:	18d3      	adds	r3, r2, r3
 800fb16:	881b      	ldrh	r3, [r3, #0]
 800fb18:	b29b      	uxth	r3, r3
 800fb1a:	b21b      	sxth	r3, r3
 800fb1c:	4aac      	ldr	r2, [pc, #688]	; (800fdd0 <USB_ActivateEndpoint+0x36c>)
 800fb1e:	4013      	ands	r3, r2
 800fb20:	b21a      	sxth	r2, r3
 800fb22:	683b      	ldr	r3, [r7, #0]
 800fb24:	781b      	ldrb	r3, [r3, #0]
 800fb26:	b21b      	sxth	r3, r3
 800fb28:	4313      	orrs	r3, r2
 800fb2a:	b21a      	sxth	r2, r3
 800fb2c:	2166      	movs	r1, #102	; 0x66
 800fb2e:	187b      	adds	r3, r7, r1
 800fb30:	801a      	strh	r2, [r3, #0]
 800fb32:	687a      	ldr	r2, [r7, #4]
 800fb34:	683b      	ldr	r3, [r7, #0]
 800fb36:	781b      	ldrb	r3, [r3, #0]
 800fb38:	009b      	lsls	r3, r3, #2
 800fb3a:	18d3      	adds	r3, r2, r3
 800fb3c:	187a      	adds	r2, r7, r1
 800fb3e:	8812      	ldrh	r2, [r2, #0]
 800fb40:	49a2      	ldr	r1, [pc, #648]	; (800fdcc <USB_ActivateEndpoint+0x368>)
 800fb42:	430a      	orrs	r2, r1
 800fb44:	b292      	uxth	r2, r2
 800fb46:	801a      	strh	r2, [r3, #0]

  if (ep->doublebuffer == 0U)
 800fb48:	683b      	ldr	r3, [r7, #0]
 800fb4a:	7b1b      	ldrb	r3, [r3, #12]
 800fb4c:	2b00      	cmp	r3, #0
 800fb4e:	d000      	beq.n	800fb52 <USB_ActivateEndpoint+0xee>
 800fb50:	e150      	b.n	800fdf4 <USB_ActivateEndpoint+0x390>
  {
    if (ep->is_in != 0U)
 800fb52:	683b      	ldr	r3, [r7, #0]
 800fb54:	785b      	ldrb	r3, [r3, #1]
 800fb56:	2b00      	cmp	r3, #0
 800fb58:	d100      	bne.n	800fb5c <USB_ActivateEndpoint+0xf8>
 800fb5a:	e07a      	b.n	800fc52 <USB_ActivateEndpoint+0x1ee>
    {
      /*Set the endpoint Transmit buffer address */
      PCD_SET_EP_TX_ADDRESS(USBx, ep->num, ep->pmaadress);
 800fb5c:	687b      	ldr	r3, [r7, #4]
 800fb5e:	61bb      	str	r3, [r7, #24]
 800fb60:	687b      	ldr	r3, [r7, #4]
 800fb62:	2250      	movs	r2, #80	; 0x50
 800fb64:	5a9b      	ldrh	r3, [r3, r2]
 800fb66:	b29b      	uxth	r3, r3
 800fb68:	001a      	movs	r2, r3
 800fb6a:	69bb      	ldr	r3, [r7, #24]
 800fb6c:	189b      	adds	r3, r3, r2
 800fb6e:	61bb      	str	r3, [r7, #24]
 800fb70:	683b      	ldr	r3, [r7, #0]
 800fb72:	781b      	ldrb	r3, [r3, #0]
 800fb74:	00da      	lsls	r2, r3, #3
 800fb76:	69bb      	ldr	r3, [r7, #24]
 800fb78:	18d3      	adds	r3, r2, r3
 800fb7a:	2280      	movs	r2, #128	; 0x80
 800fb7c:	00d2      	lsls	r2, r2, #3
 800fb7e:	4694      	mov	ip, r2
 800fb80:	4463      	add	r3, ip
 800fb82:	617b      	str	r3, [r7, #20]
 800fb84:	683b      	ldr	r3, [r7, #0]
 800fb86:	88db      	ldrh	r3, [r3, #6]
 800fb88:	085b      	lsrs	r3, r3, #1
 800fb8a:	b29b      	uxth	r3, r3
 800fb8c:	18db      	adds	r3, r3, r3
 800fb8e:	b29a      	uxth	r2, r3
 800fb90:	697b      	ldr	r3, [r7, #20]
 800fb92:	801a      	strh	r2, [r3, #0]
      PCD_CLEAR_TX_DTOG(USBx, ep->num);
 800fb94:	687a      	ldr	r2, [r7, #4]
 800fb96:	683b      	ldr	r3, [r7, #0]
 800fb98:	781b      	ldrb	r3, [r3, #0]
 800fb9a:	009b      	lsls	r3, r3, #2
 800fb9c:	18d2      	adds	r2, r2, r3
 800fb9e:	2112      	movs	r1, #18
 800fba0:	187b      	adds	r3, r7, r1
 800fba2:	8812      	ldrh	r2, [r2, #0]
 800fba4:	801a      	strh	r2, [r3, #0]
 800fba6:	187b      	adds	r3, r7, r1
 800fba8:	881b      	ldrh	r3, [r3, #0]
 800fbaa:	2240      	movs	r2, #64	; 0x40
 800fbac:	4013      	ands	r3, r2
 800fbae:	d016      	beq.n	800fbde <USB_ActivateEndpoint+0x17a>
 800fbb0:	687a      	ldr	r2, [r7, #4]
 800fbb2:	683b      	ldr	r3, [r7, #0]
 800fbb4:	781b      	ldrb	r3, [r3, #0]
 800fbb6:	009b      	lsls	r3, r3, #2
 800fbb8:	18d3      	adds	r3, r2, r3
 800fbba:	881b      	ldrh	r3, [r3, #0]
 800fbbc:	b29a      	uxth	r2, r3
 800fbbe:	2010      	movs	r0, #16
 800fbc0:	183b      	adds	r3, r7, r0
 800fbc2:	4983      	ldr	r1, [pc, #524]	; (800fdd0 <USB_ActivateEndpoint+0x36c>)
 800fbc4:	400a      	ands	r2, r1
 800fbc6:	801a      	strh	r2, [r3, #0]
 800fbc8:	687a      	ldr	r2, [r7, #4]
 800fbca:	683b      	ldr	r3, [r7, #0]
 800fbcc:	781b      	ldrb	r3, [r3, #0]
 800fbce:	009b      	lsls	r3, r3, #2
 800fbd0:	18d3      	adds	r3, r2, r3
 800fbd2:	183a      	adds	r2, r7, r0
 800fbd4:	8812      	ldrh	r2, [r2, #0]
 800fbd6:	497f      	ldr	r1, [pc, #508]	; (800fdd4 <USB_ActivateEndpoint+0x370>)
 800fbd8:	430a      	orrs	r2, r1
 800fbda:	b292      	uxth	r2, r2
 800fbdc:	801a      	strh	r2, [r3, #0]

      if (ep->type != EP_TYPE_ISOC)
 800fbde:	683b      	ldr	r3, [r7, #0]
 800fbe0:	78db      	ldrb	r3, [r3, #3]
 800fbe2:	2b01      	cmp	r3, #1
 800fbe4:	d01d      	beq.n	800fc22 <USB_ActivateEndpoint+0x1be>
      {
        /* Configure NAK status for the Endpoint */
        PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_NAK);
 800fbe6:	687a      	ldr	r2, [r7, #4]
 800fbe8:	683b      	ldr	r3, [r7, #0]
 800fbea:	781b      	ldrb	r3, [r3, #0]
 800fbec:	009b      	lsls	r3, r3, #2
 800fbee:	18d3      	adds	r3, r2, r3
 800fbf0:	881b      	ldrh	r3, [r3, #0]
 800fbf2:	b29a      	uxth	r2, r3
 800fbf4:	200c      	movs	r0, #12
 800fbf6:	183b      	adds	r3, r7, r0
 800fbf8:	4977      	ldr	r1, [pc, #476]	; (800fdd8 <USB_ActivateEndpoint+0x374>)
 800fbfa:	400a      	ands	r2, r1
 800fbfc:	801a      	strh	r2, [r3, #0]
 800fbfe:	183b      	adds	r3, r7, r0
 800fc00:	183a      	adds	r2, r7, r0
 800fc02:	8812      	ldrh	r2, [r2, #0]
 800fc04:	2120      	movs	r1, #32
 800fc06:	404a      	eors	r2, r1
 800fc08:	801a      	strh	r2, [r3, #0]
 800fc0a:	687a      	ldr	r2, [r7, #4]
 800fc0c:	683b      	ldr	r3, [r7, #0]
 800fc0e:	781b      	ldrb	r3, [r3, #0]
 800fc10:	009b      	lsls	r3, r3, #2
 800fc12:	18d3      	adds	r3, r2, r3
 800fc14:	183a      	adds	r2, r7, r0
 800fc16:	8812      	ldrh	r2, [r2, #0]
 800fc18:	496c      	ldr	r1, [pc, #432]	; (800fdcc <USB_ActivateEndpoint+0x368>)
 800fc1a:	430a      	orrs	r2, r1
 800fc1c:	b292      	uxth	r2, r2
 800fc1e:	801a      	strh	r2, [r3, #0]
 800fc20:	e27a      	b.n	8010118 <USB_ActivateEndpoint+0x6b4>
      }
      else
      {
        /* Configure TX Endpoint to disabled state */
        PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_DIS);
 800fc22:	687a      	ldr	r2, [r7, #4]
 800fc24:	683b      	ldr	r3, [r7, #0]
 800fc26:	781b      	ldrb	r3, [r3, #0]
 800fc28:	009b      	lsls	r3, r3, #2
 800fc2a:	18d3      	adds	r3, r2, r3
 800fc2c:	881b      	ldrh	r3, [r3, #0]
 800fc2e:	b29a      	uxth	r2, r3
 800fc30:	200e      	movs	r0, #14
 800fc32:	183b      	adds	r3, r7, r0
 800fc34:	4968      	ldr	r1, [pc, #416]	; (800fdd8 <USB_ActivateEndpoint+0x374>)
 800fc36:	400a      	ands	r2, r1
 800fc38:	801a      	strh	r2, [r3, #0]
 800fc3a:	687a      	ldr	r2, [r7, #4]
 800fc3c:	683b      	ldr	r3, [r7, #0]
 800fc3e:	781b      	ldrb	r3, [r3, #0]
 800fc40:	009b      	lsls	r3, r3, #2
 800fc42:	18d3      	adds	r3, r2, r3
 800fc44:	183a      	adds	r2, r7, r0
 800fc46:	8812      	ldrh	r2, [r2, #0]
 800fc48:	4960      	ldr	r1, [pc, #384]	; (800fdcc <USB_ActivateEndpoint+0x368>)
 800fc4a:	430a      	orrs	r2, r1
 800fc4c:	b292      	uxth	r2, r2
 800fc4e:	801a      	strh	r2, [r3, #0]
 800fc50:	e262      	b.n	8010118 <USB_ActivateEndpoint+0x6b4>
      }
    }
    else
    {
      /* Set the endpoint Receive buffer address */
      PCD_SET_EP_RX_ADDRESS(USBx, ep->num, ep->pmaadress);
 800fc52:	687b      	ldr	r3, [r7, #4]
 800fc54:	633b      	str	r3, [r7, #48]	; 0x30
 800fc56:	687b      	ldr	r3, [r7, #4]
 800fc58:	2250      	movs	r2, #80	; 0x50
 800fc5a:	5a9b      	ldrh	r3, [r3, r2]
 800fc5c:	b29b      	uxth	r3, r3
 800fc5e:	001a      	movs	r2, r3
 800fc60:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800fc62:	189b      	adds	r3, r3, r2
 800fc64:	633b      	str	r3, [r7, #48]	; 0x30
 800fc66:	683b      	ldr	r3, [r7, #0]
 800fc68:	781b      	ldrb	r3, [r3, #0]
 800fc6a:	00da      	lsls	r2, r3, #3
 800fc6c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800fc6e:	18d3      	adds	r3, r2, r3
 800fc70:	4a5a      	ldr	r2, [pc, #360]	; (800fddc <USB_ActivateEndpoint+0x378>)
 800fc72:	4694      	mov	ip, r2
 800fc74:	4463      	add	r3, ip
 800fc76:	62fb      	str	r3, [r7, #44]	; 0x2c
 800fc78:	683b      	ldr	r3, [r7, #0]
 800fc7a:	88db      	ldrh	r3, [r3, #6]
 800fc7c:	085b      	lsrs	r3, r3, #1
 800fc7e:	b29b      	uxth	r3, r3
 800fc80:	18db      	adds	r3, r3, r3
 800fc82:	b29a      	uxth	r2, r3
 800fc84:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800fc86:	801a      	strh	r2, [r3, #0]

      /* Set the endpoint Receive buffer counter */
      PCD_SET_EP_RX_CNT(USBx, ep->num, ep->maxpacket);
 800fc88:	687b      	ldr	r3, [r7, #4]
 800fc8a:	62bb      	str	r3, [r7, #40]	; 0x28
 800fc8c:	687b      	ldr	r3, [r7, #4]
 800fc8e:	2250      	movs	r2, #80	; 0x50
 800fc90:	5a9b      	ldrh	r3, [r3, r2]
 800fc92:	b29b      	uxth	r3, r3
 800fc94:	001a      	movs	r2, r3
 800fc96:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800fc98:	189b      	adds	r3, r3, r2
 800fc9a:	62bb      	str	r3, [r7, #40]	; 0x28
 800fc9c:	683b      	ldr	r3, [r7, #0]
 800fc9e:	781b      	ldrb	r3, [r3, #0]
 800fca0:	00da      	lsls	r2, r3, #3
 800fca2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800fca4:	18d3      	adds	r3, r2, r3
 800fca6:	4a4e      	ldr	r2, [pc, #312]	; (800fde0 <USB_ActivateEndpoint+0x37c>)
 800fca8:	4694      	mov	ip, r2
 800fcaa:	4463      	add	r3, ip
 800fcac:	627b      	str	r3, [r7, #36]	; 0x24
 800fcae:	683b      	ldr	r3, [r7, #0]
 800fcb0:	691b      	ldr	r3, [r3, #16]
 800fcb2:	2b00      	cmp	r3, #0
 800fcb4:	d110      	bne.n	800fcd8 <USB_ActivateEndpoint+0x274>
 800fcb6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800fcb8:	881b      	ldrh	r3, [r3, #0]
 800fcba:	b29b      	uxth	r3, r3
 800fcbc:	4a49      	ldr	r2, [pc, #292]	; (800fde4 <USB_ActivateEndpoint+0x380>)
 800fcbe:	4013      	ands	r3, r2
 800fcc0:	b29a      	uxth	r2, r3
 800fcc2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800fcc4:	801a      	strh	r2, [r3, #0]
 800fcc6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800fcc8:	881b      	ldrh	r3, [r3, #0]
 800fcca:	b29b      	uxth	r3, r3
 800fccc:	4a46      	ldr	r2, [pc, #280]	; (800fde8 <USB_ActivateEndpoint+0x384>)
 800fcce:	4313      	orrs	r3, r2
 800fcd0:	b29a      	uxth	r2, r3
 800fcd2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800fcd4:	801a      	strh	r2, [r3, #0]
 800fcd6:	e02b      	b.n	800fd30 <USB_ActivateEndpoint+0x2cc>
 800fcd8:	683b      	ldr	r3, [r7, #0]
 800fcda:	691b      	ldr	r3, [r3, #16]
 800fcdc:	2b3e      	cmp	r3, #62	; 0x3e
 800fcde:	d812      	bhi.n	800fd06 <USB_ActivateEndpoint+0x2a2>
 800fce0:	683b      	ldr	r3, [r7, #0]
 800fce2:	691b      	ldr	r3, [r3, #16]
 800fce4:	085b      	lsrs	r3, r3, #1
 800fce6:	66bb      	str	r3, [r7, #104]	; 0x68
 800fce8:	683b      	ldr	r3, [r7, #0]
 800fcea:	691b      	ldr	r3, [r3, #16]
 800fcec:	2201      	movs	r2, #1
 800fcee:	4013      	ands	r3, r2
 800fcf0:	d002      	beq.n	800fcf8 <USB_ActivateEndpoint+0x294>
 800fcf2:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800fcf4:	3301      	adds	r3, #1
 800fcf6:	66bb      	str	r3, [r7, #104]	; 0x68
 800fcf8:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800fcfa:	b29b      	uxth	r3, r3
 800fcfc:	029b      	lsls	r3, r3, #10
 800fcfe:	b29a      	uxth	r2, r3
 800fd00:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800fd02:	801a      	strh	r2, [r3, #0]
 800fd04:	e014      	b.n	800fd30 <USB_ActivateEndpoint+0x2cc>
 800fd06:	683b      	ldr	r3, [r7, #0]
 800fd08:	691b      	ldr	r3, [r3, #16]
 800fd0a:	095b      	lsrs	r3, r3, #5
 800fd0c:	66bb      	str	r3, [r7, #104]	; 0x68
 800fd0e:	683b      	ldr	r3, [r7, #0]
 800fd10:	691b      	ldr	r3, [r3, #16]
 800fd12:	221f      	movs	r2, #31
 800fd14:	4013      	ands	r3, r2
 800fd16:	d102      	bne.n	800fd1e <USB_ActivateEndpoint+0x2ba>
 800fd18:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800fd1a:	3b01      	subs	r3, #1
 800fd1c:	66bb      	str	r3, [r7, #104]	; 0x68
 800fd1e:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800fd20:	b29b      	uxth	r3, r3
 800fd22:	029b      	lsls	r3, r3, #10
 800fd24:	b29b      	uxth	r3, r3
 800fd26:	4a30      	ldr	r2, [pc, #192]	; (800fde8 <USB_ActivateEndpoint+0x384>)
 800fd28:	4313      	orrs	r3, r2
 800fd2a:	b29a      	uxth	r2, r3
 800fd2c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800fd2e:	801a      	strh	r2, [r3, #0]
      PCD_CLEAR_RX_DTOG(USBx, ep->num);
 800fd30:	687a      	ldr	r2, [r7, #4]
 800fd32:	683b      	ldr	r3, [r7, #0]
 800fd34:	781b      	ldrb	r3, [r3, #0]
 800fd36:	009b      	lsls	r3, r3, #2
 800fd38:	18d2      	adds	r2, r2, r3
 800fd3a:	2122      	movs	r1, #34	; 0x22
 800fd3c:	187b      	adds	r3, r7, r1
 800fd3e:	8812      	ldrh	r2, [r2, #0]
 800fd40:	801a      	strh	r2, [r3, #0]
 800fd42:	187b      	adds	r3, r7, r1
 800fd44:	881a      	ldrh	r2, [r3, #0]
 800fd46:	2380      	movs	r3, #128	; 0x80
 800fd48:	01db      	lsls	r3, r3, #7
 800fd4a:	4013      	ands	r3, r2
 800fd4c:	d016      	beq.n	800fd7c <USB_ActivateEndpoint+0x318>
 800fd4e:	687a      	ldr	r2, [r7, #4]
 800fd50:	683b      	ldr	r3, [r7, #0]
 800fd52:	781b      	ldrb	r3, [r3, #0]
 800fd54:	009b      	lsls	r3, r3, #2
 800fd56:	18d3      	adds	r3, r2, r3
 800fd58:	881b      	ldrh	r3, [r3, #0]
 800fd5a:	b29a      	uxth	r2, r3
 800fd5c:	2020      	movs	r0, #32
 800fd5e:	183b      	adds	r3, r7, r0
 800fd60:	491b      	ldr	r1, [pc, #108]	; (800fdd0 <USB_ActivateEndpoint+0x36c>)
 800fd62:	400a      	ands	r2, r1
 800fd64:	801a      	strh	r2, [r3, #0]
 800fd66:	687a      	ldr	r2, [r7, #4]
 800fd68:	683b      	ldr	r3, [r7, #0]
 800fd6a:	781b      	ldrb	r3, [r3, #0]
 800fd6c:	009b      	lsls	r3, r3, #2
 800fd6e:	18d3      	adds	r3, r2, r3
 800fd70:	183a      	adds	r2, r7, r0
 800fd72:	8812      	ldrh	r2, [r2, #0]
 800fd74:	491d      	ldr	r1, [pc, #116]	; (800fdec <USB_ActivateEndpoint+0x388>)
 800fd76:	430a      	orrs	r2, r1
 800fd78:	b292      	uxth	r2, r2
 800fd7a:	801a      	strh	r2, [r3, #0]

      /* Configure VALID status for the Endpoint */
      PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_VALID);
 800fd7c:	687a      	ldr	r2, [r7, #4]
 800fd7e:	683b      	ldr	r3, [r7, #0]
 800fd80:	781b      	ldrb	r3, [r3, #0]
 800fd82:	009b      	lsls	r3, r3, #2
 800fd84:	18d3      	adds	r3, r2, r3
 800fd86:	881b      	ldrh	r3, [r3, #0]
 800fd88:	b29a      	uxth	r2, r3
 800fd8a:	201e      	movs	r0, #30
 800fd8c:	183b      	adds	r3, r7, r0
 800fd8e:	4918      	ldr	r1, [pc, #96]	; (800fdf0 <USB_ActivateEndpoint+0x38c>)
 800fd90:	400a      	ands	r2, r1
 800fd92:	801a      	strh	r2, [r3, #0]
 800fd94:	183b      	adds	r3, r7, r0
 800fd96:	183a      	adds	r2, r7, r0
 800fd98:	8812      	ldrh	r2, [r2, #0]
 800fd9a:	2180      	movs	r1, #128	; 0x80
 800fd9c:	0149      	lsls	r1, r1, #5
 800fd9e:	404a      	eors	r2, r1
 800fda0:	801a      	strh	r2, [r3, #0]
 800fda2:	183b      	adds	r3, r7, r0
 800fda4:	183a      	adds	r2, r7, r0
 800fda6:	8812      	ldrh	r2, [r2, #0]
 800fda8:	2180      	movs	r1, #128	; 0x80
 800fdaa:	0189      	lsls	r1, r1, #6
 800fdac:	404a      	eors	r2, r1
 800fdae:	801a      	strh	r2, [r3, #0]
 800fdb0:	687a      	ldr	r2, [r7, #4]
 800fdb2:	683b      	ldr	r3, [r7, #0]
 800fdb4:	781b      	ldrb	r3, [r3, #0]
 800fdb6:	009b      	lsls	r3, r3, #2
 800fdb8:	18d3      	adds	r3, r2, r3
 800fdba:	183a      	adds	r2, r7, r0
 800fdbc:	8812      	ldrh	r2, [r2, #0]
 800fdbe:	4903      	ldr	r1, [pc, #12]	; (800fdcc <USB_ActivateEndpoint+0x368>)
 800fdc0:	430a      	orrs	r2, r1
 800fdc2:	b292      	uxth	r2, r2
 800fdc4:	801a      	strh	r2, [r3, #0]
 800fdc6:	e1a7      	b.n	8010118 <USB_ActivateEndpoint+0x6b4>
 800fdc8:	ffff898f 	.word	0xffff898f
 800fdcc:	ffff8080 	.word	0xffff8080
 800fdd0:	ffff8f8f 	.word	0xffff8f8f
 800fdd4:	ffff80c0 	.word	0xffff80c0
 800fdd8:	ffff8fbf 	.word	0xffff8fbf
 800fddc:	00000404 	.word	0x00000404
 800fde0:	00000406 	.word	0x00000406
 800fde4:	ffff83ff 	.word	0xffff83ff
 800fde8:	ffff8000 	.word	0xffff8000
 800fdec:	ffffc080 	.word	0xffffc080
 800fdf0:	ffffbf8f 	.word	0xffffbf8f
    }
  }
  /* Double Buffer */
  else
  {
    if (ep->type == EP_TYPE_BULK)
 800fdf4:	683b      	ldr	r3, [r7, #0]
 800fdf6:	78db      	ldrb	r3, [r3, #3]
 800fdf8:	2b02      	cmp	r3, #2
 800fdfa:	d117      	bne.n	800fe2c <USB_ActivateEndpoint+0x3c8>
    {
      /* Set bulk endpoint as double buffered */
      PCD_SET_BULK_EP_DBUF(USBx, ep->num);
 800fdfc:	687a      	ldr	r2, [r7, #4]
 800fdfe:	683b      	ldr	r3, [r7, #0]
 800fe00:	781b      	ldrb	r3, [r3, #0]
 800fe02:	009b      	lsls	r3, r3, #2
 800fe04:	18d3      	adds	r3, r2, r3
 800fe06:	881b      	ldrh	r3, [r3, #0]
 800fe08:	b29a      	uxth	r2, r3
 800fe0a:	2062      	movs	r0, #98	; 0x62
 800fe0c:	183b      	adds	r3, r7, r0
 800fe0e:	49c6      	ldr	r1, [pc, #792]	; (8010128 <USB_ActivateEndpoint+0x6c4>)
 800fe10:	400a      	ands	r2, r1
 800fe12:	801a      	strh	r2, [r3, #0]
 800fe14:	687a      	ldr	r2, [r7, #4]
 800fe16:	683b      	ldr	r3, [r7, #0]
 800fe18:	781b      	ldrb	r3, [r3, #0]
 800fe1a:	009b      	lsls	r3, r3, #2
 800fe1c:	18d3      	adds	r3, r2, r3
 800fe1e:	183a      	adds	r2, r7, r0
 800fe20:	8812      	ldrh	r2, [r2, #0]
 800fe22:	49c2      	ldr	r1, [pc, #776]	; (801012c <USB_ActivateEndpoint+0x6c8>)
 800fe24:	430a      	orrs	r2, r1
 800fe26:	b292      	uxth	r2, r2
 800fe28:	801a      	strh	r2, [r3, #0]
 800fe2a:	e016      	b.n	800fe5a <USB_ActivateEndpoint+0x3f6>
    }
    else
    {
      /* Set the ISOC endpoint in double buffer mode */
      PCD_CLEAR_EP_KIND(USBx, ep->num);
 800fe2c:	687a      	ldr	r2, [r7, #4]
 800fe2e:	683b      	ldr	r3, [r7, #0]
 800fe30:	781b      	ldrb	r3, [r3, #0]
 800fe32:	009b      	lsls	r3, r3, #2
 800fe34:	18d3      	adds	r3, r2, r3
 800fe36:	881b      	ldrh	r3, [r3, #0]
 800fe38:	b29a      	uxth	r2, r3
 800fe3a:	2064      	movs	r0, #100	; 0x64
 800fe3c:	183b      	adds	r3, r7, r0
 800fe3e:	49bc      	ldr	r1, [pc, #752]	; (8010130 <USB_ActivateEndpoint+0x6cc>)
 800fe40:	400a      	ands	r2, r1
 800fe42:	801a      	strh	r2, [r3, #0]
 800fe44:	687a      	ldr	r2, [r7, #4]
 800fe46:	683b      	ldr	r3, [r7, #0]
 800fe48:	781b      	ldrb	r3, [r3, #0]
 800fe4a:	009b      	lsls	r3, r3, #2
 800fe4c:	18d3      	adds	r3, r2, r3
 800fe4e:	183a      	adds	r2, r7, r0
 800fe50:	8812      	ldrh	r2, [r2, #0]
 800fe52:	49b8      	ldr	r1, [pc, #736]	; (8010134 <USB_ActivateEndpoint+0x6d0>)
 800fe54:	430a      	orrs	r2, r1
 800fe56:	b292      	uxth	r2, r2
 800fe58:	801a      	strh	r2, [r3, #0]
    }

    /* Set buffer address for double buffered mode */
    PCD_SET_EP_DBUF_ADDR(USBx, ep->num, ep->pmaaddr0, ep->pmaaddr1);
 800fe5a:	687b      	ldr	r3, [r7, #4]
 800fe5c:	65fb      	str	r3, [r7, #92]	; 0x5c
 800fe5e:	687b      	ldr	r3, [r7, #4]
 800fe60:	2250      	movs	r2, #80	; 0x50
 800fe62:	5a9b      	ldrh	r3, [r3, r2]
 800fe64:	b29b      	uxth	r3, r3
 800fe66:	001a      	movs	r2, r3
 800fe68:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800fe6a:	189b      	adds	r3, r3, r2
 800fe6c:	65fb      	str	r3, [r7, #92]	; 0x5c
 800fe6e:	683b      	ldr	r3, [r7, #0]
 800fe70:	781b      	ldrb	r3, [r3, #0]
 800fe72:	00da      	lsls	r2, r3, #3
 800fe74:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800fe76:	18d3      	adds	r3, r2, r3
 800fe78:	2280      	movs	r2, #128	; 0x80
 800fe7a:	00d2      	lsls	r2, r2, #3
 800fe7c:	4694      	mov	ip, r2
 800fe7e:	4463      	add	r3, ip
 800fe80:	65bb      	str	r3, [r7, #88]	; 0x58
 800fe82:	683b      	ldr	r3, [r7, #0]
 800fe84:	891b      	ldrh	r3, [r3, #8]
 800fe86:	085b      	lsrs	r3, r3, #1
 800fe88:	b29b      	uxth	r3, r3
 800fe8a:	18db      	adds	r3, r3, r3
 800fe8c:	b29a      	uxth	r2, r3
 800fe8e:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800fe90:	801a      	strh	r2, [r3, #0]
 800fe92:	687b      	ldr	r3, [r7, #4]
 800fe94:	657b      	str	r3, [r7, #84]	; 0x54
 800fe96:	687b      	ldr	r3, [r7, #4]
 800fe98:	2250      	movs	r2, #80	; 0x50
 800fe9a:	5a9b      	ldrh	r3, [r3, r2]
 800fe9c:	b29b      	uxth	r3, r3
 800fe9e:	001a      	movs	r2, r3
 800fea0:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800fea2:	189b      	adds	r3, r3, r2
 800fea4:	657b      	str	r3, [r7, #84]	; 0x54
 800fea6:	683b      	ldr	r3, [r7, #0]
 800fea8:	781b      	ldrb	r3, [r3, #0]
 800feaa:	00da      	lsls	r2, r3, #3
 800feac:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800feae:	18d3      	adds	r3, r2, r3
 800feb0:	4aa1      	ldr	r2, [pc, #644]	; (8010138 <USB_ActivateEndpoint+0x6d4>)
 800feb2:	4694      	mov	ip, r2
 800feb4:	4463      	add	r3, ip
 800feb6:	653b      	str	r3, [r7, #80]	; 0x50
 800feb8:	683b      	ldr	r3, [r7, #0]
 800feba:	895b      	ldrh	r3, [r3, #10]
 800febc:	085b      	lsrs	r3, r3, #1
 800febe:	b29b      	uxth	r3, r3
 800fec0:	18db      	adds	r3, r3, r3
 800fec2:	b29a      	uxth	r2, r3
 800fec4:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800fec6:	801a      	strh	r2, [r3, #0]

    if (ep->is_in == 0U)
 800fec8:	683b      	ldr	r3, [r7, #0]
 800feca:	785b      	ldrb	r3, [r3, #1]
 800fecc:	2b00      	cmp	r3, #0
 800fece:	d000      	beq.n	800fed2 <USB_ActivateEndpoint+0x46e>
 800fed0:	e087      	b.n	800ffe2 <USB_ActivateEndpoint+0x57e>
    {
      /* Clear the data toggle bits for the endpoint IN/OUT */
      PCD_CLEAR_RX_DTOG(USBx, ep->num);
 800fed2:	687a      	ldr	r2, [r7, #4]
 800fed4:	683b      	ldr	r3, [r7, #0]
 800fed6:	781b      	ldrb	r3, [r3, #0]
 800fed8:	009b      	lsls	r3, r3, #2
 800feda:	18d2      	adds	r2, r2, r3
 800fedc:	2140      	movs	r1, #64	; 0x40
 800fede:	187b      	adds	r3, r7, r1
 800fee0:	8812      	ldrh	r2, [r2, #0]
 800fee2:	801a      	strh	r2, [r3, #0]
 800fee4:	187b      	adds	r3, r7, r1
 800fee6:	881a      	ldrh	r2, [r3, #0]
 800fee8:	2380      	movs	r3, #128	; 0x80
 800feea:	01db      	lsls	r3, r3, #7
 800feec:	4013      	ands	r3, r2
 800feee:	d016      	beq.n	800ff1e <USB_ActivateEndpoint+0x4ba>
 800fef0:	687a      	ldr	r2, [r7, #4]
 800fef2:	683b      	ldr	r3, [r7, #0]
 800fef4:	781b      	ldrb	r3, [r3, #0]
 800fef6:	009b      	lsls	r3, r3, #2
 800fef8:	18d3      	adds	r3, r2, r3
 800fefa:	881b      	ldrh	r3, [r3, #0]
 800fefc:	b29a      	uxth	r2, r3
 800fefe:	203e      	movs	r0, #62	; 0x3e
 800ff00:	183b      	adds	r3, r7, r0
 800ff02:	4989      	ldr	r1, [pc, #548]	; (8010128 <USB_ActivateEndpoint+0x6c4>)
 800ff04:	400a      	ands	r2, r1
 800ff06:	801a      	strh	r2, [r3, #0]
 800ff08:	687a      	ldr	r2, [r7, #4]
 800ff0a:	683b      	ldr	r3, [r7, #0]
 800ff0c:	781b      	ldrb	r3, [r3, #0]
 800ff0e:	009b      	lsls	r3, r3, #2
 800ff10:	18d3      	adds	r3, r2, r3
 800ff12:	183a      	adds	r2, r7, r0
 800ff14:	8812      	ldrh	r2, [r2, #0]
 800ff16:	4989      	ldr	r1, [pc, #548]	; (801013c <USB_ActivateEndpoint+0x6d8>)
 800ff18:	430a      	orrs	r2, r1
 800ff1a:	b292      	uxth	r2, r2
 800ff1c:	801a      	strh	r2, [r3, #0]
      PCD_CLEAR_TX_DTOG(USBx, ep->num);
 800ff1e:	687a      	ldr	r2, [r7, #4]
 800ff20:	683b      	ldr	r3, [r7, #0]
 800ff22:	781b      	ldrb	r3, [r3, #0]
 800ff24:	009b      	lsls	r3, r3, #2
 800ff26:	18d2      	adds	r2, r2, r3
 800ff28:	213c      	movs	r1, #60	; 0x3c
 800ff2a:	187b      	adds	r3, r7, r1
 800ff2c:	8812      	ldrh	r2, [r2, #0]
 800ff2e:	801a      	strh	r2, [r3, #0]
 800ff30:	187b      	adds	r3, r7, r1
 800ff32:	881b      	ldrh	r3, [r3, #0]
 800ff34:	2240      	movs	r2, #64	; 0x40
 800ff36:	4013      	ands	r3, r2
 800ff38:	d016      	beq.n	800ff68 <USB_ActivateEndpoint+0x504>
 800ff3a:	687a      	ldr	r2, [r7, #4]
 800ff3c:	683b      	ldr	r3, [r7, #0]
 800ff3e:	781b      	ldrb	r3, [r3, #0]
 800ff40:	009b      	lsls	r3, r3, #2
 800ff42:	18d3      	adds	r3, r2, r3
 800ff44:	881b      	ldrh	r3, [r3, #0]
 800ff46:	b29a      	uxth	r2, r3
 800ff48:	203a      	movs	r0, #58	; 0x3a
 800ff4a:	183b      	adds	r3, r7, r0
 800ff4c:	4976      	ldr	r1, [pc, #472]	; (8010128 <USB_ActivateEndpoint+0x6c4>)
 800ff4e:	400a      	ands	r2, r1
 800ff50:	801a      	strh	r2, [r3, #0]
 800ff52:	687a      	ldr	r2, [r7, #4]
 800ff54:	683b      	ldr	r3, [r7, #0]
 800ff56:	781b      	ldrb	r3, [r3, #0]
 800ff58:	009b      	lsls	r3, r3, #2
 800ff5a:	18d3      	adds	r3, r2, r3
 800ff5c:	183a      	adds	r2, r7, r0
 800ff5e:	8812      	ldrh	r2, [r2, #0]
 800ff60:	4977      	ldr	r1, [pc, #476]	; (8010140 <USB_ActivateEndpoint+0x6dc>)
 800ff62:	430a      	orrs	r2, r1
 800ff64:	b292      	uxth	r2, r2
 800ff66:	801a      	strh	r2, [r3, #0]

      PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_VALID);
 800ff68:	687a      	ldr	r2, [r7, #4]
 800ff6a:	683b      	ldr	r3, [r7, #0]
 800ff6c:	781b      	ldrb	r3, [r3, #0]
 800ff6e:	009b      	lsls	r3, r3, #2
 800ff70:	18d3      	adds	r3, r2, r3
 800ff72:	881b      	ldrh	r3, [r3, #0]
 800ff74:	b29a      	uxth	r2, r3
 800ff76:	2038      	movs	r0, #56	; 0x38
 800ff78:	183b      	adds	r3, r7, r0
 800ff7a:	4972      	ldr	r1, [pc, #456]	; (8010144 <USB_ActivateEndpoint+0x6e0>)
 800ff7c:	400a      	ands	r2, r1
 800ff7e:	801a      	strh	r2, [r3, #0]
 800ff80:	183b      	adds	r3, r7, r0
 800ff82:	183a      	adds	r2, r7, r0
 800ff84:	8812      	ldrh	r2, [r2, #0]
 800ff86:	2180      	movs	r1, #128	; 0x80
 800ff88:	0149      	lsls	r1, r1, #5
 800ff8a:	404a      	eors	r2, r1
 800ff8c:	801a      	strh	r2, [r3, #0]
 800ff8e:	183b      	adds	r3, r7, r0
 800ff90:	183a      	adds	r2, r7, r0
 800ff92:	8812      	ldrh	r2, [r2, #0]
 800ff94:	2180      	movs	r1, #128	; 0x80
 800ff96:	0189      	lsls	r1, r1, #6
 800ff98:	404a      	eors	r2, r1
 800ff9a:	801a      	strh	r2, [r3, #0]
 800ff9c:	687a      	ldr	r2, [r7, #4]
 800ff9e:	683b      	ldr	r3, [r7, #0]
 800ffa0:	781b      	ldrb	r3, [r3, #0]
 800ffa2:	009b      	lsls	r3, r3, #2
 800ffa4:	18d3      	adds	r3, r2, r3
 800ffa6:	183a      	adds	r2, r7, r0
 800ffa8:	8812      	ldrh	r2, [r2, #0]
 800ffaa:	4962      	ldr	r1, [pc, #392]	; (8010134 <USB_ActivateEndpoint+0x6d0>)
 800ffac:	430a      	orrs	r2, r1
 800ffae:	b292      	uxth	r2, r2
 800ffb0:	801a      	strh	r2, [r3, #0]
      PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_DIS);
 800ffb2:	687a      	ldr	r2, [r7, #4]
 800ffb4:	683b      	ldr	r3, [r7, #0]
 800ffb6:	781b      	ldrb	r3, [r3, #0]
 800ffb8:	009b      	lsls	r3, r3, #2
 800ffba:	18d3      	adds	r3, r2, r3
 800ffbc:	881b      	ldrh	r3, [r3, #0]
 800ffbe:	b29a      	uxth	r2, r3
 800ffc0:	2036      	movs	r0, #54	; 0x36
 800ffc2:	183b      	adds	r3, r7, r0
 800ffc4:	4960      	ldr	r1, [pc, #384]	; (8010148 <USB_ActivateEndpoint+0x6e4>)
 800ffc6:	400a      	ands	r2, r1
 800ffc8:	801a      	strh	r2, [r3, #0]
 800ffca:	687a      	ldr	r2, [r7, #4]
 800ffcc:	683b      	ldr	r3, [r7, #0]
 800ffce:	781b      	ldrb	r3, [r3, #0]
 800ffd0:	009b      	lsls	r3, r3, #2
 800ffd2:	18d3      	adds	r3, r2, r3
 800ffd4:	183a      	adds	r2, r7, r0
 800ffd6:	8812      	ldrh	r2, [r2, #0]
 800ffd8:	4956      	ldr	r1, [pc, #344]	; (8010134 <USB_ActivateEndpoint+0x6d0>)
 800ffda:	430a      	orrs	r2, r1
 800ffdc:	b292      	uxth	r2, r2
 800ffde:	801a      	strh	r2, [r3, #0]
 800ffe0:	e09a      	b.n	8010118 <USB_ActivateEndpoint+0x6b4>
    }
    else
    {
      /* Clear the data toggle bits for the endpoint IN/OUT */
      PCD_CLEAR_RX_DTOG(USBx, ep->num);
 800ffe2:	687a      	ldr	r2, [r7, #4]
 800ffe4:	683b      	ldr	r3, [r7, #0]
 800ffe6:	781b      	ldrb	r3, [r3, #0]
 800ffe8:	009b      	lsls	r3, r3, #2
 800ffea:	18d2      	adds	r2, r2, r3
 800ffec:	214e      	movs	r1, #78	; 0x4e
 800ffee:	187b      	adds	r3, r7, r1
 800fff0:	8812      	ldrh	r2, [r2, #0]
 800fff2:	801a      	strh	r2, [r3, #0]
 800fff4:	187b      	adds	r3, r7, r1
 800fff6:	881a      	ldrh	r2, [r3, #0]
 800fff8:	2380      	movs	r3, #128	; 0x80
 800fffa:	01db      	lsls	r3, r3, #7
 800fffc:	4013      	ands	r3, r2
 800fffe:	d016      	beq.n	801002e <USB_ActivateEndpoint+0x5ca>
 8010000:	687a      	ldr	r2, [r7, #4]
 8010002:	683b      	ldr	r3, [r7, #0]
 8010004:	781b      	ldrb	r3, [r3, #0]
 8010006:	009b      	lsls	r3, r3, #2
 8010008:	18d3      	adds	r3, r2, r3
 801000a:	881b      	ldrh	r3, [r3, #0]
 801000c:	b29a      	uxth	r2, r3
 801000e:	204c      	movs	r0, #76	; 0x4c
 8010010:	183b      	adds	r3, r7, r0
 8010012:	4945      	ldr	r1, [pc, #276]	; (8010128 <USB_ActivateEndpoint+0x6c4>)
 8010014:	400a      	ands	r2, r1
 8010016:	801a      	strh	r2, [r3, #0]
 8010018:	687a      	ldr	r2, [r7, #4]
 801001a:	683b      	ldr	r3, [r7, #0]
 801001c:	781b      	ldrb	r3, [r3, #0]
 801001e:	009b      	lsls	r3, r3, #2
 8010020:	18d3      	adds	r3, r2, r3
 8010022:	183a      	adds	r2, r7, r0
 8010024:	8812      	ldrh	r2, [r2, #0]
 8010026:	4945      	ldr	r1, [pc, #276]	; (801013c <USB_ActivateEndpoint+0x6d8>)
 8010028:	430a      	orrs	r2, r1
 801002a:	b292      	uxth	r2, r2
 801002c:	801a      	strh	r2, [r3, #0]
      PCD_CLEAR_TX_DTOG(USBx, ep->num);
 801002e:	687a      	ldr	r2, [r7, #4]
 8010030:	683b      	ldr	r3, [r7, #0]
 8010032:	781b      	ldrb	r3, [r3, #0]
 8010034:	009b      	lsls	r3, r3, #2
 8010036:	18d2      	adds	r2, r2, r3
 8010038:	214a      	movs	r1, #74	; 0x4a
 801003a:	187b      	adds	r3, r7, r1
 801003c:	8812      	ldrh	r2, [r2, #0]
 801003e:	801a      	strh	r2, [r3, #0]
 8010040:	187b      	adds	r3, r7, r1
 8010042:	881b      	ldrh	r3, [r3, #0]
 8010044:	2240      	movs	r2, #64	; 0x40
 8010046:	4013      	ands	r3, r2
 8010048:	d016      	beq.n	8010078 <USB_ActivateEndpoint+0x614>
 801004a:	687a      	ldr	r2, [r7, #4]
 801004c:	683b      	ldr	r3, [r7, #0]
 801004e:	781b      	ldrb	r3, [r3, #0]
 8010050:	009b      	lsls	r3, r3, #2
 8010052:	18d3      	adds	r3, r2, r3
 8010054:	881b      	ldrh	r3, [r3, #0]
 8010056:	b29a      	uxth	r2, r3
 8010058:	2048      	movs	r0, #72	; 0x48
 801005a:	183b      	adds	r3, r7, r0
 801005c:	4932      	ldr	r1, [pc, #200]	; (8010128 <USB_ActivateEndpoint+0x6c4>)
 801005e:	400a      	ands	r2, r1
 8010060:	801a      	strh	r2, [r3, #0]
 8010062:	687a      	ldr	r2, [r7, #4]
 8010064:	683b      	ldr	r3, [r7, #0]
 8010066:	781b      	ldrb	r3, [r3, #0]
 8010068:	009b      	lsls	r3, r3, #2
 801006a:	18d3      	adds	r3, r2, r3
 801006c:	183a      	adds	r2, r7, r0
 801006e:	8812      	ldrh	r2, [r2, #0]
 8010070:	4933      	ldr	r1, [pc, #204]	; (8010140 <USB_ActivateEndpoint+0x6dc>)
 8010072:	430a      	orrs	r2, r1
 8010074:	b292      	uxth	r2, r2
 8010076:	801a      	strh	r2, [r3, #0]

      if (ep->type != EP_TYPE_ISOC)
 8010078:	683b      	ldr	r3, [r7, #0]
 801007a:	78db      	ldrb	r3, [r3, #3]
 801007c:	2b01      	cmp	r3, #1
 801007e:	d01d      	beq.n	80100bc <USB_ActivateEndpoint+0x658>
      {
        /* Configure NAK status for the Endpoint */
        PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_NAK);
 8010080:	687a      	ldr	r2, [r7, #4]
 8010082:	683b      	ldr	r3, [r7, #0]
 8010084:	781b      	ldrb	r3, [r3, #0]
 8010086:	009b      	lsls	r3, r3, #2
 8010088:	18d3      	adds	r3, r2, r3
 801008a:	881b      	ldrh	r3, [r3, #0]
 801008c:	b29a      	uxth	r2, r3
 801008e:	2044      	movs	r0, #68	; 0x44
 8010090:	183b      	adds	r3, r7, r0
 8010092:	492d      	ldr	r1, [pc, #180]	; (8010148 <USB_ActivateEndpoint+0x6e4>)
 8010094:	400a      	ands	r2, r1
 8010096:	801a      	strh	r2, [r3, #0]
 8010098:	183b      	adds	r3, r7, r0
 801009a:	183a      	adds	r2, r7, r0
 801009c:	8812      	ldrh	r2, [r2, #0]
 801009e:	2120      	movs	r1, #32
 80100a0:	404a      	eors	r2, r1
 80100a2:	801a      	strh	r2, [r3, #0]
 80100a4:	687a      	ldr	r2, [r7, #4]
 80100a6:	683b      	ldr	r3, [r7, #0]
 80100a8:	781b      	ldrb	r3, [r3, #0]
 80100aa:	009b      	lsls	r3, r3, #2
 80100ac:	18d3      	adds	r3, r2, r3
 80100ae:	183a      	adds	r2, r7, r0
 80100b0:	8812      	ldrh	r2, [r2, #0]
 80100b2:	4920      	ldr	r1, [pc, #128]	; (8010134 <USB_ActivateEndpoint+0x6d0>)
 80100b4:	430a      	orrs	r2, r1
 80100b6:	b292      	uxth	r2, r2
 80100b8:	801a      	strh	r2, [r3, #0]
 80100ba:	e016      	b.n	80100ea <USB_ActivateEndpoint+0x686>
      }
      else
      {
        /* Configure TX Endpoint to disabled state */
        PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_DIS);
 80100bc:	687a      	ldr	r2, [r7, #4]
 80100be:	683b      	ldr	r3, [r7, #0]
 80100c0:	781b      	ldrb	r3, [r3, #0]
 80100c2:	009b      	lsls	r3, r3, #2
 80100c4:	18d3      	adds	r3, r2, r3
 80100c6:	881b      	ldrh	r3, [r3, #0]
 80100c8:	b29a      	uxth	r2, r3
 80100ca:	2046      	movs	r0, #70	; 0x46
 80100cc:	183b      	adds	r3, r7, r0
 80100ce:	491e      	ldr	r1, [pc, #120]	; (8010148 <USB_ActivateEndpoint+0x6e4>)
 80100d0:	400a      	ands	r2, r1
 80100d2:	801a      	strh	r2, [r3, #0]
 80100d4:	687a      	ldr	r2, [r7, #4]
 80100d6:	683b      	ldr	r3, [r7, #0]
 80100d8:	781b      	ldrb	r3, [r3, #0]
 80100da:	009b      	lsls	r3, r3, #2
 80100dc:	18d3      	adds	r3, r2, r3
 80100de:	183a      	adds	r2, r7, r0
 80100e0:	8812      	ldrh	r2, [r2, #0]
 80100e2:	4914      	ldr	r1, [pc, #80]	; (8010134 <USB_ActivateEndpoint+0x6d0>)
 80100e4:	430a      	orrs	r2, r1
 80100e6:	b292      	uxth	r2, r2
 80100e8:	801a      	strh	r2, [r3, #0]
      }

      PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_DIS);
 80100ea:	687a      	ldr	r2, [r7, #4]
 80100ec:	683b      	ldr	r3, [r7, #0]
 80100ee:	781b      	ldrb	r3, [r3, #0]
 80100f0:	009b      	lsls	r3, r3, #2
 80100f2:	18d3      	adds	r3, r2, r3
 80100f4:	881b      	ldrh	r3, [r3, #0]
 80100f6:	b29a      	uxth	r2, r3
 80100f8:	2042      	movs	r0, #66	; 0x42
 80100fa:	183b      	adds	r3, r7, r0
 80100fc:	4911      	ldr	r1, [pc, #68]	; (8010144 <USB_ActivateEndpoint+0x6e0>)
 80100fe:	400a      	ands	r2, r1
 8010100:	801a      	strh	r2, [r3, #0]
 8010102:	687a      	ldr	r2, [r7, #4]
 8010104:	683b      	ldr	r3, [r7, #0]
 8010106:	781b      	ldrb	r3, [r3, #0]
 8010108:	009b      	lsls	r3, r3, #2
 801010a:	18d3      	adds	r3, r2, r3
 801010c:	183a      	adds	r2, r7, r0
 801010e:	8812      	ldrh	r2, [r2, #0]
 8010110:	4908      	ldr	r1, [pc, #32]	; (8010134 <USB_ActivateEndpoint+0x6d0>)
 8010112:	430a      	orrs	r2, r1
 8010114:	b292      	uxth	r2, r2
 8010116:	801a      	strh	r2, [r3, #0]
    }
  }

  return ret;
 8010118:	236f      	movs	r3, #111	; 0x6f
 801011a:	18fb      	adds	r3, r7, r3
 801011c:	781b      	ldrb	r3, [r3, #0]
}
 801011e:	0018      	movs	r0, r3
 8010120:	46bd      	mov	sp, r7
 8010122:	b01c      	add	sp, #112	; 0x70
 8010124:	bd80      	pop	{r7, pc}
 8010126:	46c0      	nop			; (mov r8, r8)
 8010128:	ffff8f8f 	.word	0xffff8f8f
 801012c:	ffff8180 	.word	0xffff8180
 8010130:	ffff8e8f 	.word	0xffff8e8f
 8010134:	ffff8080 	.word	0xffff8080
 8010138:	00000404 	.word	0x00000404
 801013c:	ffffc080 	.word	0xffffc080
 8010140:	ffff80c0 	.word	0xffff80c0
 8010144:	ffffbf8f 	.word	0xffffbf8f
 8010148:	ffff8fbf 	.word	0xffff8fbf

0801014c <USB_DeactivateEndpoint>:
  * @param  USBx Selected device
  * @param  ep pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DeactivateEndpoint(USB_TypeDef *USBx, USB_EPTypeDef *ep)
{
 801014c:	b580      	push	{r7, lr}
 801014e:	b08c      	sub	sp, #48	; 0x30
 8010150:	af00      	add	r7, sp, #0
 8010152:	6078      	str	r0, [r7, #4]
 8010154:	6039      	str	r1, [r7, #0]
  if (ep->doublebuffer == 0U)
 8010156:	683b      	ldr	r3, [r7, #0]
 8010158:	7b1b      	ldrb	r3, [r3, #12]
 801015a:	2b00      	cmp	r3, #0
 801015c:	d000      	beq.n	8010160 <USB_DeactivateEndpoint+0x14>
 801015e:	e07e      	b.n	801025e <USB_DeactivateEndpoint+0x112>
  {
    if (ep->is_in != 0U)
 8010160:	683b      	ldr	r3, [r7, #0]
 8010162:	785b      	ldrb	r3, [r3, #1]
 8010164:	2b00      	cmp	r3, #0
 8010166:	d03c      	beq.n	80101e2 <USB_DeactivateEndpoint+0x96>
    {
      PCD_CLEAR_TX_DTOG(USBx, ep->num);
 8010168:	687a      	ldr	r2, [r7, #4]
 801016a:	683b      	ldr	r3, [r7, #0]
 801016c:	781b      	ldrb	r3, [r3, #0]
 801016e:	009b      	lsls	r3, r3, #2
 8010170:	18d2      	adds	r2, r2, r3
 8010172:	210c      	movs	r1, #12
 8010174:	187b      	adds	r3, r7, r1
 8010176:	8812      	ldrh	r2, [r2, #0]
 8010178:	801a      	strh	r2, [r3, #0]
 801017a:	187b      	adds	r3, r7, r1
 801017c:	881b      	ldrh	r3, [r3, #0]
 801017e:	2240      	movs	r2, #64	; 0x40
 8010180:	4013      	ands	r3, r2
 8010182:	d016      	beq.n	80101b2 <USB_DeactivateEndpoint+0x66>
 8010184:	687a      	ldr	r2, [r7, #4]
 8010186:	683b      	ldr	r3, [r7, #0]
 8010188:	781b      	ldrb	r3, [r3, #0]
 801018a:	009b      	lsls	r3, r3, #2
 801018c:	18d3      	adds	r3, r2, r3
 801018e:	881b      	ldrh	r3, [r3, #0]
 8010190:	b29a      	uxth	r2, r3
 8010192:	200a      	movs	r0, #10
 8010194:	183b      	adds	r3, r7, r0
 8010196:	49c7      	ldr	r1, [pc, #796]	; (80104b4 <USB_DeactivateEndpoint+0x368>)
 8010198:	400a      	ands	r2, r1
 801019a:	801a      	strh	r2, [r3, #0]
 801019c:	687a      	ldr	r2, [r7, #4]
 801019e:	683b      	ldr	r3, [r7, #0]
 80101a0:	781b      	ldrb	r3, [r3, #0]
 80101a2:	009b      	lsls	r3, r3, #2
 80101a4:	18d3      	adds	r3, r2, r3
 80101a6:	183a      	adds	r2, r7, r0
 80101a8:	8812      	ldrh	r2, [r2, #0]
 80101aa:	49c3      	ldr	r1, [pc, #780]	; (80104b8 <USB_DeactivateEndpoint+0x36c>)
 80101ac:	430a      	orrs	r2, r1
 80101ae:	b292      	uxth	r2, r2
 80101b0:	801a      	strh	r2, [r3, #0]

      /* Configure DISABLE status for the Endpoint*/
      PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_DIS);
 80101b2:	687a      	ldr	r2, [r7, #4]
 80101b4:	683b      	ldr	r3, [r7, #0]
 80101b6:	781b      	ldrb	r3, [r3, #0]
 80101b8:	009b      	lsls	r3, r3, #2
 80101ba:	18d3      	adds	r3, r2, r3
 80101bc:	881b      	ldrh	r3, [r3, #0]
 80101be:	b29a      	uxth	r2, r3
 80101c0:	2008      	movs	r0, #8
 80101c2:	183b      	adds	r3, r7, r0
 80101c4:	49bd      	ldr	r1, [pc, #756]	; (80104bc <USB_DeactivateEndpoint+0x370>)
 80101c6:	400a      	ands	r2, r1
 80101c8:	801a      	strh	r2, [r3, #0]
 80101ca:	687a      	ldr	r2, [r7, #4]
 80101cc:	683b      	ldr	r3, [r7, #0]
 80101ce:	781b      	ldrb	r3, [r3, #0]
 80101d0:	009b      	lsls	r3, r3, #2
 80101d2:	18d3      	adds	r3, r2, r3
 80101d4:	183a      	adds	r2, r7, r0
 80101d6:	8812      	ldrh	r2, [r2, #0]
 80101d8:	49b9      	ldr	r1, [pc, #740]	; (80104c0 <USB_DeactivateEndpoint+0x374>)
 80101da:	430a      	orrs	r2, r1
 80101dc:	b292      	uxth	r2, r2
 80101de:	801a      	strh	r2, [r3, #0]
 80101e0:	e163      	b.n	80104aa <USB_DeactivateEndpoint+0x35e>
    }
    else
    {
      PCD_CLEAR_RX_DTOG(USBx, ep->num);
 80101e2:	687a      	ldr	r2, [r7, #4]
 80101e4:	683b      	ldr	r3, [r7, #0]
 80101e6:	781b      	ldrb	r3, [r3, #0]
 80101e8:	009b      	lsls	r3, r3, #2
 80101ea:	18d2      	adds	r2, r2, r3
 80101ec:	2112      	movs	r1, #18
 80101ee:	187b      	adds	r3, r7, r1
 80101f0:	8812      	ldrh	r2, [r2, #0]
 80101f2:	801a      	strh	r2, [r3, #0]
 80101f4:	187b      	adds	r3, r7, r1
 80101f6:	881a      	ldrh	r2, [r3, #0]
 80101f8:	2380      	movs	r3, #128	; 0x80
 80101fa:	01db      	lsls	r3, r3, #7
 80101fc:	4013      	ands	r3, r2
 80101fe:	d016      	beq.n	801022e <USB_DeactivateEndpoint+0xe2>
 8010200:	687a      	ldr	r2, [r7, #4]
 8010202:	683b      	ldr	r3, [r7, #0]
 8010204:	781b      	ldrb	r3, [r3, #0]
 8010206:	009b      	lsls	r3, r3, #2
 8010208:	18d3      	adds	r3, r2, r3
 801020a:	881b      	ldrh	r3, [r3, #0]
 801020c:	b29a      	uxth	r2, r3
 801020e:	2010      	movs	r0, #16
 8010210:	183b      	adds	r3, r7, r0
 8010212:	49a8      	ldr	r1, [pc, #672]	; (80104b4 <USB_DeactivateEndpoint+0x368>)
 8010214:	400a      	ands	r2, r1
 8010216:	801a      	strh	r2, [r3, #0]
 8010218:	687a      	ldr	r2, [r7, #4]
 801021a:	683b      	ldr	r3, [r7, #0]
 801021c:	781b      	ldrb	r3, [r3, #0]
 801021e:	009b      	lsls	r3, r3, #2
 8010220:	18d3      	adds	r3, r2, r3
 8010222:	183a      	adds	r2, r7, r0
 8010224:	8812      	ldrh	r2, [r2, #0]
 8010226:	49a7      	ldr	r1, [pc, #668]	; (80104c4 <USB_DeactivateEndpoint+0x378>)
 8010228:	430a      	orrs	r2, r1
 801022a:	b292      	uxth	r2, r2
 801022c:	801a      	strh	r2, [r3, #0]

      /* Configure DISABLE status for the Endpoint*/
      PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_DIS);
 801022e:	687a      	ldr	r2, [r7, #4]
 8010230:	683b      	ldr	r3, [r7, #0]
 8010232:	781b      	ldrb	r3, [r3, #0]
 8010234:	009b      	lsls	r3, r3, #2
 8010236:	18d3      	adds	r3, r2, r3
 8010238:	881b      	ldrh	r3, [r3, #0]
 801023a:	b29a      	uxth	r2, r3
 801023c:	200e      	movs	r0, #14
 801023e:	183b      	adds	r3, r7, r0
 8010240:	49a1      	ldr	r1, [pc, #644]	; (80104c8 <USB_DeactivateEndpoint+0x37c>)
 8010242:	400a      	ands	r2, r1
 8010244:	801a      	strh	r2, [r3, #0]
 8010246:	687a      	ldr	r2, [r7, #4]
 8010248:	683b      	ldr	r3, [r7, #0]
 801024a:	781b      	ldrb	r3, [r3, #0]
 801024c:	009b      	lsls	r3, r3, #2
 801024e:	18d3      	adds	r3, r2, r3
 8010250:	183a      	adds	r2, r7, r0
 8010252:	8812      	ldrh	r2, [r2, #0]
 8010254:	499a      	ldr	r1, [pc, #616]	; (80104c0 <USB_DeactivateEndpoint+0x374>)
 8010256:	430a      	orrs	r2, r1
 8010258:	b292      	uxth	r2, r2
 801025a:	801a      	strh	r2, [r3, #0]
 801025c:	e125      	b.n	80104aa <USB_DeactivateEndpoint+0x35e>
    }
  }
  /*Double Buffer*/
  else
  {
    if (ep->is_in == 0U)
 801025e:	683b      	ldr	r3, [r7, #0]
 8010260:	785b      	ldrb	r3, [r3, #1]
 8010262:	2b00      	cmp	r3, #0
 8010264:	d000      	beq.n	8010268 <USB_DeactivateEndpoint+0x11c>
 8010266:	e090      	b.n	801038a <USB_DeactivateEndpoint+0x23e>
    {
      /* Clear the data toggle bits for the endpoint IN/OUT*/
      PCD_CLEAR_RX_DTOG(USBx, ep->num);
 8010268:	687a      	ldr	r2, [r7, #4]
 801026a:	683b      	ldr	r3, [r7, #0]
 801026c:	781b      	ldrb	r3, [r3, #0]
 801026e:	009b      	lsls	r3, r3, #2
 8010270:	18d2      	adds	r2, r2, r3
 8010272:	2120      	movs	r1, #32
 8010274:	187b      	adds	r3, r7, r1
 8010276:	8812      	ldrh	r2, [r2, #0]
 8010278:	801a      	strh	r2, [r3, #0]
 801027a:	187b      	adds	r3, r7, r1
 801027c:	881a      	ldrh	r2, [r3, #0]
 801027e:	2380      	movs	r3, #128	; 0x80
 8010280:	01db      	lsls	r3, r3, #7
 8010282:	4013      	ands	r3, r2
 8010284:	d016      	beq.n	80102b4 <USB_DeactivateEndpoint+0x168>
 8010286:	687a      	ldr	r2, [r7, #4]
 8010288:	683b      	ldr	r3, [r7, #0]
 801028a:	781b      	ldrb	r3, [r3, #0]
 801028c:	009b      	lsls	r3, r3, #2
 801028e:	18d3      	adds	r3, r2, r3
 8010290:	881b      	ldrh	r3, [r3, #0]
 8010292:	b29a      	uxth	r2, r3
 8010294:	201e      	movs	r0, #30
 8010296:	183b      	adds	r3, r7, r0
 8010298:	4986      	ldr	r1, [pc, #536]	; (80104b4 <USB_DeactivateEndpoint+0x368>)
 801029a:	400a      	ands	r2, r1
 801029c:	801a      	strh	r2, [r3, #0]
 801029e:	687a      	ldr	r2, [r7, #4]
 80102a0:	683b      	ldr	r3, [r7, #0]
 80102a2:	781b      	ldrb	r3, [r3, #0]
 80102a4:	009b      	lsls	r3, r3, #2
 80102a6:	18d3      	adds	r3, r2, r3
 80102a8:	183a      	adds	r2, r7, r0
 80102aa:	8812      	ldrh	r2, [r2, #0]
 80102ac:	4985      	ldr	r1, [pc, #532]	; (80104c4 <USB_DeactivateEndpoint+0x378>)
 80102ae:	430a      	orrs	r2, r1
 80102b0:	b292      	uxth	r2, r2
 80102b2:	801a      	strh	r2, [r3, #0]
      PCD_CLEAR_TX_DTOG(USBx, ep->num);
 80102b4:	687a      	ldr	r2, [r7, #4]
 80102b6:	683b      	ldr	r3, [r7, #0]
 80102b8:	781b      	ldrb	r3, [r3, #0]
 80102ba:	009b      	lsls	r3, r3, #2
 80102bc:	18d2      	adds	r2, r2, r3
 80102be:	211c      	movs	r1, #28
 80102c0:	187b      	adds	r3, r7, r1
 80102c2:	8812      	ldrh	r2, [r2, #0]
 80102c4:	801a      	strh	r2, [r3, #0]
 80102c6:	187b      	adds	r3, r7, r1
 80102c8:	881b      	ldrh	r3, [r3, #0]
 80102ca:	2240      	movs	r2, #64	; 0x40
 80102cc:	4013      	ands	r3, r2
 80102ce:	d016      	beq.n	80102fe <USB_DeactivateEndpoint+0x1b2>
 80102d0:	687a      	ldr	r2, [r7, #4]
 80102d2:	683b      	ldr	r3, [r7, #0]
 80102d4:	781b      	ldrb	r3, [r3, #0]
 80102d6:	009b      	lsls	r3, r3, #2
 80102d8:	18d3      	adds	r3, r2, r3
 80102da:	881b      	ldrh	r3, [r3, #0]
 80102dc:	b29a      	uxth	r2, r3
 80102de:	201a      	movs	r0, #26
 80102e0:	183b      	adds	r3, r7, r0
 80102e2:	4974      	ldr	r1, [pc, #464]	; (80104b4 <USB_DeactivateEndpoint+0x368>)
 80102e4:	400a      	ands	r2, r1
 80102e6:	801a      	strh	r2, [r3, #0]
 80102e8:	687a      	ldr	r2, [r7, #4]
 80102ea:	683b      	ldr	r3, [r7, #0]
 80102ec:	781b      	ldrb	r3, [r3, #0]
 80102ee:	009b      	lsls	r3, r3, #2
 80102f0:	18d3      	adds	r3, r2, r3
 80102f2:	183a      	adds	r2, r7, r0
 80102f4:	8812      	ldrh	r2, [r2, #0]
 80102f6:	4970      	ldr	r1, [pc, #448]	; (80104b8 <USB_DeactivateEndpoint+0x36c>)
 80102f8:	430a      	orrs	r2, r1
 80102fa:	b292      	uxth	r2, r2
 80102fc:	801a      	strh	r2, [r3, #0]

      /* Reset value of the data toggle bits for the endpoint out*/
      PCD_TX_DTOG(USBx, ep->num);
 80102fe:	687a      	ldr	r2, [r7, #4]
 8010300:	683b      	ldr	r3, [r7, #0]
 8010302:	781b      	ldrb	r3, [r3, #0]
 8010304:	009b      	lsls	r3, r3, #2
 8010306:	18d3      	adds	r3, r2, r3
 8010308:	881b      	ldrh	r3, [r3, #0]
 801030a:	b29a      	uxth	r2, r3
 801030c:	2018      	movs	r0, #24
 801030e:	183b      	adds	r3, r7, r0
 8010310:	4968      	ldr	r1, [pc, #416]	; (80104b4 <USB_DeactivateEndpoint+0x368>)
 8010312:	400a      	ands	r2, r1
 8010314:	801a      	strh	r2, [r3, #0]
 8010316:	687a      	ldr	r2, [r7, #4]
 8010318:	683b      	ldr	r3, [r7, #0]
 801031a:	781b      	ldrb	r3, [r3, #0]
 801031c:	009b      	lsls	r3, r3, #2
 801031e:	18d3      	adds	r3, r2, r3
 8010320:	183a      	adds	r2, r7, r0
 8010322:	8812      	ldrh	r2, [r2, #0]
 8010324:	4964      	ldr	r1, [pc, #400]	; (80104b8 <USB_DeactivateEndpoint+0x36c>)
 8010326:	430a      	orrs	r2, r1
 8010328:	b292      	uxth	r2, r2
 801032a:	801a      	strh	r2, [r3, #0]

      PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_DIS);
 801032c:	687a      	ldr	r2, [r7, #4]
 801032e:	683b      	ldr	r3, [r7, #0]
 8010330:	781b      	ldrb	r3, [r3, #0]
 8010332:	009b      	lsls	r3, r3, #2
 8010334:	18d3      	adds	r3, r2, r3
 8010336:	881b      	ldrh	r3, [r3, #0]
 8010338:	b29a      	uxth	r2, r3
 801033a:	2016      	movs	r0, #22
 801033c:	183b      	adds	r3, r7, r0
 801033e:	4962      	ldr	r1, [pc, #392]	; (80104c8 <USB_DeactivateEndpoint+0x37c>)
 8010340:	400a      	ands	r2, r1
 8010342:	801a      	strh	r2, [r3, #0]
 8010344:	687a      	ldr	r2, [r7, #4]
 8010346:	683b      	ldr	r3, [r7, #0]
 8010348:	781b      	ldrb	r3, [r3, #0]
 801034a:	009b      	lsls	r3, r3, #2
 801034c:	18d3      	adds	r3, r2, r3
 801034e:	183a      	adds	r2, r7, r0
 8010350:	8812      	ldrh	r2, [r2, #0]
 8010352:	495b      	ldr	r1, [pc, #364]	; (80104c0 <USB_DeactivateEndpoint+0x374>)
 8010354:	430a      	orrs	r2, r1
 8010356:	b292      	uxth	r2, r2
 8010358:	801a      	strh	r2, [r3, #0]
      PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_DIS);
 801035a:	687a      	ldr	r2, [r7, #4]
 801035c:	683b      	ldr	r3, [r7, #0]
 801035e:	781b      	ldrb	r3, [r3, #0]
 8010360:	009b      	lsls	r3, r3, #2
 8010362:	18d3      	adds	r3, r2, r3
 8010364:	881b      	ldrh	r3, [r3, #0]
 8010366:	b29a      	uxth	r2, r3
 8010368:	2014      	movs	r0, #20
 801036a:	183b      	adds	r3, r7, r0
 801036c:	4953      	ldr	r1, [pc, #332]	; (80104bc <USB_DeactivateEndpoint+0x370>)
 801036e:	400a      	ands	r2, r1
 8010370:	801a      	strh	r2, [r3, #0]
 8010372:	687a      	ldr	r2, [r7, #4]
 8010374:	683b      	ldr	r3, [r7, #0]
 8010376:	781b      	ldrb	r3, [r3, #0]
 8010378:	009b      	lsls	r3, r3, #2
 801037a:	18d3      	adds	r3, r2, r3
 801037c:	183a      	adds	r2, r7, r0
 801037e:	8812      	ldrh	r2, [r2, #0]
 8010380:	494f      	ldr	r1, [pc, #316]	; (80104c0 <USB_DeactivateEndpoint+0x374>)
 8010382:	430a      	orrs	r2, r1
 8010384:	b292      	uxth	r2, r2
 8010386:	801a      	strh	r2, [r3, #0]
 8010388:	e08f      	b.n	80104aa <USB_DeactivateEndpoint+0x35e>
    }
    else
    {
      /* Clear the data toggle bits for the endpoint IN/OUT*/
      PCD_CLEAR_RX_DTOG(USBx, ep->num);
 801038a:	687a      	ldr	r2, [r7, #4]
 801038c:	683b      	ldr	r3, [r7, #0]
 801038e:	781b      	ldrb	r3, [r3, #0]
 8010390:	009b      	lsls	r3, r3, #2
 8010392:	18d2      	adds	r2, r2, r3
 8010394:	212e      	movs	r1, #46	; 0x2e
 8010396:	187b      	adds	r3, r7, r1
 8010398:	8812      	ldrh	r2, [r2, #0]
 801039a:	801a      	strh	r2, [r3, #0]
 801039c:	187b      	adds	r3, r7, r1
 801039e:	881a      	ldrh	r2, [r3, #0]
 80103a0:	2380      	movs	r3, #128	; 0x80
 80103a2:	01db      	lsls	r3, r3, #7
 80103a4:	4013      	ands	r3, r2
 80103a6:	d016      	beq.n	80103d6 <USB_DeactivateEndpoint+0x28a>
 80103a8:	687a      	ldr	r2, [r7, #4]
 80103aa:	683b      	ldr	r3, [r7, #0]
 80103ac:	781b      	ldrb	r3, [r3, #0]
 80103ae:	009b      	lsls	r3, r3, #2
 80103b0:	18d3      	adds	r3, r2, r3
 80103b2:	881b      	ldrh	r3, [r3, #0]
 80103b4:	b29a      	uxth	r2, r3
 80103b6:	202c      	movs	r0, #44	; 0x2c
 80103b8:	183b      	adds	r3, r7, r0
 80103ba:	493e      	ldr	r1, [pc, #248]	; (80104b4 <USB_DeactivateEndpoint+0x368>)
 80103bc:	400a      	ands	r2, r1
 80103be:	801a      	strh	r2, [r3, #0]
 80103c0:	687a      	ldr	r2, [r7, #4]
 80103c2:	683b      	ldr	r3, [r7, #0]
 80103c4:	781b      	ldrb	r3, [r3, #0]
 80103c6:	009b      	lsls	r3, r3, #2
 80103c8:	18d3      	adds	r3, r2, r3
 80103ca:	183a      	adds	r2, r7, r0
 80103cc:	8812      	ldrh	r2, [r2, #0]
 80103ce:	493d      	ldr	r1, [pc, #244]	; (80104c4 <USB_DeactivateEndpoint+0x378>)
 80103d0:	430a      	orrs	r2, r1
 80103d2:	b292      	uxth	r2, r2
 80103d4:	801a      	strh	r2, [r3, #0]
      PCD_CLEAR_TX_DTOG(USBx, ep->num);
 80103d6:	687a      	ldr	r2, [r7, #4]
 80103d8:	683b      	ldr	r3, [r7, #0]
 80103da:	781b      	ldrb	r3, [r3, #0]
 80103dc:	009b      	lsls	r3, r3, #2
 80103de:	18d2      	adds	r2, r2, r3
 80103e0:	212a      	movs	r1, #42	; 0x2a
 80103e2:	187b      	adds	r3, r7, r1
 80103e4:	8812      	ldrh	r2, [r2, #0]
 80103e6:	801a      	strh	r2, [r3, #0]
 80103e8:	187b      	adds	r3, r7, r1
 80103ea:	881b      	ldrh	r3, [r3, #0]
 80103ec:	2240      	movs	r2, #64	; 0x40
 80103ee:	4013      	ands	r3, r2
 80103f0:	d016      	beq.n	8010420 <USB_DeactivateEndpoint+0x2d4>
 80103f2:	687a      	ldr	r2, [r7, #4]
 80103f4:	683b      	ldr	r3, [r7, #0]
 80103f6:	781b      	ldrb	r3, [r3, #0]
 80103f8:	009b      	lsls	r3, r3, #2
 80103fa:	18d3      	adds	r3, r2, r3
 80103fc:	881b      	ldrh	r3, [r3, #0]
 80103fe:	b29a      	uxth	r2, r3
 8010400:	2028      	movs	r0, #40	; 0x28
 8010402:	183b      	adds	r3, r7, r0
 8010404:	492b      	ldr	r1, [pc, #172]	; (80104b4 <USB_DeactivateEndpoint+0x368>)
 8010406:	400a      	ands	r2, r1
 8010408:	801a      	strh	r2, [r3, #0]
 801040a:	687a      	ldr	r2, [r7, #4]
 801040c:	683b      	ldr	r3, [r7, #0]
 801040e:	781b      	ldrb	r3, [r3, #0]
 8010410:	009b      	lsls	r3, r3, #2
 8010412:	18d3      	adds	r3, r2, r3
 8010414:	183a      	adds	r2, r7, r0
 8010416:	8812      	ldrh	r2, [r2, #0]
 8010418:	4927      	ldr	r1, [pc, #156]	; (80104b8 <USB_DeactivateEndpoint+0x36c>)
 801041a:	430a      	orrs	r2, r1
 801041c:	b292      	uxth	r2, r2
 801041e:	801a      	strh	r2, [r3, #0]
      PCD_RX_DTOG(USBx, ep->num);
 8010420:	687a      	ldr	r2, [r7, #4]
 8010422:	683b      	ldr	r3, [r7, #0]
 8010424:	781b      	ldrb	r3, [r3, #0]
 8010426:	009b      	lsls	r3, r3, #2
 8010428:	18d3      	adds	r3, r2, r3
 801042a:	881b      	ldrh	r3, [r3, #0]
 801042c:	b29a      	uxth	r2, r3
 801042e:	2026      	movs	r0, #38	; 0x26
 8010430:	183b      	adds	r3, r7, r0
 8010432:	4920      	ldr	r1, [pc, #128]	; (80104b4 <USB_DeactivateEndpoint+0x368>)
 8010434:	400a      	ands	r2, r1
 8010436:	801a      	strh	r2, [r3, #0]
 8010438:	687a      	ldr	r2, [r7, #4]
 801043a:	683b      	ldr	r3, [r7, #0]
 801043c:	781b      	ldrb	r3, [r3, #0]
 801043e:	009b      	lsls	r3, r3, #2
 8010440:	18d3      	adds	r3, r2, r3
 8010442:	183a      	adds	r2, r7, r0
 8010444:	8812      	ldrh	r2, [r2, #0]
 8010446:	491f      	ldr	r1, [pc, #124]	; (80104c4 <USB_DeactivateEndpoint+0x378>)
 8010448:	430a      	orrs	r2, r1
 801044a:	b292      	uxth	r2, r2
 801044c:	801a      	strh	r2, [r3, #0]

      /* Configure DISABLE status for the Endpoint*/
      PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_DIS);
 801044e:	687a      	ldr	r2, [r7, #4]
 8010450:	683b      	ldr	r3, [r7, #0]
 8010452:	781b      	ldrb	r3, [r3, #0]
 8010454:	009b      	lsls	r3, r3, #2
 8010456:	18d3      	adds	r3, r2, r3
 8010458:	881b      	ldrh	r3, [r3, #0]
 801045a:	b29a      	uxth	r2, r3
 801045c:	2024      	movs	r0, #36	; 0x24
 801045e:	183b      	adds	r3, r7, r0
 8010460:	4916      	ldr	r1, [pc, #88]	; (80104bc <USB_DeactivateEndpoint+0x370>)
 8010462:	400a      	ands	r2, r1
 8010464:	801a      	strh	r2, [r3, #0]
 8010466:	687a      	ldr	r2, [r7, #4]
 8010468:	683b      	ldr	r3, [r7, #0]
 801046a:	781b      	ldrb	r3, [r3, #0]
 801046c:	009b      	lsls	r3, r3, #2
 801046e:	18d3      	adds	r3, r2, r3
 8010470:	183a      	adds	r2, r7, r0
 8010472:	8812      	ldrh	r2, [r2, #0]
 8010474:	4912      	ldr	r1, [pc, #72]	; (80104c0 <USB_DeactivateEndpoint+0x374>)
 8010476:	430a      	orrs	r2, r1
 8010478:	b292      	uxth	r2, r2
 801047a:	801a      	strh	r2, [r3, #0]
      PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_DIS);
 801047c:	687a      	ldr	r2, [r7, #4]
 801047e:	683b      	ldr	r3, [r7, #0]
 8010480:	781b      	ldrb	r3, [r3, #0]
 8010482:	009b      	lsls	r3, r3, #2
 8010484:	18d3      	adds	r3, r2, r3
 8010486:	881b      	ldrh	r3, [r3, #0]
 8010488:	b29a      	uxth	r2, r3
 801048a:	2022      	movs	r0, #34	; 0x22
 801048c:	183b      	adds	r3, r7, r0
 801048e:	490e      	ldr	r1, [pc, #56]	; (80104c8 <USB_DeactivateEndpoint+0x37c>)
 8010490:	400a      	ands	r2, r1
 8010492:	801a      	strh	r2, [r3, #0]
 8010494:	687a      	ldr	r2, [r7, #4]
 8010496:	683b      	ldr	r3, [r7, #0]
 8010498:	781b      	ldrb	r3, [r3, #0]
 801049a:	009b      	lsls	r3, r3, #2
 801049c:	18d3      	adds	r3, r2, r3
 801049e:	183a      	adds	r2, r7, r0
 80104a0:	8812      	ldrh	r2, [r2, #0]
 80104a2:	4907      	ldr	r1, [pc, #28]	; (80104c0 <USB_DeactivateEndpoint+0x374>)
 80104a4:	430a      	orrs	r2, r1
 80104a6:	b292      	uxth	r2, r2
 80104a8:	801a      	strh	r2, [r3, #0]
    }
  }

  return HAL_OK;
 80104aa:	2300      	movs	r3, #0
}
 80104ac:	0018      	movs	r0, r3
 80104ae:	46bd      	mov	sp, r7
 80104b0:	b00c      	add	sp, #48	; 0x30
 80104b2:	bd80      	pop	{r7, pc}
 80104b4:	ffff8f8f 	.word	0xffff8f8f
 80104b8:	ffff80c0 	.word	0xffff80c0
 80104bc:	ffff8fbf 	.word	0xffff8fbf
 80104c0:	ffff8080 	.word	0xffff8080
 80104c4:	ffffc080 	.word	0xffffc080
 80104c8:	ffffbf8f 	.word	0xffffbf8f

080104cc <USB_EPStartXfer>:
  * @param  USBx Selected device
  * @param  ep pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EPStartXfer(USB_TypeDef *USBx, USB_EPTypeDef *ep)
{
 80104cc:	b590      	push	{r4, r7, lr}
 80104ce:	b0c3      	sub	sp, #268	; 0x10c
 80104d0:	af00      	add	r7, sp, #0
 80104d2:	6078      	str	r0, [r7, #4]
 80104d4:	6039      	str	r1, [r7, #0]
  uint32_t len;
  uint16_t pmabuffer;
  uint16_t wEPVal;

  /* IN endpoint */
  if (ep->is_in == 1U)
 80104d6:	683b      	ldr	r3, [r7, #0]
 80104d8:	785b      	ldrb	r3, [r3, #1]
 80104da:	2b01      	cmp	r3, #1
 80104dc:	d001      	beq.n	80104e2 <USB_EPStartXfer+0x16>
 80104de:	f000 fcef 	bl	8010ec0 <USB_EPStartXfer+0x9f4>
  {
    /*Multi packet transfer*/
    if (ep->xfer_len > ep->maxpacket)
 80104e2:	683b      	ldr	r3, [r7, #0]
 80104e4:	699a      	ldr	r2, [r3, #24]
 80104e6:	683b      	ldr	r3, [r7, #0]
 80104e8:	691b      	ldr	r3, [r3, #16]
 80104ea:	429a      	cmp	r2, r3
 80104ec:	d905      	bls.n	80104fa <USB_EPStartXfer+0x2e>
    {
      len = ep->maxpacket;
 80104ee:	683b      	ldr	r3, [r7, #0]
 80104f0:	691b      	ldr	r3, [r3, #16]
 80104f2:	1d7a      	adds	r2, r7, #5
 80104f4:	32ff      	adds	r2, #255	; 0xff
 80104f6:	6013      	str	r3, [r2, #0]
 80104f8:	e004      	b.n	8010504 <USB_EPStartXfer+0x38>
    }
    else
    {
      len = ep->xfer_len;
 80104fa:	683b      	ldr	r3, [r7, #0]
 80104fc:	699b      	ldr	r3, [r3, #24]
 80104fe:	1d7a      	adds	r2, r7, #5
 8010500:	32ff      	adds	r2, #255	; 0xff
 8010502:	6013      	str	r3, [r2, #0]
    }

    /* configure and validate Tx endpoint */
    if (ep->doublebuffer == 0U)
 8010504:	683b      	ldr	r3, [r7, #0]
 8010506:	7b1b      	ldrb	r3, [r3, #12]
 8010508:	2b00      	cmp	r3, #0
 801050a:	d125      	bne.n	8010558 <USB_EPStartXfer+0x8c>
    {
      USB_WritePMA(USBx, ep->xfer_buff, ep->pmaadress, (uint16_t)len);
 801050c:	683b      	ldr	r3, [r7, #0]
 801050e:	6959      	ldr	r1, [r3, #20]
 8010510:	683b      	ldr	r3, [r7, #0]
 8010512:	88da      	ldrh	r2, [r3, #6]
 8010514:	1d7b      	adds	r3, r7, #5
 8010516:	33ff      	adds	r3, #255	; 0xff
 8010518:	681b      	ldr	r3, [r3, #0]
 801051a:	b29b      	uxth	r3, r3
 801051c:	6878      	ldr	r0, [r7, #4]
 801051e:	f001 f9c9 	bl	80118b4 <USB_WritePMA>
      PCD_SET_EP_TX_CNT(USBx, ep->num, len);
 8010522:	687b      	ldr	r3, [r7, #4]
 8010524:	613b      	str	r3, [r7, #16]
 8010526:	687b      	ldr	r3, [r7, #4]
 8010528:	2250      	movs	r2, #80	; 0x50
 801052a:	5a9b      	ldrh	r3, [r3, r2]
 801052c:	b29b      	uxth	r3, r3
 801052e:	001a      	movs	r2, r3
 8010530:	693b      	ldr	r3, [r7, #16]
 8010532:	189b      	adds	r3, r3, r2
 8010534:	613b      	str	r3, [r7, #16]
 8010536:	683b      	ldr	r3, [r7, #0]
 8010538:	781b      	ldrb	r3, [r3, #0]
 801053a:	00da      	lsls	r2, r3, #3
 801053c:	693b      	ldr	r3, [r7, #16]
 801053e:	18d3      	adds	r3, r2, r3
 8010540:	4acc      	ldr	r2, [pc, #816]	; (8010874 <USB_EPStartXfer+0x3a8>)
 8010542:	4694      	mov	ip, r2
 8010544:	4463      	add	r3, ip
 8010546:	60fb      	str	r3, [r7, #12]
 8010548:	1d7b      	adds	r3, r7, #5
 801054a:	33ff      	adds	r3, #255	; 0xff
 801054c:	681b      	ldr	r3, [r3, #0]
 801054e:	b29a      	uxth	r2, r3
 8010550:	68fb      	ldr	r3, [r7, #12]
 8010552:	801a      	strh	r2, [r3, #0]
 8010554:	f000 fc8f 	bl	8010e76 <USB_EPStartXfer+0x9aa>
    }
    else
    {
      /* double buffer bulk management */
      if (ep->type == EP_TYPE_BULK)
 8010558:	683b      	ldr	r3, [r7, #0]
 801055a:	78db      	ldrb	r3, [r3, #3]
 801055c:	2b02      	cmp	r3, #2
 801055e:	d000      	beq.n	8010562 <USB_EPStartXfer+0x96>
 8010560:	e33a      	b.n	8010bd8 <USB_EPStartXfer+0x70c>
      {
        if (ep->xfer_len_db > ep->maxpacket)
 8010562:	683b      	ldr	r3, [r7, #0]
 8010564:	6a1a      	ldr	r2, [r3, #32]
 8010566:	683b      	ldr	r3, [r7, #0]
 8010568:	691b      	ldr	r3, [r3, #16]
 801056a:	429a      	cmp	r2, r3
 801056c:	d800      	bhi.n	8010570 <USB_EPStartXfer+0xa4>
 801056e:	e2df      	b.n	8010b30 <USB_EPStartXfer+0x664>
        {
          /* enable double buffer */
          PCD_SET_BULK_EP_DBUF(USBx, ep->num);
 8010570:	687a      	ldr	r2, [r7, #4]
 8010572:	683b      	ldr	r3, [r7, #0]
 8010574:	781b      	ldrb	r3, [r3, #0]
 8010576:	009b      	lsls	r3, r3, #2
 8010578:	18d3      	adds	r3, r2, r3
 801057a:	881b      	ldrh	r3, [r3, #0]
 801057c:	b29a      	uxth	r2, r3
 801057e:	2056      	movs	r0, #86	; 0x56
 8010580:	183b      	adds	r3, r7, r0
 8010582:	49bd      	ldr	r1, [pc, #756]	; (8010878 <USB_EPStartXfer+0x3ac>)
 8010584:	400a      	ands	r2, r1
 8010586:	801a      	strh	r2, [r3, #0]
 8010588:	687a      	ldr	r2, [r7, #4]
 801058a:	683b      	ldr	r3, [r7, #0]
 801058c:	781b      	ldrb	r3, [r3, #0]
 801058e:	009b      	lsls	r3, r3, #2
 8010590:	18d3      	adds	r3, r2, r3
 8010592:	183a      	adds	r2, r7, r0
 8010594:	8812      	ldrh	r2, [r2, #0]
 8010596:	49b9      	ldr	r1, [pc, #740]	; (801087c <USB_EPStartXfer+0x3b0>)
 8010598:	430a      	orrs	r2, r1
 801059a:	b292      	uxth	r2, r2
 801059c:	801a      	strh	r2, [r3, #0]

          /* each Time to write in PMA xfer_len_db will */
          ep->xfer_len_db -= len;
 801059e:	683b      	ldr	r3, [r7, #0]
 80105a0:	6a1a      	ldr	r2, [r3, #32]
 80105a2:	1d7b      	adds	r3, r7, #5
 80105a4:	33ff      	adds	r3, #255	; 0xff
 80105a6:	681b      	ldr	r3, [r3, #0]
 80105a8:	1ad2      	subs	r2, r2, r3
 80105aa:	683b      	ldr	r3, [r7, #0]
 80105ac:	621a      	str	r2, [r3, #32]

          /* Fill the two first buffer in the Buffer0 & Buffer1 */
          if ((PCD_GET_ENDPOINT(USBx, ep->num) & USB_EP_DTOG_TX) != 0U)
 80105ae:	687a      	ldr	r2, [r7, #4]
 80105b0:	683b      	ldr	r3, [r7, #0]
 80105b2:	781b      	ldrb	r3, [r3, #0]
 80105b4:	009b      	lsls	r3, r3, #2
 80105b6:	18d3      	adds	r3, r2, r3
 80105b8:	881b      	ldrh	r3, [r3, #0]
 80105ba:	b29b      	uxth	r3, r3
 80105bc:	001a      	movs	r2, r3
 80105be:	2340      	movs	r3, #64	; 0x40
 80105c0:	4013      	ands	r3, r2
 80105c2:	d100      	bne.n	80105c6 <USB_EPStartXfer+0xfa>
 80105c4:	e162      	b.n	801088c <USB_EPStartXfer+0x3c0>
          {
            /* Set the Double buffer counter for pmabuffer1 */
            PCD_SET_EP_DBUF1_CNT(USBx, ep->num, ep->is_in, len);
 80105c6:	687b      	ldr	r3, [r7, #4]
 80105c8:	633b      	str	r3, [r7, #48]	; 0x30
 80105ca:	683b      	ldr	r3, [r7, #0]
 80105cc:	785b      	ldrb	r3, [r3, #1]
 80105ce:	2b00      	cmp	r3, #0
 80105d0:	d16a      	bne.n	80106a8 <USB_EPStartXfer+0x1dc>
 80105d2:	687b      	ldr	r3, [r7, #4]
 80105d4:	62bb      	str	r3, [r7, #40]	; 0x28
 80105d6:	687b      	ldr	r3, [r7, #4]
 80105d8:	2250      	movs	r2, #80	; 0x50
 80105da:	5a9b      	ldrh	r3, [r3, r2]
 80105dc:	b29b      	uxth	r3, r3
 80105de:	001a      	movs	r2, r3
 80105e0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80105e2:	189b      	adds	r3, r3, r2
 80105e4:	62bb      	str	r3, [r7, #40]	; 0x28
 80105e6:	683b      	ldr	r3, [r7, #0]
 80105e8:	781b      	ldrb	r3, [r3, #0]
 80105ea:	00da      	lsls	r2, r3, #3
 80105ec:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80105ee:	18d3      	adds	r3, r2, r3
 80105f0:	4aa3      	ldr	r2, [pc, #652]	; (8010880 <USB_EPStartXfer+0x3b4>)
 80105f2:	4694      	mov	ip, r2
 80105f4:	4463      	add	r3, ip
 80105f6:	627b      	str	r3, [r7, #36]	; 0x24
 80105f8:	1d7b      	adds	r3, r7, #5
 80105fa:	33ff      	adds	r3, #255	; 0xff
 80105fc:	681b      	ldr	r3, [r3, #0]
 80105fe:	2b00      	cmp	r3, #0
 8010600:	d110      	bne.n	8010624 <USB_EPStartXfer+0x158>
 8010602:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010604:	881b      	ldrh	r3, [r3, #0]
 8010606:	b29b      	uxth	r3, r3
 8010608:	4a9e      	ldr	r2, [pc, #632]	; (8010884 <USB_EPStartXfer+0x3b8>)
 801060a:	4013      	ands	r3, r2
 801060c:	b29a      	uxth	r2, r3
 801060e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010610:	801a      	strh	r2, [r3, #0]
 8010612:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010614:	881b      	ldrh	r3, [r3, #0]
 8010616:	b29b      	uxth	r3, r3
 8010618:	4a9b      	ldr	r2, [pc, #620]	; (8010888 <USB_EPStartXfer+0x3bc>)
 801061a:	4313      	orrs	r3, r2
 801061c:	b29a      	uxth	r2, r3
 801061e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010620:	801a      	strh	r2, [r3, #0]
 8010622:	e05c      	b.n	80106de <USB_EPStartXfer+0x212>
 8010624:	1d7b      	adds	r3, r7, #5
 8010626:	33ff      	adds	r3, #255	; 0xff
 8010628:	681b      	ldr	r3, [r3, #0]
 801062a:	2b3e      	cmp	r3, #62	; 0x3e
 801062c:	d81c      	bhi.n	8010668 <USB_EPStartXfer+0x19c>
 801062e:	1d7b      	adds	r3, r7, #5
 8010630:	33ff      	adds	r3, #255	; 0xff
 8010632:	681b      	ldr	r3, [r3, #0]
 8010634:	085b      	lsrs	r3, r3, #1
 8010636:	1c7a      	adds	r2, r7, #1
 8010638:	32ff      	adds	r2, #255	; 0xff
 801063a:	6013      	str	r3, [r2, #0]
 801063c:	1d7b      	adds	r3, r7, #5
 801063e:	33ff      	adds	r3, #255	; 0xff
 8010640:	681b      	ldr	r3, [r3, #0]
 8010642:	2201      	movs	r2, #1
 8010644:	4013      	ands	r3, r2
 8010646:	d006      	beq.n	8010656 <USB_EPStartXfer+0x18a>
 8010648:	1c7b      	adds	r3, r7, #1
 801064a:	33ff      	adds	r3, #255	; 0xff
 801064c:	681b      	ldr	r3, [r3, #0]
 801064e:	3301      	adds	r3, #1
 8010650:	1c7a      	adds	r2, r7, #1
 8010652:	32ff      	adds	r2, #255	; 0xff
 8010654:	6013      	str	r3, [r2, #0]
 8010656:	1c7b      	adds	r3, r7, #1
 8010658:	33ff      	adds	r3, #255	; 0xff
 801065a:	681b      	ldr	r3, [r3, #0]
 801065c:	b29b      	uxth	r3, r3
 801065e:	029b      	lsls	r3, r3, #10
 8010660:	b29a      	uxth	r2, r3
 8010662:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010664:	801a      	strh	r2, [r3, #0]
 8010666:	e03a      	b.n	80106de <USB_EPStartXfer+0x212>
 8010668:	1d7b      	adds	r3, r7, #5
 801066a:	33ff      	adds	r3, #255	; 0xff
 801066c:	681b      	ldr	r3, [r3, #0]
 801066e:	095b      	lsrs	r3, r3, #5
 8010670:	1c7a      	adds	r2, r7, #1
 8010672:	32ff      	adds	r2, #255	; 0xff
 8010674:	6013      	str	r3, [r2, #0]
 8010676:	1d7b      	adds	r3, r7, #5
 8010678:	33ff      	adds	r3, #255	; 0xff
 801067a:	681b      	ldr	r3, [r3, #0]
 801067c:	221f      	movs	r2, #31
 801067e:	4013      	ands	r3, r2
 8010680:	d106      	bne.n	8010690 <USB_EPStartXfer+0x1c4>
 8010682:	1c7b      	adds	r3, r7, #1
 8010684:	33ff      	adds	r3, #255	; 0xff
 8010686:	681b      	ldr	r3, [r3, #0]
 8010688:	3b01      	subs	r3, #1
 801068a:	1c7a      	adds	r2, r7, #1
 801068c:	32ff      	adds	r2, #255	; 0xff
 801068e:	6013      	str	r3, [r2, #0]
 8010690:	1c7b      	adds	r3, r7, #1
 8010692:	33ff      	adds	r3, #255	; 0xff
 8010694:	681b      	ldr	r3, [r3, #0]
 8010696:	b29b      	uxth	r3, r3
 8010698:	029b      	lsls	r3, r3, #10
 801069a:	b29b      	uxth	r3, r3
 801069c:	4a7a      	ldr	r2, [pc, #488]	; (8010888 <USB_EPStartXfer+0x3bc>)
 801069e:	4313      	orrs	r3, r2
 80106a0:	b29a      	uxth	r2, r3
 80106a2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80106a4:	801a      	strh	r2, [r3, #0]
 80106a6:	e01a      	b.n	80106de <USB_EPStartXfer+0x212>
 80106a8:	683b      	ldr	r3, [r7, #0]
 80106aa:	785b      	ldrb	r3, [r3, #1]
 80106ac:	2b01      	cmp	r3, #1
 80106ae:	d116      	bne.n	80106de <USB_EPStartXfer+0x212>
 80106b0:	687b      	ldr	r3, [r7, #4]
 80106b2:	2250      	movs	r2, #80	; 0x50
 80106b4:	5a9b      	ldrh	r3, [r3, r2]
 80106b6:	b29b      	uxth	r3, r3
 80106b8:	001a      	movs	r2, r3
 80106ba:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80106bc:	189b      	adds	r3, r3, r2
 80106be:	633b      	str	r3, [r7, #48]	; 0x30
 80106c0:	683b      	ldr	r3, [r7, #0]
 80106c2:	781b      	ldrb	r3, [r3, #0]
 80106c4:	00da      	lsls	r2, r3, #3
 80106c6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80106c8:	18d3      	adds	r3, r2, r3
 80106ca:	4a6d      	ldr	r2, [pc, #436]	; (8010880 <USB_EPStartXfer+0x3b4>)
 80106cc:	4694      	mov	ip, r2
 80106ce:	4463      	add	r3, ip
 80106d0:	62fb      	str	r3, [r7, #44]	; 0x2c
 80106d2:	1d7b      	adds	r3, r7, #5
 80106d4:	33ff      	adds	r3, #255	; 0xff
 80106d6:	681b      	ldr	r3, [r3, #0]
 80106d8:	b29a      	uxth	r2, r3
 80106da:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80106dc:	801a      	strh	r2, [r3, #0]
            pmabuffer = ep->pmaaddr1;
 80106de:	2076      	movs	r0, #118	; 0x76
 80106e0:	183b      	adds	r3, r7, r0
 80106e2:	683a      	ldr	r2, [r7, #0]
 80106e4:	8952      	ldrh	r2, [r2, #10]
 80106e6:	801a      	strh	r2, [r3, #0]

            /* Write the user buffer to USB PMA */
            USB_WritePMA(USBx, ep->xfer_buff, pmabuffer, (uint16_t)len);
 80106e8:	683b      	ldr	r3, [r7, #0]
 80106ea:	6959      	ldr	r1, [r3, #20]
 80106ec:	1d7b      	adds	r3, r7, #5
 80106ee:	33ff      	adds	r3, #255	; 0xff
 80106f0:	681b      	ldr	r3, [r3, #0]
 80106f2:	b29c      	uxth	r4, r3
 80106f4:	183b      	adds	r3, r7, r0
 80106f6:	881a      	ldrh	r2, [r3, #0]
 80106f8:	6878      	ldr	r0, [r7, #4]
 80106fa:	0023      	movs	r3, r4
 80106fc:	f001 f8da 	bl	80118b4 <USB_WritePMA>
            ep->xfer_buff += len;
 8010700:	683b      	ldr	r3, [r7, #0]
 8010702:	695a      	ldr	r2, [r3, #20]
 8010704:	1d7b      	adds	r3, r7, #5
 8010706:	33ff      	adds	r3, #255	; 0xff
 8010708:	681b      	ldr	r3, [r3, #0]
 801070a:	18d2      	adds	r2, r2, r3
 801070c:	683b      	ldr	r3, [r7, #0]
 801070e:	615a      	str	r2, [r3, #20]

            if (ep->xfer_len_db > ep->maxpacket)
 8010710:	683b      	ldr	r3, [r7, #0]
 8010712:	6a1a      	ldr	r2, [r3, #32]
 8010714:	683b      	ldr	r3, [r7, #0]
 8010716:	691b      	ldr	r3, [r3, #16]
 8010718:	429a      	cmp	r2, r3
 801071a:	d908      	bls.n	801072e <USB_EPStartXfer+0x262>
            {
              ep->xfer_len_db -= len;
 801071c:	683b      	ldr	r3, [r7, #0]
 801071e:	6a1a      	ldr	r2, [r3, #32]
 8010720:	1d7b      	adds	r3, r7, #5
 8010722:	33ff      	adds	r3, #255	; 0xff
 8010724:	681b      	ldr	r3, [r3, #0]
 8010726:	1ad2      	subs	r2, r2, r3
 8010728:	683b      	ldr	r3, [r7, #0]
 801072a:	621a      	str	r2, [r3, #32]
 801072c:	e007      	b.n	801073e <USB_EPStartXfer+0x272>
            }
            else
            {
              len = ep->xfer_len_db;
 801072e:	683b      	ldr	r3, [r7, #0]
 8010730:	6a1b      	ldr	r3, [r3, #32]
 8010732:	1d7a      	adds	r2, r7, #5
 8010734:	32ff      	adds	r2, #255	; 0xff
 8010736:	6013      	str	r3, [r2, #0]
              ep->xfer_len_db = 0U;
 8010738:	683b      	ldr	r3, [r7, #0]
 801073a:	2200      	movs	r2, #0
 801073c:	621a      	str	r2, [r3, #32]
            }

            /* Set the Double buffer counter for pmabuffer0 */
            PCD_SET_EP_DBUF0_CNT(USBx, ep->num, ep->is_in, len);
 801073e:	683b      	ldr	r3, [r7, #0]
 8010740:	785b      	ldrb	r3, [r3, #1]
 8010742:	2b00      	cmp	r3, #0
 8010744:	d166      	bne.n	8010814 <USB_EPStartXfer+0x348>
 8010746:	687b      	ldr	r3, [r7, #4]
 8010748:	61bb      	str	r3, [r7, #24]
 801074a:	687b      	ldr	r3, [r7, #4]
 801074c:	2250      	movs	r2, #80	; 0x50
 801074e:	5a9b      	ldrh	r3, [r3, r2]
 8010750:	b29b      	uxth	r3, r3
 8010752:	001a      	movs	r2, r3
 8010754:	69bb      	ldr	r3, [r7, #24]
 8010756:	189b      	adds	r3, r3, r2
 8010758:	61bb      	str	r3, [r7, #24]
 801075a:	683b      	ldr	r3, [r7, #0]
 801075c:	781b      	ldrb	r3, [r3, #0]
 801075e:	00da      	lsls	r2, r3, #3
 8010760:	69bb      	ldr	r3, [r7, #24]
 8010762:	18d3      	adds	r3, r2, r3
 8010764:	4a43      	ldr	r2, [pc, #268]	; (8010874 <USB_EPStartXfer+0x3a8>)
 8010766:	4694      	mov	ip, r2
 8010768:	4463      	add	r3, ip
 801076a:	617b      	str	r3, [r7, #20]
 801076c:	1d7b      	adds	r3, r7, #5
 801076e:	33ff      	adds	r3, #255	; 0xff
 8010770:	681b      	ldr	r3, [r3, #0]
 8010772:	2b00      	cmp	r3, #0
 8010774:	d110      	bne.n	8010798 <USB_EPStartXfer+0x2cc>
 8010776:	697b      	ldr	r3, [r7, #20]
 8010778:	881b      	ldrh	r3, [r3, #0]
 801077a:	b29b      	uxth	r3, r3
 801077c:	4a41      	ldr	r2, [pc, #260]	; (8010884 <USB_EPStartXfer+0x3b8>)
 801077e:	4013      	ands	r3, r2
 8010780:	b29a      	uxth	r2, r3
 8010782:	697b      	ldr	r3, [r7, #20]
 8010784:	801a      	strh	r2, [r3, #0]
 8010786:	697b      	ldr	r3, [r7, #20]
 8010788:	881b      	ldrh	r3, [r3, #0]
 801078a:	b29b      	uxth	r3, r3
 801078c:	4a3e      	ldr	r2, [pc, #248]	; (8010888 <USB_EPStartXfer+0x3bc>)
 801078e:	4313      	orrs	r3, r2
 8010790:	b29a      	uxth	r2, r3
 8010792:	697b      	ldr	r3, [r7, #20]
 8010794:	801a      	strh	r2, [r3, #0]
 8010796:	e05a      	b.n	801084e <USB_EPStartXfer+0x382>
 8010798:	1d7b      	adds	r3, r7, #5
 801079a:	33ff      	adds	r3, #255	; 0xff
 801079c:	681b      	ldr	r3, [r3, #0]
 801079e:	2b3e      	cmp	r3, #62	; 0x3e
 80107a0:	d81a      	bhi.n	80107d8 <USB_EPStartXfer+0x30c>
 80107a2:	1d7b      	adds	r3, r7, #5
 80107a4:	33ff      	adds	r3, #255	; 0xff
 80107a6:	681b      	ldr	r3, [r3, #0]
 80107a8:	085b      	lsrs	r3, r3, #1
 80107aa:	21fc      	movs	r1, #252	; 0xfc
 80107ac:	187a      	adds	r2, r7, r1
 80107ae:	6013      	str	r3, [r2, #0]
 80107b0:	1d7b      	adds	r3, r7, #5
 80107b2:	33ff      	adds	r3, #255	; 0xff
 80107b4:	681b      	ldr	r3, [r3, #0]
 80107b6:	2201      	movs	r2, #1
 80107b8:	4013      	ands	r3, r2
 80107ba:	d004      	beq.n	80107c6 <USB_EPStartXfer+0x2fa>
 80107bc:	187b      	adds	r3, r7, r1
 80107be:	681b      	ldr	r3, [r3, #0]
 80107c0:	3301      	adds	r3, #1
 80107c2:	187a      	adds	r2, r7, r1
 80107c4:	6013      	str	r3, [r2, #0]
 80107c6:	23fc      	movs	r3, #252	; 0xfc
 80107c8:	18fb      	adds	r3, r7, r3
 80107ca:	681b      	ldr	r3, [r3, #0]
 80107cc:	b29b      	uxth	r3, r3
 80107ce:	029b      	lsls	r3, r3, #10
 80107d0:	b29a      	uxth	r2, r3
 80107d2:	697b      	ldr	r3, [r7, #20]
 80107d4:	801a      	strh	r2, [r3, #0]
 80107d6:	e03a      	b.n	801084e <USB_EPStartXfer+0x382>
 80107d8:	1d7b      	adds	r3, r7, #5
 80107da:	33ff      	adds	r3, #255	; 0xff
 80107dc:	681b      	ldr	r3, [r3, #0]
 80107de:	095b      	lsrs	r3, r3, #5
 80107e0:	21fc      	movs	r1, #252	; 0xfc
 80107e2:	187a      	adds	r2, r7, r1
 80107e4:	6013      	str	r3, [r2, #0]
 80107e6:	1d7b      	adds	r3, r7, #5
 80107e8:	33ff      	adds	r3, #255	; 0xff
 80107ea:	681b      	ldr	r3, [r3, #0]
 80107ec:	221f      	movs	r2, #31
 80107ee:	4013      	ands	r3, r2
 80107f0:	d104      	bne.n	80107fc <USB_EPStartXfer+0x330>
 80107f2:	187b      	adds	r3, r7, r1
 80107f4:	681b      	ldr	r3, [r3, #0]
 80107f6:	3b01      	subs	r3, #1
 80107f8:	187a      	adds	r2, r7, r1
 80107fa:	6013      	str	r3, [r2, #0]
 80107fc:	23fc      	movs	r3, #252	; 0xfc
 80107fe:	18fb      	adds	r3, r7, r3
 8010800:	681b      	ldr	r3, [r3, #0]
 8010802:	b29b      	uxth	r3, r3
 8010804:	029b      	lsls	r3, r3, #10
 8010806:	b29b      	uxth	r3, r3
 8010808:	4a1f      	ldr	r2, [pc, #124]	; (8010888 <USB_EPStartXfer+0x3bc>)
 801080a:	4313      	orrs	r3, r2
 801080c:	b29a      	uxth	r2, r3
 801080e:	697b      	ldr	r3, [r7, #20]
 8010810:	801a      	strh	r2, [r3, #0]
 8010812:	e01c      	b.n	801084e <USB_EPStartXfer+0x382>
 8010814:	683b      	ldr	r3, [r7, #0]
 8010816:	785b      	ldrb	r3, [r3, #1]
 8010818:	2b01      	cmp	r3, #1
 801081a:	d118      	bne.n	801084e <USB_EPStartXfer+0x382>
 801081c:	687b      	ldr	r3, [r7, #4]
 801081e:	623b      	str	r3, [r7, #32]
 8010820:	687b      	ldr	r3, [r7, #4]
 8010822:	2250      	movs	r2, #80	; 0x50
 8010824:	5a9b      	ldrh	r3, [r3, r2]
 8010826:	b29b      	uxth	r3, r3
 8010828:	001a      	movs	r2, r3
 801082a:	6a3b      	ldr	r3, [r7, #32]
 801082c:	189b      	adds	r3, r3, r2
 801082e:	623b      	str	r3, [r7, #32]
 8010830:	683b      	ldr	r3, [r7, #0]
 8010832:	781b      	ldrb	r3, [r3, #0]
 8010834:	00da      	lsls	r2, r3, #3
 8010836:	6a3b      	ldr	r3, [r7, #32]
 8010838:	18d3      	adds	r3, r2, r3
 801083a:	4a0e      	ldr	r2, [pc, #56]	; (8010874 <USB_EPStartXfer+0x3a8>)
 801083c:	4694      	mov	ip, r2
 801083e:	4463      	add	r3, ip
 8010840:	61fb      	str	r3, [r7, #28]
 8010842:	1d7b      	adds	r3, r7, #5
 8010844:	33ff      	adds	r3, #255	; 0xff
 8010846:	681b      	ldr	r3, [r3, #0]
 8010848:	b29a      	uxth	r2, r3
 801084a:	69fb      	ldr	r3, [r7, #28]
 801084c:	801a      	strh	r2, [r3, #0]
            pmabuffer = ep->pmaaddr0;
 801084e:	2076      	movs	r0, #118	; 0x76
 8010850:	183b      	adds	r3, r7, r0
 8010852:	683a      	ldr	r2, [r7, #0]
 8010854:	8912      	ldrh	r2, [r2, #8]
 8010856:	801a      	strh	r2, [r3, #0]

            /* Write the user buffer to USB PMA */
            USB_WritePMA(USBx, ep->xfer_buff, pmabuffer, (uint16_t)len);
 8010858:	683b      	ldr	r3, [r7, #0]
 801085a:	6959      	ldr	r1, [r3, #20]
 801085c:	1d7b      	adds	r3, r7, #5
 801085e:	33ff      	adds	r3, #255	; 0xff
 8010860:	681b      	ldr	r3, [r3, #0]
 8010862:	b29c      	uxth	r4, r3
 8010864:	183b      	adds	r3, r7, r0
 8010866:	881a      	ldrh	r2, [r3, #0]
 8010868:	6878      	ldr	r0, [r7, #4]
 801086a:	0023      	movs	r3, r4
 801086c:	f001 f822 	bl	80118b4 <USB_WritePMA>
 8010870:	e301      	b.n	8010e76 <USB_EPStartXfer+0x9aa>
 8010872:	46c0      	nop			; (mov r8, r8)
 8010874:	00000402 	.word	0x00000402
 8010878:	ffff8f8f 	.word	0xffff8f8f
 801087c:	ffff8180 	.word	0xffff8180
 8010880:	00000406 	.word	0x00000406
 8010884:	ffff83ff 	.word	0xffff83ff
 8010888:	ffff8000 	.word	0xffff8000
          }
          else
          {
            /* Set the Double buffer counter for pmabuffer0 */
            PCD_SET_EP_DBUF0_CNT(USBx, ep->num, ep->is_in, len);
 801088c:	683b      	ldr	r3, [r7, #0]
 801088e:	785b      	ldrb	r3, [r3, #1]
 8010890:	2b00      	cmp	r3, #0
 8010892:	d166      	bne.n	8010962 <USB_EPStartXfer+0x496>
 8010894:	687b      	ldr	r3, [r7, #4]
 8010896:	64bb      	str	r3, [r7, #72]	; 0x48
 8010898:	687b      	ldr	r3, [r7, #4]
 801089a:	2250      	movs	r2, #80	; 0x50
 801089c:	5a9b      	ldrh	r3, [r3, r2]
 801089e:	b29b      	uxth	r3, r3
 80108a0:	001a      	movs	r2, r3
 80108a2:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80108a4:	189b      	adds	r3, r3, r2
 80108a6:	64bb      	str	r3, [r7, #72]	; 0x48
 80108a8:	683b      	ldr	r3, [r7, #0]
 80108aa:	781b      	ldrb	r3, [r3, #0]
 80108ac:	00da      	lsls	r2, r3, #3
 80108ae:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80108b0:	18d3      	adds	r3, r2, r3
 80108b2:	4ac3      	ldr	r2, [pc, #780]	; (8010bc0 <USB_EPStartXfer+0x6f4>)
 80108b4:	4694      	mov	ip, r2
 80108b6:	4463      	add	r3, ip
 80108b8:	647b      	str	r3, [r7, #68]	; 0x44
 80108ba:	1d7b      	adds	r3, r7, #5
 80108bc:	33ff      	adds	r3, #255	; 0xff
 80108be:	681b      	ldr	r3, [r3, #0]
 80108c0:	2b00      	cmp	r3, #0
 80108c2:	d110      	bne.n	80108e6 <USB_EPStartXfer+0x41a>
 80108c4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80108c6:	881b      	ldrh	r3, [r3, #0]
 80108c8:	b29b      	uxth	r3, r3
 80108ca:	4abe      	ldr	r2, [pc, #760]	; (8010bc4 <USB_EPStartXfer+0x6f8>)
 80108cc:	4013      	ands	r3, r2
 80108ce:	b29a      	uxth	r2, r3
 80108d0:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80108d2:	801a      	strh	r2, [r3, #0]
 80108d4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80108d6:	881b      	ldrh	r3, [r3, #0]
 80108d8:	b29b      	uxth	r3, r3
 80108da:	4abb      	ldr	r2, [pc, #748]	; (8010bc8 <USB_EPStartXfer+0x6fc>)
 80108dc:	4313      	orrs	r3, r2
 80108de:	b29a      	uxth	r2, r3
 80108e0:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80108e2:	801a      	strh	r2, [r3, #0]
 80108e4:	e05a      	b.n	801099c <USB_EPStartXfer+0x4d0>
 80108e6:	1d7b      	adds	r3, r7, #5
 80108e8:	33ff      	adds	r3, #255	; 0xff
 80108ea:	681b      	ldr	r3, [r3, #0]
 80108ec:	2b3e      	cmp	r3, #62	; 0x3e
 80108ee:	d81a      	bhi.n	8010926 <USB_EPStartXfer+0x45a>
 80108f0:	1d7b      	adds	r3, r7, #5
 80108f2:	33ff      	adds	r3, #255	; 0xff
 80108f4:	681b      	ldr	r3, [r3, #0]
 80108f6:	085b      	lsrs	r3, r3, #1
 80108f8:	21f8      	movs	r1, #248	; 0xf8
 80108fa:	187a      	adds	r2, r7, r1
 80108fc:	6013      	str	r3, [r2, #0]
 80108fe:	1d7b      	adds	r3, r7, #5
 8010900:	33ff      	adds	r3, #255	; 0xff
 8010902:	681b      	ldr	r3, [r3, #0]
 8010904:	2201      	movs	r2, #1
 8010906:	4013      	ands	r3, r2
 8010908:	d004      	beq.n	8010914 <USB_EPStartXfer+0x448>
 801090a:	187b      	adds	r3, r7, r1
 801090c:	681b      	ldr	r3, [r3, #0]
 801090e:	3301      	adds	r3, #1
 8010910:	187a      	adds	r2, r7, r1
 8010912:	6013      	str	r3, [r2, #0]
 8010914:	23f8      	movs	r3, #248	; 0xf8
 8010916:	18fb      	adds	r3, r7, r3
 8010918:	681b      	ldr	r3, [r3, #0]
 801091a:	b29b      	uxth	r3, r3
 801091c:	029b      	lsls	r3, r3, #10
 801091e:	b29a      	uxth	r2, r3
 8010920:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8010922:	801a      	strh	r2, [r3, #0]
 8010924:	e03a      	b.n	801099c <USB_EPStartXfer+0x4d0>
 8010926:	1d7b      	adds	r3, r7, #5
 8010928:	33ff      	adds	r3, #255	; 0xff
 801092a:	681b      	ldr	r3, [r3, #0]
 801092c:	095b      	lsrs	r3, r3, #5
 801092e:	21f8      	movs	r1, #248	; 0xf8
 8010930:	187a      	adds	r2, r7, r1
 8010932:	6013      	str	r3, [r2, #0]
 8010934:	1d7b      	adds	r3, r7, #5
 8010936:	33ff      	adds	r3, #255	; 0xff
 8010938:	681b      	ldr	r3, [r3, #0]
 801093a:	221f      	movs	r2, #31
 801093c:	4013      	ands	r3, r2
 801093e:	d104      	bne.n	801094a <USB_EPStartXfer+0x47e>
 8010940:	187b      	adds	r3, r7, r1
 8010942:	681b      	ldr	r3, [r3, #0]
 8010944:	3b01      	subs	r3, #1
 8010946:	187a      	adds	r2, r7, r1
 8010948:	6013      	str	r3, [r2, #0]
 801094a:	23f8      	movs	r3, #248	; 0xf8
 801094c:	18fb      	adds	r3, r7, r3
 801094e:	681b      	ldr	r3, [r3, #0]
 8010950:	b29b      	uxth	r3, r3
 8010952:	029b      	lsls	r3, r3, #10
 8010954:	b29b      	uxth	r3, r3
 8010956:	4a9c      	ldr	r2, [pc, #624]	; (8010bc8 <USB_EPStartXfer+0x6fc>)
 8010958:	4313      	orrs	r3, r2
 801095a:	b29a      	uxth	r2, r3
 801095c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801095e:	801a      	strh	r2, [r3, #0]
 8010960:	e01c      	b.n	801099c <USB_EPStartXfer+0x4d0>
 8010962:	683b      	ldr	r3, [r7, #0]
 8010964:	785b      	ldrb	r3, [r3, #1]
 8010966:	2b01      	cmp	r3, #1
 8010968:	d118      	bne.n	801099c <USB_EPStartXfer+0x4d0>
 801096a:	687b      	ldr	r3, [r7, #4]
 801096c:	653b      	str	r3, [r7, #80]	; 0x50
 801096e:	687b      	ldr	r3, [r7, #4]
 8010970:	2250      	movs	r2, #80	; 0x50
 8010972:	5a9b      	ldrh	r3, [r3, r2]
 8010974:	b29b      	uxth	r3, r3
 8010976:	001a      	movs	r2, r3
 8010978:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801097a:	189b      	adds	r3, r3, r2
 801097c:	653b      	str	r3, [r7, #80]	; 0x50
 801097e:	683b      	ldr	r3, [r7, #0]
 8010980:	781b      	ldrb	r3, [r3, #0]
 8010982:	00da      	lsls	r2, r3, #3
 8010984:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8010986:	18d3      	adds	r3, r2, r3
 8010988:	4a8d      	ldr	r2, [pc, #564]	; (8010bc0 <USB_EPStartXfer+0x6f4>)
 801098a:	4694      	mov	ip, r2
 801098c:	4463      	add	r3, ip
 801098e:	64fb      	str	r3, [r7, #76]	; 0x4c
 8010990:	1d7b      	adds	r3, r7, #5
 8010992:	33ff      	adds	r3, #255	; 0xff
 8010994:	681b      	ldr	r3, [r3, #0]
 8010996:	b29a      	uxth	r2, r3
 8010998:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801099a:	801a      	strh	r2, [r3, #0]
            pmabuffer = ep->pmaaddr0;
 801099c:	2076      	movs	r0, #118	; 0x76
 801099e:	183b      	adds	r3, r7, r0
 80109a0:	683a      	ldr	r2, [r7, #0]
 80109a2:	8912      	ldrh	r2, [r2, #8]
 80109a4:	801a      	strh	r2, [r3, #0]

            /* Write the user buffer to USB PMA */
            USB_WritePMA(USBx, ep->xfer_buff, pmabuffer, (uint16_t)len);
 80109a6:	683b      	ldr	r3, [r7, #0]
 80109a8:	6959      	ldr	r1, [r3, #20]
 80109aa:	1d7b      	adds	r3, r7, #5
 80109ac:	33ff      	adds	r3, #255	; 0xff
 80109ae:	681b      	ldr	r3, [r3, #0]
 80109b0:	b29c      	uxth	r4, r3
 80109b2:	183b      	adds	r3, r7, r0
 80109b4:	881a      	ldrh	r2, [r3, #0]
 80109b6:	6878      	ldr	r0, [r7, #4]
 80109b8:	0023      	movs	r3, r4
 80109ba:	f000 ff7b 	bl	80118b4 <USB_WritePMA>
            ep->xfer_buff += len;
 80109be:	683b      	ldr	r3, [r7, #0]
 80109c0:	695a      	ldr	r2, [r3, #20]
 80109c2:	1d7b      	adds	r3, r7, #5
 80109c4:	33ff      	adds	r3, #255	; 0xff
 80109c6:	681b      	ldr	r3, [r3, #0]
 80109c8:	18d2      	adds	r2, r2, r3
 80109ca:	683b      	ldr	r3, [r7, #0]
 80109cc:	615a      	str	r2, [r3, #20]

            if (ep->xfer_len_db > ep->maxpacket)
 80109ce:	683b      	ldr	r3, [r7, #0]
 80109d0:	6a1a      	ldr	r2, [r3, #32]
 80109d2:	683b      	ldr	r3, [r7, #0]
 80109d4:	691b      	ldr	r3, [r3, #16]
 80109d6:	429a      	cmp	r2, r3
 80109d8:	d908      	bls.n	80109ec <USB_EPStartXfer+0x520>
            {
              ep->xfer_len_db -= len;
 80109da:	683b      	ldr	r3, [r7, #0]
 80109dc:	6a1a      	ldr	r2, [r3, #32]
 80109de:	1d7b      	adds	r3, r7, #5
 80109e0:	33ff      	adds	r3, #255	; 0xff
 80109e2:	681b      	ldr	r3, [r3, #0]
 80109e4:	1ad2      	subs	r2, r2, r3
 80109e6:	683b      	ldr	r3, [r7, #0]
 80109e8:	621a      	str	r2, [r3, #32]
 80109ea:	e007      	b.n	80109fc <USB_EPStartXfer+0x530>
            }
            else
            {
              len = ep->xfer_len_db;
 80109ec:	683b      	ldr	r3, [r7, #0]
 80109ee:	6a1b      	ldr	r3, [r3, #32]
 80109f0:	1d7a      	adds	r2, r7, #5
 80109f2:	32ff      	adds	r2, #255	; 0xff
 80109f4:	6013      	str	r3, [r2, #0]
              ep->xfer_len_db = 0U;
 80109f6:	683b      	ldr	r3, [r7, #0]
 80109f8:	2200      	movs	r2, #0
 80109fa:	621a      	str	r2, [r3, #32]
            }

            /* Set the Double buffer counter for pmabuffer1 */
            PCD_SET_EP_DBUF1_CNT(USBx, ep->num, ep->is_in, len);
 80109fc:	687b      	ldr	r3, [r7, #4]
 80109fe:	643b      	str	r3, [r7, #64]	; 0x40
 8010a00:	683b      	ldr	r3, [r7, #0]
 8010a02:	785b      	ldrb	r3, [r3, #1]
 8010a04:	2b00      	cmp	r3, #0
 8010a06:	d166      	bne.n	8010ad6 <USB_EPStartXfer+0x60a>
 8010a08:	687b      	ldr	r3, [r7, #4]
 8010a0a:	63bb      	str	r3, [r7, #56]	; 0x38
 8010a0c:	687b      	ldr	r3, [r7, #4]
 8010a0e:	2250      	movs	r2, #80	; 0x50
 8010a10:	5a9b      	ldrh	r3, [r3, r2]
 8010a12:	b29b      	uxth	r3, r3
 8010a14:	001a      	movs	r2, r3
 8010a16:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8010a18:	189b      	adds	r3, r3, r2
 8010a1a:	63bb      	str	r3, [r7, #56]	; 0x38
 8010a1c:	683b      	ldr	r3, [r7, #0]
 8010a1e:	781b      	ldrb	r3, [r3, #0]
 8010a20:	00da      	lsls	r2, r3, #3
 8010a22:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8010a24:	18d3      	adds	r3, r2, r3
 8010a26:	4a69      	ldr	r2, [pc, #420]	; (8010bcc <USB_EPStartXfer+0x700>)
 8010a28:	4694      	mov	ip, r2
 8010a2a:	4463      	add	r3, ip
 8010a2c:	637b      	str	r3, [r7, #52]	; 0x34
 8010a2e:	1d7b      	adds	r3, r7, #5
 8010a30:	33ff      	adds	r3, #255	; 0xff
 8010a32:	681b      	ldr	r3, [r3, #0]
 8010a34:	2b00      	cmp	r3, #0
 8010a36:	d110      	bne.n	8010a5a <USB_EPStartXfer+0x58e>
 8010a38:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8010a3a:	881b      	ldrh	r3, [r3, #0]
 8010a3c:	b29b      	uxth	r3, r3
 8010a3e:	4a61      	ldr	r2, [pc, #388]	; (8010bc4 <USB_EPStartXfer+0x6f8>)
 8010a40:	4013      	ands	r3, r2
 8010a42:	b29a      	uxth	r2, r3
 8010a44:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8010a46:	801a      	strh	r2, [r3, #0]
 8010a48:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8010a4a:	881b      	ldrh	r3, [r3, #0]
 8010a4c:	b29b      	uxth	r3, r3
 8010a4e:	4a5e      	ldr	r2, [pc, #376]	; (8010bc8 <USB_EPStartXfer+0x6fc>)
 8010a50:	4313      	orrs	r3, r2
 8010a52:	b29a      	uxth	r2, r3
 8010a54:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8010a56:	801a      	strh	r2, [r3, #0]
 8010a58:	e058      	b.n	8010b0c <USB_EPStartXfer+0x640>
 8010a5a:	1d7b      	adds	r3, r7, #5
 8010a5c:	33ff      	adds	r3, #255	; 0xff
 8010a5e:	681b      	ldr	r3, [r3, #0]
 8010a60:	2b3e      	cmp	r3, #62	; 0x3e
 8010a62:	d81a      	bhi.n	8010a9a <USB_EPStartXfer+0x5ce>
 8010a64:	1d7b      	adds	r3, r7, #5
 8010a66:	33ff      	adds	r3, #255	; 0xff
 8010a68:	681b      	ldr	r3, [r3, #0]
 8010a6a:	085b      	lsrs	r3, r3, #1
 8010a6c:	21f4      	movs	r1, #244	; 0xf4
 8010a6e:	187a      	adds	r2, r7, r1
 8010a70:	6013      	str	r3, [r2, #0]
 8010a72:	1d7b      	adds	r3, r7, #5
 8010a74:	33ff      	adds	r3, #255	; 0xff
 8010a76:	681b      	ldr	r3, [r3, #0]
 8010a78:	2201      	movs	r2, #1
 8010a7a:	4013      	ands	r3, r2
 8010a7c:	d004      	beq.n	8010a88 <USB_EPStartXfer+0x5bc>
 8010a7e:	187b      	adds	r3, r7, r1
 8010a80:	681b      	ldr	r3, [r3, #0]
 8010a82:	3301      	adds	r3, #1
 8010a84:	187a      	adds	r2, r7, r1
 8010a86:	6013      	str	r3, [r2, #0]
 8010a88:	23f4      	movs	r3, #244	; 0xf4
 8010a8a:	18fb      	adds	r3, r7, r3
 8010a8c:	681b      	ldr	r3, [r3, #0]
 8010a8e:	b29b      	uxth	r3, r3
 8010a90:	029b      	lsls	r3, r3, #10
 8010a92:	b29a      	uxth	r2, r3
 8010a94:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8010a96:	801a      	strh	r2, [r3, #0]
 8010a98:	e038      	b.n	8010b0c <USB_EPStartXfer+0x640>
 8010a9a:	1d7b      	adds	r3, r7, #5
 8010a9c:	33ff      	adds	r3, #255	; 0xff
 8010a9e:	681b      	ldr	r3, [r3, #0]
 8010aa0:	095b      	lsrs	r3, r3, #5
 8010aa2:	21f4      	movs	r1, #244	; 0xf4
 8010aa4:	187a      	adds	r2, r7, r1
 8010aa6:	6013      	str	r3, [r2, #0]
 8010aa8:	1d7b      	adds	r3, r7, #5
 8010aaa:	33ff      	adds	r3, #255	; 0xff
 8010aac:	681b      	ldr	r3, [r3, #0]
 8010aae:	221f      	movs	r2, #31
 8010ab0:	4013      	ands	r3, r2
 8010ab2:	d104      	bne.n	8010abe <USB_EPStartXfer+0x5f2>
 8010ab4:	187b      	adds	r3, r7, r1
 8010ab6:	681b      	ldr	r3, [r3, #0]
 8010ab8:	3b01      	subs	r3, #1
 8010aba:	187a      	adds	r2, r7, r1
 8010abc:	6013      	str	r3, [r2, #0]
 8010abe:	23f4      	movs	r3, #244	; 0xf4
 8010ac0:	18fb      	adds	r3, r7, r3
 8010ac2:	681b      	ldr	r3, [r3, #0]
 8010ac4:	b29b      	uxth	r3, r3
 8010ac6:	029b      	lsls	r3, r3, #10
 8010ac8:	b29b      	uxth	r3, r3
 8010aca:	4a3f      	ldr	r2, [pc, #252]	; (8010bc8 <USB_EPStartXfer+0x6fc>)
 8010acc:	4313      	orrs	r3, r2
 8010ace:	b29a      	uxth	r2, r3
 8010ad0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8010ad2:	801a      	strh	r2, [r3, #0]
 8010ad4:	e01a      	b.n	8010b0c <USB_EPStartXfer+0x640>
 8010ad6:	683b      	ldr	r3, [r7, #0]
 8010ad8:	785b      	ldrb	r3, [r3, #1]
 8010ada:	2b01      	cmp	r3, #1
 8010adc:	d116      	bne.n	8010b0c <USB_EPStartXfer+0x640>
 8010ade:	687b      	ldr	r3, [r7, #4]
 8010ae0:	2250      	movs	r2, #80	; 0x50
 8010ae2:	5a9b      	ldrh	r3, [r3, r2]
 8010ae4:	b29b      	uxth	r3, r3
 8010ae6:	001a      	movs	r2, r3
 8010ae8:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8010aea:	189b      	adds	r3, r3, r2
 8010aec:	643b      	str	r3, [r7, #64]	; 0x40
 8010aee:	683b      	ldr	r3, [r7, #0]
 8010af0:	781b      	ldrb	r3, [r3, #0]
 8010af2:	00da      	lsls	r2, r3, #3
 8010af4:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8010af6:	18d3      	adds	r3, r2, r3
 8010af8:	4a34      	ldr	r2, [pc, #208]	; (8010bcc <USB_EPStartXfer+0x700>)
 8010afa:	4694      	mov	ip, r2
 8010afc:	4463      	add	r3, ip
 8010afe:	63fb      	str	r3, [r7, #60]	; 0x3c
 8010b00:	1d7b      	adds	r3, r7, #5
 8010b02:	33ff      	adds	r3, #255	; 0xff
 8010b04:	681b      	ldr	r3, [r3, #0]
 8010b06:	b29a      	uxth	r2, r3
 8010b08:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8010b0a:	801a      	strh	r2, [r3, #0]
            pmabuffer = ep->pmaaddr1;
 8010b0c:	2076      	movs	r0, #118	; 0x76
 8010b0e:	183b      	adds	r3, r7, r0
 8010b10:	683a      	ldr	r2, [r7, #0]
 8010b12:	8952      	ldrh	r2, [r2, #10]
 8010b14:	801a      	strh	r2, [r3, #0]

            /* Write the user buffer to USB PMA */
            USB_WritePMA(USBx, ep->xfer_buff, pmabuffer, (uint16_t)len);
 8010b16:	683b      	ldr	r3, [r7, #0]
 8010b18:	6959      	ldr	r1, [r3, #20]
 8010b1a:	1d7b      	adds	r3, r7, #5
 8010b1c:	33ff      	adds	r3, #255	; 0xff
 8010b1e:	681b      	ldr	r3, [r3, #0]
 8010b20:	b29c      	uxth	r4, r3
 8010b22:	183b      	adds	r3, r7, r0
 8010b24:	881a      	ldrh	r2, [r3, #0]
 8010b26:	6878      	ldr	r0, [r7, #4]
 8010b28:	0023      	movs	r3, r4
 8010b2a:	f000 fec3 	bl	80118b4 <USB_WritePMA>
 8010b2e:	e1a2      	b.n	8010e76 <USB_EPStartXfer+0x9aa>
          }
        }
        /* auto Switch to single buffer mode when transfer <Mps no need to manage in double buffer */
        else
        {
          len = ep->xfer_len_db;
 8010b30:	683b      	ldr	r3, [r7, #0]
 8010b32:	6a1b      	ldr	r3, [r3, #32]
 8010b34:	1d7a      	adds	r2, r7, #5
 8010b36:	32ff      	adds	r2, #255	; 0xff
 8010b38:	6013      	str	r3, [r2, #0]

          /* disable double buffer mode for Bulk endpoint */
          PCD_CLEAR_BULK_EP_DBUF(USBx, ep->num);
 8010b3a:	687a      	ldr	r2, [r7, #4]
 8010b3c:	683b      	ldr	r3, [r7, #0]
 8010b3e:	781b      	ldrb	r3, [r3, #0]
 8010b40:	009b      	lsls	r3, r3, #2
 8010b42:	18d3      	adds	r3, r2, r3
 8010b44:	881b      	ldrh	r3, [r3, #0]
 8010b46:	b29a      	uxth	r2, r3
 8010b48:	2062      	movs	r0, #98	; 0x62
 8010b4a:	183b      	adds	r3, r7, r0
 8010b4c:	4920      	ldr	r1, [pc, #128]	; (8010bd0 <USB_EPStartXfer+0x704>)
 8010b4e:	400a      	ands	r2, r1
 8010b50:	801a      	strh	r2, [r3, #0]
 8010b52:	687a      	ldr	r2, [r7, #4]
 8010b54:	683b      	ldr	r3, [r7, #0]
 8010b56:	781b      	ldrb	r3, [r3, #0]
 8010b58:	009b      	lsls	r3, r3, #2
 8010b5a:	18d3      	adds	r3, r2, r3
 8010b5c:	183a      	adds	r2, r7, r0
 8010b5e:	8812      	ldrh	r2, [r2, #0]
 8010b60:	491c      	ldr	r1, [pc, #112]	; (8010bd4 <USB_EPStartXfer+0x708>)
 8010b62:	430a      	orrs	r2, r1
 8010b64:	b292      	uxth	r2, r2
 8010b66:	801a      	strh	r2, [r3, #0]

          /* Set Tx count with nbre of byte to be transmitted */
          PCD_SET_EP_TX_CNT(USBx, ep->num, len);
 8010b68:	687b      	ldr	r3, [r7, #4]
 8010b6a:	65fb      	str	r3, [r7, #92]	; 0x5c
 8010b6c:	687b      	ldr	r3, [r7, #4]
 8010b6e:	2250      	movs	r2, #80	; 0x50
 8010b70:	5a9b      	ldrh	r3, [r3, r2]
 8010b72:	b29b      	uxth	r3, r3
 8010b74:	001a      	movs	r2, r3
 8010b76:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8010b78:	189b      	adds	r3, r3, r2
 8010b7a:	65fb      	str	r3, [r7, #92]	; 0x5c
 8010b7c:	683b      	ldr	r3, [r7, #0]
 8010b7e:	781b      	ldrb	r3, [r3, #0]
 8010b80:	00da      	lsls	r2, r3, #3
 8010b82:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8010b84:	18d3      	adds	r3, r2, r3
 8010b86:	4a0e      	ldr	r2, [pc, #56]	; (8010bc0 <USB_EPStartXfer+0x6f4>)
 8010b88:	4694      	mov	ip, r2
 8010b8a:	4463      	add	r3, ip
 8010b8c:	65bb      	str	r3, [r7, #88]	; 0x58
 8010b8e:	1d7b      	adds	r3, r7, #5
 8010b90:	33ff      	adds	r3, #255	; 0xff
 8010b92:	681b      	ldr	r3, [r3, #0]
 8010b94:	b29a      	uxth	r2, r3
 8010b96:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8010b98:	801a      	strh	r2, [r3, #0]
          pmabuffer = ep->pmaaddr0;
 8010b9a:	2076      	movs	r0, #118	; 0x76
 8010b9c:	183b      	adds	r3, r7, r0
 8010b9e:	683a      	ldr	r2, [r7, #0]
 8010ba0:	8912      	ldrh	r2, [r2, #8]
 8010ba2:	801a      	strh	r2, [r3, #0]

          /* Write the user buffer to USB PMA */
          USB_WritePMA(USBx, ep->xfer_buff, pmabuffer, (uint16_t)len);
 8010ba4:	683b      	ldr	r3, [r7, #0]
 8010ba6:	6959      	ldr	r1, [r3, #20]
 8010ba8:	1d7b      	adds	r3, r7, #5
 8010baa:	33ff      	adds	r3, #255	; 0xff
 8010bac:	681b      	ldr	r3, [r3, #0]
 8010bae:	b29c      	uxth	r4, r3
 8010bb0:	183b      	adds	r3, r7, r0
 8010bb2:	881a      	ldrh	r2, [r3, #0]
 8010bb4:	6878      	ldr	r0, [r7, #4]
 8010bb6:	0023      	movs	r3, r4
 8010bb8:	f000 fe7c 	bl	80118b4 <USB_WritePMA>
 8010bbc:	e15b      	b.n	8010e76 <USB_EPStartXfer+0x9aa>
 8010bbe:	46c0      	nop			; (mov r8, r8)
 8010bc0:	00000402 	.word	0x00000402
 8010bc4:	ffff83ff 	.word	0xffff83ff
 8010bc8:	ffff8000 	.word	0xffff8000
 8010bcc:	00000406 	.word	0x00000406
 8010bd0:	ffff8e8f 	.word	0xffff8e8f
 8010bd4:	ffff8080 	.word	0xffff8080
        }
      }
      else /* manage isochronous double buffer IN mode */
      {
        /* each Time to write in PMA xfer_len_db will */
        ep->xfer_len_db -= len;
 8010bd8:	683b      	ldr	r3, [r7, #0]
 8010bda:	6a1a      	ldr	r2, [r3, #32]
 8010bdc:	1d7b      	adds	r3, r7, #5
 8010bde:	33ff      	adds	r3, #255	; 0xff
 8010be0:	681b      	ldr	r3, [r3, #0]
 8010be2:	1ad2      	subs	r2, r2, r3
 8010be4:	683b      	ldr	r3, [r7, #0]
 8010be6:	621a      	str	r2, [r3, #32]

        /* Fill the data buffer */
        if ((PCD_GET_ENDPOINT(USBx, ep->num) & USB_EP_DTOG_TX) != 0U)
 8010be8:	687a      	ldr	r2, [r7, #4]
 8010bea:	683b      	ldr	r3, [r7, #0]
 8010bec:	781b      	ldrb	r3, [r3, #0]
 8010bee:	009b      	lsls	r3, r3, #2
 8010bf0:	18d3      	adds	r3, r2, r3
 8010bf2:	881b      	ldrh	r3, [r3, #0]
 8010bf4:	b29b      	uxth	r3, r3
 8010bf6:	001a      	movs	r2, r3
 8010bf8:	2340      	movs	r3, #64	; 0x40
 8010bfa:	4013      	ands	r3, r2
 8010bfc:	d100      	bne.n	8010c00 <USB_EPStartXfer+0x734>
 8010bfe:	e099      	b.n	8010d34 <USB_EPStartXfer+0x868>
        {
          /* Set the Double buffer counter for pmabuffer1 */
          PCD_SET_EP_DBUF1_CNT(USBx, ep->num, ep->is_in, len);
 8010c00:	687b      	ldr	r3, [r7, #4]
 8010c02:	673b      	str	r3, [r7, #112]	; 0x70
 8010c04:	683b      	ldr	r3, [r7, #0]
 8010c06:	785b      	ldrb	r3, [r3, #1]
 8010c08:	2b00      	cmp	r3, #0
 8010c0a:	d166      	bne.n	8010cda <USB_EPStartXfer+0x80e>
 8010c0c:	687b      	ldr	r3, [r7, #4]
 8010c0e:	66bb      	str	r3, [r7, #104]	; 0x68
 8010c10:	687b      	ldr	r3, [r7, #4]
 8010c12:	2250      	movs	r2, #80	; 0x50
 8010c14:	5a9b      	ldrh	r3, [r3, r2]
 8010c16:	b29b      	uxth	r3, r3
 8010c18:	001a      	movs	r2, r3
 8010c1a:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8010c1c:	189b      	adds	r3, r3, r2
 8010c1e:	66bb      	str	r3, [r7, #104]	; 0x68
 8010c20:	683b      	ldr	r3, [r7, #0]
 8010c22:	781b      	ldrb	r3, [r3, #0]
 8010c24:	00da      	lsls	r2, r3, #3
 8010c26:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8010c28:	18d3      	adds	r3, r2, r3
 8010c2a:	4ad0      	ldr	r2, [pc, #832]	; (8010f6c <USB_EPStartXfer+0xaa0>)
 8010c2c:	4694      	mov	ip, r2
 8010c2e:	4463      	add	r3, ip
 8010c30:	667b      	str	r3, [r7, #100]	; 0x64
 8010c32:	1d7b      	adds	r3, r7, #5
 8010c34:	33ff      	adds	r3, #255	; 0xff
 8010c36:	681b      	ldr	r3, [r3, #0]
 8010c38:	2b00      	cmp	r3, #0
 8010c3a:	d110      	bne.n	8010c5e <USB_EPStartXfer+0x792>
 8010c3c:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010c3e:	881b      	ldrh	r3, [r3, #0]
 8010c40:	b29b      	uxth	r3, r3
 8010c42:	4acb      	ldr	r2, [pc, #812]	; (8010f70 <USB_EPStartXfer+0xaa4>)
 8010c44:	4013      	ands	r3, r2
 8010c46:	b29a      	uxth	r2, r3
 8010c48:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010c4a:	801a      	strh	r2, [r3, #0]
 8010c4c:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010c4e:	881b      	ldrh	r3, [r3, #0]
 8010c50:	b29b      	uxth	r3, r3
 8010c52:	4ac8      	ldr	r2, [pc, #800]	; (8010f74 <USB_EPStartXfer+0xaa8>)
 8010c54:	4313      	orrs	r3, r2
 8010c56:	b29a      	uxth	r2, r3
 8010c58:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010c5a:	801a      	strh	r2, [r3, #0]
 8010c5c:	e058      	b.n	8010d10 <USB_EPStartXfer+0x844>
 8010c5e:	1d7b      	adds	r3, r7, #5
 8010c60:	33ff      	adds	r3, #255	; 0xff
 8010c62:	681b      	ldr	r3, [r3, #0]
 8010c64:	2b3e      	cmp	r3, #62	; 0x3e
 8010c66:	d81a      	bhi.n	8010c9e <USB_EPStartXfer+0x7d2>
 8010c68:	1d7b      	adds	r3, r7, #5
 8010c6a:	33ff      	adds	r3, #255	; 0xff
 8010c6c:	681b      	ldr	r3, [r3, #0]
 8010c6e:	085b      	lsrs	r3, r3, #1
 8010c70:	21f0      	movs	r1, #240	; 0xf0
 8010c72:	187a      	adds	r2, r7, r1
 8010c74:	6013      	str	r3, [r2, #0]
 8010c76:	1d7b      	adds	r3, r7, #5
 8010c78:	33ff      	adds	r3, #255	; 0xff
 8010c7a:	681b      	ldr	r3, [r3, #0]
 8010c7c:	2201      	movs	r2, #1
 8010c7e:	4013      	ands	r3, r2
 8010c80:	d004      	beq.n	8010c8c <USB_EPStartXfer+0x7c0>
 8010c82:	187b      	adds	r3, r7, r1
 8010c84:	681b      	ldr	r3, [r3, #0]
 8010c86:	3301      	adds	r3, #1
 8010c88:	187a      	adds	r2, r7, r1
 8010c8a:	6013      	str	r3, [r2, #0]
 8010c8c:	23f0      	movs	r3, #240	; 0xf0
 8010c8e:	18fb      	adds	r3, r7, r3
 8010c90:	681b      	ldr	r3, [r3, #0]
 8010c92:	b29b      	uxth	r3, r3
 8010c94:	029b      	lsls	r3, r3, #10
 8010c96:	b29a      	uxth	r2, r3
 8010c98:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010c9a:	801a      	strh	r2, [r3, #0]
 8010c9c:	e038      	b.n	8010d10 <USB_EPStartXfer+0x844>
 8010c9e:	1d7b      	adds	r3, r7, #5
 8010ca0:	33ff      	adds	r3, #255	; 0xff
 8010ca2:	681b      	ldr	r3, [r3, #0]
 8010ca4:	095b      	lsrs	r3, r3, #5
 8010ca6:	21f0      	movs	r1, #240	; 0xf0
 8010ca8:	187a      	adds	r2, r7, r1
 8010caa:	6013      	str	r3, [r2, #0]
 8010cac:	1d7b      	adds	r3, r7, #5
 8010cae:	33ff      	adds	r3, #255	; 0xff
 8010cb0:	681b      	ldr	r3, [r3, #0]
 8010cb2:	221f      	movs	r2, #31
 8010cb4:	4013      	ands	r3, r2
 8010cb6:	d104      	bne.n	8010cc2 <USB_EPStartXfer+0x7f6>
 8010cb8:	187b      	adds	r3, r7, r1
 8010cba:	681b      	ldr	r3, [r3, #0]
 8010cbc:	3b01      	subs	r3, #1
 8010cbe:	187a      	adds	r2, r7, r1
 8010cc0:	6013      	str	r3, [r2, #0]
 8010cc2:	23f0      	movs	r3, #240	; 0xf0
 8010cc4:	18fb      	adds	r3, r7, r3
 8010cc6:	681b      	ldr	r3, [r3, #0]
 8010cc8:	b29b      	uxth	r3, r3
 8010cca:	029b      	lsls	r3, r3, #10
 8010ccc:	b29b      	uxth	r3, r3
 8010cce:	4aa9      	ldr	r2, [pc, #676]	; (8010f74 <USB_EPStartXfer+0xaa8>)
 8010cd0:	4313      	orrs	r3, r2
 8010cd2:	b29a      	uxth	r2, r3
 8010cd4:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010cd6:	801a      	strh	r2, [r3, #0]
 8010cd8:	e01a      	b.n	8010d10 <USB_EPStartXfer+0x844>
 8010cda:	683b      	ldr	r3, [r7, #0]
 8010cdc:	785b      	ldrb	r3, [r3, #1]
 8010cde:	2b01      	cmp	r3, #1
 8010ce0:	d116      	bne.n	8010d10 <USB_EPStartXfer+0x844>
 8010ce2:	687b      	ldr	r3, [r7, #4]
 8010ce4:	2250      	movs	r2, #80	; 0x50
 8010ce6:	5a9b      	ldrh	r3, [r3, r2]
 8010ce8:	b29b      	uxth	r3, r3
 8010cea:	001a      	movs	r2, r3
 8010cec:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8010cee:	189b      	adds	r3, r3, r2
 8010cf0:	673b      	str	r3, [r7, #112]	; 0x70
 8010cf2:	683b      	ldr	r3, [r7, #0]
 8010cf4:	781b      	ldrb	r3, [r3, #0]
 8010cf6:	00da      	lsls	r2, r3, #3
 8010cf8:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8010cfa:	18d3      	adds	r3, r2, r3
 8010cfc:	4a9b      	ldr	r2, [pc, #620]	; (8010f6c <USB_EPStartXfer+0xaa0>)
 8010cfe:	4694      	mov	ip, r2
 8010d00:	4463      	add	r3, ip
 8010d02:	66fb      	str	r3, [r7, #108]	; 0x6c
 8010d04:	1d7b      	adds	r3, r7, #5
 8010d06:	33ff      	adds	r3, #255	; 0xff
 8010d08:	681b      	ldr	r3, [r3, #0]
 8010d0a:	b29a      	uxth	r2, r3
 8010d0c:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8010d0e:	801a      	strh	r2, [r3, #0]
          pmabuffer = ep->pmaaddr1;
 8010d10:	2076      	movs	r0, #118	; 0x76
 8010d12:	183b      	adds	r3, r7, r0
 8010d14:	683a      	ldr	r2, [r7, #0]
 8010d16:	8952      	ldrh	r2, [r2, #10]
 8010d18:	801a      	strh	r2, [r3, #0]

          /* Write the user buffer to USB PMA */
          USB_WritePMA(USBx, ep->xfer_buff, pmabuffer, (uint16_t)len);
 8010d1a:	683b      	ldr	r3, [r7, #0]
 8010d1c:	6959      	ldr	r1, [r3, #20]
 8010d1e:	1d7b      	adds	r3, r7, #5
 8010d20:	33ff      	adds	r3, #255	; 0xff
 8010d22:	681b      	ldr	r3, [r3, #0]
 8010d24:	b29c      	uxth	r4, r3
 8010d26:	183b      	adds	r3, r7, r0
 8010d28:	881a      	ldrh	r2, [r3, #0]
 8010d2a:	6878      	ldr	r0, [r7, #4]
 8010d2c:	0023      	movs	r3, r4
 8010d2e:	f000 fdc1 	bl	80118b4 <USB_WritePMA>
 8010d32:	e0a0      	b.n	8010e76 <USB_EPStartXfer+0x9aa>
        }
        else
        {
          /* Set the Double buffer counter for pmabuffer0 */
          PCD_SET_EP_DBUF0_CNT(USBx, ep->num, ep->is_in, len);
 8010d34:	683b      	ldr	r3, [r7, #0]
 8010d36:	785b      	ldrb	r3, [r3, #1]
 8010d38:	2b00      	cmp	r3, #0
 8010d3a:	d166      	bne.n	8010e0a <USB_EPStartXfer+0x93e>
 8010d3c:	687b      	ldr	r3, [r7, #4]
 8010d3e:	67fb      	str	r3, [r7, #124]	; 0x7c
 8010d40:	687b      	ldr	r3, [r7, #4]
 8010d42:	2250      	movs	r2, #80	; 0x50
 8010d44:	5a9b      	ldrh	r3, [r3, r2]
 8010d46:	b29b      	uxth	r3, r3
 8010d48:	001a      	movs	r2, r3
 8010d4a:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 8010d4c:	189b      	adds	r3, r3, r2
 8010d4e:	67fb      	str	r3, [r7, #124]	; 0x7c
 8010d50:	683b      	ldr	r3, [r7, #0]
 8010d52:	781b      	ldrb	r3, [r3, #0]
 8010d54:	00da      	lsls	r2, r3, #3
 8010d56:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 8010d58:	18d3      	adds	r3, r2, r3
 8010d5a:	4a87      	ldr	r2, [pc, #540]	; (8010f78 <USB_EPStartXfer+0xaac>)
 8010d5c:	4694      	mov	ip, r2
 8010d5e:	4463      	add	r3, ip
 8010d60:	67bb      	str	r3, [r7, #120]	; 0x78
 8010d62:	1d7b      	adds	r3, r7, #5
 8010d64:	33ff      	adds	r3, #255	; 0xff
 8010d66:	681b      	ldr	r3, [r3, #0]
 8010d68:	2b00      	cmp	r3, #0
 8010d6a:	d110      	bne.n	8010d8e <USB_EPStartXfer+0x8c2>
 8010d6c:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8010d6e:	881b      	ldrh	r3, [r3, #0]
 8010d70:	b29b      	uxth	r3, r3
 8010d72:	4a7f      	ldr	r2, [pc, #508]	; (8010f70 <USB_EPStartXfer+0xaa4>)
 8010d74:	4013      	ands	r3, r2
 8010d76:	b29a      	uxth	r2, r3
 8010d78:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8010d7a:	801a      	strh	r2, [r3, #0]
 8010d7c:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8010d7e:	881b      	ldrh	r3, [r3, #0]
 8010d80:	b29b      	uxth	r3, r3
 8010d82:	4a7c      	ldr	r2, [pc, #496]	; (8010f74 <USB_EPStartXfer+0xaa8>)
 8010d84:	4313      	orrs	r3, r2
 8010d86:	b29a      	uxth	r2, r3
 8010d88:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8010d8a:	801a      	strh	r2, [r3, #0]
 8010d8c:	e062      	b.n	8010e54 <USB_EPStartXfer+0x988>
 8010d8e:	1d7b      	adds	r3, r7, #5
 8010d90:	33ff      	adds	r3, #255	; 0xff
 8010d92:	681b      	ldr	r3, [r3, #0]
 8010d94:	2b3e      	cmp	r3, #62	; 0x3e
 8010d96:	d81a      	bhi.n	8010dce <USB_EPStartXfer+0x902>
 8010d98:	1d7b      	adds	r3, r7, #5
 8010d9a:	33ff      	adds	r3, #255	; 0xff
 8010d9c:	681b      	ldr	r3, [r3, #0]
 8010d9e:	085b      	lsrs	r3, r3, #1
 8010da0:	21ec      	movs	r1, #236	; 0xec
 8010da2:	187a      	adds	r2, r7, r1
 8010da4:	6013      	str	r3, [r2, #0]
 8010da6:	1d7b      	adds	r3, r7, #5
 8010da8:	33ff      	adds	r3, #255	; 0xff
 8010daa:	681b      	ldr	r3, [r3, #0]
 8010dac:	2201      	movs	r2, #1
 8010dae:	4013      	ands	r3, r2
 8010db0:	d004      	beq.n	8010dbc <USB_EPStartXfer+0x8f0>
 8010db2:	187b      	adds	r3, r7, r1
 8010db4:	681b      	ldr	r3, [r3, #0]
 8010db6:	3301      	adds	r3, #1
 8010db8:	187a      	adds	r2, r7, r1
 8010dba:	6013      	str	r3, [r2, #0]
 8010dbc:	23ec      	movs	r3, #236	; 0xec
 8010dbe:	18fb      	adds	r3, r7, r3
 8010dc0:	681b      	ldr	r3, [r3, #0]
 8010dc2:	b29b      	uxth	r3, r3
 8010dc4:	029b      	lsls	r3, r3, #10
 8010dc6:	b29a      	uxth	r2, r3
 8010dc8:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8010dca:	801a      	strh	r2, [r3, #0]
 8010dcc:	e042      	b.n	8010e54 <USB_EPStartXfer+0x988>
 8010dce:	1d7b      	adds	r3, r7, #5
 8010dd0:	33ff      	adds	r3, #255	; 0xff
 8010dd2:	681b      	ldr	r3, [r3, #0]
 8010dd4:	095b      	lsrs	r3, r3, #5
 8010dd6:	21ec      	movs	r1, #236	; 0xec
 8010dd8:	187a      	adds	r2, r7, r1
 8010dda:	6013      	str	r3, [r2, #0]
 8010ddc:	1d7b      	adds	r3, r7, #5
 8010dde:	33ff      	adds	r3, #255	; 0xff
 8010de0:	681b      	ldr	r3, [r3, #0]
 8010de2:	221f      	movs	r2, #31
 8010de4:	4013      	ands	r3, r2
 8010de6:	d104      	bne.n	8010df2 <USB_EPStartXfer+0x926>
 8010de8:	187b      	adds	r3, r7, r1
 8010dea:	681b      	ldr	r3, [r3, #0]
 8010dec:	3b01      	subs	r3, #1
 8010dee:	187a      	adds	r2, r7, r1
 8010df0:	6013      	str	r3, [r2, #0]
 8010df2:	23ec      	movs	r3, #236	; 0xec
 8010df4:	18fb      	adds	r3, r7, r3
 8010df6:	681b      	ldr	r3, [r3, #0]
 8010df8:	b29b      	uxth	r3, r3
 8010dfa:	029b      	lsls	r3, r3, #10
 8010dfc:	b29b      	uxth	r3, r3
 8010dfe:	4a5d      	ldr	r2, [pc, #372]	; (8010f74 <USB_EPStartXfer+0xaa8>)
 8010e00:	4313      	orrs	r3, r2
 8010e02:	b29a      	uxth	r2, r3
 8010e04:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8010e06:	801a      	strh	r2, [r3, #0]
 8010e08:	e024      	b.n	8010e54 <USB_EPStartXfer+0x988>
 8010e0a:	683b      	ldr	r3, [r7, #0]
 8010e0c:	785b      	ldrb	r3, [r3, #1]
 8010e0e:	2b01      	cmp	r3, #1
 8010e10:	d120      	bne.n	8010e54 <USB_EPStartXfer+0x988>
 8010e12:	687b      	ldr	r3, [r7, #4]
 8010e14:	2184      	movs	r1, #132	; 0x84
 8010e16:	187a      	adds	r2, r7, r1
 8010e18:	6013      	str	r3, [r2, #0]
 8010e1a:	687b      	ldr	r3, [r7, #4]
 8010e1c:	2250      	movs	r2, #80	; 0x50
 8010e1e:	5a9b      	ldrh	r3, [r3, r2]
 8010e20:	b29b      	uxth	r3, r3
 8010e22:	001a      	movs	r2, r3
 8010e24:	187b      	adds	r3, r7, r1
 8010e26:	681b      	ldr	r3, [r3, #0]
 8010e28:	189b      	adds	r3, r3, r2
 8010e2a:	187a      	adds	r2, r7, r1
 8010e2c:	6013      	str	r3, [r2, #0]
 8010e2e:	683b      	ldr	r3, [r7, #0]
 8010e30:	781b      	ldrb	r3, [r3, #0]
 8010e32:	00da      	lsls	r2, r3, #3
 8010e34:	187b      	adds	r3, r7, r1
 8010e36:	681b      	ldr	r3, [r3, #0]
 8010e38:	18d3      	adds	r3, r2, r3
 8010e3a:	4a4f      	ldr	r2, [pc, #316]	; (8010f78 <USB_EPStartXfer+0xaac>)
 8010e3c:	4694      	mov	ip, r2
 8010e3e:	4463      	add	r3, ip
 8010e40:	2180      	movs	r1, #128	; 0x80
 8010e42:	187a      	adds	r2, r7, r1
 8010e44:	6013      	str	r3, [r2, #0]
 8010e46:	1d7b      	adds	r3, r7, #5
 8010e48:	33ff      	adds	r3, #255	; 0xff
 8010e4a:	681b      	ldr	r3, [r3, #0]
 8010e4c:	b29a      	uxth	r2, r3
 8010e4e:	187b      	adds	r3, r7, r1
 8010e50:	681b      	ldr	r3, [r3, #0]
 8010e52:	801a      	strh	r2, [r3, #0]
          pmabuffer = ep->pmaaddr0;
 8010e54:	2076      	movs	r0, #118	; 0x76
 8010e56:	183b      	adds	r3, r7, r0
 8010e58:	683a      	ldr	r2, [r7, #0]
 8010e5a:	8912      	ldrh	r2, [r2, #8]
 8010e5c:	801a      	strh	r2, [r3, #0]

          /* Write the user buffer to USB PMA */
          USB_WritePMA(USBx, ep->xfer_buff, pmabuffer, (uint16_t)len);
 8010e5e:	683b      	ldr	r3, [r7, #0]
 8010e60:	6959      	ldr	r1, [r3, #20]
 8010e62:	1d7b      	adds	r3, r7, #5
 8010e64:	33ff      	adds	r3, #255	; 0xff
 8010e66:	681b      	ldr	r3, [r3, #0]
 8010e68:	b29c      	uxth	r4, r3
 8010e6a:	183b      	adds	r3, r7, r0
 8010e6c:	881a      	ldrh	r2, [r3, #0]
 8010e6e:	6878      	ldr	r0, [r7, #4]
 8010e70:	0023      	movs	r3, r4
 8010e72:	f000 fd1f 	bl	80118b4 <USB_WritePMA>
        }
      }
    }

    PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_VALID);
 8010e76:	687a      	ldr	r2, [r7, #4]
 8010e78:	683b      	ldr	r3, [r7, #0]
 8010e7a:	781b      	ldrb	r3, [r3, #0]
 8010e7c:	009b      	lsls	r3, r3, #2
 8010e7e:	18d3      	adds	r3, r2, r3
 8010e80:	881b      	ldrh	r3, [r3, #0]
 8010e82:	b29a      	uxth	r2, r3
 8010e84:	200a      	movs	r0, #10
 8010e86:	183b      	adds	r3, r7, r0
 8010e88:	493c      	ldr	r1, [pc, #240]	; (8010f7c <USB_EPStartXfer+0xab0>)
 8010e8a:	400a      	ands	r2, r1
 8010e8c:	801a      	strh	r2, [r3, #0]
 8010e8e:	183b      	adds	r3, r7, r0
 8010e90:	183a      	adds	r2, r7, r0
 8010e92:	8812      	ldrh	r2, [r2, #0]
 8010e94:	2110      	movs	r1, #16
 8010e96:	404a      	eors	r2, r1
 8010e98:	801a      	strh	r2, [r3, #0]
 8010e9a:	183b      	adds	r3, r7, r0
 8010e9c:	183a      	adds	r2, r7, r0
 8010e9e:	8812      	ldrh	r2, [r2, #0]
 8010ea0:	2120      	movs	r1, #32
 8010ea2:	404a      	eors	r2, r1
 8010ea4:	801a      	strh	r2, [r3, #0]
 8010ea6:	687a      	ldr	r2, [r7, #4]
 8010ea8:	683b      	ldr	r3, [r7, #0]
 8010eaa:	781b      	ldrb	r3, [r3, #0]
 8010eac:	009b      	lsls	r3, r3, #2
 8010eae:	18d3      	adds	r3, r2, r3
 8010eb0:	183a      	adds	r2, r7, r0
 8010eb2:	8812      	ldrh	r2, [r2, #0]
 8010eb4:	4932      	ldr	r1, [pc, #200]	; (8010f80 <USB_EPStartXfer+0xab4>)
 8010eb6:	430a      	orrs	r2, r1
 8010eb8:	b292      	uxth	r2, r2
 8010eba:	801a      	strh	r2, [r3, #0]
 8010ebc:	f000 fbaf 	bl	801161e <USB_EPStartXfer+0x1152>
  }
  else /* OUT endpoint */
  {
    if (ep->doublebuffer == 0U)
 8010ec0:	683b      	ldr	r3, [r7, #0]
 8010ec2:	7b1b      	ldrb	r3, [r3, #12]
 8010ec4:	2b00      	cmp	r3, #0
 8010ec6:	d000      	beq.n	8010eca <USB_EPStartXfer+0x9fe>
 8010ec8:	e09e      	b.n	8011008 <USB_EPStartXfer+0xb3c>
    {
      /* Multi packet transfer */
      if (ep->xfer_len > ep->maxpacket)
 8010eca:	683b      	ldr	r3, [r7, #0]
 8010ecc:	699a      	ldr	r2, [r3, #24]
 8010ece:	683b      	ldr	r3, [r7, #0]
 8010ed0:	691b      	ldr	r3, [r3, #16]
 8010ed2:	429a      	cmp	r2, r3
 8010ed4:	d90d      	bls.n	8010ef2 <USB_EPStartXfer+0xa26>
      {
        len = ep->maxpacket;
 8010ed6:	683b      	ldr	r3, [r7, #0]
 8010ed8:	691b      	ldr	r3, [r3, #16]
 8010eda:	1d7a      	adds	r2, r7, #5
 8010edc:	32ff      	adds	r2, #255	; 0xff
 8010ede:	6013      	str	r3, [r2, #0]
        ep->xfer_len -= len;
 8010ee0:	683b      	ldr	r3, [r7, #0]
 8010ee2:	699a      	ldr	r2, [r3, #24]
 8010ee4:	1d7b      	adds	r3, r7, #5
 8010ee6:	33ff      	adds	r3, #255	; 0xff
 8010ee8:	681b      	ldr	r3, [r3, #0]
 8010eea:	1ad2      	subs	r2, r2, r3
 8010eec:	683b      	ldr	r3, [r7, #0]
 8010eee:	619a      	str	r2, [r3, #24]
 8010ef0:	e007      	b.n	8010f02 <USB_EPStartXfer+0xa36>
      }
      else
      {
        len = ep->xfer_len;
 8010ef2:	683b      	ldr	r3, [r7, #0]
 8010ef4:	699b      	ldr	r3, [r3, #24]
 8010ef6:	1d7a      	adds	r2, r7, #5
 8010ef8:	32ff      	adds	r2, #255	; 0xff
 8010efa:	6013      	str	r3, [r2, #0]
        ep->xfer_len = 0U;
 8010efc:	683b      	ldr	r3, [r7, #0]
 8010efe:	2200      	movs	r2, #0
 8010f00:	619a      	str	r2, [r3, #24]
      }
      /* configure and validate Rx endpoint */
      PCD_SET_EP_RX_CNT(USBx, ep->num, len);
 8010f02:	687b      	ldr	r3, [r7, #4]
 8010f04:	2190      	movs	r1, #144	; 0x90
 8010f06:	187a      	adds	r2, r7, r1
 8010f08:	6013      	str	r3, [r2, #0]
 8010f0a:	687b      	ldr	r3, [r7, #4]
 8010f0c:	2250      	movs	r2, #80	; 0x50
 8010f0e:	5a9b      	ldrh	r3, [r3, r2]
 8010f10:	b29b      	uxth	r3, r3
 8010f12:	001a      	movs	r2, r3
 8010f14:	187b      	adds	r3, r7, r1
 8010f16:	681b      	ldr	r3, [r3, #0]
 8010f18:	189b      	adds	r3, r3, r2
 8010f1a:	187a      	adds	r2, r7, r1
 8010f1c:	6013      	str	r3, [r2, #0]
 8010f1e:	683b      	ldr	r3, [r7, #0]
 8010f20:	781b      	ldrb	r3, [r3, #0]
 8010f22:	00da      	lsls	r2, r3, #3
 8010f24:	187b      	adds	r3, r7, r1
 8010f26:	681b      	ldr	r3, [r3, #0]
 8010f28:	18d3      	adds	r3, r2, r3
 8010f2a:	4a10      	ldr	r2, [pc, #64]	; (8010f6c <USB_EPStartXfer+0xaa0>)
 8010f2c:	4694      	mov	ip, r2
 8010f2e:	4463      	add	r3, ip
 8010f30:	218c      	movs	r1, #140	; 0x8c
 8010f32:	187a      	adds	r2, r7, r1
 8010f34:	6013      	str	r3, [r2, #0]
 8010f36:	1d7b      	adds	r3, r7, #5
 8010f38:	33ff      	adds	r3, #255	; 0xff
 8010f3a:	681b      	ldr	r3, [r3, #0]
 8010f3c:	2b00      	cmp	r3, #0
 8010f3e:	d121      	bne.n	8010f84 <USB_EPStartXfer+0xab8>
 8010f40:	187b      	adds	r3, r7, r1
 8010f42:	681b      	ldr	r3, [r3, #0]
 8010f44:	881b      	ldrh	r3, [r3, #0]
 8010f46:	b29b      	uxth	r3, r3
 8010f48:	4a09      	ldr	r2, [pc, #36]	; (8010f70 <USB_EPStartXfer+0xaa4>)
 8010f4a:	4013      	ands	r3, r2
 8010f4c:	b29a      	uxth	r2, r3
 8010f4e:	187b      	adds	r3, r7, r1
 8010f50:	681b      	ldr	r3, [r3, #0]
 8010f52:	801a      	strh	r2, [r3, #0]
 8010f54:	187b      	adds	r3, r7, r1
 8010f56:	681b      	ldr	r3, [r3, #0]
 8010f58:	881b      	ldrh	r3, [r3, #0]
 8010f5a:	b29b      	uxth	r3, r3
 8010f5c:	4a05      	ldr	r2, [pc, #20]	; (8010f74 <USB_EPStartXfer+0xaa8>)
 8010f5e:	4313      	orrs	r3, r2
 8010f60:	b29a      	uxth	r2, r3
 8010f62:	187b      	adds	r3, r7, r1
 8010f64:	681b      	ldr	r3, [r3, #0]
 8010f66:	801a      	strh	r2, [r3, #0]
 8010f68:	e334      	b.n	80115d4 <USB_EPStartXfer+0x1108>
 8010f6a:	46c0      	nop			; (mov r8, r8)
 8010f6c:	00000406 	.word	0x00000406
 8010f70:	ffff83ff 	.word	0xffff83ff
 8010f74:	ffff8000 	.word	0xffff8000
 8010f78:	00000402 	.word	0x00000402
 8010f7c:	ffff8fbf 	.word	0xffff8fbf
 8010f80:	ffff8080 	.word	0xffff8080
 8010f84:	1d7b      	adds	r3, r7, #5
 8010f86:	33ff      	adds	r3, #255	; 0xff
 8010f88:	681b      	ldr	r3, [r3, #0]
 8010f8a:	2b3e      	cmp	r3, #62	; 0x3e
 8010f8c:	d81c      	bhi.n	8010fc8 <USB_EPStartXfer+0xafc>
 8010f8e:	1d7b      	adds	r3, r7, #5
 8010f90:	33ff      	adds	r3, #255	; 0xff
 8010f92:	681b      	ldr	r3, [r3, #0]
 8010f94:	085b      	lsrs	r3, r3, #1
 8010f96:	21e8      	movs	r1, #232	; 0xe8
 8010f98:	187a      	adds	r2, r7, r1
 8010f9a:	6013      	str	r3, [r2, #0]
 8010f9c:	1d7b      	adds	r3, r7, #5
 8010f9e:	33ff      	adds	r3, #255	; 0xff
 8010fa0:	681b      	ldr	r3, [r3, #0]
 8010fa2:	2201      	movs	r2, #1
 8010fa4:	4013      	ands	r3, r2
 8010fa6:	d004      	beq.n	8010fb2 <USB_EPStartXfer+0xae6>
 8010fa8:	187b      	adds	r3, r7, r1
 8010faa:	681b      	ldr	r3, [r3, #0]
 8010fac:	3301      	adds	r3, #1
 8010fae:	187a      	adds	r2, r7, r1
 8010fb0:	6013      	str	r3, [r2, #0]
 8010fb2:	23e8      	movs	r3, #232	; 0xe8
 8010fb4:	18fb      	adds	r3, r7, r3
 8010fb6:	681b      	ldr	r3, [r3, #0]
 8010fb8:	b29b      	uxth	r3, r3
 8010fba:	029b      	lsls	r3, r3, #10
 8010fbc:	b29a      	uxth	r2, r3
 8010fbe:	238c      	movs	r3, #140	; 0x8c
 8010fc0:	18fb      	adds	r3, r7, r3
 8010fc2:	681b      	ldr	r3, [r3, #0]
 8010fc4:	801a      	strh	r2, [r3, #0]
 8010fc6:	e305      	b.n	80115d4 <USB_EPStartXfer+0x1108>
 8010fc8:	1d7b      	adds	r3, r7, #5
 8010fca:	33ff      	adds	r3, #255	; 0xff
 8010fcc:	681b      	ldr	r3, [r3, #0]
 8010fce:	095b      	lsrs	r3, r3, #5
 8010fd0:	21e8      	movs	r1, #232	; 0xe8
 8010fd2:	187a      	adds	r2, r7, r1
 8010fd4:	6013      	str	r3, [r2, #0]
 8010fd6:	1d7b      	adds	r3, r7, #5
 8010fd8:	33ff      	adds	r3, #255	; 0xff
 8010fda:	681b      	ldr	r3, [r3, #0]
 8010fdc:	221f      	movs	r2, #31
 8010fde:	4013      	ands	r3, r2
 8010fe0:	d104      	bne.n	8010fec <USB_EPStartXfer+0xb20>
 8010fe2:	187b      	adds	r3, r7, r1
 8010fe4:	681b      	ldr	r3, [r3, #0]
 8010fe6:	3b01      	subs	r3, #1
 8010fe8:	187a      	adds	r2, r7, r1
 8010fea:	6013      	str	r3, [r2, #0]
 8010fec:	23e8      	movs	r3, #232	; 0xe8
 8010fee:	18fb      	adds	r3, r7, r3
 8010ff0:	681b      	ldr	r3, [r3, #0]
 8010ff2:	b29b      	uxth	r3, r3
 8010ff4:	029b      	lsls	r3, r3, #10
 8010ff6:	b29b      	uxth	r3, r3
 8010ff8:	4aca      	ldr	r2, [pc, #808]	; (8011324 <USB_EPStartXfer+0xe58>)
 8010ffa:	4313      	orrs	r3, r2
 8010ffc:	b29a      	uxth	r2, r3
 8010ffe:	238c      	movs	r3, #140	; 0x8c
 8011000:	18fb      	adds	r3, r7, r3
 8011002:	681b      	ldr	r3, [r3, #0]
 8011004:	801a      	strh	r2, [r3, #0]
 8011006:	e2e5      	b.n	80115d4 <USB_EPStartXfer+0x1108>
    }
    else
    {
      /* First Transfer Coming From HAL_PCD_EP_Receive & From ISR */
      /* Set the Double buffer counter */
      if (ep->type == EP_TYPE_BULK)
 8011008:	683b      	ldr	r3, [r7, #0]
 801100a:	78db      	ldrb	r3, [r3, #3]
 801100c:	2b02      	cmp	r3, #2
 801100e:	d000      	beq.n	8011012 <USB_EPStartXfer+0xb46>
 8011010:	e16f      	b.n	80112f2 <USB_EPStartXfer+0xe26>
      {
        PCD_SET_EP_DBUF_CNT(USBx, ep->num, ep->is_in, ep->maxpacket);
 8011012:	683b      	ldr	r3, [r7, #0]
 8011014:	785b      	ldrb	r3, [r3, #1]
 8011016:	2b00      	cmp	r3, #0
 8011018:	d16f      	bne.n	80110fa <USB_EPStartXfer+0xc2e>
 801101a:	687b      	ldr	r3, [r7, #4]
 801101c:	21ac      	movs	r1, #172	; 0xac
 801101e:	187a      	adds	r2, r7, r1
 8011020:	6013      	str	r3, [r2, #0]
 8011022:	687b      	ldr	r3, [r7, #4]
 8011024:	2250      	movs	r2, #80	; 0x50
 8011026:	5a9b      	ldrh	r3, [r3, r2]
 8011028:	b29b      	uxth	r3, r3
 801102a:	001a      	movs	r2, r3
 801102c:	187b      	adds	r3, r7, r1
 801102e:	681b      	ldr	r3, [r3, #0]
 8011030:	189b      	adds	r3, r3, r2
 8011032:	187a      	adds	r2, r7, r1
 8011034:	6013      	str	r3, [r2, #0]
 8011036:	683b      	ldr	r3, [r7, #0]
 8011038:	781b      	ldrb	r3, [r3, #0]
 801103a:	00da      	lsls	r2, r3, #3
 801103c:	187b      	adds	r3, r7, r1
 801103e:	681b      	ldr	r3, [r3, #0]
 8011040:	18d3      	adds	r3, r2, r3
 8011042:	4ab9      	ldr	r2, [pc, #740]	; (8011328 <USB_EPStartXfer+0xe5c>)
 8011044:	4694      	mov	ip, r2
 8011046:	4463      	add	r3, ip
 8011048:	21a8      	movs	r1, #168	; 0xa8
 801104a:	187a      	adds	r2, r7, r1
 801104c:	6013      	str	r3, [r2, #0]
 801104e:	683b      	ldr	r3, [r7, #0]
 8011050:	691b      	ldr	r3, [r3, #16]
 8011052:	2b00      	cmp	r3, #0
 8011054:	d114      	bne.n	8011080 <USB_EPStartXfer+0xbb4>
 8011056:	187b      	adds	r3, r7, r1
 8011058:	681b      	ldr	r3, [r3, #0]
 801105a:	881b      	ldrh	r3, [r3, #0]
 801105c:	b29b      	uxth	r3, r3
 801105e:	4ab3      	ldr	r2, [pc, #716]	; (801132c <USB_EPStartXfer+0xe60>)
 8011060:	4013      	ands	r3, r2
 8011062:	b29a      	uxth	r2, r3
 8011064:	187b      	adds	r3, r7, r1
 8011066:	681b      	ldr	r3, [r3, #0]
 8011068:	801a      	strh	r2, [r3, #0]
 801106a:	187b      	adds	r3, r7, r1
 801106c:	681b      	ldr	r3, [r3, #0]
 801106e:	881b      	ldrh	r3, [r3, #0]
 8011070:	b29b      	uxth	r3, r3
 8011072:	4aac      	ldr	r2, [pc, #688]	; (8011324 <USB_EPStartXfer+0xe58>)
 8011074:	4313      	orrs	r3, r2
 8011076:	b29a      	uxth	r2, r3
 8011078:	187b      	adds	r3, r7, r1
 801107a:	681b      	ldr	r3, [r3, #0]
 801107c:	801a      	strh	r2, [r3, #0]
 801107e:	e060      	b.n	8011142 <USB_EPStartXfer+0xc76>
 8011080:	683b      	ldr	r3, [r7, #0]
 8011082:	691b      	ldr	r3, [r3, #16]
 8011084:	2b3e      	cmp	r3, #62	; 0x3e
 8011086:	d81a      	bhi.n	80110be <USB_EPStartXfer+0xbf2>
 8011088:	683b      	ldr	r3, [r7, #0]
 801108a:	691b      	ldr	r3, [r3, #16]
 801108c:	085b      	lsrs	r3, r3, #1
 801108e:	21e4      	movs	r1, #228	; 0xe4
 8011090:	187a      	adds	r2, r7, r1
 8011092:	6013      	str	r3, [r2, #0]
 8011094:	683b      	ldr	r3, [r7, #0]
 8011096:	691b      	ldr	r3, [r3, #16]
 8011098:	2201      	movs	r2, #1
 801109a:	4013      	ands	r3, r2
 801109c:	d004      	beq.n	80110a8 <USB_EPStartXfer+0xbdc>
 801109e:	187b      	adds	r3, r7, r1
 80110a0:	681b      	ldr	r3, [r3, #0]
 80110a2:	3301      	adds	r3, #1
 80110a4:	187a      	adds	r2, r7, r1
 80110a6:	6013      	str	r3, [r2, #0]
 80110a8:	23e4      	movs	r3, #228	; 0xe4
 80110aa:	18fb      	adds	r3, r7, r3
 80110ac:	681b      	ldr	r3, [r3, #0]
 80110ae:	b29b      	uxth	r3, r3
 80110b0:	029b      	lsls	r3, r3, #10
 80110b2:	b29a      	uxth	r2, r3
 80110b4:	23a8      	movs	r3, #168	; 0xa8
 80110b6:	18fb      	adds	r3, r7, r3
 80110b8:	681b      	ldr	r3, [r3, #0]
 80110ba:	801a      	strh	r2, [r3, #0]
 80110bc:	e041      	b.n	8011142 <USB_EPStartXfer+0xc76>
 80110be:	683b      	ldr	r3, [r7, #0]
 80110c0:	691b      	ldr	r3, [r3, #16]
 80110c2:	095b      	lsrs	r3, r3, #5
 80110c4:	21e4      	movs	r1, #228	; 0xe4
 80110c6:	187a      	adds	r2, r7, r1
 80110c8:	6013      	str	r3, [r2, #0]
 80110ca:	683b      	ldr	r3, [r7, #0]
 80110cc:	691b      	ldr	r3, [r3, #16]
 80110ce:	221f      	movs	r2, #31
 80110d0:	4013      	ands	r3, r2
 80110d2:	d104      	bne.n	80110de <USB_EPStartXfer+0xc12>
 80110d4:	187b      	adds	r3, r7, r1
 80110d6:	681b      	ldr	r3, [r3, #0]
 80110d8:	3b01      	subs	r3, #1
 80110da:	187a      	adds	r2, r7, r1
 80110dc:	6013      	str	r3, [r2, #0]
 80110de:	23e4      	movs	r3, #228	; 0xe4
 80110e0:	18fb      	adds	r3, r7, r3
 80110e2:	681b      	ldr	r3, [r3, #0]
 80110e4:	b29b      	uxth	r3, r3
 80110e6:	029b      	lsls	r3, r3, #10
 80110e8:	b29b      	uxth	r3, r3
 80110ea:	4a8e      	ldr	r2, [pc, #568]	; (8011324 <USB_EPStartXfer+0xe58>)
 80110ec:	4313      	orrs	r3, r2
 80110ee:	b29a      	uxth	r2, r3
 80110f0:	23a8      	movs	r3, #168	; 0xa8
 80110f2:	18fb      	adds	r3, r7, r3
 80110f4:	681b      	ldr	r3, [r3, #0]
 80110f6:	801a      	strh	r2, [r3, #0]
 80110f8:	e023      	b.n	8011142 <USB_EPStartXfer+0xc76>
 80110fa:	683b      	ldr	r3, [r7, #0]
 80110fc:	785b      	ldrb	r3, [r3, #1]
 80110fe:	2b01      	cmp	r3, #1
 8011100:	d11f      	bne.n	8011142 <USB_EPStartXfer+0xc76>
 8011102:	687b      	ldr	r3, [r7, #4]
 8011104:	21b4      	movs	r1, #180	; 0xb4
 8011106:	187a      	adds	r2, r7, r1
 8011108:	6013      	str	r3, [r2, #0]
 801110a:	687b      	ldr	r3, [r7, #4]
 801110c:	2250      	movs	r2, #80	; 0x50
 801110e:	5a9b      	ldrh	r3, [r3, r2]
 8011110:	b29b      	uxth	r3, r3
 8011112:	001a      	movs	r2, r3
 8011114:	187b      	adds	r3, r7, r1
 8011116:	681b      	ldr	r3, [r3, #0]
 8011118:	189b      	adds	r3, r3, r2
 801111a:	187a      	adds	r2, r7, r1
 801111c:	6013      	str	r3, [r2, #0]
 801111e:	683b      	ldr	r3, [r7, #0]
 8011120:	781b      	ldrb	r3, [r3, #0]
 8011122:	00da      	lsls	r2, r3, #3
 8011124:	187b      	adds	r3, r7, r1
 8011126:	681b      	ldr	r3, [r3, #0]
 8011128:	18d3      	adds	r3, r2, r3
 801112a:	4a7f      	ldr	r2, [pc, #508]	; (8011328 <USB_EPStartXfer+0xe5c>)
 801112c:	4694      	mov	ip, r2
 801112e:	4463      	add	r3, ip
 8011130:	21b0      	movs	r1, #176	; 0xb0
 8011132:	187a      	adds	r2, r7, r1
 8011134:	6013      	str	r3, [r2, #0]
 8011136:	683b      	ldr	r3, [r7, #0]
 8011138:	691b      	ldr	r3, [r3, #16]
 801113a:	b29a      	uxth	r2, r3
 801113c:	187b      	adds	r3, r7, r1
 801113e:	681b      	ldr	r3, [r3, #0]
 8011140:	801a      	strh	r2, [r3, #0]
 8011142:	687b      	ldr	r3, [r7, #4]
 8011144:	22a4      	movs	r2, #164	; 0xa4
 8011146:	18ba      	adds	r2, r7, r2
 8011148:	6013      	str	r3, [r2, #0]
 801114a:	683b      	ldr	r3, [r7, #0]
 801114c:	785b      	ldrb	r3, [r3, #1]
 801114e:	2b00      	cmp	r3, #0
 8011150:	d16f      	bne.n	8011232 <USB_EPStartXfer+0xd66>
 8011152:	687b      	ldr	r3, [r7, #4]
 8011154:	219c      	movs	r1, #156	; 0x9c
 8011156:	187a      	adds	r2, r7, r1
 8011158:	6013      	str	r3, [r2, #0]
 801115a:	687b      	ldr	r3, [r7, #4]
 801115c:	2250      	movs	r2, #80	; 0x50
 801115e:	5a9b      	ldrh	r3, [r3, r2]
 8011160:	b29b      	uxth	r3, r3
 8011162:	001a      	movs	r2, r3
 8011164:	187b      	adds	r3, r7, r1
 8011166:	681b      	ldr	r3, [r3, #0]
 8011168:	189b      	adds	r3, r3, r2
 801116a:	187a      	adds	r2, r7, r1
 801116c:	6013      	str	r3, [r2, #0]
 801116e:	683b      	ldr	r3, [r7, #0]
 8011170:	781b      	ldrb	r3, [r3, #0]
 8011172:	00da      	lsls	r2, r3, #3
 8011174:	187b      	adds	r3, r7, r1
 8011176:	681b      	ldr	r3, [r3, #0]
 8011178:	18d3      	adds	r3, r2, r3
 801117a:	4a6d      	ldr	r2, [pc, #436]	; (8011330 <USB_EPStartXfer+0xe64>)
 801117c:	4694      	mov	ip, r2
 801117e:	4463      	add	r3, ip
 8011180:	2198      	movs	r1, #152	; 0x98
 8011182:	187a      	adds	r2, r7, r1
 8011184:	6013      	str	r3, [r2, #0]
 8011186:	683b      	ldr	r3, [r7, #0]
 8011188:	691b      	ldr	r3, [r3, #16]
 801118a:	2b00      	cmp	r3, #0
 801118c:	d114      	bne.n	80111b8 <USB_EPStartXfer+0xcec>
 801118e:	187b      	adds	r3, r7, r1
 8011190:	681b      	ldr	r3, [r3, #0]
 8011192:	881b      	ldrh	r3, [r3, #0]
 8011194:	b29b      	uxth	r3, r3
 8011196:	4a65      	ldr	r2, [pc, #404]	; (801132c <USB_EPStartXfer+0xe60>)
 8011198:	4013      	ands	r3, r2
 801119a:	b29a      	uxth	r2, r3
 801119c:	187b      	adds	r3, r7, r1
 801119e:	681b      	ldr	r3, [r3, #0]
 80111a0:	801a      	strh	r2, [r3, #0]
 80111a2:	187b      	adds	r3, r7, r1
 80111a4:	681b      	ldr	r3, [r3, #0]
 80111a6:	881b      	ldrh	r3, [r3, #0]
 80111a8:	b29b      	uxth	r3, r3
 80111aa:	4a5e      	ldr	r2, [pc, #376]	; (8011324 <USB_EPStartXfer+0xe58>)
 80111ac:	4313      	orrs	r3, r2
 80111ae:	b29a      	uxth	r2, r3
 80111b0:	187b      	adds	r3, r7, r1
 80111b2:	681b      	ldr	r3, [r3, #0]
 80111b4:	801a      	strh	r2, [r3, #0]
 80111b6:	e05d      	b.n	8011274 <USB_EPStartXfer+0xda8>
 80111b8:	683b      	ldr	r3, [r7, #0]
 80111ba:	691b      	ldr	r3, [r3, #16]
 80111bc:	2b3e      	cmp	r3, #62	; 0x3e
 80111be:	d81a      	bhi.n	80111f6 <USB_EPStartXfer+0xd2a>
 80111c0:	683b      	ldr	r3, [r7, #0]
 80111c2:	691b      	ldr	r3, [r3, #16]
 80111c4:	085b      	lsrs	r3, r3, #1
 80111c6:	21e0      	movs	r1, #224	; 0xe0
 80111c8:	187a      	adds	r2, r7, r1
 80111ca:	6013      	str	r3, [r2, #0]
 80111cc:	683b      	ldr	r3, [r7, #0]
 80111ce:	691b      	ldr	r3, [r3, #16]
 80111d0:	2201      	movs	r2, #1
 80111d2:	4013      	ands	r3, r2
 80111d4:	d004      	beq.n	80111e0 <USB_EPStartXfer+0xd14>
 80111d6:	187b      	adds	r3, r7, r1
 80111d8:	681b      	ldr	r3, [r3, #0]
 80111da:	3301      	adds	r3, #1
 80111dc:	187a      	adds	r2, r7, r1
 80111de:	6013      	str	r3, [r2, #0]
 80111e0:	23e0      	movs	r3, #224	; 0xe0
 80111e2:	18fb      	adds	r3, r7, r3
 80111e4:	681b      	ldr	r3, [r3, #0]
 80111e6:	b29b      	uxth	r3, r3
 80111e8:	029b      	lsls	r3, r3, #10
 80111ea:	b29a      	uxth	r2, r3
 80111ec:	2398      	movs	r3, #152	; 0x98
 80111ee:	18fb      	adds	r3, r7, r3
 80111f0:	681b      	ldr	r3, [r3, #0]
 80111f2:	801a      	strh	r2, [r3, #0]
 80111f4:	e03e      	b.n	8011274 <USB_EPStartXfer+0xda8>
 80111f6:	683b      	ldr	r3, [r7, #0]
 80111f8:	691b      	ldr	r3, [r3, #16]
 80111fa:	095b      	lsrs	r3, r3, #5
 80111fc:	21e0      	movs	r1, #224	; 0xe0
 80111fe:	187a      	adds	r2, r7, r1
 8011200:	6013      	str	r3, [r2, #0]
 8011202:	683b      	ldr	r3, [r7, #0]
 8011204:	691b      	ldr	r3, [r3, #16]
 8011206:	221f      	movs	r2, #31
 8011208:	4013      	ands	r3, r2
 801120a:	d104      	bne.n	8011216 <USB_EPStartXfer+0xd4a>
 801120c:	187b      	adds	r3, r7, r1
 801120e:	681b      	ldr	r3, [r3, #0]
 8011210:	3b01      	subs	r3, #1
 8011212:	187a      	adds	r2, r7, r1
 8011214:	6013      	str	r3, [r2, #0]
 8011216:	23e0      	movs	r3, #224	; 0xe0
 8011218:	18fb      	adds	r3, r7, r3
 801121a:	681b      	ldr	r3, [r3, #0]
 801121c:	b29b      	uxth	r3, r3
 801121e:	029b      	lsls	r3, r3, #10
 8011220:	b29b      	uxth	r3, r3
 8011222:	4a40      	ldr	r2, [pc, #256]	; (8011324 <USB_EPStartXfer+0xe58>)
 8011224:	4313      	orrs	r3, r2
 8011226:	b29a      	uxth	r2, r3
 8011228:	2398      	movs	r3, #152	; 0x98
 801122a:	18fb      	adds	r3, r7, r3
 801122c:	681b      	ldr	r3, [r3, #0]
 801122e:	801a      	strh	r2, [r3, #0]
 8011230:	e020      	b.n	8011274 <USB_EPStartXfer+0xda8>
 8011232:	683b      	ldr	r3, [r7, #0]
 8011234:	785b      	ldrb	r3, [r3, #1]
 8011236:	2b01      	cmp	r3, #1
 8011238:	d11c      	bne.n	8011274 <USB_EPStartXfer+0xda8>
 801123a:	687b      	ldr	r3, [r7, #4]
 801123c:	2250      	movs	r2, #80	; 0x50
 801123e:	5a9b      	ldrh	r3, [r3, r2]
 8011240:	b29b      	uxth	r3, r3
 8011242:	001a      	movs	r2, r3
 8011244:	21a4      	movs	r1, #164	; 0xa4
 8011246:	187b      	adds	r3, r7, r1
 8011248:	681b      	ldr	r3, [r3, #0]
 801124a:	189b      	adds	r3, r3, r2
 801124c:	187a      	adds	r2, r7, r1
 801124e:	6013      	str	r3, [r2, #0]
 8011250:	683b      	ldr	r3, [r7, #0]
 8011252:	781b      	ldrb	r3, [r3, #0]
 8011254:	00da      	lsls	r2, r3, #3
 8011256:	187b      	adds	r3, r7, r1
 8011258:	681b      	ldr	r3, [r3, #0]
 801125a:	18d3      	adds	r3, r2, r3
 801125c:	4a34      	ldr	r2, [pc, #208]	; (8011330 <USB_EPStartXfer+0xe64>)
 801125e:	4694      	mov	ip, r2
 8011260:	4463      	add	r3, ip
 8011262:	21a0      	movs	r1, #160	; 0xa0
 8011264:	187a      	adds	r2, r7, r1
 8011266:	6013      	str	r3, [r2, #0]
 8011268:	683b      	ldr	r3, [r7, #0]
 801126a:	691b      	ldr	r3, [r3, #16]
 801126c:	b29a      	uxth	r2, r3
 801126e:	187b      	adds	r3, r7, r1
 8011270:	681b      	ldr	r3, [r3, #0]
 8011272:	801a      	strh	r2, [r3, #0]

        /* Coming from ISR */
        if (ep->xfer_count != 0U)
 8011274:	683b      	ldr	r3, [r7, #0]
 8011276:	69db      	ldr	r3, [r3, #28]
 8011278:	2b00      	cmp	r3, #0
 801127a:	d100      	bne.n	801127e <USB_EPStartXfer+0xdb2>
 801127c:	e1aa      	b.n	80115d4 <USB_EPStartXfer+0x1108>
        {
          /* update last value to check if there is blocking state */
          wEPVal = PCD_GET_ENDPOINT(USBx, ep->num);
 801127e:	687a      	ldr	r2, [r7, #4]
 8011280:	683b      	ldr	r3, [r7, #0]
 8011282:	781b      	ldrb	r3, [r3, #0]
 8011284:	009b      	lsls	r3, r3, #2
 8011286:	18d2      	adds	r2, r2, r3
 8011288:	2196      	movs	r1, #150	; 0x96
 801128a:	187b      	adds	r3, r7, r1
 801128c:	8812      	ldrh	r2, [r2, #0]
 801128e:	801a      	strh	r2, [r3, #0]

          /*Blocking State */
          if ((((wEPVal & USB_EP_DTOG_RX) != 0U) && ((wEPVal & USB_EP_DTOG_TX) != 0U)) ||
 8011290:	187b      	adds	r3, r7, r1
 8011292:	881a      	ldrh	r2, [r3, #0]
 8011294:	2380      	movs	r3, #128	; 0x80
 8011296:	01db      	lsls	r3, r3, #7
 8011298:	4013      	ands	r3, r2
 801129a:	d004      	beq.n	80112a6 <USB_EPStartXfer+0xdda>
 801129c:	187b      	adds	r3, r7, r1
 801129e:	881b      	ldrh	r3, [r3, #0]
 80112a0:	2240      	movs	r2, #64	; 0x40
 80112a2:	4013      	ands	r3, r2
 80112a4:	d10d      	bne.n	80112c2 <USB_EPStartXfer+0xdf6>
              (((wEPVal & USB_EP_DTOG_RX) == 0U) && ((wEPVal & USB_EP_DTOG_TX) == 0U)))
 80112a6:	2196      	movs	r1, #150	; 0x96
 80112a8:	187b      	adds	r3, r7, r1
 80112aa:	881a      	ldrh	r2, [r3, #0]
 80112ac:	2380      	movs	r3, #128	; 0x80
 80112ae:	01db      	lsls	r3, r3, #7
 80112b0:	4013      	ands	r3, r2
          if ((((wEPVal & USB_EP_DTOG_RX) != 0U) && ((wEPVal & USB_EP_DTOG_TX) != 0U)) ||
 80112b2:	d000      	beq.n	80112b6 <USB_EPStartXfer+0xdea>
 80112b4:	e18e      	b.n	80115d4 <USB_EPStartXfer+0x1108>
              (((wEPVal & USB_EP_DTOG_RX) == 0U) && ((wEPVal & USB_EP_DTOG_TX) == 0U)))
 80112b6:	187b      	adds	r3, r7, r1
 80112b8:	881b      	ldrh	r3, [r3, #0]
 80112ba:	2240      	movs	r2, #64	; 0x40
 80112bc:	4013      	ands	r3, r2
 80112be:	d000      	beq.n	80112c2 <USB_EPStartXfer+0xdf6>
 80112c0:	e188      	b.n	80115d4 <USB_EPStartXfer+0x1108>
          {
            PCD_FreeUserBuffer(USBx, ep->num, 0U);
 80112c2:	687a      	ldr	r2, [r7, #4]
 80112c4:	683b      	ldr	r3, [r7, #0]
 80112c6:	781b      	ldrb	r3, [r3, #0]
 80112c8:	009b      	lsls	r3, r3, #2
 80112ca:	18d3      	adds	r3, r2, r3
 80112cc:	881b      	ldrh	r3, [r3, #0]
 80112ce:	b29a      	uxth	r2, r3
 80112d0:	2094      	movs	r0, #148	; 0x94
 80112d2:	183b      	adds	r3, r7, r0
 80112d4:	4917      	ldr	r1, [pc, #92]	; (8011334 <USB_EPStartXfer+0xe68>)
 80112d6:	400a      	ands	r2, r1
 80112d8:	801a      	strh	r2, [r3, #0]
 80112da:	687a      	ldr	r2, [r7, #4]
 80112dc:	683b      	ldr	r3, [r7, #0]
 80112de:	781b      	ldrb	r3, [r3, #0]
 80112e0:	009b      	lsls	r3, r3, #2
 80112e2:	18d3      	adds	r3, r2, r3
 80112e4:	183a      	adds	r2, r7, r0
 80112e6:	8812      	ldrh	r2, [r2, #0]
 80112e8:	4913      	ldr	r1, [pc, #76]	; (8011338 <USB_EPStartXfer+0xe6c>)
 80112ea:	430a      	orrs	r2, r1
 80112ec:	b292      	uxth	r2, r2
 80112ee:	801a      	strh	r2, [r3, #0]
 80112f0:	e170      	b.n	80115d4 <USB_EPStartXfer+0x1108>
          }
        }
      }
      /* iso out double */
      else if (ep->type == EP_TYPE_ISOC)
 80112f2:	683b      	ldr	r3, [r7, #0]
 80112f4:	78db      	ldrb	r3, [r3, #3]
 80112f6:	2b01      	cmp	r3, #1
 80112f8:	d000      	beq.n	80112fc <USB_EPStartXfer+0xe30>
 80112fa:	e169      	b.n	80115d0 <USB_EPStartXfer+0x1104>
      {
        /* Multi packet transfer */
        if (ep->xfer_len > ep->maxpacket)
 80112fc:	683b      	ldr	r3, [r7, #0]
 80112fe:	699a      	ldr	r2, [r3, #24]
 8011300:	683b      	ldr	r3, [r7, #0]
 8011302:	691b      	ldr	r3, [r3, #16]
 8011304:	429a      	cmp	r2, r3
 8011306:	d919      	bls.n	801133c <USB_EPStartXfer+0xe70>
        {
          len = ep->maxpacket;
 8011308:	683b      	ldr	r3, [r7, #0]
 801130a:	691b      	ldr	r3, [r3, #16]
 801130c:	1d7a      	adds	r2, r7, #5
 801130e:	32ff      	adds	r2, #255	; 0xff
 8011310:	6013      	str	r3, [r2, #0]
          ep->xfer_len -= len;
 8011312:	683b      	ldr	r3, [r7, #0]
 8011314:	699a      	ldr	r2, [r3, #24]
 8011316:	1d7b      	adds	r3, r7, #5
 8011318:	33ff      	adds	r3, #255	; 0xff
 801131a:	681b      	ldr	r3, [r3, #0]
 801131c:	1ad2      	subs	r2, r2, r3
 801131e:	683b      	ldr	r3, [r7, #0]
 8011320:	619a      	str	r2, [r3, #24]
 8011322:	e013      	b.n	801134c <USB_EPStartXfer+0xe80>
 8011324:	ffff8000 	.word	0xffff8000
 8011328:	00000402 	.word	0x00000402
 801132c:	ffff83ff 	.word	0xffff83ff
 8011330:	00000406 	.word	0x00000406
 8011334:	ffff8f8f 	.word	0xffff8f8f
 8011338:	ffff80c0 	.word	0xffff80c0
        }
        else
        {
          len = ep->xfer_len;
 801133c:	683b      	ldr	r3, [r7, #0]
 801133e:	699b      	ldr	r3, [r3, #24]
 8011340:	1d7a      	adds	r2, r7, #5
 8011342:	32ff      	adds	r2, #255	; 0xff
 8011344:	6013      	str	r3, [r2, #0]
          ep->xfer_len = 0U;
 8011346:	683b      	ldr	r3, [r7, #0]
 8011348:	2200      	movs	r2, #0
 801134a:	619a      	str	r2, [r3, #24]
        }
        PCD_SET_EP_DBUF_CNT(USBx, ep->num, ep->is_in, len);
 801134c:	683b      	ldr	r3, [r7, #0]
 801134e:	785b      	ldrb	r3, [r3, #1]
 8011350:	2b00      	cmp	r3, #0
 8011352:	d000      	beq.n	8011356 <USB_EPStartXfer+0xe8a>
 8011354:	e075      	b.n	8011442 <USB_EPStartXfer+0xf76>
 8011356:	687b      	ldr	r3, [r7, #4]
 8011358:	21cc      	movs	r1, #204	; 0xcc
 801135a:	187a      	adds	r2, r7, r1
 801135c:	6013      	str	r3, [r2, #0]
 801135e:	687b      	ldr	r3, [r7, #4]
 8011360:	2250      	movs	r2, #80	; 0x50
 8011362:	5a9b      	ldrh	r3, [r3, r2]
 8011364:	b29b      	uxth	r3, r3
 8011366:	001a      	movs	r2, r3
 8011368:	187b      	adds	r3, r7, r1
 801136a:	681b      	ldr	r3, [r3, #0]
 801136c:	189b      	adds	r3, r3, r2
 801136e:	187a      	adds	r2, r7, r1
 8011370:	6013      	str	r3, [r2, #0]
 8011372:	683b      	ldr	r3, [r7, #0]
 8011374:	781b      	ldrb	r3, [r3, #0]
 8011376:	00da      	lsls	r2, r3, #3
 8011378:	187b      	adds	r3, r7, r1
 801137a:	681b      	ldr	r3, [r3, #0]
 801137c:	18d3      	adds	r3, r2, r3
 801137e:	4aaa      	ldr	r2, [pc, #680]	; (8011628 <USB_EPStartXfer+0x115c>)
 8011380:	4694      	mov	ip, r2
 8011382:	4463      	add	r3, ip
 8011384:	21c8      	movs	r1, #200	; 0xc8
 8011386:	187a      	adds	r2, r7, r1
 8011388:	6013      	str	r3, [r2, #0]
 801138a:	1d7b      	adds	r3, r7, #5
 801138c:	33ff      	adds	r3, #255	; 0xff
 801138e:	681b      	ldr	r3, [r3, #0]
 8011390:	2b00      	cmp	r3, #0
 8011392:	d114      	bne.n	80113be <USB_EPStartXfer+0xef2>
 8011394:	187b      	adds	r3, r7, r1
 8011396:	681b      	ldr	r3, [r3, #0]
 8011398:	881b      	ldrh	r3, [r3, #0]
 801139a:	b29b      	uxth	r3, r3
 801139c:	4aa3      	ldr	r2, [pc, #652]	; (801162c <USB_EPStartXfer+0x1160>)
 801139e:	4013      	ands	r3, r2
 80113a0:	b29a      	uxth	r2, r3
 80113a2:	187b      	adds	r3, r7, r1
 80113a4:	681b      	ldr	r3, [r3, #0]
 80113a6:	801a      	strh	r2, [r3, #0]
 80113a8:	187b      	adds	r3, r7, r1
 80113aa:	681b      	ldr	r3, [r3, #0]
 80113ac:	881b      	ldrh	r3, [r3, #0]
 80113ae:	b29b      	uxth	r3, r3
 80113b0:	4a9f      	ldr	r2, [pc, #636]	; (8011630 <USB_EPStartXfer+0x1164>)
 80113b2:	4313      	orrs	r3, r2
 80113b4:	b29a      	uxth	r2, r3
 80113b6:	187b      	adds	r3, r7, r1
 80113b8:	681b      	ldr	r3, [r3, #0]
 80113ba:	801a      	strh	r2, [r3, #0]
 80113bc:	e066      	b.n	801148c <USB_EPStartXfer+0xfc0>
 80113be:	1d7b      	adds	r3, r7, #5
 80113c0:	33ff      	adds	r3, #255	; 0xff
 80113c2:	681b      	ldr	r3, [r3, #0]
 80113c4:	2b3e      	cmp	r3, #62	; 0x3e
 80113c6:	d81c      	bhi.n	8011402 <USB_EPStartXfer+0xf36>
 80113c8:	1d7b      	adds	r3, r7, #5
 80113ca:	33ff      	adds	r3, #255	; 0xff
 80113cc:	681b      	ldr	r3, [r3, #0]
 80113ce:	085b      	lsrs	r3, r3, #1
 80113d0:	21dc      	movs	r1, #220	; 0xdc
 80113d2:	187a      	adds	r2, r7, r1
 80113d4:	6013      	str	r3, [r2, #0]
 80113d6:	1d7b      	adds	r3, r7, #5
 80113d8:	33ff      	adds	r3, #255	; 0xff
 80113da:	681b      	ldr	r3, [r3, #0]
 80113dc:	2201      	movs	r2, #1
 80113de:	4013      	ands	r3, r2
 80113e0:	d004      	beq.n	80113ec <USB_EPStartXfer+0xf20>
 80113e2:	187b      	adds	r3, r7, r1
 80113e4:	681b      	ldr	r3, [r3, #0]
 80113e6:	3301      	adds	r3, #1
 80113e8:	187a      	adds	r2, r7, r1
 80113ea:	6013      	str	r3, [r2, #0]
 80113ec:	23dc      	movs	r3, #220	; 0xdc
 80113ee:	18fb      	adds	r3, r7, r3
 80113f0:	681b      	ldr	r3, [r3, #0]
 80113f2:	b29b      	uxth	r3, r3
 80113f4:	029b      	lsls	r3, r3, #10
 80113f6:	b29a      	uxth	r2, r3
 80113f8:	23c8      	movs	r3, #200	; 0xc8
 80113fa:	18fb      	adds	r3, r7, r3
 80113fc:	681b      	ldr	r3, [r3, #0]
 80113fe:	801a      	strh	r2, [r3, #0]
 8011400:	e044      	b.n	801148c <USB_EPStartXfer+0xfc0>
 8011402:	1d7b      	adds	r3, r7, #5
 8011404:	33ff      	adds	r3, #255	; 0xff
 8011406:	681b      	ldr	r3, [r3, #0]
 8011408:	095b      	lsrs	r3, r3, #5
 801140a:	21dc      	movs	r1, #220	; 0xdc
 801140c:	187a      	adds	r2, r7, r1
 801140e:	6013      	str	r3, [r2, #0]
 8011410:	1d7b      	adds	r3, r7, #5
 8011412:	33ff      	adds	r3, #255	; 0xff
 8011414:	681b      	ldr	r3, [r3, #0]
 8011416:	221f      	movs	r2, #31
 8011418:	4013      	ands	r3, r2
 801141a:	d104      	bne.n	8011426 <USB_EPStartXfer+0xf5a>
 801141c:	187b      	adds	r3, r7, r1
 801141e:	681b      	ldr	r3, [r3, #0]
 8011420:	3b01      	subs	r3, #1
 8011422:	187a      	adds	r2, r7, r1
 8011424:	6013      	str	r3, [r2, #0]
 8011426:	23dc      	movs	r3, #220	; 0xdc
 8011428:	18fb      	adds	r3, r7, r3
 801142a:	681b      	ldr	r3, [r3, #0]
 801142c:	b29b      	uxth	r3, r3
 801142e:	029b      	lsls	r3, r3, #10
 8011430:	b29b      	uxth	r3, r3
 8011432:	4a7f      	ldr	r2, [pc, #508]	; (8011630 <USB_EPStartXfer+0x1164>)
 8011434:	4313      	orrs	r3, r2
 8011436:	b29a      	uxth	r2, r3
 8011438:	23c8      	movs	r3, #200	; 0xc8
 801143a:	18fb      	adds	r3, r7, r3
 801143c:	681b      	ldr	r3, [r3, #0]
 801143e:	801a      	strh	r2, [r3, #0]
 8011440:	e024      	b.n	801148c <USB_EPStartXfer+0xfc0>
 8011442:	683b      	ldr	r3, [r7, #0]
 8011444:	785b      	ldrb	r3, [r3, #1]
 8011446:	2b01      	cmp	r3, #1
 8011448:	d120      	bne.n	801148c <USB_EPStartXfer+0xfc0>
 801144a:	687b      	ldr	r3, [r7, #4]
 801144c:	21d4      	movs	r1, #212	; 0xd4
 801144e:	187a      	adds	r2, r7, r1
 8011450:	6013      	str	r3, [r2, #0]
 8011452:	687b      	ldr	r3, [r7, #4]
 8011454:	2250      	movs	r2, #80	; 0x50
 8011456:	5a9b      	ldrh	r3, [r3, r2]
 8011458:	b29b      	uxth	r3, r3
 801145a:	001a      	movs	r2, r3
 801145c:	187b      	adds	r3, r7, r1
 801145e:	681b      	ldr	r3, [r3, #0]
 8011460:	189b      	adds	r3, r3, r2
 8011462:	187a      	adds	r2, r7, r1
 8011464:	6013      	str	r3, [r2, #0]
 8011466:	683b      	ldr	r3, [r7, #0]
 8011468:	781b      	ldrb	r3, [r3, #0]
 801146a:	00da      	lsls	r2, r3, #3
 801146c:	187b      	adds	r3, r7, r1
 801146e:	681b      	ldr	r3, [r3, #0]
 8011470:	18d3      	adds	r3, r2, r3
 8011472:	4a6d      	ldr	r2, [pc, #436]	; (8011628 <USB_EPStartXfer+0x115c>)
 8011474:	4694      	mov	ip, r2
 8011476:	4463      	add	r3, ip
 8011478:	21d0      	movs	r1, #208	; 0xd0
 801147a:	187a      	adds	r2, r7, r1
 801147c:	6013      	str	r3, [r2, #0]
 801147e:	1d7b      	adds	r3, r7, #5
 8011480:	33ff      	adds	r3, #255	; 0xff
 8011482:	681b      	ldr	r3, [r3, #0]
 8011484:	b29a      	uxth	r2, r3
 8011486:	187b      	adds	r3, r7, r1
 8011488:	681b      	ldr	r3, [r3, #0]
 801148a:	801a      	strh	r2, [r3, #0]
 801148c:	687b      	ldr	r3, [r7, #4]
 801148e:	22c4      	movs	r2, #196	; 0xc4
 8011490:	18ba      	adds	r2, r7, r2
 8011492:	6013      	str	r3, [r2, #0]
 8011494:	683b      	ldr	r3, [r7, #0]
 8011496:	785b      	ldrb	r3, [r3, #1]
 8011498:	2b00      	cmp	r3, #0
 801149a:	d000      	beq.n	801149e <USB_EPStartXfer+0xfd2>
 801149c:	e075      	b.n	801158a <USB_EPStartXfer+0x10be>
 801149e:	687b      	ldr	r3, [r7, #4]
 80114a0:	21bc      	movs	r1, #188	; 0xbc
 80114a2:	187a      	adds	r2, r7, r1
 80114a4:	6013      	str	r3, [r2, #0]
 80114a6:	687b      	ldr	r3, [r7, #4]
 80114a8:	2250      	movs	r2, #80	; 0x50
 80114aa:	5a9b      	ldrh	r3, [r3, r2]
 80114ac:	b29b      	uxth	r3, r3
 80114ae:	001a      	movs	r2, r3
 80114b0:	187b      	adds	r3, r7, r1
 80114b2:	681b      	ldr	r3, [r3, #0]
 80114b4:	189b      	adds	r3, r3, r2
 80114b6:	187a      	adds	r2, r7, r1
 80114b8:	6013      	str	r3, [r2, #0]
 80114ba:	683b      	ldr	r3, [r7, #0]
 80114bc:	781b      	ldrb	r3, [r3, #0]
 80114be:	00da      	lsls	r2, r3, #3
 80114c0:	187b      	adds	r3, r7, r1
 80114c2:	681b      	ldr	r3, [r3, #0]
 80114c4:	18d3      	adds	r3, r2, r3
 80114c6:	4a5b      	ldr	r2, [pc, #364]	; (8011634 <USB_EPStartXfer+0x1168>)
 80114c8:	4694      	mov	ip, r2
 80114ca:	4463      	add	r3, ip
 80114cc:	21b8      	movs	r1, #184	; 0xb8
 80114ce:	187a      	adds	r2, r7, r1
 80114d0:	6013      	str	r3, [r2, #0]
 80114d2:	1d7b      	adds	r3, r7, #5
 80114d4:	33ff      	adds	r3, #255	; 0xff
 80114d6:	681b      	ldr	r3, [r3, #0]
 80114d8:	2b00      	cmp	r3, #0
 80114da:	d114      	bne.n	8011506 <USB_EPStartXfer+0x103a>
 80114dc:	187b      	adds	r3, r7, r1
 80114de:	681b      	ldr	r3, [r3, #0]
 80114e0:	881b      	ldrh	r3, [r3, #0]
 80114e2:	b29b      	uxth	r3, r3
 80114e4:	4a51      	ldr	r2, [pc, #324]	; (801162c <USB_EPStartXfer+0x1160>)
 80114e6:	4013      	ands	r3, r2
 80114e8:	b29a      	uxth	r2, r3
 80114ea:	187b      	adds	r3, r7, r1
 80114ec:	681b      	ldr	r3, [r3, #0]
 80114ee:	801a      	strh	r2, [r3, #0]
 80114f0:	187b      	adds	r3, r7, r1
 80114f2:	681b      	ldr	r3, [r3, #0]
 80114f4:	881b      	ldrh	r3, [r3, #0]
 80114f6:	b29b      	uxth	r3, r3
 80114f8:	4a4d      	ldr	r2, [pc, #308]	; (8011630 <USB_EPStartXfer+0x1164>)
 80114fa:	4313      	orrs	r3, r2
 80114fc:	b29a      	uxth	r2, r3
 80114fe:	187b      	adds	r3, r7, r1
 8011500:	681b      	ldr	r3, [r3, #0]
 8011502:	801a      	strh	r2, [r3, #0]
 8011504:	e066      	b.n	80115d4 <USB_EPStartXfer+0x1108>
 8011506:	1d7b      	adds	r3, r7, #5
 8011508:	33ff      	adds	r3, #255	; 0xff
 801150a:	681b      	ldr	r3, [r3, #0]
 801150c:	2b3e      	cmp	r3, #62	; 0x3e
 801150e:	d81c      	bhi.n	801154a <USB_EPStartXfer+0x107e>
 8011510:	1d7b      	adds	r3, r7, #5
 8011512:	33ff      	adds	r3, #255	; 0xff
 8011514:	681b      	ldr	r3, [r3, #0]
 8011516:	085b      	lsrs	r3, r3, #1
 8011518:	21d8      	movs	r1, #216	; 0xd8
 801151a:	187a      	adds	r2, r7, r1
 801151c:	6013      	str	r3, [r2, #0]
 801151e:	1d7b      	adds	r3, r7, #5
 8011520:	33ff      	adds	r3, #255	; 0xff
 8011522:	681b      	ldr	r3, [r3, #0]
 8011524:	2201      	movs	r2, #1
 8011526:	4013      	ands	r3, r2
 8011528:	d004      	beq.n	8011534 <USB_EPStartXfer+0x1068>
 801152a:	187b      	adds	r3, r7, r1
 801152c:	681b      	ldr	r3, [r3, #0]
 801152e:	3301      	adds	r3, #1
 8011530:	187a      	adds	r2, r7, r1
 8011532:	6013      	str	r3, [r2, #0]
 8011534:	23d8      	movs	r3, #216	; 0xd8
 8011536:	18fb      	adds	r3, r7, r3
 8011538:	681b      	ldr	r3, [r3, #0]
 801153a:	b29b      	uxth	r3, r3
 801153c:	029b      	lsls	r3, r3, #10
 801153e:	b29a      	uxth	r2, r3
 8011540:	23b8      	movs	r3, #184	; 0xb8
 8011542:	18fb      	adds	r3, r7, r3
 8011544:	681b      	ldr	r3, [r3, #0]
 8011546:	801a      	strh	r2, [r3, #0]
 8011548:	e044      	b.n	80115d4 <USB_EPStartXfer+0x1108>
 801154a:	1d7b      	adds	r3, r7, #5
 801154c:	33ff      	adds	r3, #255	; 0xff
 801154e:	681b      	ldr	r3, [r3, #0]
 8011550:	095b      	lsrs	r3, r3, #5
 8011552:	21d8      	movs	r1, #216	; 0xd8
 8011554:	187a      	adds	r2, r7, r1
 8011556:	6013      	str	r3, [r2, #0]
 8011558:	1d7b      	adds	r3, r7, #5
 801155a:	33ff      	adds	r3, #255	; 0xff
 801155c:	681b      	ldr	r3, [r3, #0]
 801155e:	221f      	movs	r2, #31
 8011560:	4013      	ands	r3, r2
 8011562:	d104      	bne.n	801156e <USB_EPStartXfer+0x10a2>
 8011564:	187b      	adds	r3, r7, r1
 8011566:	681b      	ldr	r3, [r3, #0]
 8011568:	3b01      	subs	r3, #1
 801156a:	187a      	adds	r2, r7, r1
 801156c:	6013      	str	r3, [r2, #0]
 801156e:	23d8      	movs	r3, #216	; 0xd8
 8011570:	18fb      	adds	r3, r7, r3
 8011572:	681b      	ldr	r3, [r3, #0]
 8011574:	b29b      	uxth	r3, r3
 8011576:	029b      	lsls	r3, r3, #10
 8011578:	b29b      	uxth	r3, r3
 801157a:	4a2d      	ldr	r2, [pc, #180]	; (8011630 <USB_EPStartXfer+0x1164>)
 801157c:	4313      	orrs	r3, r2
 801157e:	b29a      	uxth	r2, r3
 8011580:	23b8      	movs	r3, #184	; 0xb8
 8011582:	18fb      	adds	r3, r7, r3
 8011584:	681b      	ldr	r3, [r3, #0]
 8011586:	801a      	strh	r2, [r3, #0]
 8011588:	e024      	b.n	80115d4 <USB_EPStartXfer+0x1108>
 801158a:	683b      	ldr	r3, [r7, #0]
 801158c:	785b      	ldrb	r3, [r3, #1]
 801158e:	2b01      	cmp	r3, #1
 8011590:	d120      	bne.n	80115d4 <USB_EPStartXfer+0x1108>
 8011592:	687b      	ldr	r3, [r7, #4]
 8011594:	2250      	movs	r2, #80	; 0x50
 8011596:	5a9b      	ldrh	r3, [r3, r2]
 8011598:	b29b      	uxth	r3, r3
 801159a:	001a      	movs	r2, r3
 801159c:	21c4      	movs	r1, #196	; 0xc4
 801159e:	187b      	adds	r3, r7, r1
 80115a0:	681b      	ldr	r3, [r3, #0]
 80115a2:	189b      	adds	r3, r3, r2
 80115a4:	187a      	adds	r2, r7, r1
 80115a6:	6013      	str	r3, [r2, #0]
 80115a8:	683b      	ldr	r3, [r7, #0]
 80115aa:	781b      	ldrb	r3, [r3, #0]
 80115ac:	00da      	lsls	r2, r3, #3
 80115ae:	187b      	adds	r3, r7, r1
 80115b0:	681b      	ldr	r3, [r3, #0]
 80115b2:	18d3      	adds	r3, r2, r3
 80115b4:	4a1f      	ldr	r2, [pc, #124]	; (8011634 <USB_EPStartXfer+0x1168>)
 80115b6:	4694      	mov	ip, r2
 80115b8:	4463      	add	r3, ip
 80115ba:	21c0      	movs	r1, #192	; 0xc0
 80115bc:	187a      	adds	r2, r7, r1
 80115be:	6013      	str	r3, [r2, #0]
 80115c0:	1d7b      	adds	r3, r7, #5
 80115c2:	33ff      	adds	r3, #255	; 0xff
 80115c4:	681b      	ldr	r3, [r3, #0]
 80115c6:	b29a      	uxth	r2, r3
 80115c8:	187b      	adds	r3, r7, r1
 80115ca:	681b      	ldr	r3, [r3, #0]
 80115cc:	801a      	strh	r2, [r3, #0]
 80115ce:	e001      	b.n	80115d4 <USB_EPStartXfer+0x1108>
      }
      else
      {
        return HAL_ERROR;
 80115d0:	2301      	movs	r3, #1
 80115d2:	e025      	b.n	8011620 <USB_EPStartXfer+0x1154>
      }
    }

    PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_VALID);
 80115d4:	687a      	ldr	r2, [r7, #4]
 80115d6:	683b      	ldr	r3, [r7, #0]
 80115d8:	781b      	ldrb	r3, [r3, #0]
 80115da:	009b      	lsls	r3, r3, #2
 80115dc:	18d3      	adds	r3, r2, r3
 80115de:	881b      	ldrh	r3, [r3, #0]
 80115e0:	b29a      	uxth	r2, r3
 80115e2:	208a      	movs	r0, #138	; 0x8a
 80115e4:	183b      	adds	r3, r7, r0
 80115e6:	4914      	ldr	r1, [pc, #80]	; (8011638 <USB_EPStartXfer+0x116c>)
 80115e8:	400a      	ands	r2, r1
 80115ea:	801a      	strh	r2, [r3, #0]
 80115ec:	183b      	adds	r3, r7, r0
 80115ee:	183a      	adds	r2, r7, r0
 80115f0:	8812      	ldrh	r2, [r2, #0]
 80115f2:	2180      	movs	r1, #128	; 0x80
 80115f4:	0149      	lsls	r1, r1, #5
 80115f6:	404a      	eors	r2, r1
 80115f8:	801a      	strh	r2, [r3, #0]
 80115fa:	183b      	adds	r3, r7, r0
 80115fc:	183a      	adds	r2, r7, r0
 80115fe:	8812      	ldrh	r2, [r2, #0]
 8011600:	2180      	movs	r1, #128	; 0x80
 8011602:	0189      	lsls	r1, r1, #6
 8011604:	404a      	eors	r2, r1
 8011606:	801a      	strh	r2, [r3, #0]
 8011608:	687a      	ldr	r2, [r7, #4]
 801160a:	683b      	ldr	r3, [r7, #0]
 801160c:	781b      	ldrb	r3, [r3, #0]
 801160e:	009b      	lsls	r3, r3, #2
 8011610:	18d3      	adds	r3, r2, r3
 8011612:	183a      	adds	r2, r7, r0
 8011614:	8812      	ldrh	r2, [r2, #0]
 8011616:	4909      	ldr	r1, [pc, #36]	; (801163c <USB_EPStartXfer+0x1170>)
 8011618:	430a      	orrs	r2, r1
 801161a:	b292      	uxth	r2, r2
 801161c:	801a      	strh	r2, [r3, #0]
  }

  return HAL_OK;
 801161e:	2300      	movs	r3, #0
}
 8011620:	0018      	movs	r0, r3
 8011622:	46bd      	mov	sp, r7
 8011624:	b043      	add	sp, #268	; 0x10c
 8011626:	bd90      	pop	{r4, r7, pc}
 8011628:	00000402 	.word	0x00000402
 801162c:	ffff83ff 	.word	0xffff83ff
 8011630:	ffff8000 	.word	0xffff8000
 8011634:	00000406 	.word	0x00000406
 8011638:	ffffbf8f 	.word	0xffffbf8f
 801163c:	ffff8080 	.word	0xffff8080

08011640 <USB_EPSetStall>:
  * @param  USBx Selected device
  * @param  ep pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EPSetStall(USB_TypeDef *USBx, USB_EPTypeDef *ep)
{
 8011640:	b580      	push	{r7, lr}
 8011642:	b084      	sub	sp, #16
 8011644:	af00      	add	r7, sp, #0
 8011646:	6078      	str	r0, [r7, #4]
 8011648:	6039      	str	r1, [r7, #0]
  if (ep->is_in != 0U)
 801164a:	683b      	ldr	r3, [r7, #0]
 801164c:	785b      	ldrb	r3, [r3, #1]
 801164e:	2b00      	cmp	r3, #0
 8011650:	d01d      	beq.n	801168e <USB_EPSetStall+0x4e>
  {
    PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_STALL);
 8011652:	687a      	ldr	r2, [r7, #4]
 8011654:	683b      	ldr	r3, [r7, #0]
 8011656:	781b      	ldrb	r3, [r3, #0]
 8011658:	009b      	lsls	r3, r3, #2
 801165a:	18d3      	adds	r3, r2, r3
 801165c:	881b      	ldrh	r3, [r3, #0]
 801165e:	b29a      	uxth	r2, r3
 8011660:	200c      	movs	r0, #12
 8011662:	183b      	adds	r3, r7, r0
 8011664:	491b      	ldr	r1, [pc, #108]	; (80116d4 <USB_EPSetStall+0x94>)
 8011666:	400a      	ands	r2, r1
 8011668:	801a      	strh	r2, [r3, #0]
 801166a:	183b      	adds	r3, r7, r0
 801166c:	183a      	adds	r2, r7, r0
 801166e:	8812      	ldrh	r2, [r2, #0]
 8011670:	2110      	movs	r1, #16
 8011672:	404a      	eors	r2, r1
 8011674:	801a      	strh	r2, [r3, #0]
 8011676:	687a      	ldr	r2, [r7, #4]
 8011678:	683b      	ldr	r3, [r7, #0]
 801167a:	781b      	ldrb	r3, [r3, #0]
 801167c:	009b      	lsls	r3, r3, #2
 801167e:	18d3      	adds	r3, r2, r3
 8011680:	183a      	adds	r2, r7, r0
 8011682:	8812      	ldrh	r2, [r2, #0]
 8011684:	4914      	ldr	r1, [pc, #80]	; (80116d8 <USB_EPSetStall+0x98>)
 8011686:	430a      	orrs	r2, r1
 8011688:	b292      	uxth	r2, r2
 801168a:	801a      	strh	r2, [r3, #0]
 801168c:	e01d      	b.n	80116ca <USB_EPSetStall+0x8a>
  }
  else
  {
    PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_STALL);
 801168e:	687a      	ldr	r2, [r7, #4]
 8011690:	683b      	ldr	r3, [r7, #0]
 8011692:	781b      	ldrb	r3, [r3, #0]
 8011694:	009b      	lsls	r3, r3, #2
 8011696:	18d3      	adds	r3, r2, r3
 8011698:	881b      	ldrh	r3, [r3, #0]
 801169a:	b29a      	uxth	r2, r3
 801169c:	200e      	movs	r0, #14
 801169e:	183b      	adds	r3, r7, r0
 80116a0:	490e      	ldr	r1, [pc, #56]	; (80116dc <USB_EPSetStall+0x9c>)
 80116a2:	400a      	ands	r2, r1
 80116a4:	801a      	strh	r2, [r3, #0]
 80116a6:	183b      	adds	r3, r7, r0
 80116a8:	183a      	adds	r2, r7, r0
 80116aa:	8812      	ldrh	r2, [r2, #0]
 80116ac:	2180      	movs	r1, #128	; 0x80
 80116ae:	0149      	lsls	r1, r1, #5
 80116b0:	404a      	eors	r2, r1
 80116b2:	801a      	strh	r2, [r3, #0]
 80116b4:	687a      	ldr	r2, [r7, #4]
 80116b6:	683b      	ldr	r3, [r7, #0]
 80116b8:	781b      	ldrb	r3, [r3, #0]
 80116ba:	009b      	lsls	r3, r3, #2
 80116bc:	18d3      	adds	r3, r2, r3
 80116be:	183a      	adds	r2, r7, r0
 80116c0:	8812      	ldrh	r2, [r2, #0]
 80116c2:	4905      	ldr	r1, [pc, #20]	; (80116d8 <USB_EPSetStall+0x98>)
 80116c4:	430a      	orrs	r2, r1
 80116c6:	b292      	uxth	r2, r2
 80116c8:	801a      	strh	r2, [r3, #0]
  }

  return HAL_OK;
 80116ca:	2300      	movs	r3, #0
}
 80116cc:	0018      	movs	r0, r3
 80116ce:	46bd      	mov	sp, r7
 80116d0:	b004      	add	sp, #16
 80116d2:	bd80      	pop	{r7, pc}
 80116d4:	ffff8fbf 	.word	0xffff8fbf
 80116d8:	ffff8080 	.word	0xffff8080
 80116dc:	ffffbf8f 	.word	0xffffbf8f

080116e0 <USB_EPClearStall>:
  * @param  USBx Selected device
  * @param  ep pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EPClearStall(USB_TypeDef *USBx, USB_EPTypeDef *ep)
{
 80116e0:	b580      	push	{r7, lr}
 80116e2:	b086      	sub	sp, #24
 80116e4:	af00      	add	r7, sp, #0
 80116e6:	6078      	str	r0, [r7, #4]
 80116e8:	6039      	str	r1, [r7, #0]
  if (ep->doublebuffer == 0U)
 80116ea:	683b      	ldr	r3, [r7, #0]
 80116ec:	7b1b      	ldrb	r3, [r3, #12]
 80116ee:	2b00      	cmp	r3, #0
 80116f0:	d000      	beq.n	80116f4 <USB_EPClearStall+0x14>
 80116f2:	e095      	b.n	8011820 <USB_EPClearStall+0x140>
  {
    if (ep->is_in != 0U)
 80116f4:	683b      	ldr	r3, [r7, #0]
 80116f6:	785b      	ldrb	r3, [r3, #1]
 80116f8:	2b00      	cmp	r3, #0
 80116fa:	d046      	beq.n	801178a <USB_EPClearStall+0xaa>
    {
      PCD_CLEAR_TX_DTOG(USBx, ep->num);
 80116fc:	687a      	ldr	r2, [r7, #4]
 80116fe:	683b      	ldr	r3, [r7, #0]
 8011700:	781b      	ldrb	r3, [r3, #0]
 8011702:	009b      	lsls	r3, r3, #2
 8011704:	18d2      	adds	r2, r2, r3
 8011706:	2110      	movs	r1, #16
 8011708:	187b      	adds	r3, r7, r1
 801170a:	8812      	ldrh	r2, [r2, #0]
 801170c:	801a      	strh	r2, [r3, #0]
 801170e:	187b      	adds	r3, r7, r1
 8011710:	881b      	ldrh	r3, [r3, #0]
 8011712:	2240      	movs	r2, #64	; 0x40
 8011714:	4013      	ands	r3, r2
 8011716:	d016      	beq.n	8011746 <USB_EPClearStall+0x66>
 8011718:	687a      	ldr	r2, [r7, #4]
 801171a:	683b      	ldr	r3, [r7, #0]
 801171c:	781b      	ldrb	r3, [r3, #0]
 801171e:	009b      	lsls	r3, r3, #2
 8011720:	18d3      	adds	r3, r2, r3
 8011722:	881b      	ldrh	r3, [r3, #0]
 8011724:	b29a      	uxth	r2, r3
 8011726:	200e      	movs	r0, #14
 8011728:	183b      	adds	r3, r7, r0
 801172a:	4940      	ldr	r1, [pc, #256]	; (801182c <USB_EPClearStall+0x14c>)
 801172c:	400a      	ands	r2, r1
 801172e:	801a      	strh	r2, [r3, #0]
 8011730:	687a      	ldr	r2, [r7, #4]
 8011732:	683b      	ldr	r3, [r7, #0]
 8011734:	781b      	ldrb	r3, [r3, #0]
 8011736:	009b      	lsls	r3, r3, #2
 8011738:	18d3      	adds	r3, r2, r3
 801173a:	183a      	adds	r2, r7, r0
 801173c:	8812      	ldrh	r2, [r2, #0]
 801173e:	493c      	ldr	r1, [pc, #240]	; (8011830 <USB_EPClearStall+0x150>)
 8011740:	430a      	orrs	r2, r1
 8011742:	b292      	uxth	r2, r2
 8011744:	801a      	strh	r2, [r3, #0]

      if (ep->type != EP_TYPE_ISOC)
 8011746:	683b      	ldr	r3, [r7, #0]
 8011748:	78db      	ldrb	r3, [r3, #3]
 801174a:	2b01      	cmp	r3, #1
 801174c:	d068      	beq.n	8011820 <USB_EPClearStall+0x140>
      {
        /* Configure NAK status for the Endpoint */
        PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_NAK);
 801174e:	687a      	ldr	r2, [r7, #4]
 8011750:	683b      	ldr	r3, [r7, #0]
 8011752:	781b      	ldrb	r3, [r3, #0]
 8011754:	009b      	lsls	r3, r3, #2
 8011756:	18d3      	adds	r3, r2, r3
 8011758:	881b      	ldrh	r3, [r3, #0]
 801175a:	b29a      	uxth	r2, r3
 801175c:	200c      	movs	r0, #12
 801175e:	183b      	adds	r3, r7, r0
 8011760:	4934      	ldr	r1, [pc, #208]	; (8011834 <USB_EPClearStall+0x154>)
 8011762:	400a      	ands	r2, r1
 8011764:	801a      	strh	r2, [r3, #0]
 8011766:	183b      	adds	r3, r7, r0
 8011768:	183a      	adds	r2, r7, r0
 801176a:	8812      	ldrh	r2, [r2, #0]
 801176c:	2120      	movs	r1, #32
 801176e:	404a      	eors	r2, r1
 8011770:	801a      	strh	r2, [r3, #0]
 8011772:	687a      	ldr	r2, [r7, #4]
 8011774:	683b      	ldr	r3, [r7, #0]
 8011776:	781b      	ldrb	r3, [r3, #0]
 8011778:	009b      	lsls	r3, r3, #2
 801177a:	18d3      	adds	r3, r2, r3
 801177c:	183a      	adds	r2, r7, r0
 801177e:	8812      	ldrh	r2, [r2, #0]
 8011780:	492d      	ldr	r1, [pc, #180]	; (8011838 <USB_EPClearStall+0x158>)
 8011782:	430a      	orrs	r2, r1
 8011784:	b292      	uxth	r2, r2
 8011786:	801a      	strh	r2, [r3, #0]
 8011788:	e04a      	b.n	8011820 <USB_EPClearStall+0x140>
      }
    }
    else
    {
      PCD_CLEAR_RX_DTOG(USBx, ep->num);
 801178a:	687a      	ldr	r2, [r7, #4]
 801178c:	683b      	ldr	r3, [r7, #0]
 801178e:	781b      	ldrb	r3, [r3, #0]
 8011790:	009b      	lsls	r3, r3, #2
 8011792:	18d2      	adds	r2, r2, r3
 8011794:	2116      	movs	r1, #22
 8011796:	187b      	adds	r3, r7, r1
 8011798:	8812      	ldrh	r2, [r2, #0]
 801179a:	801a      	strh	r2, [r3, #0]
 801179c:	187b      	adds	r3, r7, r1
 801179e:	881a      	ldrh	r2, [r3, #0]
 80117a0:	2380      	movs	r3, #128	; 0x80
 80117a2:	01db      	lsls	r3, r3, #7
 80117a4:	4013      	ands	r3, r2
 80117a6:	d016      	beq.n	80117d6 <USB_EPClearStall+0xf6>
 80117a8:	687a      	ldr	r2, [r7, #4]
 80117aa:	683b      	ldr	r3, [r7, #0]
 80117ac:	781b      	ldrb	r3, [r3, #0]
 80117ae:	009b      	lsls	r3, r3, #2
 80117b0:	18d3      	adds	r3, r2, r3
 80117b2:	881b      	ldrh	r3, [r3, #0]
 80117b4:	b29a      	uxth	r2, r3
 80117b6:	2014      	movs	r0, #20
 80117b8:	183b      	adds	r3, r7, r0
 80117ba:	491c      	ldr	r1, [pc, #112]	; (801182c <USB_EPClearStall+0x14c>)
 80117bc:	400a      	ands	r2, r1
 80117be:	801a      	strh	r2, [r3, #0]
 80117c0:	687a      	ldr	r2, [r7, #4]
 80117c2:	683b      	ldr	r3, [r7, #0]
 80117c4:	781b      	ldrb	r3, [r3, #0]
 80117c6:	009b      	lsls	r3, r3, #2
 80117c8:	18d3      	adds	r3, r2, r3
 80117ca:	183a      	adds	r2, r7, r0
 80117cc:	8812      	ldrh	r2, [r2, #0]
 80117ce:	491b      	ldr	r1, [pc, #108]	; (801183c <USB_EPClearStall+0x15c>)
 80117d0:	430a      	orrs	r2, r1
 80117d2:	b292      	uxth	r2, r2
 80117d4:	801a      	strh	r2, [r3, #0]

      /* Configure VALID status for the Endpoint */
      PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_VALID);
 80117d6:	687a      	ldr	r2, [r7, #4]
 80117d8:	683b      	ldr	r3, [r7, #0]
 80117da:	781b      	ldrb	r3, [r3, #0]
 80117dc:	009b      	lsls	r3, r3, #2
 80117de:	18d3      	adds	r3, r2, r3
 80117e0:	881b      	ldrh	r3, [r3, #0]
 80117e2:	b29a      	uxth	r2, r3
 80117e4:	2012      	movs	r0, #18
 80117e6:	183b      	adds	r3, r7, r0
 80117e8:	4915      	ldr	r1, [pc, #84]	; (8011840 <USB_EPClearStall+0x160>)
 80117ea:	400a      	ands	r2, r1
 80117ec:	801a      	strh	r2, [r3, #0]
 80117ee:	183b      	adds	r3, r7, r0
 80117f0:	183a      	adds	r2, r7, r0
 80117f2:	8812      	ldrh	r2, [r2, #0]
 80117f4:	2180      	movs	r1, #128	; 0x80
 80117f6:	0149      	lsls	r1, r1, #5
 80117f8:	404a      	eors	r2, r1
 80117fa:	801a      	strh	r2, [r3, #0]
 80117fc:	183b      	adds	r3, r7, r0
 80117fe:	183a      	adds	r2, r7, r0
 8011800:	8812      	ldrh	r2, [r2, #0]
 8011802:	2180      	movs	r1, #128	; 0x80
 8011804:	0189      	lsls	r1, r1, #6
 8011806:	404a      	eors	r2, r1
 8011808:	801a      	strh	r2, [r3, #0]
 801180a:	687a      	ldr	r2, [r7, #4]
 801180c:	683b      	ldr	r3, [r7, #0]
 801180e:	781b      	ldrb	r3, [r3, #0]
 8011810:	009b      	lsls	r3, r3, #2
 8011812:	18d3      	adds	r3, r2, r3
 8011814:	183a      	adds	r2, r7, r0
 8011816:	8812      	ldrh	r2, [r2, #0]
 8011818:	4907      	ldr	r1, [pc, #28]	; (8011838 <USB_EPClearStall+0x158>)
 801181a:	430a      	orrs	r2, r1
 801181c:	b292      	uxth	r2, r2
 801181e:	801a      	strh	r2, [r3, #0]
    }
  }

  return HAL_OK;
 8011820:	2300      	movs	r3, #0
}
 8011822:	0018      	movs	r0, r3
 8011824:	46bd      	mov	sp, r7
 8011826:	b006      	add	sp, #24
 8011828:	bd80      	pop	{r7, pc}
 801182a:	46c0      	nop			; (mov r8, r8)
 801182c:	ffff8f8f 	.word	0xffff8f8f
 8011830:	ffff80c0 	.word	0xffff80c0
 8011834:	ffff8fbf 	.word	0xffff8fbf
 8011838:	ffff8080 	.word	0xffff8080
 801183c:	ffffc080 	.word	0xffffc080
 8011840:	ffffbf8f 	.word	0xffffbf8f

08011844 <USB_SetDevAddress>:
  * @param  address new device address to be assigned
  *          This parameter can be a value from 0 to 255
  * @retval HAL status
  */
HAL_StatusTypeDef  USB_SetDevAddress(USB_TypeDef *USBx, uint8_t address)
{
 8011844:	b580      	push	{r7, lr}
 8011846:	b082      	sub	sp, #8
 8011848:	af00      	add	r7, sp, #0
 801184a:	6078      	str	r0, [r7, #4]
 801184c:	000a      	movs	r2, r1
 801184e:	1cfb      	adds	r3, r7, #3
 8011850:	701a      	strb	r2, [r3, #0]
  if (address == 0U)
 8011852:	1cfb      	adds	r3, r7, #3
 8011854:	781b      	ldrb	r3, [r3, #0]
 8011856:	2b00      	cmp	r3, #0
 8011858:	d103      	bne.n	8011862 <USB_SetDevAddress+0x1e>
  {
    /* set device address and enable function */
    USBx->DADDR = (uint16_t)USB_DADDR_EF;
 801185a:	687b      	ldr	r3, [r7, #4]
 801185c:	224c      	movs	r2, #76	; 0x4c
 801185e:	2180      	movs	r1, #128	; 0x80
 8011860:	5299      	strh	r1, [r3, r2]
  }

  return HAL_OK;
 8011862:	2300      	movs	r3, #0
}
 8011864:	0018      	movs	r0, r3
 8011866:	46bd      	mov	sp, r7
 8011868:	b002      	add	sp, #8
 801186a:	bd80      	pop	{r7, pc}

0801186c <USB_DevConnect>:
  * @brief  USB_DevConnect Connect the USB device by enabling the pull-up/pull-down
  * @param  USBx Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef  USB_DevConnect(USB_TypeDef *USBx)
{
 801186c:	b580      	push	{r7, lr}
 801186e:	b082      	sub	sp, #8
 8011870:	af00      	add	r7, sp, #0
 8011872:	6078      	str	r0, [r7, #4]
  /* Enabling DP Pull-UP bit to Connect internal PU resistor on USB DP line */
  USBx->BCDR |= (uint16_t)USB_BCDR_DPPU;
 8011874:	687b      	ldr	r3, [r7, #4]
 8011876:	2258      	movs	r2, #88	; 0x58
 8011878:	5a9b      	ldrh	r3, [r3, r2]
 801187a:	b29b      	uxth	r3, r3
 801187c:	4a05      	ldr	r2, [pc, #20]	; (8011894 <USB_DevConnect+0x28>)
 801187e:	4313      	orrs	r3, r2
 8011880:	b299      	uxth	r1, r3
 8011882:	687b      	ldr	r3, [r7, #4]
 8011884:	2258      	movs	r2, #88	; 0x58
 8011886:	5299      	strh	r1, [r3, r2]

  return HAL_OK;
 8011888:	2300      	movs	r3, #0
}
 801188a:	0018      	movs	r0, r3
 801188c:	46bd      	mov	sp, r7
 801188e:	b002      	add	sp, #8
 8011890:	bd80      	pop	{r7, pc}
 8011892:	46c0      	nop			; (mov r8, r8)
 8011894:	ffff8000 	.word	0xffff8000

08011898 <USB_ReadInterrupts>:
  * @brief  USB_ReadInterrupts return the global USB interrupt status
  * @param  USBx Selected device
  * @retval HAL status
  */
uint32_t  USB_ReadInterrupts(USB_TypeDef *USBx)
{
 8011898:	b580      	push	{r7, lr}
 801189a:	b084      	sub	sp, #16
 801189c:	af00      	add	r7, sp, #0
 801189e:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg;

  tmpreg = USBx->ISTR;
 80118a0:	687b      	ldr	r3, [r7, #4]
 80118a2:	2244      	movs	r2, #68	; 0x44
 80118a4:	5a9b      	ldrh	r3, [r3, r2]
 80118a6:	b29b      	uxth	r3, r3
 80118a8:	60fb      	str	r3, [r7, #12]
  return tmpreg;
 80118aa:	68fb      	ldr	r3, [r7, #12]
}
 80118ac:	0018      	movs	r0, r3
 80118ae:	46bd      	mov	sp, r7
 80118b0:	b004      	add	sp, #16
 80118b2:	bd80      	pop	{r7, pc}

080118b4 <USB_WritePMA>:
  * @param   wPMABufAddr address into PMA.
  * @param   wNBytes no. of bytes to be copied.
  * @retval None
  */
void USB_WritePMA(USB_TypeDef *USBx, uint8_t *pbUsrBuf, uint16_t wPMABufAddr, uint16_t wNBytes)
{
 80118b4:	b580      	push	{r7, lr}
 80118b6:	b08c      	sub	sp, #48	; 0x30
 80118b8:	af00      	add	r7, sp, #0
 80118ba:	60f8      	str	r0, [r7, #12]
 80118bc:	60b9      	str	r1, [r7, #8]
 80118be:	0019      	movs	r1, r3
 80118c0:	1dbb      	adds	r3, r7, #6
 80118c2:	801a      	strh	r2, [r3, #0]
 80118c4:	1d3b      	adds	r3, r7, #4
 80118c6:	1c0a      	adds	r2, r1, #0
 80118c8:	801a      	strh	r2, [r3, #0]
  uint32_t n = ((uint32_t)wNBytes + 1U) >> 1;
 80118ca:	1d3b      	adds	r3, r7, #4
 80118cc:	881b      	ldrh	r3, [r3, #0]
 80118ce:	3301      	adds	r3, #1
 80118d0:	085b      	lsrs	r3, r3, #1
 80118d2:	623b      	str	r3, [r7, #32]
  uint32_t BaseAddr = (uint32_t)USBx;
 80118d4:	68fb      	ldr	r3, [r7, #12]
 80118d6:	61fb      	str	r3, [r7, #28]
  uint32_t i, temp1, temp2;
  __IO uint16_t *pdwVal;
  uint8_t *pBuf = pbUsrBuf;
 80118d8:	68bb      	ldr	r3, [r7, #8]
 80118da:	627b      	str	r3, [r7, #36]	; 0x24

  pdwVal = (__IO uint16_t *)(BaseAddr + 0x400U + ((uint32_t)wPMABufAddr * PMA_ACCESS));
 80118dc:	1dbb      	adds	r3, r7, #6
 80118de:	881a      	ldrh	r2, [r3, #0]
 80118e0:	69fb      	ldr	r3, [r7, #28]
 80118e2:	18d3      	adds	r3, r2, r3
 80118e4:	2280      	movs	r2, #128	; 0x80
 80118e6:	00d2      	lsls	r2, r2, #3
 80118e8:	4694      	mov	ip, r2
 80118ea:	4463      	add	r3, ip
 80118ec:	62bb      	str	r3, [r7, #40]	; 0x28

  for (i = n; i != 0U; i--)
 80118ee:	6a3b      	ldr	r3, [r7, #32]
 80118f0:	62fb      	str	r3, [r7, #44]	; 0x2c
 80118f2:	e01b      	b.n	801192c <USB_WritePMA+0x78>
  {
    temp1 = *pBuf;
 80118f4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80118f6:	781b      	ldrb	r3, [r3, #0]
 80118f8:	61bb      	str	r3, [r7, #24]
    pBuf++;
 80118fa:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80118fc:	3301      	adds	r3, #1
 80118fe:	627b      	str	r3, [r7, #36]	; 0x24
    temp2 = temp1 | ((uint16_t)((uint16_t) *pBuf << 8));
 8011900:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011902:	781b      	ldrb	r3, [r3, #0]
 8011904:	b29b      	uxth	r3, r3
 8011906:	021b      	lsls	r3, r3, #8
 8011908:	b29b      	uxth	r3, r3
 801190a:	001a      	movs	r2, r3
 801190c:	69bb      	ldr	r3, [r7, #24]
 801190e:	4313      	orrs	r3, r2
 8011910:	617b      	str	r3, [r7, #20]
    *pdwVal = (uint16_t)temp2;
 8011912:	697b      	ldr	r3, [r7, #20]
 8011914:	b29a      	uxth	r2, r3
 8011916:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8011918:	801a      	strh	r2, [r3, #0]
    pdwVal++;
 801191a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801191c:	3302      	adds	r3, #2
 801191e:	62bb      	str	r3, [r7, #40]	; 0x28

#if PMA_ACCESS > 1U
    pdwVal++;
#endif

    pBuf++;
 8011920:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011922:	3301      	adds	r3, #1
 8011924:	627b      	str	r3, [r7, #36]	; 0x24
  for (i = n; i != 0U; i--)
 8011926:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8011928:	3b01      	subs	r3, #1
 801192a:	62fb      	str	r3, [r7, #44]	; 0x2c
 801192c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801192e:	2b00      	cmp	r3, #0
 8011930:	d1e0      	bne.n	80118f4 <USB_WritePMA+0x40>
  }
}
 8011932:	46c0      	nop			; (mov r8, r8)
 8011934:	46c0      	nop			; (mov r8, r8)
 8011936:	46bd      	mov	sp, r7
 8011938:	b00c      	add	sp, #48	; 0x30
 801193a:	bd80      	pop	{r7, pc}

0801193c <USB_ReadPMA>:
  * @param   wPMABufAddr address into PMA.
  * @param   wNBytes no. of bytes to be copied.
  * @retval None
  */
void USB_ReadPMA(USB_TypeDef *USBx, uint8_t *pbUsrBuf, uint16_t wPMABufAddr, uint16_t wNBytes)
{
 801193c:	b580      	push	{r7, lr}
 801193e:	b08a      	sub	sp, #40	; 0x28
 8011940:	af00      	add	r7, sp, #0
 8011942:	60f8      	str	r0, [r7, #12]
 8011944:	60b9      	str	r1, [r7, #8]
 8011946:	0019      	movs	r1, r3
 8011948:	1dbb      	adds	r3, r7, #6
 801194a:	801a      	strh	r2, [r3, #0]
 801194c:	1d3b      	adds	r3, r7, #4
 801194e:	1c0a      	adds	r2, r1, #0
 8011950:	801a      	strh	r2, [r3, #0]
  uint32_t n = (uint32_t)wNBytes >> 1;
 8011952:	1d3b      	adds	r3, r7, #4
 8011954:	881b      	ldrh	r3, [r3, #0]
 8011956:	085b      	lsrs	r3, r3, #1
 8011958:	b29b      	uxth	r3, r3
 801195a:	61bb      	str	r3, [r7, #24]
  uint32_t BaseAddr = (uint32_t)USBx;
 801195c:	68fb      	ldr	r3, [r7, #12]
 801195e:	617b      	str	r3, [r7, #20]
  uint32_t i, temp;
  __IO uint16_t *pdwVal;
  uint8_t *pBuf = pbUsrBuf;
 8011960:	68bb      	ldr	r3, [r7, #8]
 8011962:	61fb      	str	r3, [r7, #28]

  pdwVal = (__IO uint16_t *)(BaseAddr + 0x400U + ((uint32_t)wPMABufAddr * PMA_ACCESS));
 8011964:	1dbb      	adds	r3, r7, #6
 8011966:	881a      	ldrh	r2, [r3, #0]
 8011968:	697b      	ldr	r3, [r7, #20]
 801196a:	18d3      	adds	r3, r2, r3
 801196c:	2280      	movs	r2, #128	; 0x80
 801196e:	00d2      	lsls	r2, r2, #3
 8011970:	4694      	mov	ip, r2
 8011972:	4463      	add	r3, ip
 8011974:	623b      	str	r3, [r7, #32]

  for (i = n; i != 0U; i--)
 8011976:	69bb      	ldr	r3, [r7, #24]
 8011978:	627b      	str	r3, [r7, #36]	; 0x24
 801197a:	e018      	b.n	80119ae <USB_ReadPMA+0x72>
  {
    temp = *(__IO uint16_t *)pdwVal;
 801197c:	6a3b      	ldr	r3, [r7, #32]
 801197e:	881b      	ldrh	r3, [r3, #0]
 8011980:	b29b      	uxth	r3, r3
 8011982:	613b      	str	r3, [r7, #16]
    pdwVal++;
 8011984:	6a3b      	ldr	r3, [r7, #32]
 8011986:	3302      	adds	r3, #2
 8011988:	623b      	str	r3, [r7, #32]
    *pBuf = (uint8_t)((temp >> 0) & 0xFFU);
 801198a:	693b      	ldr	r3, [r7, #16]
 801198c:	b2da      	uxtb	r2, r3
 801198e:	69fb      	ldr	r3, [r7, #28]
 8011990:	701a      	strb	r2, [r3, #0]
    pBuf++;
 8011992:	69fb      	ldr	r3, [r7, #28]
 8011994:	3301      	adds	r3, #1
 8011996:	61fb      	str	r3, [r7, #28]
    *pBuf = (uint8_t)((temp >> 8) & 0xFFU);
 8011998:	693b      	ldr	r3, [r7, #16]
 801199a:	0a1b      	lsrs	r3, r3, #8
 801199c:	b2da      	uxtb	r2, r3
 801199e:	69fb      	ldr	r3, [r7, #28]
 80119a0:	701a      	strb	r2, [r3, #0]
    pBuf++;
 80119a2:	69fb      	ldr	r3, [r7, #28]
 80119a4:	3301      	adds	r3, #1
 80119a6:	61fb      	str	r3, [r7, #28]
  for (i = n; i != 0U; i--)
 80119a8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80119aa:	3b01      	subs	r3, #1
 80119ac:	627b      	str	r3, [r7, #36]	; 0x24
 80119ae:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80119b0:	2b00      	cmp	r3, #0
 80119b2:	d1e3      	bne.n	801197c <USB_ReadPMA+0x40>
#if PMA_ACCESS > 1U
    pdwVal++;
#endif
  }

  if ((wNBytes % 2U) != 0U)
 80119b4:	1d3b      	adds	r3, r7, #4
 80119b6:	881b      	ldrh	r3, [r3, #0]
 80119b8:	2201      	movs	r2, #1
 80119ba:	4013      	ands	r3, r2
 80119bc:	b29b      	uxth	r3, r3
 80119be:	2b00      	cmp	r3, #0
 80119c0:	d007      	beq.n	80119d2 <USB_ReadPMA+0x96>
  {
    temp = *pdwVal;
 80119c2:	6a3b      	ldr	r3, [r7, #32]
 80119c4:	881b      	ldrh	r3, [r3, #0]
 80119c6:	b29b      	uxth	r3, r3
 80119c8:	613b      	str	r3, [r7, #16]
    *pBuf = (uint8_t)((temp >> 0) & 0xFFU);
 80119ca:	693b      	ldr	r3, [r7, #16]
 80119cc:	b2da      	uxtb	r2, r3
 80119ce:	69fb      	ldr	r3, [r7, #28]
 80119d0:	701a      	strb	r2, [r3, #0]
  }
}
 80119d2:	46c0      	nop			; (mov r8, r8)
 80119d4:	46bd      	mov	sp, r7
 80119d6:	b00a      	add	sp, #40	; 0x28
 80119d8:	bd80      	pop	{r7, pc}

080119da <USBD_CDC_Init>:
  * @param  pdev: device instance
  * @param  cfgidx: Configuration index
  * @retval status
  */
static uint8_t  USBD_CDC_Init(USBD_HandleTypeDef *pdev, uint8_t cfgidx)
{
 80119da:	b580      	push	{r7, lr}
 80119dc:	b084      	sub	sp, #16
 80119de:	af00      	add	r7, sp, #0
 80119e0:	6078      	str	r0, [r7, #4]
 80119e2:	000a      	movs	r2, r1
 80119e4:	1cfb      	adds	r3, r7, #3
 80119e6:	701a      	strb	r2, [r3, #0]
  uint8_t ret = 0U;
 80119e8:	230f      	movs	r3, #15
 80119ea:	18fb      	adds	r3, r7, r3
 80119ec:	2200      	movs	r2, #0
 80119ee:	701a      	strb	r2, [r3, #0]
  USBD_CDC_HandleTypeDef   *hcdc;

  if (pdev->dev_speed == USBD_SPEED_HIGH)
 80119f0:	687b      	ldr	r3, [r7, #4]
 80119f2:	7c1b      	ldrb	r3, [r3, #16]
 80119f4:	2b00      	cmp	r3, #0
 80119f6:	d116      	bne.n	8011a26 <USBD_CDC_Init+0x4c>
  {
    /* Open EP IN */
    USBD_LL_OpenEP(pdev, CDC_IN_EP, USBD_EP_TYPE_BULK,
 80119f8:	2380      	movs	r3, #128	; 0x80
 80119fa:	009b      	lsls	r3, r3, #2
 80119fc:	6878      	ldr	r0, [r7, #4]
 80119fe:	2202      	movs	r2, #2
 8011a00:	2181      	movs	r1, #129	; 0x81
 8011a02:	f003 f8e8 	bl	8014bd6 <USBD_LL_OpenEP>
                   CDC_DATA_HS_IN_PACKET_SIZE);

    pdev->ep_in[CDC_IN_EP & 0xFU].is_used = 1U;
 8011a06:	687b      	ldr	r3, [r7, #4]
 8011a08:	2201      	movs	r2, #1
 8011a0a:	62da      	str	r2, [r3, #44]	; 0x2c

    /* Open EP OUT */
    USBD_LL_OpenEP(pdev, CDC_OUT_EP, USBD_EP_TYPE_BULK,
 8011a0c:	2380      	movs	r3, #128	; 0x80
 8011a0e:	009b      	lsls	r3, r3, #2
 8011a10:	6878      	ldr	r0, [r7, #4]
 8011a12:	2202      	movs	r2, #2
 8011a14:	2101      	movs	r1, #1
 8011a16:	f003 f8de 	bl	8014bd6 <USBD_LL_OpenEP>
                   CDC_DATA_HS_OUT_PACKET_SIZE);

    pdev->ep_out[CDC_OUT_EP & 0xFU].is_used = 1U;
 8011a1a:	687a      	ldr	r2, [r7, #4]
 8011a1c:	23b6      	movs	r3, #182	; 0xb6
 8011a1e:	005b      	lsls	r3, r3, #1
 8011a20:	2101      	movs	r1, #1
 8011a22:	50d1      	str	r1, [r2, r3]
 8011a24:	e013      	b.n	8011a4e <USBD_CDC_Init+0x74>

  }
  else
  {
    /* Open EP IN */
    USBD_LL_OpenEP(pdev, CDC_IN_EP, USBD_EP_TYPE_BULK,
 8011a26:	6878      	ldr	r0, [r7, #4]
 8011a28:	2340      	movs	r3, #64	; 0x40
 8011a2a:	2202      	movs	r2, #2
 8011a2c:	2181      	movs	r1, #129	; 0x81
 8011a2e:	f003 f8d2 	bl	8014bd6 <USBD_LL_OpenEP>
                   CDC_DATA_FS_IN_PACKET_SIZE);

    pdev->ep_in[CDC_IN_EP & 0xFU].is_used = 1U;
 8011a32:	687b      	ldr	r3, [r7, #4]
 8011a34:	2201      	movs	r2, #1
 8011a36:	62da      	str	r2, [r3, #44]	; 0x2c

    /* Open EP OUT */
    USBD_LL_OpenEP(pdev, CDC_OUT_EP, USBD_EP_TYPE_BULK,
 8011a38:	6878      	ldr	r0, [r7, #4]
 8011a3a:	2340      	movs	r3, #64	; 0x40
 8011a3c:	2202      	movs	r2, #2
 8011a3e:	2101      	movs	r1, #1
 8011a40:	f003 f8c9 	bl	8014bd6 <USBD_LL_OpenEP>
                   CDC_DATA_FS_OUT_PACKET_SIZE);

    pdev->ep_out[CDC_OUT_EP & 0xFU].is_used = 1U;
 8011a44:	687a      	ldr	r2, [r7, #4]
 8011a46:	23b6      	movs	r3, #182	; 0xb6
 8011a48:	005b      	lsls	r3, r3, #1
 8011a4a:	2101      	movs	r1, #1
 8011a4c:	50d1      	str	r1, [r2, r3]
  }
  /* Open Command IN EP */
  USBD_LL_OpenEP(pdev, CDC_CMD_EP, USBD_EP_TYPE_INTR, CDC_CMD_PACKET_SIZE);
 8011a4e:	6878      	ldr	r0, [r7, #4]
 8011a50:	2308      	movs	r3, #8
 8011a52:	2203      	movs	r2, #3
 8011a54:	2182      	movs	r1, #130	; 0x82
 8011a56:	f003 f8be 	bl	8014bd6 <USBD_LL_OpenEP>
  pdev->ep_in[CDC_CMD_EP & 0xFU].is_used = 1U;
 8011a5a:	687b      	ldr	r3, [r7, #4]
 8011a5c:	2201      	movs	r2, #1
 8011a5e:	641a      	str	r2, [r3, #64]	; 0x40

  pdev->pClassData = USBD_malloc(sizeof(USBD_CDC_HandleTypeDef));
 8011a60:	2387      	movs	r3, #135	; 0x87
 8011a62:	009b      	lsls	r3, r3, #2
 8011a64:	0018      	movs	r0, r3
 8011a66:	f003 fa4f 	bl	8014f08 <USBD_static_malloc>
 8011a6a:	0001      	movs	r1, r0
 8011a6c:	687a      	ldr	r2, [r7, #4]
 8011a6e:	23ae      	movs	r3, #174	; 0xae
 8011a70:	009b      	lsls	r3, r3, #2
 8011a72:	50d1      	str	r1, [r2, r3]

  if (pdev->pClassData == NULL)
 8011a74:	687a      	ldr	r2, [r7, #4]
 8011a76:	23ae      	movs	r3, #174	; 0xae
 8011a78:	009b      	lsls	r3, r3, #2
 8011a7a:	58d3      	ldr	r3, [r2, r3]
 8011a7c:	2b00      	cmp	r3, #0
 8011a7e:	d104      	bne.n	8011a8a <USBD_CDC_Init+0xb0>
  {
    ret = 1U;
 8011a80:	230f      	movs	r3, #15
 8011a82:	18fb      	adds	r3, r7, r3
 8011a84:	2201      	movs	r2, #1
 8011a86:	701a      	strb	r2, [r3, #0]
 8011a88:	e02c      	b.n	8011ae4 <USBD_CDC_Init+0x10a>
  }
  else
  {
    hcdc = (USBD_CDC_HandleTypeDef *) pdev->pClassData;
 8011a8a:	687a      	ldr	r2, [r7, #4]
 8011a8c:	23ae      	movs	r3, #174	; 0xae
 8011a8e:	009b      	lsls	r3, r3, #2
 8011a90:	58d3      	ldr	r3, [r2, r3]
 8011a92:	60bb      	str	r3, [r7, #8]

    /* Init  physical Interface components */
    ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->Init();
 8011a94:	687a      	ldr	r2, [r7, #4]
 8011a96:	23af      	movs	r3, #175	; 0xaf
 8011a98:	009b      	lsls	r3, r3, #2
 8011a9a:	58d3      	ldr	r3, [r2, r3]
 8011a9c:	681b      	ldr	r3, [r3, #0]
 8011a9e:	4798      	blx	r3

    /* Init Xfer states */
    hcdc->TxState = 0U;
 8011aa0:	68ba      	ldr	r2, [r7, #8]
 8011aa2:	2385      	movs	r3, #133	; 0x85
 8011aa4:	009b      	lsls	r3, r3, #2
 8011aa6:	2100      	movs	r1, #0
 8011aa8:	50d1      	str	r1, [r2, r3]
    hcdc->RxState = 0U;
 8011aaa:	68ba      	ldr	r2, [r7, #8]
 8011aac:	2386      	movs	r3, #134	; 0x86
 8011aae:	009b      	lsls	r3, r3, #2
 8011ab0:	2100      	movs	r1, #0
 8011ab2:	50d1      	str	r1, [r2, r3]

    if (pdev->dev_speed == USBD_SPEED_HIGH)
 8011ab4:	687b      	ldr	r3, [r7, #4]
 8011ab6:	7c1b      	ldrb	r3, [r3, #16]
 8011ab8:	2b00      	cmp	r3, #0
 8011aba:	d10a      	bne.n	8011ad2 <USBD_CDC_Init+0xf8>
    {
      /* Prepare Out endpoint to receive next packet */
      USBD_LL_PrepareReceive(pdev, CDC_OUT_EP, hcdc->RxBuffer,
 8011abc:	68ba      	ldr	r2, [r7, #8]
 8011abe:	2381      	movs	r3, #129	; 0x81
 8011ac0:	009b      	lsls	r3, r3, #2
 8011ac2:	58d2      	ldr	r2, [r2, r3]
 8011ac4:	2380      	movs	r3, #128	; 0x80
 8011ac6:	009b      	lsls	r3, r3, #2
 8011ac8:	6878      	ldr	r0, [r7, #4]
 8011aca:	2101      	movs	r1, #1
 8011acc:	f003 f9ce 	bl	8014e6c <USBD_LL_PrepareReceive>
 8011ad0:	e008      	b.n	8011ae4 <USBD_CDC_Init+0x10a>
                             CDC_DATA_HS_OUT_PACKET_SIZE);
    }
    else
    {
      /* Prepare Out endpoint to receive next packet */
      USBD_LL_PrepareReceive(pdev, CDC_OUT_EP, hcdc->RxBuffer,
 8011ad2:	68ba      	ldr	r2, [r7, #8]
 8011ad4:	2381      	movs	r3, #129	; 0x81
 8011ad6:	009b      	lsls	r3, r3, #2
 8011ad8:	58d2      	ldr	r2, [r2, r3]
 8011ada:	6878      	ldr	r0, [r7, #4]
 8011adc:	2340      	movs	r3, #64	; 0x40
 8011ade:	2101      	movs	r1, #1
 8011ae0:	f003 f9c4 	bl	8014e6c <USBD_LL_PrepareReceive>
                             CDC_DATA_FS_OUT_PACKET_SIZE);
    }
  }
  return ret;
 8011ae4:	230f      	movs	r3, #15
 8011ae6:	18fb      	adds	r3, r7, r3
 8011ae8:	781b      	ldrb	r3, [r3, #0]
}
 8011aea:	0018      	movs	r0, r3
 8011aec:	46bd      	mov	sp, r7
 8011aee:	b004      	add	sp, #16
 8011af0:	bd80      	pop	{r7, pc}

08011af2 <USBD_CDC_DeInit>:
  * @param  pdev: device instance
  * @param  cfgidx: Configuration index
  * @retval status
  */
static uint8_t  USBD_CDC_DeInit(USBD_HandleTypeDef *pdev, uint8_t cfgidx)
{
 8011af2:	b580      	push	{r7, lr}
 8011af4:	b084      	sub	sp, #16
 8011af6:	af00      	add	r7, sp, #0
 8011af8:	6078      	str	r0, [r7, #4]
 8011afa:	000a      	movs	r2, r1
 8011afc:	1cfb      	adds	r3, r7, #3
 8011afe:	701a      	strb	r2, [r3, #0]
  uint8_t ret = 0U;
 8011b00:	230f      	movs	r3, #15
 8011b02:	18fb      	adds	r3, r7, r3
 8011b04:	2200      	movs	r2, #0
 8011b06:	701a      	strb	r2, [r3, #0]

  /* Close EP IN */
  USBD_LL_CloseEP(pdev, CDC_IN_EP);
 8011b08:	687b      	ldr	r3, [r7, #4]
 8011b0a:	2181      	movs	r1, #129	; 0x81
 8011b0c:	0018      	movs	r0, r3
 8011b0e:	f003 f899 	bl	8014c44 <USBD_LL_CloseEP>
  pdev->ep_in[CDC_IN_EP & 0xFU].is_used = 0U;
 8011b12:	687b      	ldr	r3, [r7, #4]
 8011b14:	2200      	movs	r2, #0
 8011b16:	62da      	str	r2, [r3, #44]	; 0x2c

  /* Close EP OUT */
  USBD_LL_CloseEP(pdev, CDC_OUT_EP);
 8011b18:	687b      	ldr	r3, [r7, #4]
 8011b1a:	2101      	movs	r1, #1
 8011b1c:	0018      	movs	r0, r3
 8011b1e:	f003 f891 	bl	8014c44 <USBD_LL_CloseEP>
  pdev->ep_out[CDC_OUT_EP & 0xFU].is_used = 0U;
 8011b22:	687a      	ldr	r2, [r7, #4]
 8011b24:	23b6      	movs	r3, #182	; 0xb6
 8011b26:	005b      	lsls	r3, r3, #1
 8011b28:	2100      	movs	r1, #0
 8011b2a:	50d1      	str	r1, [r2, r3]

  /* Close Command IN EP */
  USBD_LL_CloseEP(pdev, CDC_CMD_EP);
 8011b2c:	687b      	ldr	r3, [r7, #4]
 8011b2e:	2182      	movs	r1, #130	; 0x82
 8011b30:	0018      	movs	r0, r3
 8011b32:	f003 f887 	bl	8014c44 <USBD_LL_CloseEP>
  pdev->ep_in[CDC_CMD_EP & 0xFU].is_used = 0U;
 8011b36:	687b      	ldr	r3, [r7, #4]
 8011b38:	2200      	movs	r2, #0
 8011b3a:	641a      	str	r2, [r3, #64]	; 0x40

  /* DeInit  physical Interface components */
  if (pdev->pClassData != NULL)
 8011b3c:	687a      	ldr	r2, [r7, #4]
 8011b3e:	23ae      	movs	r3, #174	; 0xae
 8011b40:	009b      	lsls	r3, r3, #2
 8011b42:	58d3      	ldr	r3, [r2, r3]
 8011b44:	2b00      	cmp	r3, #0
 8011b46:	d011      	beq.n	8011b6c <USBD_CDC_DeInit+0x7a>
  {
    ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->DeInit();
 8011b48:	687a      	ldr	r2, [r7, #4]
 8011b4a:	23af      	movs	r3, #175	; 0xaf
 8011b4c:	009b      	lsls	r3, r3, #2
 8011b4e:	58d3      	ldr	r3, [r2, r3]
 8011b50:	685b      	ldr	r3, [r3, #4]
 8011b52:	4798      	blx	r3
    USBD_free(pdev->pClassData);
 8011b54:	687a      	ldr	r2, [r7, #4]
 8011b56:	23ae      	movs	r3, #174	; 0xae
 8011b58:	009b      	lsls	r3, r3, #2
 8011b5a:	58d3      	ldr	r3, [r2, r3]
 8011b5c:	0018      	movs	r0, r3
 8011b5e:	f003 f9df 	bl	8014f20 <USBD_static_free>
    pdev->pClassData = NULL;
 8011b62:	687a      	ldr	r2, [r7, #4]
 8011b64:	23ae      	movs	r3, #174	; 0xae
 8011b66:	009b      	lsls	r3, r3, #2
 8011b68:	2100      	movs	r1, #0
 8011b6a:	50d1      	str	r1, [r2, r3]
  }

  return ret;
 8011b6c:	230f      	movs	r3, #15
 8011b6e:	18fb      	adds	r3, r7, r3
 8011b70:	781b      	ldrb	r3, [r3, #0]
}
 8011b72:	0018      	movs	r0, r3
 8011b74:	46bd      	mov	sp, r7
 8011b76:	b004      	add	sp, #16
 8011b78:	bd80      	pop	{r7, pc}
	...

08011b7c <USBD_CDC_Setup>:
  * @param  req: usb requests
  * @retval status
  */
static uint8_t  USBD_CDC_Setup(USBD_HandleTypeDef *pdev,
                               USBD_SetupReqTypedef *req)
{
 8011b7c:	b580      	push	{r7, lr}
 8011b7e:	b086      	sub	sp, #24
 8011b80:	af00      	add	r7, sp, #0
 8011b82:	6078      	str	r0, [r7, #4]
 8011b84:	6039      	str	r1, [r7, #0]
  USBD_CDC_HandleTypeDef   *hcdc = (USBD_CDC_HandleTypeDef *) pdev->pClassData;
 8011b86:	687a      	ldr	r2, [r7, #4]
 8011b88:	23ae      	movs	r3, #174	; 0xae
 8011b8a:	009b      	lsls	r3, r3, #2
 8011b8c:	58d3      	ldr	r3, [r2, r3]
 8011b8e:	613b      	str	r3, [r7, #16]
  uint8_t ifalt = 0U;
 8011b90:	230f      	movs	r3, #15
 8011b92:	18fb      	adds	r3, r7, r3
 8011b94:	2200      	movs	r2, #0
 8011b96:	701a      	strb	r2, [r3, #0]
  uint16_t status_info = 0U;
 8011b98:	230c      	movs	r3, #12
 8011b9a:	18fb      	adds	r3, r7, r3
 8011b9c:	2200      	movs	r2, #0
 8011b9e:	801a      	strh	r2, [r3, #0]
  uint8_t ret = USBD_OK;
 8011ba0:	2317      	movs	r3, #23
 8011ba2:	18fb      	adds	r3, r7, r3
 8011ba4:	2200      	movs	r2, #0
 8011ba6:	701a      	strb	r2, [r3, #0]

  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 8011ba8:	683b      	ldr	r3, [r7, #0]
 8011baa:	781b      	ldrb	r3, [r3, #0]
 8011bac:	001a      	movs	r2, r3
 8011bae:	2360      	movs	r3, #96	; 0x60
 8011bb0:	4013      	ands	r3, r2
 8011bb2:	d03d      	beq.n	8011c30 <USBD_CDC_Setup+0xb4>
 8011bb4:	2b20      	cmp	r3, #32
 8011bb6:	d000      	beq.n	8011bba <USBD_CDC_Setup+0x3e>
 8011bb8:	e094      	b.n	8011ce4 <USBD_CDC_Setup+0x168>
  {
    case USB_REQ_TYPE_CLASS :
      if (req->wLength)
 8011bba:	683b      	ldr	r3, [r7, #0]
 8011bbc:	88db      	ldrh	r3, [r3, #6]
 8011bbe:	2b00      	cmp	r3, #0
 8011bc0:	d02b      	beq.n	8011c1a <USBD_CDC_Setup+0x9e>
      {
        if (req->bmRequest & 0x80U)
 8011bc2:	683b      	ldr	r3, [r7, #0]
 8011bc4:	781b      	ldrb	r3, [r3, #0]
 8011bc6:	b25b      	sxtb	r3, r3
 8011bc8:	2b00      	cmp	r3, #0
 8011bca:	da12      	bge.n	8011bf2 <USBD_CDC_Setup+0x76>
        {
          ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->Control(req->bRequest,
 8011bcc:	687a      	ldr	r2, [r7, #4]
 8011bce:	23af      	movs	r3, #175	; 0xaf
 8011bd0:	009b      	lsls	r3, r3, #2
 8011bd2:	58d3      	ldr	r3, [r2, r3]
 8011bd4:	689b      	ldr	r3, [r3, #8]
 8011bd6:	683a      	ldr	r2, [r7, #0]
 8011bd8:	7850      	ldrb	r0, [r2, #1]
                                                            (uint8_t *)(void *)hcdc->data,
 8011bda:	6939      	ldr	r1, [r7, #16]
          ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->Control(req->bRequest,
 8011bdc:	683a      	ldr	r2, [r7, #0]
 8011bde:	88d2      	ldrh	r2, [r2, #6]
 8011be0:	4798      	blx	r3
                                                            req->wLength);

          USBD_CtlSendData(pdev, (uint8_t *)(void *)hcdc->data, req->wLength);
 8011be2:	6939      	ldr	r1, [r7, #16]
 8011be4:	683b      	ldr	r3, [r7, #0]
 8011be6:	88da      	ldrh	r2, [r3, #6]
 8011be8:	687b      	ldr	r3, [r7, #4]
 8011bea:	0018      	movs	r0, r3
 8011bec:	f001 fb7c 	bl	80132e8 <USBD_CtlSendData>
      else
      {
        ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->Control(req->bRequest,
                                                          (uint8_t *)(void *)req, 0U);
      }
      break;
 8011bf0:	e083      	b.n	8011cfa <USBD_CDC_Setup+0x17e>
          hcdc->CmdOpCode = req->bRequest;
 8011bf2:	683b      	ldr	r3, [r7, #0]
 8011bf4:	7859      	ldrb	r1, [r3, #1]
 8011bf6:	693a      	ldr	r2, [r7, #16]
 8011bf8:	2380      	movs	r3, #128	; 0x80
 8011bfa:	009b      	lsls	r3, r3, #2
 8011bfc:	54d1      	strb	r1, [r2, r3]
          hcdc->CmdLength = (uint8_t)req->wLength;
 8011bfe:	683b      	ldr	r3, [r7, #0]
 8011c00:	88db      	ldrh	r3, [r3, #6]
 8011c02:	b2d9      	uxtb	r1, r3
 8011c04:	693b      	ldr	r3, [r7, #16]
 8011c06:	4a40      	ldr	r2, [pc, #256]	; (8011d08 <USBD_CDC_Setup+0x18c>)
 8011c08:	5499      	strb	r1, [r3, r2]
          USBD_CtlPrepareRx(pdev, (uint8_t *)(void *)hcdc->data, req->wLength);
 8011c0a:	6939      	ldr	r1, [r7, #16]
 8011c0c:	683b      	ldr	r3, [r7, #0]
 8011c0e:	88da      	ldrh	r2, [r3, #6]
 8011c10:	687b      	ldr	r3, [r7, #4]
 8011c12:	0018      	movs	r0, r3
 8011c14:	f001 fb9b 	bl	801334e <USBD_CtlPrepareRx>
      break;
 8011c18:	e06f      	b.n	8011cfa <USBD_CDC_Setup+0x17e>
        ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->Control(req->bRequest,
 8011c1a:	687a      	ldr	r2, [r7, #4]
 8011c1c:	23af      	movs	r3, #175	; 0xaf
 8011c1e:	009b      	lsls	r3, r3, #2
 8011c20:	58d3      	ldr	r3, [r2, r3]
 8011c22:	689b      	ldr	r3, [r3, #8]
 8011c24:	683a      	ldr	r2, [r7, #0]
 8011c26:	7850      	ldrb	r0, [r2, #1]
 8011c28:	6839      	ldr	r1, [r7, #0]
 8011c2a:	2200      	movs	r2, #0
 8011c2c:	4798      	blx	r3
      break;
 8011c2e:	e064      	b.n	8011cfa <USBD_CDC_Setup+0x17e>

    case USB_REQ_TYPE_STANDARD:
      switch (req->bRequest)
 8011c30:	683b      	ldr	r3, [r7, #0]
 8011c32:	785b      	ldrb	r3, [r3, #1]
 8011c34:	2b0b      	cmp	r3, #11
 8011c36:	d037      	beq.n	8011ca8 <USBD_CDC_Setup+0x12c>
 8011c38:	dc47      	bgt.n	8011cca <USBD_CDC_Setup+0x14e>
 8011c3a:	2b00      	cmp	r3, #0
 8011c3c:	d002      	beq.n	8011c44 <USBD_CDC_Setup+0xc8>
 8011c3e:	2b0a      	cmp	r3, #10
 8011c40:	d019      	beq.n	8011c76 <USBD_CDC_Setup+0xfa>
 8011c42:	e042      	b.n	8011cca <USBD_CDC_Setup+0x14e>
      {
        case USB_REQ_GET_STATUS:
          if (pdev->dev_state == USBD_STATE_CONFIGURED)
 8011c44:	687a      	ldr	r2, [r7, #4]
 8011c46:	23a7      	movs	r3, #167	; 0xa7
 8011c48:	009b      	lsls	r3, r3, #2
 8011c4a:	5cd3      	ldrb	r3, [r2, r3]
 8011c4c:	2b03      	cmp	r3, #3
 8011c4e:	d107      	bne.n	8011c60 <USBD_CDC_Setup+0xe4>
          {
            USBD_CtlSendData(pdev, (uint8_t *)(void *)&status_info, 2U);
 8011c50:	230c      	movs	r3, #12
 8011c52:	18f9      	adds	r1, r7, r3
 8011c54:	687b      	ldr	r3, [r7, #4]
 8011c56:	2202      	movs	r2, #2
 8011c58:	0018      	movs	r0, r3
 8011c5a:	f001 fb45 	bl	80132e8 <USBD_CtlSendData>
          else
          {
            USBD_CtlError(pdev, req);
            ret = USBD_FAIL;
          }
          break;
 8011c5e:	e040      	b.n	8011ce2 <USBD_CDC_Setup+0x166>
            USBD_CtlError(pdev, req);
 8011c60:	683a      	ldr	r2, [r7, #0]
 8011c62:	687b      	ldr	r3, [r7, #4]
 8011c64:	0011      	movs	r1, r2
 8011c66:	0018      	movs	r0, r3
 8011c68:	f001 fac0 	bl	80131ec <USBD_CtlError>
            ret = USBD_FAIL;
 8011c6c:	2317      	movs	r3, #23
 8011c6e:	18fb      	adds	r3, r7, r3
 8011c70:	2202      	movs	r2, #2
 8011c72:	701a      	strb	r2, [r3, #0]
          break;
 8011c74:	e035      	b.n	8011ce2 <USBD_CDC_Setup+0x166>

        case USB_REQ_GET_INTERFACE:
          if (pdev->dev_state == USBD_STATE_CONFIGURED)
 8011c76:	687a      	ldr	r2, [r7, #4]
 8011c78:	23a7      	movs	r3, #167	; 0xa7
 8011c7a:	009b      	lsls	r3, r3, #2
 8011c7c:	5cd3      	ldrb	r3, [r2, r3]
 8011c7e:	2b03      	cmp	r3, #3
 8011c80:	d107      	bne.n	8011c92 <USBD_CDC_Setup+0x116>
          {
            USBD_CtlSendData(pdev, &ifalt, 1U);
 8011c82:	230f      	movs	r3, #15
 8011c84:	18f9      	adds	r1, r7, r3
 8011c86:	687b      	ldr	r3, [r7, #4]
 8011c88:	2201      	movs	r2, #1
 8011c8a:	0018      	movs	r0, r3
 8011c8c:	f001 fb2c 	bl	80132e8 <USBD_CtlSendData>
          else
          {
            USBD_CtlError(pdev, req);
            ret = USBD_FAIL;
          }
          break;
 8011c90:	e027      	b.n	8011ce2 <USBD_CDC_Setup+0x166>
            USBD_CtlError(pdev, req);
 8011c92:	683a      	ldr	r2, [r7, #0]
 8011c94:	687b      	ldr	r3, [r7, #4]
 8011c96:	0011      	movs	r1, r2
 8011c98:	0018      	movs	r0, r3
 8011c9a:	f001 faa7 	bl	80131ec <USBD_CtlError>
            ret = USBD_FAIL;
 8011c9e:	2317      	movs	r3, #23
 8011ca0:	18fb      	adds	r3, r7, r3
 8011ca2:	2202      	movs	r2, #2
 8011ca4:	701a      	strb	r2, [r3, #0]
          break;
 8011ca6:	e01c      	b.n	8011ce2 <USBD_CDC_Setup+0x166>

        case USB_REQ_SET_INTERFACE:
          if (pdev->dev_state != USBD_STATE_CONFIGURED)
 8011ca8:	687a      	ldr	r2, [r7, #4]
 8011caa:	23a7      	movs	r3, #167	; 0xa7
 8011cac:	009b      	lsls	r3, r3, #2
 8011cae:	5cd3      	ldrb	r3, [r2, r3]
 8011cb0:	2b03      	cmp	r3, #3
 8011cb2:	d015      	beq.n	8011ce0 <USBD_CDC_Setup+0x164>
          {
            USBD_CtlError(pdev, req);
 8011cb4:	683a      	ldr	r2, [r7, #0]
 8011cb6:	687b      	ldr	r3, [r7, #4]
 8011cb8:	0011      	movs	r1, r2
 8011cba:	0018      	movs	r0, r3
 8011cbc:	f001 fa96 	bl	80131ec <USBD_CtlError>
            ret = USBD_FAIL;
 8011cc0:	2317      	movs	r3, #23
 8011cc2:	18fb      	adds	r3, r7, r3
 8011cc4:	2202      	movs	r2, #2
 8011cc6:	701a      	strb	r2, [r3, #0]
          }
          break;
 8011cc8:	e00a      	b.n	8011ce0 <USBD_CDC_Setup+0x164>

        default:
          USBD_CtlError(pdev, req);
 8011cca:	683a      	ldr	r2, [r7, #0]
 8011ccc:	687b      	ldr	r3, [r7, #4]
 8011cce:	0011      	movs	r1, r2
 8011cd0:	0018      	movs	r0, r3
 8011cd2:	f001 fa8b 	bl	80131ec <USBD_CtlError>
          ret = USBD_FAIL;
 8011cd6:	2317      	movs	r3, #23
 8011cd8:	18fb      	adds	r3, r7, r3
 8011cda:	2202      	movs	r2, #2
 8011cdc:	701a      	strb	r2, [r3, #0]
          break;
 8011cde:	e000      	b.n	8011ce2 <USBD_CDC_Setup+0x166>
          break;
 8011ce0:	46c0      	nop			; (mov r8, r8)
      }
      break;
 8011ce2:	e00a      	b.n	8011cfa <USBD_CDC_Setup+0x17e>

    default:
      USBD_CtlError(pdev, req);
 8011ce4:	683a      	ldr	r2, [r7, #0]
 8011ce6:	687b      	ldr	r3, [r7, #4]
 8011ce8:	0011      	movs	r1, r2
 8011cea:	0018      	movs	r0, r3
 8011cec:	f001 fa7e 	bl	80131ec <USBD_CtlError>
      ret = USBD_FAIL;
 8011cf0:	2317      	movs	r3, #23
 8011cf2:	18fb      	adds	r3, r7, r3
 8011cf4:	2202      	movs	r2, #2
 8011cf6:	701a      	strb	r2, [r3, #0]
      break;
 8011cf8:	46c0      	nop			; (mov r8, r8)
  }

  return ret;
 8011cfa:	2317      	movs	r3, #23
 8011cfc:	18fb      	adds	r3, r7, r3
 8011cfe:	781b      	ldrb	r3, [r3, #0]
}
 8011d00:	0018      	movs	r0, r3
 8011d02:	46bd      	mov	sp, r7
 8011d04:	b006      	add	sp, #24
 8011d06:	bd80      	pop	{r7, pc}
 8011d08:	00000201 	.word	0x00000201

08011d0c <USBD_CDC_DataIn>:
  * @param  pdev: device instance
  * @param  epnum: endpoint number
  * @retval status
  */
static uint8_t  USBD_CDC_DataIn(USBD_HandleTypeDef *pdev, uint8_t epnum)
{
 8011d0c:	b580      	push	{r7, lr}
 8011d0e:	b084      	sub	sp, #16
 8011d10:	af00      	add	r7, sp, #0
 8011d12:	6078      	str	r0, [r7, #4]
 8011d14:	000a      	movs	r2, r1
 8011d16:	1cfb      	adds	r3, r7, #3
 8011d18:	701a      	strb	r2, [r3, #0]
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassData;
 8011d1a:	687a      	ldr	r2, [r7, #4]
 8011d1c:	23ae      	movs	r3, #174	; 0xae
 8011d1e:	009b      	lsls	r3, r3, #2
 8011d20:	58d3      	ldr	r3, [r2, r3]
 8011d22:	60fb      	str	r3, [r7, #12]
  PCD_HandleTypeDef *hpcd = pdev->pData;
 8011d24:	687a      	ldr	r2, [r7, #4]
 8011d26:	23b0      	movs	r3, #176	; 0xb0
 8011d28:	009b      	lsls	r3, r3, #2
 8011d2a:	58d3      	ldr	r3, [r2, r3]
 8011d2c:	60bb      	str	r3, [r7, #8]

  if (pdev->pClassData != NULL)
 8011d2e:	687a      	ldr	r2, [r7, #4]
 8011d30:	23ae      	movs	r3, #174	; 0xae
 8011d32:	009b      	lsls	r3, r3, #2
 8011d34:	58d3      	ldr	r3, [r2, r3]
 8011d36:	2b00      	cmp	r3, #0
 8011d38:	d03e      	beq.n	8011db8 <USBD_CDC_DataIn+0xac>
  {
    if ((pdev->ep_in[epnum].total_length > 0U) && ((pdev->ep_in[epnum].total_length % hpcd->IN_ep[epnum].maxpacket) == 0U))
 8011d3a:	1cfb      	adds	r3, r7, #3
 8011d3c:	781a      	ldrb	r2, [r3, #0]
 8011d3e:	6879      	ldr	r1, [r7, #4]
 8011d40:	0013      	movs	r3, r2
 8011d42:	009b      	lsls	r3, r3, #2
 8011d44:	189b      	adds	r3, r3, r2
 8011d46:	009b      	lsls	r3, r3, #2
 8011d48:	18cb      	adds	r3, r1, r3
 8011d4a:	331c      	adds	r3, #28
 8011d4c:	681b      	ldr	r3, [r3, #0]
 8011d4e:	2b00      	cmp	r3, #0
 8011d50:	d02b      	beq.n	8011daa <USBD_CDC_DataIn+0x9e>
 8011d52:	1cfb      	adds	r3, r7, #3
 8011d54:	781a      	ldrb	r2, [r3, #0]
 8011d56:	6879      	ldr	r1, [r7, #4]
 8011d58:	0013      	movs	r3, r2
 8011d5a:	009b      	lsls	r3, r3, #2
 8011d5c:	189b      	adds	r3, r3, r2
 8011d5e:	009b      	lsls	r3, r3, #2
 8011d60:	18cb      	adds	r3, r1, r3
 8011d62:	331c      	adds	r3, #28
 8011d64:	6818      	ldr	r0, [r3, #0]
 8011d66:	1cfb      	adds	r3, r7, #3
 8011d68:	781a      	ldrb	r2, [r3, #0]
 8011d6a:	68b9      	ldr	r1, [r7, #8]
 8011d6c:	0013      	movs	r3, r2
 8011d6e:	009b      	lsls	r3, r3, #2
 8011d70:	189b      	adds	r3, r3, r2
 8011d72:	00db      	lsls	r3, r3, #3
 8011d74:	18cb      	adds	r3, r1, r3
 8011d76:	3338      	adds	r3, #56	; 0x38
 8011d78:	681b      	ldr	r3, [r3, #0]
 8011d7a:	0019      	movs	r1, r3
 8011d7c:	f7f7 fa5c 	bl	8009238 <__aeabi_uidivmod>
 8011d80:	1e0b      	subs	r3, r1, #0
 8011d82:	d112      	bne.n	8011daa <USBD_CDC_DataIn+0x9e>
    {
      /* Update the packet total length */
      pdev->ep_in[epnum].total_length = 0U;
 8011d84:	1cfb      	adds	r3, r7, #3
 8011d86:	781a      	ldrb	r2, [r3, #0]
 8011d88:	6879      	ldr	r1, [r7, #4]
 8011d8a:	0013      	movs	r3, r2
 8011d8c:	009b      	lsls	r3, r3, #2
 8011d8e:	189b      	adds	r3, r3, r2
 8011d90:	009b      	lsls	r3, r3, #2
 8011d92:	18cb      	adds	r3, r1, r3
 8011d94:	331c      	adds	r3, #28
 8011d96:	2200      	movs	r2, #0
 8011d98:	601a      	str	r2, [r3, #0]

      /* Send ZLP */
      USBD_LL_Transmit(pdev, epnum, NULL, 0U);
 8011d9a:	1cfb      	adds	r3, r7, #3
 8011d9c:	7819      	ldrb	r1, [r3, #0]
 8011d9e:	6878      	ldr	r0, [r7, #4]
 8011da0:	2300      	movs	r3, #0
 8011da2:	2200      	movs	r2, #0
 8011da4:	f003 f82b 	bl	8014dfe <USBD_LL_Transmit>
 8011da8:	e004      	b.n	8011db4 <USBD_CDC_DataIn+0xa8>
    }
    else
    {
      hcdc->TxState = 0U;
 8011daa:	68fa      	ldr	r2, [r7, #12]
 8011dac:	2385      	movs	r3, #133	; 0x85
 8011dae:	009b      	lsls	r3, r3, #2
 8011db0:	2100      	movs	r1, #0
 8011db2:	50d1      	str	r1, [r2, r3]
    }
    return USBD_OK;
 8011db4:	2300      	movs	r3, #0
 8011db6:	e000      	b.n	8011dba <USBD_CDC_DataIn+0xae>
  }
  else
  {
    return USBD_FAIL;
 8011db8:	2302      	movs	r3, #2
  }
}
 8011dba:	0018      	movs	r0, r3
 8011dbc:	46bd      	mov	sp, r7
 8011dbe:	b004      	add	sp, #16
 8011dc0:	bd80      	pop	{r7, pc}

08011dc2 <USBD_CDC_DataOut>:
  * @param  pdev: device instance
  * @param  epnum: endpoint number
  * @retval status
  */
static uint8_t  USBD_CDC_DataOut(USBD_HandleTypeDef *pdev, uint8_t epnum)
{
 8011dc2:	b580      	push	{r7, lr}
 8011dc4:	b084      	sub	sp, #16
 8011dc6:	af00      	add	r7, sp, #0
 8011dc8:	6078      	str	r0, [r7, #4]
 8011dca:	000a      	movs	r2, r1
 8011dcc:	1cfb      	adds	r3, r7, #3
 8011dce:	701a      	strb	r2, [r3, #0]
  USBD_CDC_HandleTypeDef   *hcdc = (USBD_CDC_HandleTypeDef *) pdev->pClassData;
 8011dd0:	687a      	ldr	r2, [r7, #4]
 8011dd2:	23ae      	movs	r3, #174	; 0xae
 8011dd4:	009b      	lsls	r3, r3, #2
 8011dd6:	58d3      	ldr	r3, [r2, r3]
 8011dd8:	60fb      	str	r3, [r7, #12]

  /* Get the received data length */
  hcdc->RxLength = USBD_LL_GetRxDataSize(pdev, epnum);
 8011dda:	1cfb      	adds	r3, r7, #3
 8011ddc:	781a      	ldrb	r2, [r3, #0]
 8011dde:	687b      	ldr	r3, [r7, #4]
 8011de0:	0011      	movs	r1, r2
 8011de2:	0018      	movs	r0, r3
 8011de4:	f003 f879 	bl	8014eda <USBD_LL_GetRxDataSize>
 8011de8:	0001      	movs	r1, r0
 8011dea:	68fa      	ldr	r2, [r7, #12]
 8011dec:	2383      	movs	r3, #131	; 0x83
 8011dee:	009b      	lsls	r3, r3, #2
 8011df0:	50d1      	str	r1, [r2, r3]

  /* USB data will be immediately processed, this allow next USB traffic being
  NAKed till the end of the application Xfer */
  if (pdev->pClassData != NULL)
 8011df2:	687a      	ldr	r2, [r7, #4]
 8011df4:	23ae      	movs	r3, #174	; 0xae
 8011df6:	009b      	lsls	r3, r3, #2
 8011df8:	58d3      	ldr	r3, [r2, r3]
 8011dfa:	2b00      	cmp	r3, #0
 8011dfc:	d011      	beq.n	8011e22 <USBD_CDC_DataOut+0x60>
  {
    ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->Receive(hcdc->RxBuffer, &hcdc->RxLength);
 8011dfe:	687a      	ldr	r2, [r7, #4]
 8011e00:	23af      	movs	r3, #175	; 0xaf
 8011e02:	009b      	lsls	r3, r3, #2
 8011e04:	58d3      	ldr	r3, [r2, r3]
 8011e06:	68da      	ldr	r2, [r3, #12]
 8011e08:	68f9      	ldr	r1, [r7, #12]
 8011e0a:	2381      	movs	r3, #129	; 0x81
 8011e0c:	009b      	lsls	r3, r3, #2
 8011e0e:	58c8      	ldr	r0, [r1, r3]
 8011e10:	68fb      	ldr	r3, [r7, #12]
 8011e12:	2183      	movs	r1, #131	; 0x83
 8011e14:	0089      	lsls	r1, r1, #2
 8011e16:	468c      	mov	ip, r1
 8011e18:	4463      	add	r3, ip
 8011e1a:	0019      	movs	r1, r3
 8011e1c:	4790      	blx	r2

    return USBD_OK;
 8011e1e:	2300      	movs	r3, #0
 8011e20:	e000      	b.n	8011e24 <USBD_CDC_DataOut+0x62>
  }
  else
  {
    return USBD_FAIL;
 8011e22:	2302      	movs	r3, #2
  }
}
 8011e24:	0018      	movs	r0, r3
 8011e26:	46bd      	mov	sp, r7
 8011e28:	b004      	add	sp, #16
 8011e2a:	bd80      	pop	{r7, pc}

08011e2c <USBD_CDC_EP0_RxReady>:
  *         Handle EP0 Rx Ready event
  * @param  pdev: device instance
  * @retval status
  */
static uint8_t  USBD_CDC_EP0_RxReady(USBD_HandleTypeDef *pdev)
{
 8011e2c:	b590      	push	{r4, r7, lr}
 8011e2e:	b085      	sub	sp, #20
 8011e30:	af00      	add	r7, sp, #0
 8011e32:	6078      	str	r0, [r7, #4]
  USBD_CDC_HandleTypeDef   *hcdc = (USBD_CDC_HandleTypeDef *) pdev->pClassData;
 8011e34:	687a      	ldr	r2, [r7, #4]
 8011e36:	23ae      	movs	r3, #174	; 0xae
 8011e38:	009b      	lsls	r3, r3, #2
 8011e3a:	58d3      	ldr	r3, [r2, r3]
 8011e3c:	60fb      	str	r3, [r7, #12]

  if ((pdev->pUserData != NULL) && (hcdc->CmdOpCode != 0xFFU))
 8011e3e:	687a      	ldr	r2, [r7, #4]
 8011e40:	23af      	movs	r3, #175	; 0xaf
 8011e42:	009b      	lsls	r3, r3, #2
 8011e44:	58d3      	ldr	r3, [r2, r3]
 8011e46:	2b00      	cmp	r3, #0
 8011e48:	d019      	beq.n	8011e7e <USBD_CDC_EP0_RxReady+0x52>
 8011e4a:	68fa      	ldr	r2, [r7, #12]
 8011e4c:	2380      	movs	r3, #128	; 0x80
 8011e4e:	009b      	lsls	r3, r3, #2
 8011e50:	5cd3      	ldrb	r3, [r2, r3]
 8011e52:	2bff      	cmp	r3, #255	; 0xff
 8011e54:	d013      	beq.n	8011e7e <USBD_CDC_EP0_RxReady+0x52>
  {
    ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->Control(hcdc->CmdOpCode,
 8011e56:	687a      	ldr	r2, [r7, #4]
 8011e58:	23af      	movs	r3, #175	; 0xaf
 8011e5a:	009b      	lsls	r3, r3, #2
 8011e5c:	58d3      	ldr	r3, [r2, r3]
 8011e5e:	689b      	ldr	r3, [r3, #8]
 8011e60:	68f9      	ldr	r1, [r7, #12]
 8011e62:	2280      	movs	r2, #128	; 0x80
 8011e64:	0092      	lsls	r2, r2, #2
 8011e66:	5c88      	ldrb	r0, [r1, r2]
                                                      (uint8_t *)(void *)hcdc->data,
 8011e68:	68f9      	ldr	r1, [r7, #12]
                                                      (uint16_t)hcdc->CmdLength);
 8011e6a:	68fa      	ldr	r2, [r7, #12]
 8011e6c:	4c06      	ldr	r4, [pc, #24]	; (8011e88 <USBD_CDC_EP0_RxReady+0x5c>)
 8011e6e:	5d12      	ldrb	r2, [r2, r4]
    ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->Control(hcdc->CmdOpCode,
 8011e70:	b292      	uxth	r2, r2
 8011e72:	4798      	blx	r3
    hcdc->CmdOpCode = 0xFFU;
 8011e74:	68fa      	ldr	r2, [r7, #12]
 8011e76:	2380      	movs	r3, #128	; 0x80
 8011e78:	009b      	lsls	r3, r3, #2
 8011e7a:	21ff      	movs	r1, #255	; 0xff
 8011e7c:	54d1      	strb	r1, [r2, r3]

  }
  return USBD_OK;
 8011e7e:	2300      	movs	r3, #0
}
 8011e80:	0018      	movs	r0, r3
 8011e82:	46bd      	mov	sp, r7
 8011e84:	b005      	add	sp, #20
 8011e86:	bd90      	pop	{r4, r7, pc}
 8011e88:	00000201 	.word	0x00000201

08011e8c <USBD_CDC_GetFSCfgDesc>:
  * @param  speed : current device speed
  * @param  length : pointer data length
  * @retval pointer to descriptor buffer
  */
static uint8_t  *USBD_CDC_GetFSCfgDesc(uint16_t *length)
{
 8011e8c:	b580      	push	{r7, lr}
 8011e8e:	b082      	sub	sp, #8
 8011e90:	af00      	add	r7, sp, #0
 8011e92:	6078      	str	r0, [r7, #4]
  *length = sizeof(USBD_CDC_CfgFSDesc);
 8011e94:	687b      	ldr	r3, [r7, #4]
 8011e96:	2243      	movs	r2, #67	; 0x43
 8011e98:	801a      	strh	r2, [r3, #0]
  return USBD_CDC_CfgFSDesc;
 8011e9a:	4b02      	ldr	r3, [pc, #8]	; (8011ea4 <USBD_CDC_GetFSCfgDesc+0x18>)
}
 8011e9c:	0018      	movs	r0, r3
 8011e9e:	46bd      	mov	sp, r7
 8011ea0:	b002      	add	sp, #8
 8011ea2:	bd80      	pop	{r7, pc}
 8011ea4:	200001f0 	.word	0x200001f0

08011ea8 <USBD_CDC_GetHSCfgDesc>:
  * @param  speed : current device speed
  * @param  length : pointer data length
  * @retval pointer to descriptor buffer
  */
static uint8_t  *USBD_CDC_GetHSCfgDesc(uint16_t *length)
{
 8011ea8:	b580      	push	{r7, lr}
 8011eaa:	b082      	sub	sp, #8
 8011eac:	af00      	add	r7, sp, #0
 8011eae:	6078      	str	r0, [r7, #4]
  *length = sizeof(USBD_CDC_CfgHSDesc);
 8011eb0:	687b      	ldr	r3, [r7, #4]
 8011eb2:	2243      	movs	r2, #67	; 0x43
 8011eb4:	801a      	strh	r2, [r3, #0]
  return USBD_CDC_CfgHSDesc;
 8011eb6:	4b02      	ldr	r3, [pc, #8]	; (8011ec0 <USBD_CDC_GetHSCfgDesc+0x18>)
}
 8011eb8:	0018      	movs	r0, r3
 8011eba:	46bd      	mov	sp, r7
 8011ebc:	b002      	add	sp, #8
 8011ebe:	bd80      	pop	{r7, pc}
 8011ec0:	200001ac 	.word	0x200001ac

08011ec4 <USBD_CDC_GetOtherSpeedCfgDesc>:
  * @param  speed : current device speed
  * @param  length : pointer data length
  * @retval pointer to descriptor buffer
  */
static uint8_t  *USBD_CDC_GetOtherSpeedCfgDesc(uint16_t *length)
{
 8011ec4:	b580      	push	{r7, lr}
 8011ec6:	b082      	sub	sp, #8
 8011ec8:	af00      	add	r7, sp, #0
 8011eca:	6078      	str	r0, [r7, #4]
  *length = sizeof(USBD_CDC_OtherSpeedCfgDesc);
 8011ecc:	687b      	ldr	r3, [r7, #4]
 8011ece:	2243      	movs	r2, #67	; 0x43
 8011ed0:	801a      	strh	r2, [r3, #0]
  return USBD_CDC_OtherSpeedCfgDesc;
 8011ed2:	4b02      	ldr	r3, [pc, #8]	; (8011edc <USBD_CDC_GetOtherSpeedCfgDesc+0x18>)
}
 8011ed4:	0018      	movs	r0, r3
 8011ed6:	46bd      	mov	sp, r7
 8011ed8:	b002      	add	sp, #8
 8011eda:	bd80      	pop	{r7, pc}
 8011edc:	20000234 	.word	0x20000234

08011ee0 <USBD_CDC_GetDeviceQualifierDescriptor>:
*         return Device Qualifier descriptor
* @param  length : pointer data length
* @retval pointer to descriptor buffer
*/
uint8_t  *USBD_CDC_GetDeviceQualifierDescriptor(uint16_t *length)
{
 8011ee0:	b580      	push	{r7, lr}
 8011ee2:	b082      	sub	sp, #8
 8011ee4:	af00      	add	r7, sp, #0
 8011ee6:	6078      	str	r0, [r7, #4]
  *length = sizeof(USBD_CDC_DeviceQualifierDesc);
 8011ee8:	687b      	ldr	r3, [r7, #4]
 8011eea:	220a      	movs	r2, #10
 8011eec:	801a      	strh	r2, [r3, #0]
  return USBD_CDC_DeviceQualifierDesc;
 8011eee:	4b02      	ldr	r3, [pc, #8]	; (8011ef8 <USBD_CDC_GetDeviceQualifierDescriptor+0x18>)
}
 8011ef0:	0018      	movs	r0, r3
 8011ef2:	46bd      	mov	sp, r7
 8011ef4:	b002      	add	sp, #8
 8011ef6:	bd80      	pop	{r7, pc}
 8011ef8:	20000168 	.word	0x20000168

08011efc <USBD_CDC_RegisterInterface>:
  * @param  fops: CD  Interface callback
  * @retval status
  */
uint8_t  USBD_CDC_RegisterInterface(USBD_HandleTypeDef   *pdev,
                                    USBD_CDC_ItfTypeDef *fops)
{
 8011efc:	b580      	push	{r7, lr}
 8011efe:	b084      	sub	sp, #16
 8011f00:	af00      	add	r7, sp, #0
 8011f02:	6078      	str	r0, [r7, #4]
 8011f04:	6039      	str	r1, [r7, #0]
  uint8_t  ret = USBD_FAIL;
 8011f06:	200f      	movs	r0, #15
 8011f08:	183b      	adds	r3, r7, r0
 8011f0a:	2202      	movs	r2, #2
 8011f0c:	701a      	strb	r2, [r3, #0]

  if (fops != NULL)
 8011f0e:	683b      	ldr	r3, [r7, #0]
 8011f10:	2b00      	cmp	r3, #0
 8011f12:	d007      	beq.n	8011f24 <USBD_CDC_RegisterInterface+0x28>
  {
    pdev->pUserData = fops;
 8011f14:	687a      	ldr	r2, [r7, #4]
 8011f16:	23af      	movs	r3, #175	; 0xaf
 8011f18:	009b      	lsls	r3, r3, #2
 8011f1a:	6839      	ldr	r1, [r7, #0]
 8011f1c:	50d1      	str	r1, [r2, r3]
    ret = USBD_OK;
 8011f1e:	183b      	adds	r3, r7, r0
 8011f20:	2200      	movs	r2, #0
 8011f22:	701a      	strb	r2, [r3, #0]
  }

  return ret;
 8011f24:	230f      	movs	r3, #15
 8011f26:	18fb      	adds	r3, r7, r3
 8011f28:	781b      	ldrb	r3, [r3, #0]
}
 8011f2a:	0018      	movs	r0, r3
 8011f2c:	46bd      	mov	sp, r7
 8011f2e:	b004      	add	sp, #16
 8011f30:	bd80      	pop	{r7, pc}

08011f32 <USBD_CDC_SetTxBuffer>:
  * @retval status
  */
uint8_t  USBD_CDC_SetTxBuffer(USBD_HandleTypeDef   *pdev,
                              uint8_t  *pbuff,
                              uint16_t length)
{
 8011f32:	b580      	push	{r7, lr}
 8011f34:	b086      	sub	sp, #24
 8011f36:	af00      	add	r7, sp, #0
 8011f38:	60f8      	str	r0, [r7, #12]
 8011f3a:	60b9      	str	r1, [r7, #8]
 8011f3c:	1dbb      	adds	r3, r7, #6
 8011f3e:	801a      	strh	r2, [r3, #0]
  USBD_CDC_HandleTypeDef   *hcdc = (USBD_CDC_HandleTypeDef *) pdev->pClassData;
 8011f40:	68fa      	ldr	r2, [r7, #12]
 8011f42:	23ae      	movs	r3, #174	; 0xae
 8011f44:	009b      	lsls	r3, r3, #2
 8011f46:	58d3      	ldr	r3, [r2, r3]
 8011f48:	617b      	str	r3, [r7, #20]

  hcdc->TxBuffer = pbuff;
 8011f4a:	697a      	ldr	r2, [r7, #20]
 8011f4c:	2382      	movs	r3, #130	; 0x82
 8011f4e:	009b      	lsls	r3, r3, #2
 8011f50:	68b9      	ldr	r1, [r7, #8]
 8011f52:	50d1      	str	r1, [r2, r3]
  hcdc->TxLength = length;
 8011f54:	1dbb      	adds	r3, r7, #6
 8011f56:	8819      	ldrh	r1, [r3, #0]
 8011f58:	697a      	ldr	r2, [r7, #20]
 8011f5a:	2384      	movs	r3, #132	; 0x84
 8011f5c:	009b      	lsls	r3, r3, #2
 8011f5e:	50d1      	str	r1, [r2, r3]

  return USBD_OK;
 8011f60:	2300      	movs	r3, #0
}
 8011f62:	0018      	movs	r0, r3
 8011f64:	46bd      	mov	sp, r7
 8011f66:	b006      	add	sp, #24
 8011f68:	bd80      	pop	{r7, pc}

08011f6a <USBD_CDC_SetRxBuffer>:
  * @param  pbuff: Rx Buffer
  * @retval status
  */
uint8_t  USBD_CDC_SetRxBuffer(USBD_HandleTypeDef   *pdev,
                              uint8_t  *pbuff)
{
 8011f6a:	b580      	push	{r7, lr}
 8011f6c:	b084      	sub	sp, #16
 8011f6e:	af00      	add	r7, sp, #0
 8011f70:	6078      	str	r0, [r7, #4]
 8011f72:	6039      	str	r1, [r7, #0]
  USBD_CDC_HandleTypeDef   *hcdc = (USBD_CDC_HandleTypeDef *) pdev->pClassData;
 8011f74:	687a      	ldr	r2, [r7, #4]
 8011f76:	23ae      	movs	r3, #174	; 0xae
 8011f78:	009b      	lsls	r3, r3, #2
 8011f7a:	58d3      	ldr	r3, [r2, r3]
 8011f7c:	60fb      	str	r3, [r7, #12]

  hcdc->RxBuffer = pbuff;
 8011f7e:	68fa      	ldr	r2, [r7, #12]
 8011f80:	2381      	movs	r3, #129	; 0x81
 8011f82:	009b      	lsls	r3, r3, #2
 8011f84:	6839      	ldr	r1, [r7, #0]
 8011f86:	50d1      	str	r1, [r2, r3]

  return USBD_OK;
 8011f88:	2300      	movs	r3, #0
}
 8011f8a:	0018      	movs	r0, r3
 8011f8c:	46bd      	mov	sp, r7
 8011f8e:	b004      	add	sp, #16
 8011f90:	bd80      	pop	{r7, pc}

08011f92 <USBD_CDC_ReceivePacket>:
  *         prepare OUT Endpoint for reception
  * @param  pdev: device instance
  * @retval status
  */
uint8_t  USBD_CDC_ReceivePacket(USBD_HandleTypeDef *pdev)
{
 8011f92:	b580      	push	{r7, lr}
 8011f94:	b084      	sub	sp, #16
 8011f96:	af00      	add	r7, sp, #0
 8011f98:	6078      	str	r0, [r7, #4]
  USBD_CDC_HandleTypeDef   *hcdc = (USBD_CDC_HandleTypeDef *) pdev->pClassData;
 8011f9a:	687a      	ldr	r2, [r7, #4]
 8011f9c:	23ae      	movs	r3, #174	; 0xae
 8011f9e:	009b      	lsls	r3, r3, #2
 8011fa0:	58d3      	ldr	r3, [r2, r3]
 8011fa2:	60fb      	str	r3, [r7, #12]

  /* Suspend or Resume USB Out process */
  if (pdev->pClassData != NULL)
 8011fa4:	687a      	ldr	r2, [r7, #4]
 8011fa6:	23ae      	movs	r3, #174	; 0xae
 8011fa8:	009b      	lsls	r3, r3, #2
 8011faa:	58d3      	ldr	r3, [r2, r3]
 8011fac:	2b00      	cmp	r3, #0
 8011fae:	d019      	beq.n	8011fe4 <USBD_CDC_ReceivePacket+0x52>
  {
    if (pdev->dev_speed == USBD_SPEED_HIGH)
 8011fb0:	687b      	ldr	r3, [r7, #4]
 8011fb2:	7c1b      	ldrb	r3, [r3, #16]
 8011fb4:	2b00      	cmp	r3, #0
 8011fb6:	d10a      	bne.n	8011fce <USBD_CDC_ReceivePacket+0x3c>
    {
      /* Prepare Out endpoint to receive next packet */
      USBD_LL_PrepareReceive(pdev,
 8011fb8:	68fa      	ldr	r2, [r7, #12]
 8011fba:	2381      	movs	r3, #129	; 0x81
 8011fbc:	009b      	lsls	r3, r3, #2
 8011fbe:	58d2      	ldr	r2, [r2, r3]
 8011fc0:	2380      	movs	r3, #128	; 0x80
 8011fc2:	009b      	lsls	r3, r3, #2
 8011fc4:	6878      	ldr	r0, [r7, #4]
 8011fc6:	2101      	movs	r1, #1
 8011fc8:	f002 ff50 	bl	8014e6c <USBD_LL_PrepareReceive>
 8011fcc:	e008      	b.n	8011fe0 <USBD_CDC_ReceivePacket+0x4e>
                             CDC_DATA_HS_OUT_PACKET_SIZE);
    }
    else
    {
      /* Prepare Out endpoint to receive next packet */
      USBD_LL_PrepareReceive(pdev,
 8011fce:	68fa      	ldr	r2, [r7, #12]
 8011fd0:	2381      	movs	r3, #129	; 0x81
 8011fd2:	009b      	lsls	r3, r3, #2
 8011fd4:	58d2      	ldr	r2, [r2, r3]
 8011fd6:	6878      	ldr	r0, [r7, #4]
 8011fd8:	2340      	movs	r3, #64	; 0x40
 8011fda:	2101      	movs	r1, #1
 8011fdc:	f002 ff46 	bl	8014e6c <USBD_LL_PrepareReceive>
                             CDC_OUT_EP,
                             hcdc->RxBuffer,
                             CDC_DATA_FS_OUT_PACKET_SIZE);
    }
    return USBD_OK;
 8011fe0:	2300      	movs	r3, #0
 8011fe2:	e000      	b.n	8011fe6 <USBD_CDC_ReceivePacket+0x54>
  }
  else
  {
    return USBD_FAIL;
 8011fe4:	2302      	movs	r3, #2
  }
}
 8011fe6:	0018      	movs	r0, r3
 8011fe8:	46bd      	mov	sp, r7
 8011fea:	b004      	add	sp, #16
 8011fec:	bd80      	pop	{r7, pc}

08011fee <USBD_Init>:
* @param  id: Low level core index
* @retval None
*/
USBD_StatusTypeDef USBD_Init(USBD_HandleTypeDef *pdev,
                             USBD_DescriptorsTypeDef *pdesc, uint8_t id)
{
 8011fee:	b580      	push	{r7, lr}
 8011ff0:	b084      	sub	sp, #16
 8011ff2:	af00      	add	r7, sp, #0
 8011ff4:	60f8      	str	r0, [r7, #12]
 8011ff6:	60b9      	str	r1, [r7, #8]
 8011ff8:	1dfb      	adds	r3, r7, #7
 8011ffa:	701a      	strb	r2, [r3, #0]
  /* Check whether the USB Host handle is valid */
  if (pdev == NULL)
 8011ffc:	68fb      	ldr	r3, [r7, #12]
 8011ffe:	2b00      	cmp	r3, #0
 8012000:	d101      	bne.n	8012006 <USBD_Init+0x18>
  {
#if (USBD_DEBUG_LEVEL > 1U)
    USBD_ErrLog("Invalid Device handle");
#endif
    return USBD_FAIL;
 8012002:	2302      	movs	r3, #2
 8012004:	e020      	b.n	8012048 <USBD_Init+0x5a>
  }

  /* Unlink previous class*/
  if (pdev->pClass != NULL)
 8012006:	68fa      	ldr	r2, [r7, #12]
 8012008:	23ad      	movs	r3, #173	; 0xad
 801200a:	009b      	lsls	r3, r3, #2
 801200c:	58d3      	ldr	r3, [r2, r3]
 801200e:	2b00      	cmp	r3, #0
 8012010:	d004      	beq.n	801201c <USBD_Init+0x2e>
  {
    pdev->pClass = NULL;
 8012012:	68fa      	ldr	r2, [r7, #12]
 8012014:	23ad      	movs	r3, #173	; 0xad
 8012016:	009b      	lsls	r3, r3, #2
 8012018:	2100      	movs	r1, #0
 801201a:	50d1      	str	r1, [r2, r3]
  }

  /* Assign USBD Descriptors */
  if (pdesc != NULL)
 801201c:	68bb      	ldr	r3, [r7, #8]
 801201e:	2b00      	cmp	r3, #0
 8012020:	d004      	beq.n	801202c <USBD_Init+0x3e>
  {
    pdev->pDesc = pdesc;
 8012022:	68fa      	ldr	r2, [r7, #12]
 8012024:	23ac      	movs	r3, #172	; 0xac
 8012026:	009b      	lsls	r3, r3, #2
 8012028:	68b9      	ldr	r1, [r7, #8]
 801202a:	50d1      	str	r1, [r2, r3]
  }

  /* Set Device initial State */
  pdev->dev_state = USBD_STATE_DEFAULT;
 801202c:	68fa      	ldr	r2, [r7, #12]
 801202e:	23a7      	movs	r3, #167	; 0xa7
 8012030:	009b      	lsls	r3, r3, #2
 8012032:	2101      	movs	r1, #1
 8012034:	54d1      	strb	r1, [r2, r3]
  pdev->id = id;
 8012036:	68fb      	ldr	r3, [r7, #12]
 8012038:	1dfa      	adds	r2, r7, #7
 801203a:	7812      	ldrb	r2, [r2, #0]
 801203c:	701a      	strb	r2, [r3, #0]
  /* Initialize low level driver */
  USBD_LL_Init(pdev);
 801203e:	68fb      	ldr	r3, [r7, #12]
 8012040:	0018      	movs	r0, r3
 8012042:	f002 fd3f 	bl	8014ac4 <USBD_LL_Init>

  return USBD_OK;
 8012046:	2300      	movs	r3, #0
}
 8012048:	0018      	movs	r0, r3
 801204a:	46bd      	mov	sp, r7
 801204c:	b004      	add	sp, #16
 801204e:	bd80      	pop	{r7, pc}

08012050 <USBD_RegisterClass>:
  * @param  pDevice : Device Handle
  * @param  pclass: Class handle
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_RegisterClass(USBD_HandleTypeDef *pdev, USBD_ClassTypeDef *pclass)
{
 8012050:	b580      	push	{r7, lr}
 8012052:	b084      	sub	sp, #16
 8012054:	af00      	add	r7, sp, #0
 8012056:	6078      	str	r0, [r7, #4]
 8012058:	6039      	str	r1, [r7, #0]
  USBD_StatusTypeDef status = USBD_OK;
 801205a:	200f      	movs	r0, #15
 801205c:	183b      	adds	r3, r7, r0
 801205e:	2200      	movs	r2, #0
 8012060:	701a      	strb	r2, [r3, #0]
  if (pclass != NULL)
 8012062:	683b      	ldr	r3, [r7, #0]
 8012064:	2b00      	cmp	r3, #0
 8012066:	d008      	beq.n	801207a <USBD_RegisterClass+0x2a>
  {
    /* link the class to the USB Device handle */
    pdev->pClass = pclass;
 8012068:	687a      	ldr	r2, [r7, #4]
 801206a:	23ad      	movs	r3, #173	; 0xad
 801206c:	009b      	lsls	r3, r3, #2
 801206e:	6839      	ldr	r1, [r7, #0]
 8012070:	50d1      	str	r1, [r2, r3]
    status = USBD_OK;
 8012072:	183b      	adds	r3, r7, r0
 8012074:	2200      	movs	r2, #0
 8012076:	701a      	strb	r2, [r3, #0]
 8012078:	e003      	b.n	8012082 <USBD_RegisterClass+0x32>
  else
  {
#if (USBD_DEBUG_LEVEL > 1U)
    USBD_ErrLog("Invalid Class handle");
#endif
    status = USBD_FAIL;
 801207a:	230f      	movs	r3, #15
 801207c:	18fb      	adds	r3, r7, r3
 801207e:	2202      	movs	r2, #2
 8012080:	701a      	strb	r2, [r3, #0]
  }

  return status;
 8012082:	230f      	movs	r3, #15
 8012084:	18fb      	adds	r3, r7, r3
 8012086:	781b      	ldrb	r3, [r3, #0]
}
 8012088:	0018      	movs	r0, r3
 801208a:	46bd      	mov	sp, r7
 801208c:	b004      	add	sp, #16
 801208e:	bd80      	pop	{r7, pc}

08012090 <USBD_Start>:
  *         Start the USB Device Core.
  * @param  pdev: Device Handle
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_Start(USBD_HandleTypeDef *pdev)
{
 8012090:	b580      	push	{r7, lr}
 8012092:	b082      	sub	sp, #8
 8012094:	af00      	add	r7, sp, #0
 8012096:	6078      	str	r0, [r7, #4]
  /* Start the low level driver  */
  USBD_LL_Start(pdev);
 8012098:	687b      	ldr	r3, [r7, #4]
 801209a:	0018      	movs	r0, r3
 801209c:	f002 fd76 	bl	8014b8c <USBD_LL_Start>

  return USBD_OK;
 80120a0:	2300      	movs	r3, #0
}
 80120a2:	0018      	movs	r0, r3
 80120a4:	46bd      	mov	sp, r7
 80120a6:	b002      	add	sp, #8
 80120a8:	bd80      	pop	{r7, pc}

080120aa <USBD_RunTestMode>:
*         Launch test mode process
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef  USBD_RunTestMode(USBD_HandleTypeDef  *pdev)
{
 80120aa:	b580      	push	{r7, lr}
 80120ac:	b082      	sub	sp, #8
 80120ae:	af00      	add	r7, sp, #0
 80120b0:	6078      	str	r0, [r7, #4]
  /* Prevent unused argument compilation warning */
  UNUSED(pdev);

  return USBD_OK;
 80120b2:	2300      	movs	r3, #0
}
 80120b4:	0018      	movs	r0, r3
 80120b6:	46bd      	mov	sp, r7
 80120b8:	b002      	add	sp, #8
 80120ba:	bd80      	pop	{r7, pc}

080120bc <USBD_SetClassConfig>:
* @param  cfgidx: configuration index
* @retval status
*/

USBD_StatusTypeDef USBD_SetClassConfig(USBD_HandleTypeDef  *pdev, uint8_t cfgidx)
{
 80120bc:	b590      	push	{r4, r7, lr}
 80120be:	b085      	sub	sp, #20
 80120c0:	af00      	add	r7, sp, #0
 80120c2:	6078      	str	r0, [r7, #4]
 80120c4:	000a      	movs	r2, r1
 80120c6:	1cfb      	adds	r3, r7, #3
 80120c8:	701a      	strb	r2, [r3, #0]
  USBD_StatusTypeDef ret = USBD_FAIL;
 80120ca:	240f      	movs	r4, #15
 80120cc:	193b      	adds	r3, r7, r4
 80120ce:	2202      	movs	r2, #2
 80120d0:	701a      	strb	r2, [r3, #0]

  if (pdev->pClass != NULL)
 80120d2:	687a      	ldr	r2, [r7, #4]
 80120d4:	23ad      	movs	r3, #173	; 0xad
 80120d6:	009b      	lsls	r3, r3, #2
 80120d8:	58d3      	ldr	r3, [r2, r3]
 80120da:	2b00      	cmp	r3, #0
 80120dc:	d00e      	beq.n	80120fc <USBD_SetClassConfig+0x40>
  {
    /* Set configuration  and Start the Class*/
    if (pdev->pClass->Init(pdev, cfgidx) == 0U)
 80120de:	687a      	ldr	r2, [r7, #4]
 80120e0:	23ad      	movs	r3, #173	; 0xad
 80120e2:	009b      	lsls	r3, r3, #2
 80120e4:	58d3      	ldr	r3, [r2, r3]
 80120e6:	681b      	ldr	r3, [r3, #0]
 80120e8:	1cfa      	adds	r2, r7, #3
 80120ea:	7811      	ldrb	r1, [r2, #0]
 80120ec:	687a      	ldr	r2, [r7, #4]
 80120ee:	0010      	movs	r0, r2
 80120f0:	4798      	blx	r3
 80120f2:	1e03      	subs	r3, r0, #0
 80120f4:	d102      	bne.n	80120fc <USBD_SetClassConfig+0x40>
    {
      ret = USBD_OK;
 80120f6:	193b      	adds	r3, r7, r4
 80120f8:	2200      	movs	r2, #0
 80120fa:	701a      	strb	r2, [r3, #0]
    }
  }

  return ret;
 80120fc:	230f      	movs	r3, #15
 80120fe:	18fb      	adds	r3, r7, r3
 8012100:	781b      	ldrb	r3, [r3, #0]
}
 8012102:	0018      	movs	r0, r3
 8012104:	46bd      	mov	sp, r7
 8012106:	b005      	add	sp, #20
 8012108:	bd90      	pop	{r4, r7, pc}

0801210a <USBD_ClrClassConfig>:
* @param  pdev: device instance
* @param  cfgidx: configuration index
* @retval status: USBD_StatusTypeDef
*/
USBD_StatusTypeDef USBD_ClrClassConfig(USBD_HandleTypeDef  *pdev, uint8_t cfgidx)
{
 801210a:	b580      	push	{r7, lr}
 801210c:	b082      	sub	sp, #8
 801210e:	af00      	add	r7, sp, #0
 8012110:	6078      	str	r0, [r7, #4]
 8012112:	000a      	movs	r2, r1
 8012114:	1cfb      	adds	r3, r7, #3
 8012116:	701a      	strb	r2, [r3, #0]
  /* Clear configuration  and De-initialize the Class process*/
  pdev->pClass->DeInit(pdev, cfgidx);
 8012118:	687a      	ldr	r2, [r7, #4]
 801211a:	23ad      	movs	r3, #173	; 0xad
 801211c:	009b      	lsls	r3, r3, #2
 801211e:	58d3      	ldr	r3, [r2, r3]
 8012120:	685b      	ldr	r3, [r3, #4]
 8012122:	1cfa      	adds	r2, r7, #3
 8012124:	7811      	ldrb	r1, [r2, #0]
 8012126:	687a      	ldr	r2, [r7, #4]
 8012128:	0010      	movs	r0, r2
 801212a:	4798      	blx	r3

  return USBD_OK;
 801212c:	2300      	movs	r3, #0
}
 801212e:	0018      	movs	r0, r3
 8012130:	46bd      	mov	sp, r7
 8012132:	b002      	add	sp, #8
 8012134:	bd80      	pop	{r7, pc}
	...

08012138 <USBD_LL_SetupStage>:
*         Handle the setup stage
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_LL_SetupStage(USBD_HandleTypeDef *pdev, uint8_t *psetup)
{
 8012138:	b580      	push	{r7, lr}
 801213a:	b082      	sub	sp, #8
 801213c:	af00      	add	r7, sp, #0
 801213e:	6078      	str	r0, [r7, #4]
 8012140:	6039      	str	r1, [r7, #0]
  USBD_ParseSetupRequest(&pdev->request, psetup);
 8012142:	687b      	ldr	r3, [r7, #4]
 8012144:	22aa      	movs	r2, #170	; 0xaa
 8012146:	0092      	lsls	r2, r2, #2
 8012148:	4694      	mov	ip, r2
 801214a:	4463      	add	r3, ip
 801214c:	683a      	ldr	r2, [r7, #0]
 801214e:	0011      	movs	r1, r2
 8012150:	0018      	movs	r0, r3
 8012152:	f001 f810 	bl	8013176 <USBD_ParseSetupRequest>

  pdev->ep0_state = USBD_EP0_SETUP;
 8012156:	687a      	ldr	r2, [r7, #4]
 8012158:	23a5      	movs	r3, #165	; 0xa5
 801215a:	009b      	lsls	r3, r3, #2
 801215c:	2101      	movs	r1, #1
 801215e:	50d1      	str	r1, [r2, r3]

  pdev->ep0_data_len = pdev->request.wLength;
 8012160:	687b      	ldr	r3, [r7, #4]
 8012162:	4a23      	ldr	r2, [pc, #140]	; (80121f0 <USBD_LL_SetupStage+0xb8>)
 8012164:	5a9b      	ldrh	r3, [r3, r2]
 8012166:	0019      	movs	r1, r3
 8012168:	687a      	ldr	r2, [r7, #4]
 801216a:	23a6      	movs	r3, #166	; 0xa6
 801216c:	009b      	lsls	r3, r3, #2
 801216e:	50d1      	str	r1, [r2, r3]

  switch (pdev->request.bmRequest & 0x1FU)
 8012170:	687a      	ldr	r2, [r7, #4]
 8012172:	23aa      	movs	r3, #170	; 0xaa
 8012174:	009b      	lsls	r3, r3, #2
 8012176:	5cd3      	ldrb	r3, [r2, r3]
 8012178:	001a      	movs	r2, r3
 801217a:	231f      	movs	r3, #31
 801217c:	4013      	ands	r3, r2
 801217e:	2b02      	cmp	r3, #2
 8012180:	d019      	beq.n	80121b6 <USBD_LL_SetupStage+0x7e>
 8012182:	d822      	bhi.n	80121ca <USBD_LL_SetupStage+0x92>
 8012184:	2b00      	cmp	r3, #0
 8012186:	d002      	beq.n	801218e <USBD_LL_SetupStage+0x56>
 8012188:	2b01      	cmp	r3, #1
 801218a:	d00a      	beq.n	80121a2 <USBD_LL_SetupStage+0x6a>
 801218c:	e01d      	b.n	80121ca <USBD_LL_SetupStage+0x92>
  {
    case USB_REQ_RECIPIENT_DEVICE:
      USBD_StdDevReq(pdev, &pdev->request);
 801218e:	687b      	ldr	r3, [r7, #4]
 8012190:	22aa      	movs	r2, #170	; 0xaa
 8012192:	0092      	lsls	r2, r2, #2
 8012194:	189a      	adds	r2, r3, r2
 8012196:	687b      	ldr	r3, [r7, #4]
 8012198:	0011      	movs	r1, r2
 801219a:	0018      	movs	r0, r3
 801219c:	f000 fa10 	bl	80125c0 <USBD_StdDevReq>
      break;
 80121a0:	e020      	b.n	80121e4 <USBD_LL_SetupStage+0xac>

    case USB_REQ_RECIPIENT_INTERFACE:
      USBD_StdItfReq(pdev, &pdev->request);
 80121a2:	687b      	ldr	r3, [r7, #4]
 80121a4:	22aa      	movs	r2, #170	; 0xaa
 80121a6:	0092      	lsls	r2, r2, #2
 80121a8:	189a      	adds	r2, r3, r2
 80121aa:	687b      	ldr	r3, [r7, #4]
 80121ac:	0011      	movs	r1, r2
 80121ae:	0018      	movs	r0, r3
 80121b0:	f000 fa78 	bl	80126a4 <USBD_StdItfReq>
      break;
 80121b4:	e016      	b.n	80121e4 <USBD_LL_SetupStage+0xac>

    case USB_REQ_RECIPIENT_ENDPOINT:
      USBD_StdEPReq(pdev, &pdev->request);
 80121b6:	687b      	ldr	r3, [r7, #4]
 80121b8:	22aa      	movs	r2, #170	; 0xaa
 80121ba:	0092      	lsls	r2, r2, #2
 80121bc:	189a      	adds	r2, r3, r2
 80121be:	687b      	ldr	r3, [r7, #4]
 80121c0:	0011      	movs	r1, r2
 80121c2:	0018      	movs	r0, r3
 80121c4:	f000 fac5 	bl	8012752 <USBD_StdEPReq>
      break;
 80121c8:	e00c      	b.n	80121e4 <USBD_LL_SetupStage+0xac>

    default:
      USBD_LL_StallEP(pdev, (pdev->request.bmRequest & 0x80U));
 80121ca:	687a      	ldr	r2, [r7, #4]
 80121cc:	23aa      	movs	r3, #170	; 0xaa
 80121ce:	009b      	lsls	r3, r3, #2
 80121d0:	5cd3      	ldrb	r3, [r2, r3]
 80121d2:	227f      	movs	r2, #127	; 0x7f
 80121d4:	4393      	bics	r3, r2
 80121d6:	b2da      	uxtb	r2, r3
 80121d8:	687b      	ldr	r3, [r7, #4]
 80121da:	0011      	movs	r1, r2
 80121dc:	0018      	movs	r0, r3
 80121de:	f002 fd5c 	bl	8014c9a <USBD_LL_StallEP>
      break;
 80121e2:	46c0      	nop			; (mov r8, r8)
  }

  return USBD_OK;
 80121e4:	2300      	movs	r3, #0
}
 80121e6:	0018      	movs	r0, r3
 80121e8:	46bd      	mov	sp, r7
 80121ea:	b002      	add	sp, #8
 80121ec:	bd80      	pop	{r7, pc}
 80121ee:	46c0      	nop			; (mov r8, r8)
 80121f0:	000002ae 	.word	0x000002ae

080121f4 <USBD_LL_DataOutStage>:
* @param  epnum: endpoint index
* @retval status
*/
USBD_StatusTypeDef USBD_LL_DataOutStage(USBD_HandleTypeDef *pdev,
                                        uint8_t epnum, uint8_t *pdata)
{
 80121f4:	b580      	push	{r7, lr}
 80121f6:	b086      	sub	sp, #24
 80121f8:	af00      	add	r7, sp, #0
 80121fa:	60f8      	str	r0, [r7, #12]
 80121fc:	607a      	str	r2, [r7, #4]
 80121fe:	200b      	movs	r0, #11
 8012200:	183b      	adds	r3, r7, r0
 8012202:	1c0a      	adds	r2, r1, #0
 8012204:	701a      	strb	r2, [r3, #0]
  USBD_EndpointTypeDef *pep;

  if (epnum == 0U)
 8012206:	183b      	adds	r3, r7, r0
 8012208:	781b      	ldrb	r3, [r3, #0]
 801220a:	2b00      	cmp	r3, #0
 801220c:	d154      	bne.n	80122b8 <USBD_LL_DataOutStage+0xc4>
  {
    pep = &pdev->ep_out[0];
 801220e:	68fb      	ldr	r3, [r7, #12]
 8012210:	3355      	adds	r3, #85	; 0x55
 8012212:	33ff      	adds	r3, #255	; 0xff
 8012214:	617b      	str	r3, [r7, #20]

    if (pdev->ep0_state == USBD_EP0_DATA_OUT)
 8012216:	68fa      	ldr	r2, [r7, #12]
 8012218:	23a5      	movs	r3, #165	; 0xa5
 801221a:	009b      	lsls	r3, r3, #2
 801221c:	58d3      	ldr	r3, [r2, r3]
 801221e:	2b03      	cmp	r3, #3
 8012220:	d139      	bne.n	8012296 <USBD_LL_DataOutStage+0xa2>
    {
      if (pep->rem_length > pep->maxpacket)
 8012222:	697b      	ldr	r3, [r7, #20]
 8012224:	68da      	ldr	r2, [r3, #12]
 8012226:	697b      	ldr	r3, [r7, #20]
 8012228:	691b      	ldr	r3, [r3, #16]
 801222a:	429a      	cmp	r2, r3
 801222c:	d919      	bls.n	8012262 <USBD_LL_DataOutStage+0x6e>
      {
        pep->rem_length -= pep->maxpacket;
 801222e:	697b      	ldr	r3, [r7, #20]
 8012230:	68da      	ldr	r2, [r3, #12]
 8012232:	697b      	ldr	r3, [r7, #20]
 8012234:	691b      	ldr	r3, [r3, #16]
 8012236:	1ad2      	subs	r2, r2, r3
 8012238:	697b      	ldr	r3, [r7, #20]
 801223a:	60da      	str	r2, [r3, #12]

        USBD_CtlContinueRx(pdev, pdata,
                           (uint16_t)MIN(pep->rem_length, pep->maxpacket));
 801223c:	697b      	ldr	r3, [r7, #20]
 801223e:	68da      	ldr	r2, [r3, #12]
 8012240:	697b      	ldr	r3, [r7, #20]
 8012242:	691b      	ldr	r3, [r3, #16]
        USBD_CtlContinueRx(pdev, pdata,
 8012244:	429a      	cmp	r2, r3
 8012246:	d203      	bcs.n	8012250 <USBD_LL_DataOutStage+0x5c>
                           (uint16_t)MIN(pep->rem_length, pep->maxpacket));
 8012248:	697b      	ldr	r3, [r7, #20]
 801224a:	68db      	ldr	r3, [r3, #12]
        USBD_CtlContinueRx(pdev, pdata,
 801224c:	b29b      	uxth	r3, r3
 801224e:	e002      	b.n	8012256 <USBD_LL_DataOutStage+0x62>
                           (uint16_t)MIN(pep->rem_length, pep->maxpacket));
 8012250:	697b      	ldr	r3, [r7, #20]
 8012252:	691b      	ldr	r3, [r3, #16]
        USBD_CtlContinueRx(pdev, pdata,
 8012254:	b29b      	uxth	r3, r3
 8012256:	6879      	ldr	r1, [r7, #4]
 8012258:	68f8      	ldr	r0, [r7, #12]
 801225a:	001a      	movs	r2, r3
 801225c:	f001 f89b 	bl	8013396 <USBD_CtlContinueRx>
 8012260:	e045      	b.n	80122ee <USBD_LL_DataOutStage+0xfa>
      }
      else
      {
        if ((pdev->pClass->EP0_RxReady != NULL) &&
 8012262:	68fa      	ldr	r2, [r7, #12]
 8012264:	23ad      	movs	r3, #173	; 0xad
 8012266:	009b      	lsls	r3, r3, #2
 8012268:	58d3      	ldr	r3, [r2, r3]
 801226a:	691b      	ldr	r3, [r3, #16]
 801226c:	2b00      	cmp	r3, #0
 801226e:	d00d      	beq.n	801228c <USBD_LL_DataOutStage+0x98>
            (pdev->dev_state == USBD_STATE_CONFIGURED))
 8012270:	68fa      	ldr	r2, [r7, #12]
 8012272:	23a7      	movs	r3, #167	; 0xa7
 8012274:	009b      	lsls	r3, r3, #2
 8012276:	5cd3      	ldrb	r3, [r2, r3]
        if ((pdev->pClass->EP0_RxReady != NULL) &&
 8012278:	2b03      	cmp	r3, #3
 801227a:	d107      	bne.n	801228c <USBD_LL_DataOutStage+0x98>
        {
          pdev->pClass->EP0_RxReady(pdev);
 801227c:	68fa      	ldr	r2, [r7, #12]
 801227e:	23ad      	movs	r3, #173	; 0xad
 8012280:	009b      	lsls	r3, r3, #2
 8012282:	58d3      	ldr	r3, [r2, r3]
 8012284:	691b      	ldr	r3, [r3, #16]
 8012286:	68fa      	ldr	r2, [r7, #12]
 8012288:	0010      	movs	r0, r2
 801228a:	4798      	blx	r3
        }
        USBD_CtlSendStatus(pdev);
 801228c:	68fb      	ldr	r3, [r7, #12]
 801228e:	0018      	movs	r0, r3
 8012290:	f001 f894 	bl	80133bc <USBD_CtlSendStatus>
 8012294:	e02b      	b.n	80122ee <USBD_LL_DataOutStage+0xfa>
      }
    }
    else
    {
      if (pdev->ep0_state == USBD_EP0_STATUS_OUT)
 8012296:	68fa      	ldr	r2, [r7, #12]
 8012298:	23a5      	movs	r3, #165	; 0xa5
 801229a:	009b      	lsls	r3, r3, #2
 801229c:	58d3      	ldr	r3, [r2, r3]
 801229e:	2b05      	cmp	r3, #5
 80122a0:	d125      	bne.n	80122ee <USBD_LL_DataOutStage+0xfa>
      {
        /*
         * STATUS PHASE completed, update ep0_state to idle
         */
        pdev->ep0_state = USBD_EP0_IDLE;
 80122a2:	68fa      	ldr	r2, [r7, #12]
 80122a4:	23a5      	movs	r3, #165	; 0xa5
 80122a6:	009b      	lsls	r3, r3, #2
 80122a8:	2100      	movs	r1, #0
 80122aa:	50d1      	str	r1, [r2, r3]
        USBD_LL_StallEP(pdev, 0U);
 80122ac:	68fb      	ldr	r3, [r7, #12]
 80122ae:	2100      	movs	r1, #0
 80122b0:	0018      	movs	r0, r3
 80122b2:	f002 fcf2 	bl	8014c9a <USBD_LL_StallEP>
 80122b6:	e01a      	b.n	80122ee <USBD_LL_DataOutStage+0xfa>
      }
    }
  }
  else if ((pdev->pClass->DataOut != NULL) &&
 80122b8:	68fa      	ldr	r2, [r7, #12]
 80122ba:	23ad      	movs	r3, #173	; 0xad
 80122bc:	009b      	lsls	r3, r3, #2
 80122be:	58d3      	ldr	r3, [r2, r3]
 80122c0:	699b      	ldr	r3, [r3, #24]
 80122c2:	2b00      	cmp	r3, #0
 80122c4:	d011      	beq.n	80122ea <USBD_LL_DataOutStage+0xf6>
           (pdev->dev_state == USBD_STATE_CONFIGURED))
 80122c6:	68fa      	ldr	r2, [r7, #12]
 80122c8:	23a7      	movs	r3, #167	; 0xa7
 80122ca:	009b      	lsls	r3, r3, #2
 80122cc:	5cd3      	ldrb	r3, [r2, r3]
  else if ((pdev->pClass->DataOut != NULL) &&
 80122ce:	2b03      	cmp	r3, #3
 80122d0:	d10b      	bne.n	80122ea <USBD_LL_DataOutStage+0xf6>
  {
    pdev->pClass->DataOut(pdev, epnum);
 80122d2:	68fa      	ldr	r2, [r7, #12]
 80122d4:	23ad      	movs	r3, #173	; 0xad
 80122d6:	009b      	lsls	r3, r3, #2
 80122d8:	58d3      	ldr	r3, [r2, r3]
 80122da:	699b      	ldr	r3, [r3, #24]
 80122dc:	220b      	movs	r2, #11
 80122de:	18ba      	adds	r2, r7, r2
 80122e0:	7811      	ldrb	r1, [r2, #0]
 80122e2:	68fa      	ldr	r2, [r7, #12]
 80122e4:	0010      	movs	r0, r2
 80122e6:	4798      	blx	r3
 80122e8:	e001      	b.n	80122ee <USBD_LL_DataOutStage+0xfa>
  }
  else
  {
    /* should never be in this condition */
    return USBD_FAIL;
 80122ea:	2302      	movs	r3, #2
 80122ec:	e000      	b.n	80122f0 <USBD_LL_DataOutStage+0xfc>
  }

  return USBD_OK;
 80122ee:	2300      	movs	r3, #0
}
 80122f0:	0018      	movs	r0, r3
 80122f2:	46bd      	mov	sp, r7
 80122f4:	b006      	add	sp, #24
 80122f6:	bd80      	pop	{r7, pc}

080122f8 <USBD_LL_DataInStage>:
* @param  epnum: endpoint index
* @retval status
*/
USBD_StatusTypeDef USBD_LL_DataInStage(USBD_HandleTypeDef *pdev,
                                       uint8_t epnum, uint8_t *pdata)
{
 80122f8:	b580      	push	{r7, lr}
 80122fa:	b086      	sub	sp, #24
 80122fc:	af00      	add	r7, sp, #0
 80122fe:	60f8      	str	r0, [r7, #12]
 8012300:	607a      	str	r2, [r7, #4]
 8012302:	200b      	movs	r0, #11
 8012304:	183b      	adds	r3, r7, r0
 8012306:	1c0a      	adds	r2, r1, #0
 8012308:	701a      	strb	r2, [r3, #0]
  USBD_EndpointTypeDef *pep;

  if (epnum == 0U)
 801230a:	183b      	adds	r3, r7, r0
 801230c:	781b      	ldrb	r3, [r3, #0]
 801230e:	2b00      	cmp	r3, #0
 8012310:	d000      	beq.n	8012314 <USBD_LL_DataInStage+0x1c>
 8012312:	e08e      	b.n	8012432 <USBD_LL_DataInStage+0x13a>
  {
    pep = &pdev->ep_in[0];
 8012314:	68fb      	ldr	r3, [r7, #12]
 8012316:	3314      	adds	r3, #20
 8012318:	617b      	str	r3, [r7, #20]

    if (pdev->ep0_state == USBD_EP0_DATA_IN)
 801231a:	68fa      	ldr	r2, [r7, #12]
 801231c:	23a5      	movs	r3, #165	; 0xa5
 801231e:	009b      	lsls	r3, r3, #2
 8012320:	58d3      	ldr	r3, [r2, r3]
 8012322:	2b02      	cmp	r3, #2
 8012324:	d164      	bne.n	80123f0 <USBD_LL_DataInStage+0xf8>
    {
      if (pep->rem_length > pep->maxpacket)
 8012326:	697b      	ldr	r3, [r7, #20]
 8012328:	68da      	ldr	r2, [r3, #12]
 801232a:	697b      	ldr	r3, [r7, #20]
 801232c:	691b      	ldr	r3, [r3, #16]
 801232e:	429a      	cmp	r2, r3
 8012330:	d915      	bls.n	801235e <USBD_LL_DataInStage+0x66>
      {
        pep->rem_length -= pep->maxpacket;
 8012332:	697b      	ldr	r3, [r7, #20]
 8012334:	68da      	ldr	r2, [r3, #12]
 8012336:	697b      	ldr	r3, [r7, #20]
 8012338:	691b      	ldr	r3, [r3, #16]
 801233a:	1ad2      	subs	r2, r2, r3
 801233c:	697b      	ldr	r3, [r7, #20]
 801233e:	60da      	str	r2, [r3, #12]

        USBD_CtlContinueSendData(pdev, pdata, (uint16_t)pep->rem_length);
 8012340:	697b      	ldr	r3, [r7, #20]
 8012342:	68db      	ldr	r3, [r3, #12]
 8012344:	b29a      	uxth	r2, r3
 8012346:	6879      	ldr	r1, [r7, #4]
 8012348:	68fb      	ldr	r3, [r7, #12]
 801234a:	0018      	movs	r0, r3
 801234c:	f000 ffec 	bl	8013328 <USBD_CtlContinueSendData>

        /* Prepare endpoint for premature end of transfer */
        USBD_LL_PrepareReceive(pdev, 0U, NULL, 0U);
 8012350:	68f8      	ldr	r0, [r7, #12]
 8012352:	2300      	movs	r3, #0
 8012354:	2200      	movs	r2, #0
 8012356:	2100      	movs	r1, #0
 8012358:	f002 fd88 	bl	8014e6c <USBD_LL_PrepareReceive>
 801235c:	e059      	b.n	8012412 <USBD_LL_DataInStage+0x11a>
      }
      else
      {
        /* last packet is MPS multiple, so send ZLP packet */
        if ((pep->total_length % pep->maxpacket == 0U) &&
 801235e:	697b      	ldr	r3, [r7, #20]
 8012360:	689a      	ldr	r2, [r3, #8]
 8012362:	697b      	ldr	r3, [r7, #20]
 8012364:	691b      	ldr	r3, [r3, #16]
 8012366:	0019      	movs	r1, r3
 8012368:	0010      	movs	r0, r2
 801236a:	f7f6 ff65 	bl	8009238 <__aeabi_uidivmod>
 801236e:	1e0b      	subs	r3, r1, #0
 8012370:	d11f      	bne.n	80123b2 <USBD_LL_DataInStage+0xba>
            (pep->total_length >= pep->maxpacket) &&
 8012372:	697b      	ldr	r3, [r7, #20]
 8012374:	689a      	ldr	r2, [r3, #8]
 8012376:	697b      	ldr	r3, [r7, #20]
 8012378:	691b      	ldr	r3, [r3, #16]
        if ((pep->total_length % pep->maxpacket == 0U) &&
 801237a:	429a      	cmp	r2, r3
 801237c:	d319      	bcc.n	80123b2 <USBD_LL_DataInStage+0xba>
            (pep->total_length < pdev->ep0_data_len))
 801237e:	697b      	ldr	r3, [r7, #20]
 8012380:	689a      	ldr	r2, [r3, #8]
 8012382:	68f9      	ldr	r1, [r7, #12]
 8012384:	23a6      	movs	r3, #166	; 0xa6
 8012386:	009b      	lsls	r3, r3, #2
 8012388:	58cb      	ldr	r3, [r1, r3]
            (pep->total_length >= pep->maxpacket) &&
 801238a:	429a      	cmp	r2, r3
 801238c:	d211      	bcs.n	80123b2 <USBD_LL_DataInStage+0xba>
        {
          USBD_CtlContinueSendData(pdev, NULL, 0U);
 801238e:	68fb      	ldr	r3, [r7, #12]
 8012390:	2200      	movs	r2, #0
 8012392:	2100      	movs	r1, #0
 8012394:	0018      	movs	r0, r3
 8012396:	f000 ffc7 	bl	8013328 <USBD_CtlContinueSendData>
          pdev->ep0_data_len = 0U;
 801239a:	68fa      	ldr	r2, [r7, #12]
 801239c:	23a6      	movs	r3, #166	; 0xa6
 801239e:	009b      	lsls	r3, r3, #2
 80123a0:	2100      	movs	r1, #0
 80123a2:	50d1      	str	r1, [r2, r3]

          /* Prepare endpoint for premature end of transfer */
          USBD_LL_PrepareReceive(pdev, 0U, NULL, 0U);
 80123a4:	68f8      	ldr	r0, [r7, #12]
 80123a6:	2300      	movs	r3, #0
 80123a8:	2200      	movs	r2, #0
 80123aa:	2100      	movs	r1, #0
 80123ac:	f002 fd5e 	bl	8014e6c <USBD_LL_PrepareReceive>
 80123b0:	e02f      	b.n	8012412 <USBD_LL_DataInStage+0x11a>
        }
        else
        {
          if ((pdev->pClass->EP0_TxSent != NULL) &&
 80123b2:	68fa      	ldr	r2, [r7, #12]
 80123b4:	23ad      	movs	r3, #173	; 0xad
 80123b6:	009b      	lsls	r3, r3, #2
 80123b8:	58d3      	ldr	r3, [r2, r3]
 80123ba:	68db      	ldr	r3, [r3, #12]
 80123bc:	2b00      	cmp	r3, #0
 80123be:	d00d      	beq.n	80123dc <USBD_LL_DataInStage+0xe4>
              (pdev->dev_state == USBD_STATE_CONFIGURED))
 80123c0:	68fa      	ldr	r2, [r7, #12]
 80123c2:	23a7      	movs	r3, #167	; 0xa7
 80123c4:	009b      	lsls	r3, r3, #2
 80123c6:	5cd3      	ldrb	r3, [r2, r3]
          if ((pdev->pClass->EP0_TxSent != NULL) &&
 80123c8:	2b03      	cmp	r3, #3
 80123ca:	d107      	bne.n	80123dc <USBD_LL_DataInStage+0xe4>
          {
            pdev->pClass->EP0_TxSent(pdev);
 80123cc:	68fa      	ldr	r2, [r7, #12]
 80123ce:	23ad      	movs	r3, #173	; 0xad
 80123d0:	009b      	lsls	r3, r3, #2
 80123d2:	58d3      	ldr	r3, [r2, r3]
 80123d4:	68db      	ldr	r3, [r3, #12]
 80123d6:	68fa      	ldr	r2, [r7, #12]
 80123d8:	0010      	movs	r0, r2
 80123da:	4798      	blx	r3
          }
          USBD_LL_StallEP(pdev, 0x80U);
 80123dc:	68fb      	ldr	r3, [r7, #12]
 80123de:	2180      	movs	r1, #128	; 0x80
 80123e0:	0018      	movs	r0, r3
 80123e2:	f002 fc5a 	bl	8014c9a <USBD_LL_StallEP>
          USBD_CtlReceiveStatus(pdev);
 80123e6:	68fb      	ldr	r3, [r7, #12]
 80123e8:	0018      	movs	r0, r3
 80123ea:	f000 fffb 	bl	80133e4 <USBD_CtlReceiveStatus>
 80123ee:	e010      	b.n	8012412 <USBD_LL_DataInStage+0x11a>
        }
      }
    }
    else
    {
      if ((pdev->ep0_state == USBD_EP0_STATUS_IN) ||
 80123f0:	68fa      	ldr	r2, [r7, #12]
 80123f2:	23a5      	movs	r3, #165	; 0xa5
 80123f4:	009b      	lsls	r3, r3, #2
 80123f6:	58d3      	ldr	r3, [r2, r3]
 80123f8:	2b04      	cmp	r3, #4
 80123fa:	d005      	beq.n	8012408 <USBD_LL_DataInStage+0x110>
          (pdev->ep0_state == USBD_EP0_IDLE))
 80123fc:	68fa      	ldr	r2, [r7, #12]
 80123fe:	23a5      	movs	r3, #165	; 0xa5
 8012400:	009b      	lsls	r3, r3, #2
 8012402:	58d3      	ldr	r3, [r2, r3]
      if ((pdev->ep0_state == USBD_EP0_STATUS_IN) ||
 8012404:	2b00      	cmp	r3, #0
 8012406:	d104      	bne.n	8012412 <USBD_LL_DataInStage+0x11a>
      {
        USBD_LL_StallEP(pdev, 0x80U);
 8012408:	68fb      	ldr	r3, [r7, #12]
 801240a:	2180      	movs	r1, #128	; 0x80
 801240c:	0018      	movs	r0, r3
 801240e:	f002 fc44 	bl	8014c9a <USBD_LL_StallEP>
      }
    }

    if (pdev->dev_test_mode == 1U)
 8012412:	68fa      	ldr	r2, [r7, #12]
 8012414:	23a8      	movs	r3, #168	; 0xa8
 8012416:	009b      	lsls	r3, r3, #2
 8012418:	5cd3      	ldrb	r3, [r2, r3]
 801241a:	2b01      	cmp	r3, #1
 801241c:	d124      	bne.n	8012468 <USBD_LL_DataInStage+0x170>
    {
      USBD_RunTestMode(pdev);
 801241e:	68fb      	ldr	r3, [r7, #12]
 8012420:	0018      	movs	r0, r3
 8012422:	f7ff fe42 	bl	80120aa <USBD_RunTestMode>
      pdev->dev_test_mode = 0U;
 8012426:	68fa      	ldr	r2, [r7, #12]
 8012428:	23a8      	movs	r3, #168	; 0xa8
 801242a:	009b      	lsls	r3, r3, #2
 801242c:	2100      	movs	r1, #0
 801242e:	54d1      	strb	r1, [r2, r3]
 8012430:	e01a      	b.n	8012468 <USBD_LL_DataInStage+0x170>
    }
  }
  else if ((pdev->pClass->DataIn != NULL) &&
 8012432:	68fa      	ldr	r2, [r7, #12]
 8012434:	23ad      	movs	r3, #173	; 0xad
 8012436:	009b      	lsls	r3, r3, #2
 8012438:	58d3      	ldr	r3, [r2, r3]
 801243a:	695b      	ldr	r3, [r3, #20]
 801243c:	2b00      	cmp	r3, #0
 801243e:	d011      	beq.n	8012464 <USBD_LL_DataInStage+0x16c>
           (pdev->dev_state == USBD_STATE_CONFIGURED))
 8012440:	68fa      	ldr	r2, [r7, #12]
 8012442:	23a7      	movs	r3, #167	; 0xa7
 8012444:	009b      	lsls	r3, r3, #2
 8012446:	5cd3      	ldrb	r3, [r2, r3]
  else if ((pdev->pClass->DataIn != NULL) &&
 8012448:	2b03      	cmp	r3, #3
 801244a:	d10b      	bne.n	8012464 <USBD_LL_DataInStage+0x16c>
  {
    pdev->pClass->DataIn(pdev, epnum);
 801244c:	68fa      	ldr	r2, [r7, #12]
 801244e:	23ad      	movs	r3, #173	; 0xad
 8012450:	009b      	lsls	r3, r3, #2
 8012452:	58d3      	ldr	r3, [r2, r3]
 8012454:	695b      	ldr	r3, [r3, #20]
 8012456:	220b      	movs	r2, #11
 8012458:	18ba      	adds	r2, r7, r2
 801245a:	7811      	ldrb	r1, [r2, #0]
 801245c:	68fa      	ldr	r2, [r7, #12]
 801245e:	0010      	movs	r0, r2
 8012460:	4798      	blx	r3
 8012462:	e001      	b.n	8012468 <USBD_LL_DataInStage+0x170>
  }
  else
  {
    /* should never be in this condition */
    return USBD_FAIL;
 8012464:	2302      	movs	r3, #2
 8012466:	e000      	b.n	801246a <USBD_LL_DataInStage+0x172>
  }

  return USBD_OK;
 8012468:	2300      	movs	r3, #0
}
 801246a:	0018      	movs	r0, r3
 801246c:	46bd      	mov	sp, r7
 801246e:	b006      	add	sp, #24
 8012470:	bd80      	pop	{r7, pc}

08012472 <USBD_LL_Reset>:
* @param  pdev: device instance
* @retval status
*/

USBD_StatusTypeDef USBD_LL_Reset(USBD_HandleTypeDef *pdev)
{
 8012472:	b580      	push	{r7, lr}
 8012474:	b082      	sub	sp, #8
 8012476:	af00      	add	r7, sp, #0
 8012478:	6078      	str	r0, [r7, #4]
  /* Open EP0 OUT */
  USBD_LL_OpenEP(pdev, 0x00U, USBD_EP_TYPE_CTRL, USB_MAX_EP0_SIZE);
 801247a:	6878      	ldr	r0, [r7, #4]
 801247c:	2340      	movs	r3, #64	; 0x40
 801247e:	2200      	movs	r2, #0
 8012480:	2100      	movs	r1, #0
 8012482:	f002 fba8 	bl	8014bd6 <USBD_LL_OpenEP>
  pdev->ep_out[0x00U & 0xFU].is_used = 1U;
 8012486:	687a      	ldr	r2, [r7, #4]
 8012488:	23ac      	movs	r3, #172	; 0xac
 801248a:	005b      	lsls	r3, r3, #1
 801248c:	2101      	movs	r1, #1
 801248e:	50d1      	str	r1, [r2, r3]

  pdev->ep_out[0].maxpacket = USB_MAX_EP0_SIZE;
 8012490:	687a      	ldr	r2, [r7, #4]
 8012492:	23b2      	movs	r3, #178	; 0xb2
 8012494:	005b      	lsls	r3, r3, #1
 8012496:	2140      	movs	r1, #64	; 0x40
 8012498:	50d1      	str	r1, [r2, r3]

  /* Open EP0 IN */
  USBD_LL_OpenEP(pdev, 0x80U, USBD_EP_TYPE_CTRL, USB_MAX_EP0_SIZE);
 801249a:	6878      	ldr	r0, [r7, #4]
 801249c:	2340      	movs	r3, #64	; 0x40
 801249e:	2200      	movs	r2, #0
 80124a0:	2180      	movs	r1, #128	; 0x80
 80124a2:	f002 fb98 	bl	8014bd6 <USBD_LL_OpenEP>
  pdev->ep_in[0x80U & 0xFU].is_used = 1U;
 80124a6:	687b      	ldr	r3, [r7, #4]
 80124a8:	2201      	movs	r2, #1
 80124aa:	619a      	str	r2, [r3, #24]

  pdev->ep_in[0].maxpacket = USB_MAX_EP0_SIZE;
 80124ac:	687b      	ldr	r3, [r7, #4]
 80124ae:	2240      	movs	r2, #64	; 0x40
 80124b0:	625a      	str	r2, [r3, #36]	; 0x24

  /* Upon Reset call user call back */
  pdev->dev_state = USBD_STATE_DEFAULT;
 80124b2:	687a      	ldr	r2, [r7, #4]
 80124b4:	23a7      	movs	r3, #167	; 0xa7
 80124b6:	009b      	lsls	r3, r3, #2
 80124b8:	2101      	movs	r1, #1
 80124ba:	54d1      	strb	r1, [r2, r3]
  pdev->ep0_state = USBD_EP0_IDLE;
 80124bc:	687a      	ldr	r2, [r7, #4]
 80124be:	23a5      	movs	r3, #165	; 0xa5
 80124c0:	009b      	lsls	r3, r3, #2
 80124c2:	2100      	movs	r1, #0
 80124c4:	50d1      	str	r1, [r2, r3]
  pdev->dev_config = 0U;
 80124c6:	687b      	ldr	r3, [r7, #4]
 80124c8:	2200      	movs	r2, #0
 80124ca:	605a      	str	r2, [r3, #4]
  pdev->dev_remote_wakeup = 0U;
 80124cc:	687a      	ldr	r2, [r7, #4]
 80124ce:	23a9      	movs	r3, #169	; 0xa9
 80124d0:	009b      	lsls	r3, r3, #2
 80124d2:	2100      	movs	r1, #0
 80124d4:	50d1      	str	r1, [r2, r3]

  if (pdev->pClassData)
 80124d6:	687a      	ldr	r2, [r7, #4]
 80124d8:	23ae      	movs	r3, #174	; 0xae
 80124da:	009b      	lsls	r3, r3, #2
 80124dc:	58d3      	ldr	r3, [r2, r3]
 80124de:	2b00      	cmp	r3, #0
 80124e0:	d00a      	beq.n	80124f8 <USBD_LL_Reset+0x86>
  {
    pdev->pClass->DeInit(pdev, (uint8_t)pdev->dev_config);
 80124e2:	687a      	ldr	r2, [r7, #4]
 80124e4:	23ad      	movs	r3, #173	; 0xad
 80124e6:	009b      	lsls	r3, r3, #2
 80124e8:	58d3      	ldr	r3, [r2, r3]
 80124ea:	685a      	ldr	r2, [r3, #4]
 80124ec:	687b      	ldr	r3, [r7, #4]
 80124ee:	685b      	ldr	r3, [r3, #4]
 80124f0:	b2d9      	uxtb	r1, r3
 80124f2:	687b      	ldr	r3, [r7, #4]
 80124f4:	0018      	movs	r0, r3
 80124f6:	4790      	blx	r2
  }

  return USBD_OK;
 80124f8:	2300      	movs	r3, #0
}
 80124fa:	0018      	movs	r0, r3
 80124fc:	46bd      	mov	sp, r7
 80124fe:	b002      	add	sp, #8
 8012500:	bd80      	pop	{r7, pc}

08012502 <USBD_LL_SetSpeed>:
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_LL_SetSpeed(USBD_HandleTypeDef *pdev,
                                    USBD_SpeedTypeDef speed)
{
 8012502:	b580      	push	{r7, lr}
 8012504:	b082      	sub	sp, #8
 8012506:	af00      	add	r7, sp, #0
 8012508:	6078      	str	r0, [r7, #4]
 801250a:	000a      	movs	r2, r1
 801250c:	1cfb      	adds	r3, r7, #3
 801250e:	701a      	strb	r2, [r3, #0]
  pdev->dev_speed = speed;
 8012510:	687b      	ldr	r3, [r7, #4]
 8012512:	1cfa      	adds	r2, r7, #3
 8012514:	7812      	ldrb	r2, [r2, #0]
 8012516:	741a      	strb	r2, [r3, #16]

  return USBD_OK;
 8012518:	2300      	movs	r3, #0
}
 801251a:	0018      	movs	r0, r3
 801251c:	46bd      	mov	sp, r7
 801251e:	b002      	add	sp, #8
 8012520:	bd80      	pop	{r7, pc}
	...

08012524 <USBD_LL_Suspend>:
* @param  pdev: device instance
* @retval status
*/

USBD_StatusTypeDef USBD_LL_Suspend(USBD_HandleTypeDef *pdev)
{
 8012524:	b580      	push	{r7, lr}
 8012526:	b082      	sub	sp, #8
 8012528:	af00      	add	r7, sp, #0
 801252a:	6078      	str	r0, [r7, #4]
  pdev->dev_old_state =  pdev->dev_state;
 801252c:	687a      	ldr	r2, [r7, #4]
 801252e:	23a7      	movs	r3, #167	; 0xa7
 8012530:	009b      	lsls	r3, r3, #2
 8012532:	5cd1      	ldrb	r1, [r2, r3]
 8012534:	687b      	ldr	r3, [r7, #4]
 8012536:	4a06      	ldr	r2, [pc, #24]	; (8012550 <USBD_LL_Suspend+0x2c>)
 8012538:	5499      	strb	r1, [r3, r2]
  pdev->dev_state  = USBD_STATE_SUSPENDED;
 801253a:	687a      	ldr	r2, [r7, #4]
 801253c:	23a7      	movs	r3, #167	; 0xa7
 801253e:	009b      	lsls	r3, r3, #2
 8012540:	2104      	movs	r1, #4
 8012542:	54d1      	strb	r1, [r2, r3]

  return USBD_OK;
 8012544:	2300      	movs	r3, #0
}
 8012546:	0018      	movs	r0, r3
 8012548:	46bd      	mov	sp, r7
 801254a:	b002      	add	sp, #8
 801254c:	bd80      	pop	{r7, pc}
 801254e:	46c0      	nop			; (mov r8, r8)
 8012550:	0000029d 	.word	0x0000029d

08012554 <USBD_LL_Resume>:
* @param  pdev: device instance
* @retval status
*/

USBD_StatusTypeDef USBD_LL_Resume(USBD_HandleTypeDef *pdev)
{
 8012554:	b580      	push	{r7, lr}
 8012556:	b082      	sub	sp, #8
 8012558:	af00      	add	r7, sp, #0
 801255a:	6078      	str	r0, [r7, #4]
  if (pdev->dev_state == USBD_STATE_SUSPENDED)
 801255c:	687a      	ldr	r2, [r7, #4]
 801255e:	23a7      	movs	r3, #167	; 0xa7
 8012560:	009b      	lsls	r3, r3, #2
 8012562:	5cd3      	ldrb	r3, [r2, r3]
 8012564:	2b04      	cmp	r3, #4
 8012566:	d106      	bne.n	8012576 <USBD_LL_Resume+0x22>
  {
    pdev->dev_state = pdev->dev_old_state;
 8012568:	687b      	ldr	r3, [r7, #4]
 801256a:	4a05      	ldr	r2, [pc, #20]	; (8012580 <USBD_LL_Resume+0x2c>)
 801256c:	5c99      	ldrb	r1, [r3, r2]
 801256e:	687a      	ldr	r2, [r7, #4]
 8012570:	23a7      	movs	r3, #167	; 0xa7
 8012572:	009b      	lsls	r3, r3, #2
 8012574:	54d1      	strb	r1, [r2, r3]
  }

  return USBD_OK;
 8012576:	2300      	movs	r3, #0
}
 8012578:	0018      	movs	r0, r3
 801257a:	46bd      	mov	sp, r7
 801257c:	b002      	add	sp, #8
 801257e:	bd80      	pop	{r7, pc}
 8012580:	0000029d 	.word	0x0000029d

08012584 <USBD_LL_SOF>:
* @param  pdev: device instance
* @retval status
*/

USBD_StatusTypeDef USBD_LL_SOF(USBD_HandleTypeDef *pdev)
{
 8012584:	b580      	push	{r7, lr}
 8012586:	b082      	sub	sp, #8
 8012588:	af00      	add	r7, sp, #0
 801258a:	6078      	str	r0, [r7, #4]
  if (pdev->dev_state == USBD_STATE_CONFIGURED)
 801258c:	687a      	ldr	r2, [r7, #4]
 801258e:	23a7      	movs	r3, #167	; 0xa7
 8012590:	009b      	lsls	r3, r3, #2
 8012592:	5cd3      	ldrb	r3, [r2, r3]
 8012594:	2b03      	cmp	r3, #3
 8012596:	d10e      	bne.n	80125b6 <USBD_LL_SOF+0x32>
  {
    if (pdev->pClass->SOF != NULL)
 8012598:	687a      	ldr	r2, [r7, #4]
 801259a:	23ad      	movs	r3, #173	; 0xad
 801259c:	009b      	lsls	r3, r3, #2
 801259e:	58d3      	ldr	r3, [r2, r3]
 80125a0:	69db      	ldr	r3, [r3, #28]
 80125a2:	2b00      	cmp	r3, #0
 80125a4:	d007      	beq.n	80125b6 <USBD_LL_SOF+0x32>
    {
      pdev->pClass->SOF(pdev);
 80125a6:	687a      	ldr	r2, [r7, #4]
 80125a8:	23ad      	movs	r3, #173	; 0xad
 80125aa:	009b      	lsls	r3, r3, #2
 80125ac:	58d3      	ldr	r3, [r2, r3]
 80125ae:	69db      	ldr	r3, [r3, #28]
 80125b0:	687a      	ldr	r2, [r7, #4]
 80125b2:	0010      	movs	r0, r2
 80125b4:	4798      	blx	r3
    }
  }

  return USBD_OK;
 80125b6:	2300      	movs	r3, #0
}
 80125b8:	0018      	movs	r0, r3
 80125ba:	46bd      	mov	sp, r7
 80125bc:	b002      	add	sp, #8
 80125be:	bd80      	pop	{r7, pc}

080125c0 <USBD_StdDevReq>:
* @param  req: usb request
* @retval status
*/
USBD_StatusTypeDef  USBD_StdDevReq(USBD_HandleTypeDef *pdev,
                                   USBD_SetupReqTypedef *req)
{
 80125c0:	b580      	push	{r7, lr}
 80125c2:	b084      	sub	sp, #16
 80125c4:	af00      	add	r7, sp, #0
 80125c6:	6078      	str	r0, [r7, #4]
 80125c8:	6039      	str	r1, [r7, #0]
  USBD_StatusTypeDef ret = USBD_OK;
 80125ca:	230f      	movs	r3, #15
 80125cc:	18fb      	adds	r3, r7, r3
 80125ce:	2200      	movs	r2, #0
 80125d0:	701a      	strb	r2, [r3, #0]

  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 80125d2:	683b      	ldr	r3, [r7, #0]
 80125d4:	781b      	ldrb	r3, [r3, #0]
 80125d6:	001a      	movs	r2, r3
 80125d8:	2360      	movs	r3, #96	; 0x60
 80125da:	4013      	ands	r3, r2
 80125dc:	2b40      	cmp	r3, #64	; 0x40
 80125de:	d004      	beq.n	80125ea <USBD_StdDevReq+0x2a>
 80125e0:	d84f      	bhi.n	8012682 <USBD_StdDevReq+0xc2>
 80125e2:	2b00      	cmp	r3, #0
 80125e4:	d00b      	beq.n	80125fe <USBD_StdDevReq+0x3e>
 80125e6:	2b20      	cmp	r3, #32
 80125e8:	d14b      	bne.n	8012682 <USBD_StdDevReq+0xc2>
  {
    case USB_REQ_TYPE_CLASS:
    case USB_REQ_TYPE_VENDOR:
      pdev->pClass->Setup(pdev, req);
 80125ea:	687a      	ldr	r2, [r7, #4]
 80125ec:	23ad      	movs	r3, #173	; 0xad
 80125ee:	009b      	lsls	r3, r3, #2
 80125f0:	58d3      	ldr	r3, [r2, r3]
 80125f2:	689b      	ldr	r3, [r3, #8]
 80125f4:	6839      	ldr	r1, [r7, #0]
 80125f6:	687a      	ldr	r2, [r7, #4]
 80125f8:	0010      	movs	r0, r2
 80125fa:	4798      	blx	r3
      break;
 80125fc:	e048      	b.n	8012690 <USBD_StdDevReq+0xd0>

    case USB_REQ_TYPE_STANDARD:
      switch (req->bRequest)
 80125fe:	683b      	ldr	r3, [r7, #0]
 8012600:	785b      	ldrb	r3, [r3, #1]
 8012602:	2b09      	cmp	r3, #9
 8012604:	d835      	bhi.n	8012672 <USBD_StdDevReq+0xb2>
 8012606:	009a      	lsls	r2, r3, #2
 8012608:	4b25      	ldr	r3, [pc, #148]	; (80126a0 <USBD_StdDevReq+0xe0>)
 801260a:	18d3      	adds	r3, r2, r3
 801260c:	681b      	ldr	r3, [r3, #0]
 801260e:	469f      	mov	pc, r3
      {
        case USB_REQ_GET_DESCRIPTOR:
          USBD_GetDescriptor(pdev, req);
 8012610:	683a      	ldr	r2, [r7, #0]
 8012612:	687b      	ldr	r3, [r7, #4]
 8012614:	0011      	movs	r1, r2
 8012616:	0018      	movs	r0, r3
 8012618:	f000 fa52 	bl	8012ac0 <USBD_GetDescriptor>
          break;
 801261c:	e030      	b.n	8012680 <USBD_StdDevReq+0xc0>

        case USB_REQ_SET_ADDRESS:
          USBD_SetAddress(pdev, req);
 801261e:	683a      	ldr	r2, [r7, #0]
 8012620:	687b      	ldr	r3, [r7, #4]
 8012622:	0011      	movs	r1, r2
 8012624:	0018      	movs	r0, r3
 8012626:	f000 fbfd 	bl	8012e24 <USBD_SetAddress>
          break;
 801262a:	e029      	b.n	8012680 <USBD_StdDevReq+0xc0>

        case USB_REQ_SET_CONFIGURATION:
          USBD_SetConfig(pdev, req);
 801262c:	683a      	ldr	r2, [r7, #0]
 801262e:	687b      	ldr	r3, [r7, #4]
 8012630:	0011      	movs	r1, r2
 8012632:	0018      	movs	r0, r3
 8012634:	f000 fc4a 	bl	8012ecc <USBD_SetConfig>
          break;
 8012638:	e022      	b.n	8012680 <USBD_StdDevReq+0xc0>

        case USB_REQ_GET_CONFIGURATION:
          USBD_GetConfig(pdev, req);
 801263a:	683a      	ldr	r2, [r7, #0]
 801263c:	687b      	ldr	r3, [r7, #4]
 801263e:	0011      	movs	r1, r2
 8012640:	0018      	movs	r0, r3
 8012642:	f000 fce7 	bl	8013014 <USBD_GetConfig>
          break;
 8012646:	e01b      	b.n	8012680 <USBD_StdDevReq+0xc0>

        case USB_REQ_GET_STATUS:
          USBD_GetStatus(pdev, req);
 8012648:	683a      	ldr	r2, [r7, #0]
 801264a:	687b      	ldr	r3, [r7, #4]
 801264c:	0011      	movs	r1, r2
 801264e:	0018      	movs	r0, r3
 8012650:	f000 fd1b 	bl	801308a <USBD_GetStatus>
          break;
 8012654:	e014      	b.n	8012680 <USBD_StdDevReq+0xc0>

        case USB_REQ_SET_FEATURE:
          USBD_SetFeature(pdev, req);
 8012656:	683a      	ldr	r2, [r7, #0]
 8012658:	687b      	ldr	r3, [r7, #4]
 801265a:	0011      	movs	r1, r2
 801265c:	0018      	movs	r0, r3
 801265e:	f000 fd4e 	bl	80130fe <USBD_SetFeature>
          break;
 8012662:	e00d      	b.n	8012680 <USBD_StdDevReq+0xc0>

        case USB_REQ_CLEAR_FEATURE:
          USBD_ClrFeature(pdev, req);
 8012664:	683a      	ldr	r2, [r7, #0]
 8012666:	687b      	ldr	r3, [r7, #4]
 8012668:	0011      	movs	r1, r2
 801266a:	0018      	movs	r0, r3
 801266c:	f000 fd5d 	bl	801312a <USBD_ClrFeature>
          break;
 8012670:	e006      	b.n	8012680 <USBD_StdDevReq+0xc0>

        default:
          USBD_CtlError(pdev, req);
 8012672:	683a      	ldr	r2, [r7, #0]
 8012674:	687b      	ldr	r3, [r7, #4]
 8012676:	0011      	movs	r1, r2
 8012678:	0018      	movs	r0, r3
 801267a:	f000 fdb7 	bl	80131ec <USBD_CtlError>
          break;
 801267e:	46c0      	nop			; (mov r8, r8)
      }
      break;
 8012680:	e006      	b.n	8012690 <USBD_StdDevReq+0xd0>

    default:
      USBD_CtlError(pdev, req);
 8012682:	683a      	ldr	r2, [r7, #0]
 8012684:	687b      	ldr	r3, [r7, #4]
 8012686:	0011      	movs	r1, r2
 8012688:	0018      	movs	r0, r3
 801268a:	f000 fdaf 	bl	80131ec <USBD_CtlError>
      break;
 801268e:	46c0      	nop			; (mov r8, r8)
  }

  return ret;
 8012690:	230f      	movs	r3, #15
 8012692:	18fb      	adds	r3, r7, r3
 8012694:	781b      	ldrb	r3, [r3, #0]
}
 8012696:	0018      	movs	r0, r3
 8012698:	46bd      	mov	sp, r7
 801269a:	b004      	add	sp, #16
 801269c:	bd80      	pop	{r7, pc}
 801269e:	46c0      	nop			; (mov r8, r8)
 80126a0:	08015d54 	.word	0x08015d54

080126a4 <USBD_StdItfReq>:
* @param  req: usb request
* @retval status
*/
USBD_StatusTypeDef  USBD_StdItfReq(USBD_HandleTypeDef *pdev,
                                   USBD_SetupReqTypedef  *req)
{
 80126a4:	b5b0      	push	{r4, r5, r7, lr}
 80126a6:	b084      	sub	sp, #16
 80126a8:	af00      	add	r7, sp, #0
 80126aa:	6078      	str	r0, [r7, #4]
 80126ac:	6039      	str	r1, [r7, #0]
  USBD_StatusTypeDef ret = USBD_OK;
 80126ae:	230f      	movs	r3, #15
 80126b0:	18fb      	adds	r3, r7, r3
 80126b2:	2200      	movs	r2, #0
 80126b4:	701a      	strb	r2, [r3, #0]

  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 80126b6:	683b      	ldr	r3, [r7, #0]
 80126b8:	781b      	ldrb	r3, [r3, #0]
 80126ba:	001a      	movs	r2, r3
 80126bc:	2360      	movs	r3, #96	; 0x60
 80126be:	4013      	ands	r3, r2
 80126c0:	2b40      	cmp	r3, #64	; 0x40
 80126c2:	d004      	beq.n	80126ce <USBD_StdItfReq+0x2a>
 80126c4:	d839      	bhi.n	801273a <USBD_StdItfReq+0x96>
 80126c6:	2b00      	cmp	r3, #0
 80126c8:	d001      	beq.n	80126ce <USBD_StdItfReq+0x2a>
 80126ca:	2b20      	cmp	r3, #32
 80126cc:	d135      	bne.n	801273a <USBD_StdItfReq+0x96>
  {
    case USB_REQ_TYPE_CLASS:
    case USB_REQ_TYPE_VENDOR:
    case USB_REQ_TYPE_STANDARD:
      switch (pdev->dev_state)
 80126ce:	687a      	ldr	r2, [r7, #4]
 80126d0:	23a7      	movs	r3, #167	; 0xa7
 80126d2:	009b      	lsls	r3, r3, #2
 80126d4:	5cd3      	ldrb	r3, [r2, r3]
 80126d6:	3b01      	subs	r3, #1
 80126d8:	2b02      	cmp	r3, #2
 80126da:	d825      	bhi.n	8012728 <USBD_StdItfReq+0x84>
      {
        case USBD_STATE_DEFAULT:
        case USBD_STATE_ADDRESSED:
        case USBD_STATE_CONFIGURED:

          if (LOBYTE(req->wIndex) <= USBD_MAX_NUM_INTERFACES)
 80126dc:	683b      	ldr	r3, [r7, #0]
 80126de:	889b      	ldrh	r3, [r3, #4]
 80126e0:	b2db      	uxtb	r3, r3
 80126e2:	2b01      	cmp	r3, #1
 80126e4:	d819      	bhi.n	801271a <USBD_StdItfReq+0x76>
          {
            ret = (USBD_StatusTypeDef)pdev->pClass->Setup(pdev, req);
 80126e6:	687a      	ldr	r2, [r7, #4]
 80126e8:	23ad      	movs	r3, #173	; 0xad
 80126ea:	009b      	lsls	r3, r3, #2
 80126ec:	58d3      	ldr	r3, [r2, r3]
 80126ee:	689b      	ldr	r3, [r3, #8]
 80126f0:	250f      	movs	r5, #15
 80126f2:	197c      	adds	r4, r7, r5
 80126f4:	6839      	ldr	r1, [r7, #0]
 80126f6:	687a      	ldr	r2, [r7, #4]
 80126f8:	0010      	movs	r0, r2
 80126fa:	4798      	blx	r3
 80126fc:	0003      	movs	r3, r0
 80126fe:	7023      	strb	r3, [r4, #0]

            if ((req->wLength == 0U) && (ret == USBD_OK))
 8012700:	683b      	ldr	r3, [r7, #0]
 8012702:	88db      	ldrh	r3, [r3, #6]
 8012704:	2b00      	cmp	r3, #0
 8012706:	d116      	bne.n	8012736 <USBD_StdItfReq+0x92>
 8012708:	197b      	adds	r3, r7, r5
 801270a:	781b      	ldrb	r3, [r3, #0]
 801270c:	2b00      	cmp	r3, #0
 801270e:	d112      	bne.n	8012736 <USBD_StdItfReq+0x92>
            {
              USBD_CtlSendStatus(pdev);
 8012710:	687b      	ldr	r3, [r7, #4]
 8012712:	0018      	movs	r0, r3
 8012714:	f000 fe52 	bl	80133bc <USBD_CtlSendStatus>
          }
          else
          {
            USBD_CtlError(pdev, req);
          }
          break;
 8012718:	e00d      	b.n	8012736 <USBD_StdItfReq+0x92>
            USBD_CtlError(pdev, req);
 801271a:	683a      	ldr	r2, [r7, #0]
 801271c:	687b      	ldr	r3, [r7, #4]
 801271e:	0011      	movs	r1, r2
 8012720:	0018      	movs	r0, r3
 8012722:	f000 fd63 	bl	80131ec <USBD_CtlError>
          break;
 8012726:	e006      	b.n	8012736 <USBD_StdItfReq+0x92>

        default:
          USBD_CtlError(pdev, req);
 8012728:	683a      	ldr	r2, [r7, #0]
 801272a:	687b      	ldr	r3, [r7, #4]
 801272c:	0011      	movs	r1, r2
 801272e:	0018      	movs	r0, r3
 8012730:	f000 fd5c 	bl	80131ec <USBD_CtlError>
          break;
 8012734:	e000      	b.n	8012738 <USBD_StdItfReq+0x94>
          break;
 8012736:	46c0      	nop			; (mov r8, r8)
      }
      break;
 8012738:	e006      	b.n	8012748 <USBD_StdItfReq+0xa4>

    default:
      USBD_CtlError(pdev, req);
 801273a:	683a      	ldr	r2, [r7, #0]
 801273c:	687b      	ldr	r3, [r7, #4]
 801273e:	0011      	movs	r1, r2
 8012740:	0018      	movs	r0, r3
 8012742:	f000 fd53 	bl	80131ec <USBD_CtlError>
      break;
 8012746:	46c0      	nop			; (mov r8, r8)
  }

  return USBD_OK;
 8012748:	2300      	movs	r3, #0
}
 801274a:	0018      	movs	r0, r3
 801274c:	46bd      	mov	sp, r7
 801274e:	b004      	add	sp, #16
 8012750:	bdb0      	pop	{r4, r5, r7, pc}

08012752 <USBD_StdEPReq>:
* @param  req: usb request
* @retval status
*/
USBD_StatusTypeDef  USBD_StdEPReq(USBD_HandleTypeDef *pdev,
                                  USBD_SetupReqTypedef  *req)
{
 8012752:	b5b0      	push	{r4, r5, r7, lr}
 8012754:	b084      	sub	sp, #16
 8012756:	af00      	add	r7, sp, #0
 8012758:	6078      	str	r0, [r7, #4]
 801275a:	6039      	str	r1, [r7, #0]
  USBD_EndpointTypeDef *pep;
  uint8_t   ep_addr;
  USBD_StatusTypeDef ret = USBD_OK;
 801275c:	230f      	movs	r3, #15
 801275e:	18fb      	adds	r3, r7, r3
 8012760:	2200      	movs	r2, #0
 8012762:	701a      	strb	r2, [r3, #0]
  ep_addr  = LOBYTE(req->wIndex);
 8012764:	683b      	ldr	r3, [r7, #0]
 8012766:	889a      	ldrh	r2, [r3, #4]
 8012768:	230e      	movs	r3, #14
 801276a:	18fb      	adds	r3, r7, r3
 801276c:	701a      	strb	r2, [r3, #0]

  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 801276e:	683b      	ldr	r3, [r7, #0]
 8012770:	781b      	ldrb	r3, [r3, #0]
 8012772:	001a      	movs	r2, r3
 8012774:	2360      	movs	r3, #96	; 0x60
 8012776:	4013      	ands	r3, r2
 8012778:	2b40      	cmp	r3, #64	; 0x40
 801277a:	d006      	beq.n	801278a <USBD_StdEPReq+0x38>
 801277c:	d900      	bls.n	8012780 <USBD_StdEPReq+0x2e>
 801277e:	e190      	b.n	8012aa2 <USBD_StdEPReq+0x350>
 8012780:	2b00      	cmp	r3, #0
 8012782:	d00c      	beq.n	801279e <USBD_StdEPReq+0x4c>
 8012784:	2b20      	cmp	r3, #32
 8012786:	d000      	beq.n	801278a <USBD_StdEPReq+0x38>
 8012788:	e18b      	b.n	8012aa2 <USBD_StdEPReq+0x350>
  {
    case USB_REQ_TYPE_CLASS:
    case USB_REQ_TYPE_VENDOR:
      pdev->pClass->Setup(pdev, req);
 801278a:	687a      	ldr	r2, [r7, #4]
 801278c:	23ad      	movs	r3, #173	; 0xad
 801278e:	009b      	lsls	r3, r3, #2
 8012790:	58d3      	ldr	r3, [r2, r3]
 8012792:	689b      	ldr	r3, [r3, #8]
 8012794:	6839      	ldr	r1, [r7, #0]
 8012796:	687a      	ldr	r2, [r7, #4]
 8012798:	0010      	movs	r0, r2
 801279a:	4798      	blx	r3
      break;
 801279c:	e188      	b.n	8012ab0 <USBD_StdEPReq+0x35e>

    case USB_REQ_TYPE_STANDARD:
      /* Check if it is a class request */
      if ((req->bmRequest & 0x60U) == 0x20U)
 801279e:	683b      	ldr	r3, [r7, #0]
 80127a0:	781b      	ldrb	r3, [r3, #0]
 80127a2:	001a      	movs	r2, r3
 80127a4:	2360      	movs	r3, #96	; 0x60
 80127a6:	4013      	ands	r3, r2
 80127a8:	2b20      	cmp	r3, #32
 80127aa:	d10f      	bne.n	80127cc <USBD_StdEPReq+0x7a>
      {
        ret = (USBD_StatusTypeDef)pdev->pClass->Setup(pdev, req);
 80127ac:	687a      	ldr	r2, [r7, #4]
 80127ae:	23ad      	movs	r3, #173	; 0xad
 80127b0:	009b      	lsls	r3, r3, #2
 80127b2:	58d3      	ldr	r3, [r2, r3]
 80127b4:	689b      	ldr	r3, [r3, #8]
 80127b6:	250f      	movs	r5, #15
 80127b8:	197c      	adds	r4, r7, r5
 80127ba:	6839      	ldr	r1, [r7, #0]
 80127bc:	687a      	ldr	r2, [r7, #4]
 80127be:	0010      	movs	r0, r2
 80127c0:	4798      	blx	r3
 80127c2:	0003      	movs	r3, r0
 80127c4:	7023      	strb	r3, [r4, #0]

        return ret;
 80127c6:	197b      	adds	r3, r7, r5
 80127c8:	781b      	ldrb	r3, [r3, #0]
 80127ca:	e174      	b.n	8012ab6 <USBD_StdEPReq+0x364>
      }

      switch (req->bRequest)
 80127cc:	683b      	ldr	r3, [r7, #0]
 80127ce:	785b      	ldrb	r3, [r3, #1]
 80127d0:	2b03      	cmp	r3, #3
 80127d2:	d007      	beq.n	80127e4 <USBD_StdEPReq+0x92>
 80127d4:	dd00      	ble.n	80127d8 <USBD_StdEPReq+0x86>
 80127d6:	e15c      	b.n	8012a92 <USBD_StdEPReq+0x340>
 80127d8:	2b00      	cmp	r3, #0
 80127da:	d100      	bne.n	80127de <USBD_StdEPReq+0x8c>
 80127dc:	e092      	b.n	8012904 <USBD_StdEPReq+0x1b2>
 80127de:	2b01      	cmp	r3, #1
 80127e0:	d04b      	beq.n	801287a <USBD_StdEPReq+0x128>
 80127e2:	e156      	b.n	8012a92 <USBD_StdEPReq+0x340>
      {
        case USB_REQ_SET_FEATURE:
          switch (pdev->dev_state)
 80127e4:	687a      	ldr	r2, [r7, #4]
 80127e6:	23a7      	movs	r3, #167	; 0xa7
 80127e8:	009b      	lsls	r3, r3, #2
 80127ea:	5cd3      	ldrb	r3, [r2, r3]
 80127ec:	2b02      	cmp	r3, #2
 80127ee:	d002      	beq.n	80127f6 <USBD_StdEPReq+0xa4>
 80127f0:	2b03      	cmp	r3, #3
 80127f2:	d01d      	beq.n	8012830 <USBD_StdEPReq+0xde>
 80127f4:	e039      	b.n	801286a <USBD_StdEPReq+0x118>
          {
            case USBD_STATE_ADDRESSED:
              if ((ep_addr != 0x00U) && (ep_addr != 0x80U))
 80127f6:	220e      	movs	r2, #14
 80127f8:	18bb      	adds	r3, r7, r2
 80127fa:	781b      	ldrb	r3, [r3, #0]
 80127fc:	2b00      	cmp	r3, #0
 80127fe:	d010      	beq.n	8012822 <USBD_StdEPReq+0xd0>
 8012800:	18bb      	adds	r3, r7, r2
 8012802:	781b      	ldrb	r3, [r3, #0]
 8012804:	2b80      	cmp	r3, #128	; 0x80
 8012806:	d00c      	beq.n	8012822 <USBD_StdEPReq+0xd0>
              {
                USBD_LL_StallEP(pdev, ep_addr);
 8012808:	18bb      	adds	r3, r7, r2
 801280a:	781a      	ldrb	r2, [r3, #0]
 801280c:	687b      	ldr	r3, [r7, #4]
 801280e:	0011      	movs	r1, r2
 8012810:	0018      	movs	r0, r3
 8012812:	f002 fa42 	bl	8014c9a <USBD_LL_StallEP>
                USBD_LL_StallEP(pdev, 0x80U);
 8012816:	687b      	ldr	r3, [r7, #4]
 8012818:	2180      	movs	r1, #128	; 0x80
 801281a:	0018      	movs	r0, r3
 801281c:	f002 fa3d 	bl	8014c9a <USBD_LL_StallEP>
              }
              else
              {
                USBD_CtlError(pdev, req);
              }
              break;
 8012820:	e02a      	b.n	8012878 <USBD_StdEPReq+0x126>
                USBD_CtlError(pdev, req);
 8012822:	683a      	ldr	r2, [r7, #0]
 8012824:	687b      	ldr	r3, [r7, #4]
 8012826:	0011      	movs	r1, r2
 8012828:	0018      	movs	r0, r3
 801282a:	f000 fcdf 	bl	80131ec <USBD_CtlError>
              break;
 801282e:	e023      	b.n	8012878 <USBD_StdEPReq+0x126>

            case USBD_STATE_CONFIGURED:
              if (req->wValue == USB_FEATURE_EP_HALT)
 8012830:	683b      	ldr	r3, [r7, #0]
 8012832:	885b      	ldrh	r3, [r3, #2]
 8012834:	2b00      	cmp	r3, #0
 8012836:	d113      	bne.n	8012860 <USBD_StdEPReq+0x10e>
              {
                if ((ep_addr != 0x00U) &&
 8012838:	220e      	movs	r2, #14
 801283a:	18bb      	adds	r3, r7, r2
 801283c:	781b      	ldrb	r3, [r3, #0]
 801283e:	2b00      	cmp	r3, #0
 8012840:	d00e      	beq.n	8012860 <USBD_StdEPReq+0x10e>
 8012842:	18bb      	adds	r3, r7, r2
 8012844:	781b      	ldrb	r3, [r3, #0]
 8012846:	2b80      	cmp	r3, #128	; 0x80
 8012848:	d00a      	beq.n	8012860 <USBD_StdEPReq+0x10e>
                    (ep_addr != 0x80U) && (req->wLength == 0x00U))
 801284a:	683b      	ldr	r3, [r7, #0]
 801284c:	88db      	ldrh	r3, [r3, #6]
 801284e:	2b00      	cmp	r3, #0
 8012850:	d106      	bne.n	8012860 <USBD_StdEPReq+0x10e>
                {
                  USBD_LL_StallEP(pdev, ep_addr);
 8012852:	18bb      	adds	r3, r7, r2
 8012854:	781a      	ldrb	r2, [r3, #0]
 8012856:	687b      	ldr	r3, [r7, #4]
 8012858:	0011      	movs	r1, r2
 801285a:	0018      	movs	r0, r3
 801285c:	f002 fa1d 	bl	8014c9a <USBD_LL_StallEP>
                }
              }
              USBD_CtlSendStatus(pdev);
 8012860:	687b      	ldr	r3, [r7, #4]
 8012862:	0018      	movs	r0, r3
 8012864:	f000 fdaa 	bl	80133bc <USBD_CtlSendStatus>

              break;
 8012868:	e006      	b.n	8012878 <USBD_StdEPReq+0x126>

            default:
              USBD_CtlError(pdev, req);
 801286a:	683a      	ldr	r2, [r7, #0]
 801286c:	687b      	ldr	r3, [r7, #4]
 801286e:	0011      	movs	r1, r2
 8012870:	0018      	movs	r0, r3
 8012872:	f000 fcbb 	bl	80131ec <USBD_CtlError>
              break;
 8012876:	46c0      	nop			; (mov r8, r8)
          }
          break;
 8012878:	e112      	b.n	8012aa0 <USBD_StdEPReq+0x34e>

        case USB_REQ_CLEAR_FEATURE:

          switch (pdev->dev_state)
 801287a:	687a      	ldr	r2, [r7, #4]
 801287c:	23a7      	movs	r3, #167	; 0xa7
 801287e:	009b      	lsls	r3, r3, #2
 8012880:	5cd3      	ldrb	r3, [r2, r3]
 8012882:	2b02      	cmp	r3, #2
 8012884:	d002      	beq.n	801288c <USBD_StdEPReq+0x13a>
 8012886:	2b03      	cmp	r3, #3
 8012888:	d01d      	beq.n	80128c6 <USBD_StdEPReq+0x174>
 801288a:	e032      	b.n	80128f2 <USBD_StdEPReq+0x1a0>
          {
            case USBD_STATE_ADDRESSED:
              if ((ep_addr != 0x00U) && (ep_addr != 0x80U))
 801288c:	220e      	movs	r2, #14
 801288e:	18bb      	adds	r3, r7, r2
 8012890:	781b      	ldrb	r3, [r3, #0]
 8012892:	2b00      	cmp	r3, #0
 8012894:	d010      	beq.n	80128b8 <USBD_StdEPReq+0x166>
 8012896:	18bb      	adds	r3, r7, r2
 8012898:	781b      	ldrb	r3, [r3, #0]
 801289a:	2b80      	cmp	r3, #128	; 0x80
 801289c:	d00c      	beq.n	80128b8 <USBD_StdEPReq+0x166>
              {
                USBD_LL_StallEP(pdev, ep_addr);
 801289e:	18bb      	adds	r3, r7, r2
 80128a0:	781a      	ldrb	r2, [r3, #0]
 80128a2:	687b      	ldr	r3, [r7, #4]
 80128a4:	0011      	movs	r1, r2
 80128a6:	0018      	movs	r0, r3
 80128a8:	f002 f9f7 	bl	8014c9a <USBD_LL_StallEP>
                USBD_LL_StallEP(pdev, 0x80U);
 80128ac:	687b      	ldr	r3, [r7, #4]
 80128ae:	2180      	movs	r1, #128	; 0x80
 80128b0:	0018      	movs	r0, r3
 80128b2:	f002 f9f2 	bl	8014c9a <USBD_LL_StallEP>
              }
              else
              {
                USBD_CtlError(pdev, req);
              }
              break;
 80128b6:	e024      	b.n	8012902 <USBD_StdEPReq+0x1b0>
                USBD_CtlError(pdev, req);
 80128b8:	683a      	ldr	r2, [r7, #0]
 80128ba:	687b      	ldr	r3, [r7, #4]
 80128bc:	0011      	movs	r1, r2
 80128be:	0018      	movs	r0, r3
 80128c0:	f000 fc94 	bl	80131ec <USBD_CtlError>
              break;
 80128c4:	e01d      	b.n	8012902 <USBD_StdEPReq+0x1b0>

            case USBD_STATE_CONFIGURED:
              if (req->wValue == USB_FEATURE_EP_HALT)
 80128c6:	683b      	ldr	r3, [r7, #0]
 80128c8:	885b      	ldrh	r3, [r3, #2]
 80128ca:	2b00      	cmp	r3, #0
 80128cc:	d118      	bne.n	8012900 <USBD_StdEPReq+0x1ae>
              {
                if ((ep_addr & 0x7FU) != 0x00U)
 80128ce:	210e      	movs	r1, #14
 80128d0:	187b      	adds	r3, r7, r1
 80128d2:	781b      	ldrb	r3, [r3, #0]
 80128d4:	227f      	movs	r2, #127	; 0x7f
 80128d6:	4013      	ands	r3, r2
 80128d8:	d006      	beq.n	80128e8 <USBD_StdEPReq+0x196>
                {
                  USBD_LL_ClearStallEP(pdev, ep_addr);
 80128da:	187b      	adds	r3, r7, r1
 80128dc:	781a      	ldrb	r2, [r3, #0]
 80128de:	687b      	ldr	r3, [r7, #4]
 80128e0:	0011      	movs	r1, r2
 80128e2:	0018      	movs	r0, r3
 80128e4:	f002 fa04 	bl	8014cf0 <USBD_LL_ClearStallEP>
                }
                USBD_CtlSendStatus(pdev);
 80128e8:	687b      	ldr	r3, [r7, #4]
 80128ea:	0018      	movs	r0, r3
 80128ec:	f000 fd66 	bl	80133bc <USBD_CtlSendStatus>
              }
              break;
 80128f0:	e006      	b.n	8012900 <USBD_StdEPReq+0x1ae>

            default:
              USBD_CtlError(pdev, req);
 80128f2:	683a      	ldr	r2, [r7, #0]
 80128f4:	687b      	ldr	r3, [r7, #4]
 80128f6:	0011      	movs	r1, r2
 80128f8:	0018      	movs	r0, r3
 80128fa:	f000 fc77 	bl	80131ec <USBD_CtlError>
              break;
 80128fe:	e000      	b.n	8012902 <USBD_StdEPReq+0x1b0>
              break;
 8012900:	46c0      	nop			; (mov r8, r8)
          }
          break;
 8012902:	e0cd      	b.n	8012aa0 <USBD_StdEPReq+0x34e>

        case USB_REQ_GET_STATUS:
          switch (pdev->dev_state)
 8012904:	687a      	ldr	r2, [r7, #4]
 8012906:	23a7      	movs	r3, #167	; 0xa7
 8012908:	009b      	lsls	r3, r3, #2
 801290a:	5cd3      	ldrb	r3, [r2, r3]
 801290c:	2b02      	cmp	r3, #2
 801290e:	d002      	beq.n	8012916 <USBD_StdEPReq+0x1c4>
 8012910:	2b03      	cmp	r3, #3
 8012912:	d03c      	beq.n	801298e <USBD_StdEPReq+0x23c>
 8012914:	e0b5      	b.n	8012a82 <USBD_StdEPReq+0x330>
          {
            case USBD_STATE_ADDRESSED:
              if ((ep_addr != 0x00U) && (ep_addr != 0x80U))
 8012916:	220e      	movs	r2, #14
 8012918:	18bb      	adds	r3, r7, r2
 801291a:	781b      	ldrb	r3, [r3, #0]
 801291c:	2b00      	cmp	r3, #0
 801291e:	d00a      	beq.n	8012936 <USBD_StdEPReq+0x1e4>
 8012920:	18bb      	adds	r3, r7, r2
 8012922:	781b      	ldrb	r3, [r3, #0]
 8012924:	2b80      	cmp	r3, #128	; 0x80
 8012926:	d006      	beq.n	8012936 <USBD_StdEPReq+0x1e4>
              {
                USBD_CtlError(pdev, req);
 8012928:	683a      	ldr	r2, [r7, #0]
 801292a:	687b      	ldr	r3, [r7, #4]
 801292c:	0011      	movs	r1, r2
 801292e:	0018      	movs	r0, r3
 8012930:	f000 fc5c 	bl	80131ec <USBD_CtlError>
                break;
 8012934:	e0ac      	b.n	8012a90 <USBD_StdEPReq+0x33e>
              }
              pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU] : \
 8012936:	220e      	movs	r2, #14
 8012938:	18bb      	adds	r3, r7, r2
 801293a:	781b      	ldrb	r3, [r3, #0]
 801293c:	b25b      	sxtb	r3, r3
 801293e:	2b00      	cmp	r3, #0
 8012940:	da0c      	bge.n	801295c <USBD_StdEPReq+0x20a>
 8012942:	18bb      	adds	r3, r7, r2
 8012944:	781b      	ldrb	r3, [r3, #0]
 8012946:	227f      	movs	r2, #127	; 0x7f
 8012948:	401a      	ands	r2, r3
 801294a:	0013      	movs	r3, r2
 801294c:	009b      	lsls	r3, r3, #2
 801294e:	189b      	adds	r3, r3, r2
 8012950:	009b      	lsls	r3, r3, #2
 8012952:	3310      	adds	r3, #16
 8012954:	687a      	ldr	r2, [r7, #4]
 8012956:	18d3      	adds	r3, r2, r3
 8012958:	3304      	adds	r3, #4
 801295a:	e00d      	b.n	8012978 <USBD_StdEPReq+0x226>
                    &pdev->ep_out[ep_addr & 0x7FU];
 801295c:	230e      	movs	r3, #14
 801295e:	18fb      	adds	r3, r7, r3
 8012960:	781b      	ldrb	r3, [r3, #0]
 8012962:	227f      	movs	r2, #127	; 0x7f
 8012964:	401a      	ands	r2, r3
              pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU] : \
 8012966:	0013      	movs	r3, r2
 8012968:	009b      	lsls	r3, r3, #2
 801296a:	189b      	adds	r3, r3, r2
 801296c:	009b      	lsls	r3, r3, #2
 801296e:	3351      	adds	r3, #81	; 0x51
 8012970:	33ff      	adds	r3, #255	; 0xff
 8012972:	687a      	ldr	r2, [r7, #4]
 8012974:	18d3      	adds	r3, r2, r3
 8012976:	3304      	adds	r3, #4
 8012978:	60bb      	str	r3, [r7, #8]

              pep->status = 0x0000U;
 801297a:	68bb      	ldr	r3, [r7, #8]
 801297c:	2200      	movs	r2, #0
 801297e:	601a      	str	r2, [r3, #0]

              USBD_CtlSendData(pdev, (uint8_t *)(void *)&pep->status, 2U);
 8012980:	68b9      	ldr	r1, [r7, #8]
 8012982:	687b      	ldr	r3, [r7, #4]
 8012984:	2202      	movs	r2, #2
 8012986:	0018      	movs	r0, r3
 8012988:	f000 fcae 	bl	80132e8 <USBD_CtlSendData>
              break;
 801298c:	e080      	b.n	8012a90 <USBD_StdEPReq+0x33e>

            case USBD_STATE_CONFIGURED:
              if ((ep_addr & 0x80U) == 0x80U)
 801298e:	220e      	movs	r2, #14
 8012990:	18bb      	adds	r3, r7, r2
 8012992:	781b      	ldrb	r3, [r3, #0]
 8012994:	b25b      	sxtb	r3, r3
 8012996:	2b00      	cmp	r3, #0
 8012998:	da14      	bge.n	80129c4 <USBD_StdEPReq+0x272>
              {
                if (pdev->ep_in[ep_addr & 0xFU].is_used == 0U)
 801299a:	18bb      	adds	r3, r7, r2
 801299c:	781b      	ldrb	r3, [r3, #0]
 801299e:	220f      	movs	r2, #15
 80129a0:	401a      	ands	r2, r3
 80129a2:	6879      	ldr	r1, [r7, #4]
 80129a4:	0013      	movs	r3, r2
 80129a6:	009b      	lsls	r3, r3, #2
 80129a8:	189b      	adds	r3, r3, r2
 80129aa:	009b      	lsls	r3, r3, #2
 80129ac:	18cb      	adds	r3, r1, r3
 80129ae:	3318      	adds	r3, #24
 80129b0:	681b      	ldr	r3, [r3, #0]
 80129b2:	2b00      	cmp	r3, #0
 80129b4:	d11e      	bne.n	80129f4 <USBD_StdEPReq+0x2a2>
                {
                  USBD_CtlError(pdev, req);
 80129b6:	683a      	ldr	r2, [r7, #0]
 80129b8:	687b      	ldr	r3, [r7, #4]
 80129ba:	0011      	movs	r1, r2
 80129bc:	0018      	movs	r0, r3
 80129be:	f000 fc15 	bl	80131ec <USBD_CtlError>
                  break;
 80129c2:	e065      	b.n	8012a90 <USBD_StdEPReq+0x33e>
                }
              }
              else
              {
                if (pdev->ep_out[ep_addr & 0xFU].is_used == 0U)
 80129c4:	230e      	movs	r3, #14
 80129c6:	18fb      	adds	r3, r7, r3
 80129c8:	781b      	ldrb	r3, [r3, #0]
 80129ca:	220f      	movs	r2, #15
 80129cc:	401a      	ands	r2, r3
 80129ce:	6878      	ldr	r0, [r7, #4]
 80129d0:	23ac      	movs	r3, #172	; 0xac
 80129d2:	0059      	lsls	r1, r3, #1
 80129d4:	0013      	movs	r3, r2
 80129d6:	009b      	lsls	r3, r3, #2
 80129d8:	189b      	adds	r3, r3, r2
 80129da:	009b      	lsls	r3, r3, #2
 80129dc:	18c3      	adds	r3, r0, r3
 80129de:	185b      	adds	r3, r3, r1
 80129e0:	681b      	ldr	r3, [r3, #0]
 80129e2:	2b00      	cmp	r3, #0
 80129e4:	d106      	bne.n	80129f4 <USBD_StdEPReq+0x2a2>
                {
                  USBD_CtlError(pdev, req);
 80129e6:	683a      	ldr	r2, [r7, #0]
 80129e8:	687b      	ldr	r3, [r7, #4]
 80129ea:	0011      	movs	r1, r2
 80129ec:	0018      	movs	r0, r3
 80129ee:	f000 fbfd 	bl	80131ec <USBD_CtlError>
                  break;
 80129f2:	e04d      	b.n	8012a90 <USBD_StdEPReq+0x33e>
                }
              }

              pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU] : \
 80129f4:	220e      	movs	r2, #14
 80129f6:	18bb      	adds	r3, r7, r2
 80129f8:	781b      	ldrb	r3, [r3, #0]
 80129fa:	b25b      	sxtb	r3, r3
 80129fc:	2b00      	cmp	r3, #0
 80129fe:	da0c      	bge.n	8012a1a <USBD_StdEPReq+0x2c8>
 8012a00:	18bb      	adds	r3, r7, r2
 8012a02:	781b      	ldrb	r3, [r3, #0]
 8012a04:	227f      	movs	r2, #127	; 0x7f
 8012a06:	401a      	ands	r2, r3
 8012a08:	0013      	movs	r3, r2
 8012a0a:	009b      	lsls	r3, r3, #2
 8012a0c:	189b      	adds	r3, r3, r2
 8012a0e:	009b      	lsls	r3, r3, #2
 8012a10:	3310      	adds	r3, #16
 8012a12:	687a      	ldr	r2, [r7, #4]
 8012a14:	18d3      	adds	r3, r2, r3
 8012a16:	3304      	adds	r3, #4
 8012a18:	e00d      	b.n	8012a36 <USBD_StdEPReq+0x2e4>
                    &pdev->ep_out[ep_addr & 0x7FU];
 8012a1a:	230e      	movs	r3, #14
 8012a1c:	18fb      	adds	r3, r7, r3
 8012a1e:	781b      	ldrb	r3, [r3, #0]
 8012a20:	227f      	movs	r2, #127	; 0x7f
 8012a22:	401a      	ands	r2, r3
              pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU] : \
 8012a24:	0013      	movs	r3, r2
 8012a26:	009b      	lsls	r3, r3, #2
 8012a28:	189b      	adds	r3, r3, r2
 8012a2a:	009b      	lsls	r3, r3, #2
 8012a2c:	3351      	adds	r3, #81	; 0x51
 8012a2e:	33ff      	adds	r3, #255	; 0xff
 8012a30:	687a      	ldr	r2, [r7, #4]
 8012a32:	18d3      	adds	r3, r2, r3
 8012a34:	3304      	adds	r3, #4
 8012a36:	60bb      	str	r3, [r7, #8]

              if ((ep_addr == 0x00U) || (ep_addr == 0x80U))
 8012a38:	220e      	movs	r2, #14
 8012a3a:	18bb      	adds	r3, r7, r2
 8012a3c:	781b      	ldrb	r3, [r3, #0]
 8012a3e:	2b00      	cmp	r3, #0
 8012a40:	d003      	beq.n	8012a4a <USBD_StdEPReq+0x2f8>
 8012a42:	18bb      	adds	r3, r7, r2
 8012a44:	781b      	ldrb	r3, [r3, #0]
 8012a46:	2b80      	cmp	r3, #128	; 0x80
 8012a48:	d103      	bne.n	8012a52 <USBD_StdEPReq+0x300>
              {
                pep->status = 0x0000U;
 8012a4a:	68bb      	ldr	r3, [r7, #8]
 8012a4c:	2200      	movs	r2, #0
 8012a4e:	601a      	str	r2, [r3, #0]
 8012a50:	e010      	b.n	8012a74 <USBD_StdEPReq+0x322>
              }
              else if (USBD_LL_IsStallEP(pdev, ep_addr))
 8012a52:	230e      	movs	r3, #14
 8012a54:	18fb      	adds	r3, r7, r3
 8012a56:	781a      	ldrb	r2, [r3, #0]
 8012a58:	687b      	ldr	r3, [r7, #4]
 8012a5a:	0011      	movs	r1, r2
 8012a5c:	0018      	movs	r0, r3
 8012a5e:	f002 f972 	bl	8014d46 <USBD_LL_IsStallEP>
 8012a62:	1e03      	subs	r3, r0, #0
 8012a64:	d003      	beq.n	8012a6e <USBD_StdEPReq+0x31c>
              {
                pep->status = 0x0001U;
 8012a66:	68bb      	ldr	r3, [r7, #8]
 8012a68:	2201      	movs	r2, #1
 8012a6a:	601a      	str	r2, [r3, #0]
 8012a6c:	e002      	b.n	8012a74 <USBD_StdEPReq+0x322>
              }
              else
              {
                pep->status = 0x0000U;
 8012a6e:	68bb      	ldr	r3, [r7, #8]
 8012a70:	2200      	movs	r2, #0
 8012a72:	601a      	str	r2, [r3, #0]
              }

              USBD_CtlSendData(pdev, (uint8_t *)(void *)&pep->status, 2U);
 8012a74:	68b9      	ldr	r1, [r7, #8]
 8012a76:	687b      	ldr	r3, [r7, #4]
 8012a78:	2202      	movs	r2, #2
 8012a7a:	0018      	movs	r0, r3
 8012a7c:	f000 fc34 	bl	80132e8 <USBD_CtlSendData>
              break;
 8012a80:	e006      	b.n	8012a90 <USBD_StdEPReq+0x33e>

            default:
              USBD_CtlError(pdev, req);
 8012a82:	683a      	ldr	r2, [r7, #0]
 8012a84:	687b      	ldr	r3, [r7, #4]
 8012a86:	0011      	movs	r1, r2
 8012a88:	0018      	movs	r0, r3
 8012a8a:	f000 fbaf 	bl	80131ec <USBD_CtlError>
              break;
 8012a8e:	46c0      	nop			; (mov r8, r8)
          }
          break;
 8012a90:	e006      	b.n	8012aa0 <USBD_StdEPReq+0x34e>

        default:
          USBD_CtlError(pdev, req);
 8012a92:	683a      	ldr	r2, [r7, #0]
 8012a94:	687b      	ldr	r3, [r7, #4]
 8012a96:	0011      	movs	r1, r2
 8012a98:	0018      	movs	r0, r3
 8012a9a:	f000 fba7 	bl	80131ec <USBD_CtlError>
          break;
 8012a9e:	46c0      	nop			; (mov r8, r8)
      }
      break;
 8012aa0:	e006      	b.n	8012ab0 <USBD_StdEPReq+0x35e>

    default:
      USBD_CtlError(pdev, req);
 8012aa2:	683a      	ldr	r2, [r7, #0]
 8012aa4:	687b      	ldr	r3, [r7, #4]
 8012aa6:	0011      	movs	r1, r2
 8012aa8:	0018      	movs	r0, r3
 8012aaa:	f000 fb9f 	bl	80131ec <USBD_CtlError>
      break;
 8012aae:	46c0      	nop			; (mov r8, r8)
  }

  return ret;
 8012ab0:	230f      	movs	r3, #15
 8012ab2:	18fb      	adds	r3, r7, r3
 8012ab4:	781b      	ldrb	r3, [r3, #0]
}
 8012ab6:	0018      	movs	r0, r3
 8012ab8:	46bd      	mov	sp, r7
 8012aba:	b004      	add	sp, #16
 8012abc:	bdb0      	pop	{r4, r5, r7, pc}
	...

08012ac0 <USBD_GetDescriptor>:
* @param  req: usb request
* @retval status
*/
static void USBD_GetDescriptor(USBD_HandleTypeDef *pdev,
                               USBD_SetupReqTypedef *req)
{
 8012ac0:	b580      	push	{r7, lr}
 8012ac2:	b084      	sub	sp, #16
 8012ac4:	af00      	add	r7, sp, #0
 8012ac6:	6078      	str	r0, [r7, #4]
 8012ac8:	6039      	str	r1, [r7, #0]
  uint16_t len = 0U;
 8012aca:	2308      	movs	r3, #8
 8012acc:	18fb      	adds	r3, r7, r3
 8012ace:	2200      	movs	r2, #0
 8012ad0:	801a      	strh	r2, [r3, #0]
  uint8_t *pbuf = NULL;
 8012ad2:	2300      	movs	r3, #0
 8012ad4:	60fb      	str	r3, [r7, #12]
  uint8_t err = 0U;
 8012ad6:	230b      	movs	r3, #11
 8012ad8:	18fb      	adds	r3, r7, r3
 8012ada:	2200      	movs	r2, #0
 8012adc:	701a      	strb	r2, [r3, #0]

  switch (req->wValue >> 8)
 8012ade:	683b      	ldr	r3, [r7, #0]
 8012ae0:	885b      	ldrh	r3, [r3, #2]
 8012ae2:	0a1b      	lsrs	r3, r3, #8
 8012ae4:	b29b      	uxth	r3, r3
 8012ae6:	2b07      	cmp	r3, #7
 8012ae8:	d900      	bls.n	8012aec <USBD_GetDescriptor+0x2c>
 8012aea:	e159      	b.n	8012da0 <USBD_GetDescriptor+0x2e0>
 8012aec:	009a      	lsls	r2, r3, #2
 8012aee:	4bcb      	ldr	r3, [pc, #812]	; (8012e1c <USBD_GetDescriptor+0x35c>)
 8012af0:	18d3      	adds	r3, r2, r3
 8012af2:	681b      	ldr	r3, [r3, #0]
 8012af4:	469f      	mov	pc, r3
        err++;
      }
      break;
#endif
    case USB_DESC_TYPE_DEVICE:
      pbuf = pdev->pDesc->GetDeviceDescriptor(pdev->dev_speed, &len);
 8012af6:	687a      	ldr	r2, [r7, #4]
 8012af8:	23ac      	movs	r3, #172	; 0xac
 8012afa:	009b      	lsls	r3, r3, #2
 8012afc:	58d3      	ldr	r3, [r2, r3]
 8012afe:	681b      	ldr	r3, [r3, #0]
 8012b00:	687a      	ldr	r2, [r7, #4]
 8012b02:	7c12      	ldrb	r2, [r2, #16]
 8012b04:	2108      	movs	r1, #8
 8012b06:	1879      	adds	r1, r7, r1
 8012b08:	0010      	movs	r0, r2
 8012b0a:	4798      	blx	r3
 8012b0c:	0003      	movs	r3, r0
 8012b0e:	60fb      	str	r3, [r7, #12]
      break;
 8012b10:	e153      	b.n	8012dba <USBD_GetDescriptor+0x2fa>

    case USB_DESC_TYPE_CONFIGURATION:
      if (pdev->dev_speed == USBD_SPEED_HIGH)
 8012b12:	687b      	ldr	r3, [r7, #4]
 8012b14:	7c1b      	ldrb	r3, [r3, #16]
 8012b16:	2b00      	cmp	r3, #0
 8012b18:	d10f      	bne.n	8012b3a <USBD_GetDescriptor+0x7a>
      {
        pbuf = pdev->pClass->GetHSConfigDescriptor(&len);
 8012b1a:	687a      	ldr	r2, [r7, #4]
 8012b1c:	23ad      	movs	r3, #173	; 0xad
 8012b1e:	009b      	lsls	r3, r3, #2
 8012b20:	58d3      	ldr	r3, [r2, r3]
 8012b22:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8012b24:	2208      	movs	r2, #8
 8012b26:	18ba      	adds	r2, r7, r2
 8012b28:	0010      	movs	r0, r2
 8012b2a:	4798      	blx	r3
 8012b2c:	0003      	movs	r3, r0
 8012b2e:	60fb      	str	r3, [r7, #12]
        pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
 8012b30:	68fb      	ldr	r3, [r7, #12]
 8012b32:	3301      	adds	r3, #1
 8012b34:	2202      	movs	r2, #2
 8012b36:	701a      	strb	r2, [r3, #0]
      else
      {
        pbuf = pdev->pClass->GetFSConfigDescriptor(&len);
        pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
      }
      break;
 8012b38:	e13f      	b.n	8012dba <USBD_GetDescriptor+0x2fa>
        pbuf = pdev->pClass->GetFSConfigDescriptor(&len);
 8012b3a:	687a      	ldr	r2, [r7, #4]
 8012b3c:	23ad      	movs	r3, #173	; 0xad
 8012b3e:	009b      	lsls	r3, r3, #2
 8012b40:	58d3      	ldr	r3, [r2, r3]
 8012b42:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8012b44:	2208      	movs	r2, #8
 8012b46:	18ba      	adds	r2, r7, r2
 8012b48:	0010      	movs	r0, r2
 8012b4a:	4798      	blx	r3
 8012b4c:	0003      	movs	r3, r0
 8012b4e:	60fb      	str	r3, [r7, #12]
        pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
 8012b50:	68fb      	ldr	r3, [r7, #12]
 8012b52:	3301      	adds	r3, #1
 8012b54:	2202      	movs	r2, #2
 8012b56:	701a      	strb	r2, [r3, #0]
      break;
 8012b58:	e12f      	b.n	8012dba <USBD_GetDescriptor+0x2fa>

    case USB_DESC_TYPE_STRING:
      switch ((uint8_t)(req->wValue))
 8012b5a:	683b      	ldr	r3, [r7, #0]
 8012b5c:	885b      	ldrh	r3, [r3, #2]
 8012b5e:	b2db      	uxtb	r3, r3
 8012b60:	2b05      	cmp	r3, #5
 8012b62:	d900      	bls.n	8012b66 <USBD_GetDescriptor+0xa6>
 8012b64:	e0d0      	b.n	8012d08 <USBD_GetDescriptor+0x248>
 8012b66:	009a      	lsls	r2, r3, #2
 8012b68:	4bad      	ldr	r3, [pc, #692]	; (8012e20 <USBD_GetDescriptor+0x360>)
 8012b6a:	18d3      	adds	r3, r2, r3
 8012b6c:	681b      	ldr	r3, [r3, #0]
 8012b6e:	469f      	mov	pc, r3
      {
        case USBD_IDX_LANGID_STR:
          if (pdev->pDesc->GetLangIDStrDescriptor != NULL)
 8012b70:	687a      	ldr	r2, [r7, #4]
 8012b72:	23ac      	movs	r3, #172	; 0xac
 8012b74:	009b      	lsls	r3, r3, #2
 8012b76:	58d3      	ldr	r3, [r2, r3]
 8012b78:	685b      	ldr	r3, [r3, #4]
 8012b7a:	2b00      	cmp	r3, #0
 8012b7c:	d00d      	beq.n	8012b9a <USBD_GetDescriptor+0xda>
          {
            pbuf = pdev->pDesc->GetLangIDStrDescriptor(pdev->dev_speed, &len);
 8012b7e:	687a      	ldr	r2, [r7, #4]
 8012b80:	23ac      	movs	r3, #172	; 0xac
 8012b82:	009b      	lsls	r3, r3, #2
 8012b84:	58d3      	ldr	r3, [r2, r3]
 8012b86:	685b      	ldr	r3, [r3, #4]
 8012b88:	687a      	ldr	r2, [r7, #4]
 8012b8a:	7c12      	ldrb	r2, [r2, #16]
 8012b8c:	2108      	movs	r1, #8
 8012b8e:	1879      	adds	r1, r7, r1
 8012b90:	0010      	movs	r0, r2
 8012b92:	4798      	blx	r3
 8012b94:	0003      	movs	r3, r0
 8012b96:	60fb      	str	r3, [r7, #12]
          else
          {
            USBD_CtlError(pdev, req);
            err++;
          }
          break;
 8012b98:	e0c3      	b.n	8012d22 <USBD_GetDescriptor+0x262>
            USBD_CtlError(pdev, req);
 8012b9a:	683a      	ldr	r2, [r7, #0]
 8012b9c:	687b      	ldr	r3, [r7, #4]
 8012b9e:	0011      	movs	r1, r2
 8012ba0:	0018      	movs	r0, r3
 8012ba2:	f000 fb23 	bl	80131ec <USBD_CtlError>
            err++;
 8012ba6:	210b      	movs	r1, #11
 8012ba8:	187b      	adds	r3, r7, r1
 8012baa:	781a      	ldrb	r2, [r3, #0]
 8012bac:	187b      	adds	r3, r7, r1
 8012bae:	3201      	adds	r2, #1
 8012bb0:	701a      	strb	r2, [r3, #0]
          break;
 8012bb2:	e0b6      	b.n	8012d22 <USBD_GetDescriptor+0x262>

        case USBD_IDX_MFC_STR:
          if (pdev->pDesc->GetManufacturerStrDescriptor != NULL)
 8012bb4:	687a      	ldr	r2, [r7, #4]
 8012bb6:	23ac      	movs	r3, #172	; 0xac
 8012bb8:	009b      	lsls	r3, r3, #2
 8012bba:	58d3      	ldr	r3, [r2, r3]
 8012bbc:	689b      	ldr	r3, [r3, #8]
 8012bbe:	2b00      	cmp	r3, #0
 8012bc0:	d00d      	beq.n	8012bde <USBD_GetDescriptor+0x11e>
          {
            pbuf = pdev->pDesc->GetManufacturerStrDescriptor(pdev->dev_speed, &len);
 8012bc2:	687a      	ldr	r2, [r7, #4]
 8012bc4:	23ac      	movs	r3, #172	; 0xac
 8012bc6:	009b      	lsls	r3, r3, #2
 8012bc8:	58d3      	ldr	r3, [r2, r3]
 8012bca:	689b      	ldr	r3, [r3, #8]
 8012bcc:	687a      	ldr	r2, [r7, #4]
 8012bce:	7c12      	ldrb	r2, [r2, #16]
 8012bd0:	2108      	movs	r1, #8
 8012bd2:	1879      	adds	r1, r7, r1
 8012bd4:	0010      	movs	r0, r2
 8012bd6:	4798      	blx	r3
 8012bd8:	0003      	movs	r3, r0
 8012bda:	60fb      	str	r3, [r7, #12]
          else
          {
            USBD_CtlError(pdev, req);
            err++;
          }
          break;
 8012bdc:	e0a1      	b.n	8012d22 <USBD_GetDescriptor+0x262>
            USBD_CtlError(pdev, req);
 8012bde:	683a      	ldr	r2, [r7, #0]
 8012be0:	687b      	ldr	r3, [r7, #4]
 8012be2:	0011      	movs	r1, r2
 8012be4:	0018      	movs	r0, r3
 8012be6:	f000 fb01 	bl	80131ec <USBD_CtlError>
            err++;
 8012bea:	210b      	movs	r1, #11
 8012bec:	187b      	adds	r3, r7, r1
 8012bee:	781a      	ldrb	r2, [r3, #0]
 8012bf0:	187b      	adds	r3, r7, r1
 8012bf2:	3201      	adds	r2, #1
 8012bf4:	701a      	strb	r2, [r3, #0]
          break;
 8012bf6:	e094      	b.n	8012d22 <USBD_GetDescriptor+0x262>

        case USBD_IDX_PRODUCT_STR:
          if (pdev->pDesc->GetProductStrDescriptor != NULL)
 8012bf8:	687a      	ldr	r2, [r7, #4]
 8012bfa:	23ac      	movs	r3, #172	; 0xac
 8012bfc:	009b      	lsls	r3, r3, #2
 8012bfe:	58d3      	ldr	r3, [r2, r3]
 8012c00:	68db      	ldr	r3, [r3, #12]
 8012c02:	2b00      	cmp	r3, #0
 8012c04:	d00d      	beq.n	8012c22 <USBD_GetDescriptor+0x162>
          {
            pbuf = pdev->pDesc->GetProductStrDescriptor(pdev->dev_speed, &len);
 8012c06:	687a      	ldr	r2, [r7, #4]
 8012c08:	23ac      	movs	r3, #172	; 0xac
 8012c0a:	009b      	lsls	r3, r3, #2
 8012c0c:	58d3      	ldr	r3, [r2, r3]
 8012c0e:	68db      	ldr	r3, [r3, #12]
 8012c10:	687a      	ldr	r2, [r7, #4]
 8012c12:	7c12      	ldrb	r2, [r2, #16]
 8012c14:	2108      	movs	r1, #8
 8012c16:	1879      	adds	r1, r7, r1
 8012c18:	0010      	movs	r0, r2
 8012c1a:	4798      	blx	r3
 8012c1c:	0003      	movs	r3, r0
 8012c1e:	60fb      	str	r3, [r7, #12]
          else
          {
            USBD_CtlError(pdev, req);
            err++;
          }
          break;
 8012c20:	e07f      	b.n	8012d22 <USBD_GetDescriptor+0x262>
            USBD_CtlError(pdev, req);
 8012c22:	683a      	ldr	r2, [r7, #0]
 8012c24:	687b      	ldr	r3, [r7, #4]
 8012c26:	0011      	movs	r1, r2
 8012c28:	0018      	movs	r0, r3
 8012c2a:	f000 fadf 	bl	80131ec <USBD_CtlError>
            err++;
 8012c2e:	210b      	movs	r1, #11
 8012c30:	187b      	adds	r3, r7, r1
 8012c32:	781a      	ldrb	r2, [r3, #0]
 8012c34:	187b      	adds	r3, r7, r1
 8012c36:	3201      	adds	r2, #1
 8012c38:	701a      	strb	r2, [r3, #0]
          break;
 8012c3a:	e072      	b.n	8012d22 <USBD_GetDescriptor+0x262>

        case USBD_IDX_SERIAL_STR:
          if (pdev->pDesc->GetSerialStrDescriptor != NULL)
 8012c3c:	687a      	ldr	r2, [r7, #4]
 8012c3e:	23ac      	movs	r3, #172	; 0xac
 8012c40:	009b      	lsls	r3, r3, #2
 8012c42:	58d3      	ldr	r3, [r2, r3]
 8012c44:	691b      	ldr	r3, [r3, #16]
 8012c46:	2b00      	cmp	r3, #0
 8012c48:	d00d      	beq.n	8012c66 <USBD_GetDescriptor+0x1a6>
          {
            pbuf = pdev->pDesc->GetSerialStrDescriptor(pdev->dev_speed, &len);
 8012c4a:	687a      	ldr	r2, [r7, #4]
 8012c4c:	23ac      	movs	r3, #172	; 0xac
 8012c4e:	009b      	lsls	r3, r3, #2
 8012c50:	58d3      	ldr	r3, [r2, r3]
 8012c52:	691b      	ldr	r3, [r3, #16]
 8012c54:	687a      	ldr	r2, [r7, #4]
 8012c56:	7c12      	ldrb	r2, [r2, #16]
 8012c58:	2108      	movs	r1, #8
 8012c5a:	1879      	adds	r1, r7, r1
 8012c5c:	0010      	movs	r0, r2
 8012c5e:	4798      	blx	r3
 8012c60:	0003      	movs	r3, r0
 8012c62:	60fb      	str	r3, [r7, #12]
          else
          {
            USBD_CtlError(pdev, req);
            err++;
          }
          break;
 8012c64:	e05d      	b.n	8012d22 <USBD_GetDescriptor+0x262>
            USBD_CtlError(pdev, req);
 8012c66:	683a      	ldr	r2, [r7, #0]
 8012c68:	687b      	ldr	r3, [r7, #4]
 8012c6a:	0011      	movs	r1, r2
 8012c6c:	0018      	movs	r0, r3
 8012c6e:	f000 fabd 	bl	80131ec <USBD_CtlError>
            err++;
 8012c72:	210b      	movs	r1, #11
 8012c74:	187b      	adds	r3, r7, r1
 8012c76:	781a      	ldrb	r2, [r3, #0]
 8012c78:	187b      	adds	r3, r7, r1
 8012c7a:	3201      	adds	r2, #1
 8012c7c:	701a      	strb	r2, [r3, #0]
          break;
 8012c7e:	e050      	b.n	8012d22 <USBD_GetDescriptor+0x262>

        case USBD_IDX_CONFIG_STR:
          if (pdev->pDesc->GetConfigurationStrDescriptor != NULL)
 8012c80:	687a      	ldr	r2, [r7, #4]
 8012c82:	23ac      	movs	r3, #172	; 0xac
 8012c84:	009b      	lsls	r3, r3, #2
 8012c86:	58d3      	ldr	r3, [r2, r3]
 8012c88:	695b      	ldr	r3, [r3, #20]
 8012c8a:	2b00      	cmp	r3, #0
 8012c8c:	d00d      	beq.n	8012caa <USBD_GetDescriptor+0x1ea>
          {
            pbuf = pdev->pDesc->GetConfigurationStrDescriptor(pdev->dev_speed, &len);
 8012c8e:	687a      	ldr	r2, [r7, #4]
 8012c90:	23ac      	movs	r3, #172	; 0xac
 8012c92:	009b      	lsls	r3, r3, #2
 8012c94:	58d3      	ldr	r3, [r2, r3]
 8012c96:	695b      	ldr	r3, [r3, #20]
 8012c98:	687a      	ldr	r2, [r7, #4]
 8012c9a:	7c12      	ldrb	r2, [r2, #16]
 8012c9c:	2108      	movs	r1, #8
 8012c9e:	1879      	adds	r1, r7, r1
 8012ca0:	0010      	movs	r0, r2
 8012ca2:	4798      	blx	r3
 8012ca4:	0003      	movs	r3, r0
 8012ca6:	60fb      	str	r3, [r7, #12]
          else
          {
            USBD_CtlError(pdev, req);
            err++;
          }
          break;
 8012ca8:	e03b      	b.n	8012d22 <USBD_GetDescriptor+0x262>
            USBD_CtlError(pdev, req);
 8012caa:	683a      	ldr	r2, [r7, #0]
 8012cac:	687b      	ldr	r3, [r7, #4]
 8012cae:	0011      	movs	r1, r2
 8012cb0:	0018      	movs	r0, r3
 8012cb2:	f000 fa9b 	bl	80131ec <USBD_CtlError>
            err++;
 8012cb6:	210b      	movs	r1, #11
 8012cb8:	187b      	adds	r3, r7, r1
 8012cba:	781a      	ldrb	r2, [r3, #0]
 8012cbc:	187b      	adds	r3, r7, r1
 8012cbe:	3201      	adds	r2, #1
 8012cc0:	701a      	strb	r2, [r3, #0]
          break;
 8012cc2:	e02e      	b.n	8012d22 <USBD_GetDescriptor+0x262>

        case USBD_IDX_INTERFACE_STR:
          if (pdev->pDesc->GetInterfaceStrDescriptor != NULL)
 8012cc4:	687a      	ldr	r2, [r7, #4]
 8012cc6:	23ac      	movs	r3, #172	; 0xac
 8012cc8:	009b      	lsls	r3, r3, #2
 8012cca:	58d3      	ldr	r3, [r2, r3]
 8012ccc:	699b      	ldr	r3, [r3, #24]
 8012cce:	2b00      	cmp	r3, #0
 8012cd0:	d00d      	beq.n	8012cee <USBD_GetDescriptor+0x22e>
          {
            pbuf = pdev->pDesc->GetInterfaceStrDescriptor(pdev->dev_speed, &len);
 8012cd2:	687a      	ldr	r2, [r7, #4]
 8012cd4:	23ac      	movs	r3, #172	; 0xac
 8012cd6:	009b      	lsls	r3, r3, #2
 8012cd8:	58d3      	ldr	r3, [r2, r3]
 8012cda:	699b      	ldr	r3, [r3, #24]
 8012cdc:	687a      	ldr	r2, [r7, #4]
 8012cde:	7c12      	ldrb	r2, [r2, #16]
 8012ce0:	2108      	movs	r1, #8
 8012ce2:	1879      	adds	r1, r7, r1
 8012ce4:	0010      	movs	r0, r2
 8012ce6:	4798      	blx	r3
 8012ce8:	0003      	movs	r3, r0
 8012cea:	60fb      	str	r3, [r7, #12]
          else
          {
            USBD_CtlError(pdev, req);
            err++;
          }
          break;
 8012cec:	e019      	b.n	8012d22 <USBD_GetDescriptor+0x262>
            USBD_CtlError(pdev, req);
 8012cee:	683a      	ldr	r2, [r7, #0]
 8012cf0:	687b      	ldr	r3, [r7, #4]
 8012cf2:	0011      	movs	r1, r2
 8012cf4:	0018      	movs	r0, r3
 8012cf6:	f000 fa79 	bl	80131ec <USBD_CtlError>
            err++;
 8012cfa:	210b      	movs	r1, #11
 8012cfc:	187b      	adds	r3, r7, r1
 8012cfe:	781a      	ldrb	r2, [r3, #0]
 8012d00:	187b      	adds	r3, r7, r1
 8012d02:	3201      	adds	r2, #1
 8012d04:	701a      	strb	r2, [r3, #0]
          break;
 8012d06:	e00c      	b.n	8012d22 <USBD_GetDescriptor+0x262>
            USBD_CtlError(pdev, req);
            err++;
          }
          break;
#else
          USBD_CtlError(pdev, req);
 8012d08:	683a      	ldr	r2, [r7, #0]
 8012d0a:	687b      	ldr	r3, [r7, #4]
 8012d0c:	0011      	movs	r1, r2
 8012d0e:	0018      	movs	r0, r3
 8012d10:	f000 fa6c 	bl	80131ec <USBD_CtlError>
          err++;
 8012d14:	210b      	movs	r1, #11
 8012d16:	187b      	adds	r3, r7, r1
 8012d18:	781a      	ldrb	r2, [r3, #0]
 8012d1a:	187b      	adds	r3, r7, r1
 8012d1c:	3201      	adds	r2, #1
 8012d1e:	701a      	strb	r2, [r3, #0]
#endif
      }
      break;
 8012d20:	e04b      	b.n	8012dba <USBD_GetDescriptor+0x2fa>
 8012d22:	e04a      	b.n	8012dba <USBD_GetDescriptor+0x2fa>

    case USB_DESC_TYPE_DEVICE_QUALIFIER:
      if (pdev->dev_speed == USBD_SPEED_HIGH)
 8012d24:	687b      	ldr	r3, [r7, #4]
 8012d26:	7c1b      	ldrb	r3, [r3, #16]
 8012d28:	2b00      	cmp	r3, #0
 8012d2a:	d10b      	bne.n	8012d44 <USBD_GetDescriptor+0x284>
      {
        pbuf = pdev->pClass->GetDeviceQualifierDescriptor(&len);
 8012d2c:	687a      	ldr	r2, [r7, #4]
 8012d2e:	23ad      	movs	r3, #173	; 0xad
 8012d30:	009b      	lsls	r3, r3, #2
 8012d32:	58d3      	ldr	r3, [r2, r3]
 8012d34:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8012d36:	2208      	movs	r2, #8
 8012d38:	18ba      	adds	r2, r7, r2
 8012d3a:	0010      	movs	r0, r2
 8012d3c:	4798      	blx	r3
 8012d3e:	0003      	movs	r3, r0
 8012d40:	60fb      	str	r3, [r7, #12]
      else
      {
        USBD_CtlError(pdev, req);
        err++;
      }
      break;
 8012d42:	e03a      	b.n	8012dba <USBD_GetDescriptor+0x2fa>
        USBD_CtlError(pdev, req);
 8012d44:	683a      	ldr	r2, [r7, #0]
 8012d46:	687b      	ldr	r3, [r7, #4]
 8012d48:	0011      	movs	r1, r2
 8012d4a:	0018      	movs	r0, r3
 8012d4c:	f000 fa4e 	bl	80131ec <USBD_CtlError>
        err++;
 8012d50:	210b      	movs	r1, #11
 8012d52:	187b      	adds	r3, r7, r1
 8012d54:	781a      	ldrb	r2, [r3, #0]
 8012d56:	187b      	adds	r3, r7, r1
 8012d58:	3201      	adds	r2, #1
 8012d5a:	701a      	strb	r2, [r3, #0]
      break;
 8012d5c:	e02d      	b.n	8012dba <USBD_GetDescriptor+0x2fa>

    case USB_DESC_TYPE_OTHER_SPEED_CONFIGURATION:
      if (pdev->dev_speed == USBD_SPEED_HIGH)
 8012d5e:	687b      	ldr	r3, [r7, #4]
 8012d60:	7c1b      	ldrb	r3, [r3, #16]
 8012d62:	2b00      	cmp	r3, #0
 8012d64:	d10f      	bne.n	8012d86 <USBD_GetDescriptor+0x2c6>
      {
        pbuf = pdev->pClass->GetOtherSpeedConfigDescriptor(&len);
 8012d66:	687a      	ldr	r2, [r7, #4]
 8012d68:	23ad      	movs	r3, #173	; 0xad
 8012d6a:	009b      	lsls	r3, r3, #2
 8012d6c:	58d3      	ldr	r3, [r2, r3]
 8012d6e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8012d70:	2208      	movs	r2, #8
 8012d72:	18ba      	adds	r2, r7, r2
 8012d74:	0010      	movs	r0, r2
 8012d76:	4798      	blx	r3
 8012d78:	0003      	movs	r3, r0
 8012d7a:	60fb      	str	r3, [r7, #12]
        pbuf[1] = USB_DESC_TYPE_OTHER_SPEED_CONFIGURATION;
 8012d7c:	68fb      	ldr	r3, [r7, #12]
 8012d7e:	3301      	adds	r3, #1
 8012d80:	2207      	movs	r2, #7
 8012d82:	701a      	strb	r2, [r3, #0]
      else
      {
        USBD_CtlError(pdev, req);
        err++;
      }
      break;
 8012d84:	e019      	b.n	8012dba <USBD_GetDescriptor+0x2fa>
        USBD_CtlError(pdev, req);
 8012d86:	683a      	ldr	r2, [r7, #0]
 8012d88:	687b      	ldr	r3, [r7, #4]
 8012d8a:	0011      	movs	r1, r2
 8012d8c:	0018      	movs	r0, r3
 8012d8e:	f000 fa2d 	bl	80131ec <USBD_CtlError>
        err++;
 8012d92:	210b      	movs	r1, #11
 8012d94:	187b      	adds	r3, r7, r1
 8012d96:	781a      	ldrb	r2, [r3, #0]
 8012d98:	187b      	adds	r3, r7, r1
 8012d9a:	3201      	adds	r2, #1
 8012d9c:	701a      	strb	r2, [r3, #0]
      break;
 8012d9e:	e00c      	b.n	8012dba <USBD_GetDescriptor+0x2fa>

    default:
      USBD_CtlError(pdev, req);
 8012da0:	683a      	ldr	r2, [r7, #0]
 8012da2:	687b      	ldr	r3, [r7, #4]
 8012da4:	0011      	movs	r1, r2
 8012da6:	0018      	movs	r0, r3
 8012da8:	f000 fa20 	bl	80131ec <USBD_CtlError>
      err++;
 8012dac:	210b      	movs	r1, #11
 8012dae:	187b      	adds	r3, r7, r1
 8012db0:	781a      	ldrb	r2, [r3, #0]
 8012db2:	187b      	adds	r3, r7, r1
 8012db4:	3201      	adds	r2, #1
 8012db6:	701a      	strb	r2, [r3, #0]
      break;
 8012db8:	46c0      	nop			; (mov r8, r8)
  }

  if (err != 0U)
 8012dba:	230b      	movs	r3, #11
 8012dbc:	18fb      	adds	r3, r7, r3
 8012dbe:	781b      	ldrb	r3, [r3, #0]
 8012dc0:	2b00      	cmp	r3, #0
 8012dc2:	d127      	bne.n	8012e14 <USBD_GetDescriptor+0x354>
  {
    return;
  }
  else
  {
    if ((len != 0U) && (req->wLength != 0U))
 8012dc4:	2108      	movs	r1, #8
 8012dc6:	187b      	adds	r3, r7, r1
 8012dc8:	881b      	ldrh	r3, [r3, #0]
 8012dca:	2b00      	cmp	r3, #0
 8012dcc:	d019      	beq.n	8012e02 <USBD_GetDescriptor+0x342>
 8012dce:	683b      	ldr	r3, [r7, #0]
 8012dd0:	88db      	ldrh	r3, [r3, #6]
 8012dd2:	2b00      	cmp	r3, #0
 8012dd4:	d015      	beq.n	8012e02 <USBD_GetDescriptor+0x342>
    {
      len = MIN(len, req->wLength);
 8012dd6:	683b      	ldr	r3, [r7, #0]
 8012dd8:	88da      	ldrh	r2, [r3, #6]
 8012dda:	187b      	adds	r3, r7, r1
 8012ddc:	881b      	ldrh	r3, [r3, #0]
 8012dde:	1c18      	adds	r0, r3, #0
 8012de0:	1c11      	adds	r1, r2, #0
 8012de2:	b28a      	uxth	r2, r1
 8012de4:	b283      	uxth	r3, r0
 8012de6:	429a      	cmp	r2, r3
 8012de8:	d900      	bls.n	8012dec <USBD_GetDescriptor+0x32c>
 8012dea:	1c01      	adds	r1, r0, #0
 8012dec:	b28a      	uxth	r2, r1
 8012dee:	2108      	movs	r1, #8
 8012df0:	187b      	adds	r3, r7, r1
 8012df2:	801a      	strh	r2, [r3, #0]
      (void)USBD_CtlSendData(pdev, pbuf, len);
 8012df4:	187b      	adds	r3, r7, r1
 8012df6:	881a      	ldrh	r2, [r3, #0]
 8012df8:	68f9      	ldr	r1, [r7, #12]
 8012dfa:	687b      	ldr	r3, [r7, #4]
 8012dfc:	0018      	movs	r0, r3
 8012dfe:	f000 fa73 	bl	80132e8 <USBD_CtlSendData>
    }

    if (req->wLength == 0U)
 8012e02:	683b      	ldr	r3, [r7, #0]
 8012e04:	88db      	ldrh	r3, [r3, #6]
 8012e06:	2b00      	cmp	r3, #0
 8012e08:	d105      	bne.n	8012e16 <USBD_GetDescriptor+0x356>
    {
      (void)USBD_CtlSendStatus(pdev);
 8012e0a:	687b      	ldr	r3, [r7, #4]
 8012e0c:	0018      	movs	r0, r3
 8012e0e:	f000 fad5 	bl	80133bc <USBD_CtlSendStatus>
 8012e12:	e000      	b.n	8012e16 <USBD_GetDescriptor+0x356>
    return;
 8012e14:	46c0      	nop			; (mov r8, r8)
    }
  }
}
 8012e16:	46bd      	mov	sp, r7
 8012e18:	b004      	add	sp, #16
 8012e1a:	bd80      	pop	{r7, pc}
 8012e1c:	08015d7c 	.word	0x08015d7c
 8012e20:	08015d9c 	.word	0x08015d9c

08012e24 <USBD_SetAddress>:
* @param  req: usb request
* @retval status
*/
static void USBD_SetAddress(USBD_HandleTypeDef *pdev,
                            USBD_SetupReqTypedef *req)
{
 8012e24:	b590      	push	{r4, r7, lr}
 8012e26:	b085      	sub	sp, #20
 8012e28:	af00      	add	r7, sp, #0
 8012e2a:	6078      	str	r0, [r7, #4]
 8012e2c:	6039      	str	r1, [r7, #0]
  uint8_t  dev_addr;

  if ((req->wIndex == 0U) && (req->wLength == 0U) && (req->wValue < 128U))
 8012e2e:	683b      	ldr	r3, [r7, #0]
 8012e30:	889b      	ldrh	r3, [r3, #4]
 8012e32:	2b00      	cmp	r3, #0
 8012e34:	d13d      	bne.n	8012eb2 <USBD_SetAddress+0x8e>
 8012e36:	683b      	ldr	r3, [r7, #0]
 8012e38:	88db      	ldrh	r3, [r3, #6]
 8012e3a:	2b00      	cmp	r3, #0
 8012e3c:	d139      	bne.n	8012eb2 <USBD_SetAddress+0x8e>
 8012e3e:	683b      	ldr	r3, [r7, #0]
 8012e40:	885b      	ldrh	r3, [r3, #2]
 8012e42:	2b7f      	cmp	r3, #127	; 0x7f
 8012e44:	d835      	bhi.n	8012eb2 <USBD_SetAddress+0x8e>
  {
    dev_addr = (uint8_t)(req->wValue) & 0x7FU;
 8012e46:	683b      	ldr	r3, [r7, #0]
 8012e48:	885b      	ldrh	r3, [r3, #2]
 8012e4a:	b2da      	uxtb	r2, r3
 8012e4c:	230f      	movs	r3, #15
 8012e4e:	18fb      	adds	r3, r7, r3
 8012e50:	217f      	movs	r1, #127	; 0x7f
 8012e52:	400a      	ands	r2, r1
 8012e54:	701a      	strb	r2, [r3, #0]

    if (pdev->dev_state == USBD_STATE_CONFIGURED)
 8012e56:	687a      	ldr	r2, [r7, #4]
 8012e58:	23a7      	movs	r3, #167	; 0xa7
 8012e5a:	009b      	lsls	r3, r3, #2
 8012e5c:	5cd3      	ldrb	r3, [r2, r3]
 8012e5e:	2b03      	cmp	r3, #3
 8012e60:	d106      	bne.n	8012e70 <USBD_SetAddress+0x4c>
    {
      USBD_CtlError(pdev, req);
 8012e62:	683a      	ldr	r2, [r7, #0]
 8012e64:	687b      	ldr	r3, [r7, #4]
 8012e66:	0011      	movs	r1, r2
 8012e68:	0018      	movs	r0, r3
 8012e6a:	f000 f9bf 	bl	80131ec <USBD_CtlError>
    if (pdev->dev_state == USBD_STATE_CONFIGURED)
 8012e6e:	e027      	b.n	8012ec0 <USBD_SetAddress+0x9c>
    }
    else
    {
      pdev->dev_address = dev_addr;
 8012e70:	687b      	ldr	r3, [r7, #4]
 8012e72:	240f      	movs	r4, #15
 8012e74:	193a      	adds	r2, r7, r4
 8012e76:	4914      	ldr	r1, [pc, #80]	; (8012ec8 <USBD_SetAddress+0xa4>)
 8012e78:	7812      	ldrb	r2, [r2, #0]
 8012e7a:	545a      	strb	r2, [r3, r1]
      USBD_LL_SetUSBAddress(pdev, dev_addr);
 8012e7c:	193b      	adds	r3, r7, r4
 8012e7e:	781a      	ldrb	r2, [r3, #0]
 8012e80:	687b      	ldr	r3, [r7, #4]
 8012e82:	0011      	movs	r1, r2
 8012e84:	0018      	movs	r0, r3
 8012e86:	f001 ff8f 	bl	8014da8 <USBD_LL_SetUSBAddress>
      USBD_CtlSendStatus(pdev);
 8012e8a:	687b      	ldr	r3, [r7, #4]
 8012e8c:	0018      	movs	r0, r3
 8012e8e:	f000 fa95 	bl	80133bc <USBD_CtlSendStatus>

      if (dev_addr != 0U)
 8012e92:	193b      	adds	r3, r7, r4
 8012e94:	781b      	ldrb	r3, [r3, #0]
 8012e96:	2b00      	cmp	r3, #0
 8012e98:	d005      	beq.n	8012ea6 <USBD_SetAddress+0x82>
      {
        pdev->dev_state = USBD_STATE_ADDRESSED;
 8012e9a:	687a      	ldr	r2, [r7, #4]
 8012e9c:	23a7      	movs	r3, #167	; 0xa7
 8012e9e:	009b      	lsls	r3, r3, #2
 8012ea0:	2102      	movs	r1, #2
 8012ea2:	54d1      	strb	r1, [r2, r3]
    if (pdev->dev_state == USBD_STATE_CONFIGURED)
 8012ea4:	e00c      	b.n	8012ec0 <USBD_SetAddress+0x9c>
      }
      else
      {
        pdev->dev_state = USBD_STATE_DEFAULT;
 8012ea6:	687a      	ldr	r2, [r7, #4]
 8012ea8:	23a7      	movs	r3, #167	; 0xa7
 8012eaa:	009b      	lsls	r3, r3, #2
 8012eac:	2101      	movs	r1, #1
 8012eae:	54d1      	strb	r1, [r2, r3]
    if (pdev->dev_state == USBD_STATE_CONFIGURED)
 8012eb0:	e006      	b.n	8012ec0 <USBD_SetAddress+0x9c>
      }
    }
  }
  else
  {
    USBD_CtlError(pdev, req);
 8012eb2:	683a      	ldr	r2, [r7, #0]
 8012eb4:	687b      	ldr	r3, [r7, #4]
 8012eb6:	0011      	movs	r1, r2
 8012eb8:	0018      	movs	r0, r3
 8012eba:	f000 f997 	bl	80131ec <USBD_CtlError>
  }
}
 8012ebe:	46c0      	nop			; (mov r8, r8)
 8012ec0:	46c0      	nop			; (mov r8, r8)
 8012ec2:	46bd      	mov	sp, r7
 8012ec4:	b005      	add	sp, #20
 8012ec6:	bd90      	pop	{r4, r7, pc}
 8012ec8:	0000029e 	.word	0x0000029e

08012ecc <USBD_SetConfig>:
* @param  pdev: device instance
* @param  req: usb request
* @retval status
*/
static void USBD_SetConfig(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 8012ecc:	b580      	push	{r7, lr}
 8012ece:	b082      	sub	sp, #8
 8012ed0:	af00      	add	r7, sp, #0
 8012ed2:	6078      	str	r0, [r7, #4]
 8012ed4:	6039      	str	r1, [r7, #0]
  static uint8_t cfgidx;

  cfgidx = (uint8_t)(req->wValue);
 8012ed6:	683b      	ldr	r3, [r7, #0]
 8012ed8:	885b      	ldrh	r3, [r3, #2]
 8012eda:	b2da      	uxtb	r2, r3
 8012edc:	4b4c      	ldr	r3, [pc, #304]	; (8013010 <USBD_SetConfig+0x144>)
 8012ede:	701a      	strb	r2, [r3, #0]

  if (cfgidx > USBD_MAX_NUM_CONFIGURATION)
 8012ee0:	4b4b      	ldr	r3, [pc, #300]	; (8013010 <USBD_SetConfig+0x144>)
 8012ee2:	781b      	ldrb	r3, [r3, #0]
 8012ee4:	2b01      	cmp	r3, #1
 8012ee6:	d906      	bls.n	8012ef6 <USBD_SetConfig+0x2a>
  {
    USBD_CtlError(pdev, req);
 8012ee8:	683a      	ldr	r2, [r7, #0]
 8012eea:	687b      	ldr	r3, [r7, #4]
 8012eec:	0011      	movs	r1, r2
 8012eee:	0018      	movs	r0, r3
 8012ef0:	f000 f97c 	bl	80131ec <USBD_CtlError>
 8012ef4:	e088      	b.n	8013008 <USBD_SetConfig+0x13c>
  }
  else
  {
    switch (pdev->dev_state)
 8012ef6:	687a      	ldr	r2, [r7, #4]
 8012ef8:	23a7      	movs	r3, #167	; 0xa7
 8012efa:	009b      	lsls	r3, r3, #2
 8012efc:	5cd3      	ldrb	r3, [r2, r3]
 8012efe:	2b02      	cmp	r3, #2
 8012f00:	d002      	beq.n	8012f08 <USBD_SetConfig+0x3c>
 8012f02:	2b03      	cmp	r3, #3
 8012f04:	d029      	beq.n	8012f5a <USBD_SetConfig+0x8e>
 8012f06:	e071      	b.n	8012fec <USBD_SetConfig+0x120>
    {
      case USBD_STATE_ADDRESSED:
        if (cfgidx)
 8012f08:	4b41      	ldr	r3, [pc, #260]	; (8013010 <USBD_SetConfig+0x144>)
 8012f0a:	781b      	ldrb	r3, [r3, #0]
 8012f0c:	2b00      	cmp	r3, #0
 8012f0e:	d01f      	beq.n	8012f50 <USBD_SetConfig+0x84>
        {
          pdev->dev_config = cfgidx;
 8012f10:	4b3f      	ldr	r3, [pc, #252]	; (8013010 <USBD_SetConfig+0x144>)
 8012f12:	781b      	ldrb	r3, [r3, #0]
 8012f14:	001a      	movs	r2, r3
 8012f16:	687b      	ldr	r3, [r7, #4]
 8012f18:	605a      	str	r2, [r3, #4]
          pdev->dev_state = USBD_STATE_CONFIGURED;
 8012f1a:	687a      	ldr	r2, [r7, #4]
 8012f1c:	23a7      	movs	r3, #167	; 0xa7
 8012f1e:	009b      	lsls	r3, r3, #2
 8012f20:	2103      	movs	r1, #3
 8012f22:	54d1      	strb	r1, [r2, r3]
          if (USBD_SetClassConfig(pdev, cfgidx) == USBD_FAIL)
 8012f24:	4b3a      	ldr	r3, [pc, #232]	; (8013010 <USBD_SetConfig+0x144>)
 8012f26:	781a      	ldrb	r2, [r3, #0]
 8012f28:	687b      	ldr	r3, [r7, #4]
 8012f2a:	0011      	movs	r1, r2
 8012f2c:	0018      	movs	r0, r3
 8012f2e:	f7ff f8c5 	bl	80120bc <USBD_SetClassConfig>
 8012f32:	0003      	movs	r3, r0
 8012f34:	2b02      	cmp	r3, #2
 8012f36:	d106      	bne.n	8012f46 <USBD_SetConfig+0x7a>
          {
            USBD_CtlError(pdev, req);
 8012f38:	683a      	ldr	r2, [r7, #0]
 8012f3a:	687b      	ldr	r3, [r7, #4]
 8012f3c:	0011      	movs	r1, r2
 8012f3e:	0018      	movs	r0, r3
 8012f40:	f000 f954 	bl	80131ec <USBD_CtlError>
            return;
 8012f44:	e060      	b.n	8013008 <USBD_SetConfig+0x13c>
          }
          USBD_CtlSendStatus(pdev);
 8012f46:	687b      	ldr	r3, [r7, #4]
 8012f48:	0018      	movs	r0, r3
 8012f4a:	f000 fa37 	bl	80133bc <USBD_CtlSendStatus>
        }
        else
        {
          USBD_CtlSendStatus(pdev);
        }
        break;
 8012f4e:	e05b      	b.n	8013008 <USBD_SetConfig+0x13c>
          USBD_CtlSendStatus(pdev);
 8012f50:	687b      	ldr	r3, [r7, #4]
 8012f52:	0018      	movs	r0, r3
 8012f54:	f000 fa32 	bl	80133bc <USBD_CtlSendStatus>
        break;
 8012f58:	e056      	b.n	8013008 <USBD_SetConfig+0x13c>

      case USBD_STATE_CONFIGURED:
        if (cfgidx == 0U)
 8012f5a:	4b2d      	ldr	r3, [pc, #180]	; (8013010 <USBD_SetConfig+0x144>)
 8012f5c:	781b      	ldrb	r3, [r3, #0]
 8012f5e:	2b00      	cmp	r3, #0
 8012f60:	d115      	bne.n	8012f8e <USBD_SetConfig+0xc2>
        {
          pdev->dev_state = USBD_STATE_ADDRESSED;
 8012f62:	687a      	ldr	r2, [r7, #4]
 8012f64:	23a7      	movs	r3, #167	; 0xa7
 8012f66:	009b      	lsls	r3, r3, #2
 8012f68:	2102      	movs	r1, #2
 8012f6a:	54d1      	strb	r1, [r2, r3]
          pdev->dev_config = cfgidx;
 8012f6c:	4b28      	ldr	r3, [pc, #160]	; (8013010 <USBD_SetConfig+0x144>)
 8012f6e:	781b      	ldrb	r3, [r3, #0]
 8012f70:	001a      	movs	r2, r3
 8012f72:	687b      	ldr	r3, [r7, #4]
 8012f74:	605a      	str	r2, [r3, #4]
          USBD_ClrClassConfig(pdev, cfgidx);
 8012f76:	4b26      	ldr	r3, [pc, #152]	; (8013010 <USBD_SetConfig+0x144>)
 8012f78:	781a      	ldrb	r2, [r3, #0]
 8012f7a:	687b      	ldr	r3, [r7, #4]
 8012f7c:	0011      	movs	r1, r2
 8012f7e:	0018      	movs	r0, r3
 8012f80:	f7ff f8c3 	bl	801210a <USBD_ClrClassConfig>
          USBD_CtlSendStatus(pdev);
 8012f84:	687b      	ldr	r3, [r7, #4]
 8012f86:	0018      	movs	r0, r3
 8012f88:	f000 fa18 	bl	80133bc <USBD_CtlSendStatus>
        }
        else
        {
          USBD_CtlSendStatus(pdev);
        }
        break;
 8012f8c:	e03c      	b.n	8013008 <USBD_SetConfig+0x13c>
        else if (cfgidx != pdev->dev_config)
 8012f8e:	4b20      	ldr	r3, [pc, #128]	; (8013010 <USBD_SetConfig+0x144>)
 8012f90:	781b      	ldrb	r3, [r3, #0]
 8012f92:	001a      	movs	r2, r3
 8012f94:	687b      	ldr	r3, [r7, #4]
 8012f96:	685b      	ldr	r3, [r3, #4]
 8012f98:	429a      	cmp	r2, r3
 8012f9a:	d022      	beq.n	8012fe2 <USBD_SetConfig+0x116>
          USBD_ClrClassConfig(pdev, (uint8_t)pdev->dev_config);
 8012f9c:	687b      	ldr	r3, [r7, #4]
 8012f9e:	685b      	ldr	r3, [r3, #4]
 8012fa0:	b2da      	uxtb	r2, r3
 8012fa2:	687b      	ldr	r3, [r7, #4]
 8012fa4:	0011      	movs	r1, r2
 8012fa6:	0018      	movs	r0, r3
 8012fa8:	f7ff f8af 	bl	801210a <USBD_ClrClassConfig>
          pdev->dev_config = cfgidx;
 8012fac:	4b18      	ldr	r3, [pc, #96]	; (8013010 <USBD_SetConfig+0x144>)
 8012fae:	781b      	ldrb	r3, [r3, #0]
 8012fb0:	001a      	movs	r2, r3
 8012fb2:	687b      	ldr	r3, [r7, #4]
 8012fb4:	605a      	str	r2, [r3, #4]
          if (USBD_SetClassConfig(pdev, cfgidx) == USBD_FAIL)
 8012fb6:	4b16      	ldr	r3, [pc, #88]	; (8013010 <USBD_SetConfig+0x144>)
 8012fb8:	781a      	ldrb	r2, [r3, #0]
 8012fba:	687b      	ldr	r3, [r7, #4]
 8012fbc:	0011      	movs	r1, r2
 8012fbe:	0018      	movs	r0, r3
 8012fc0:	f7ff f87c 	bl	80120bc <USBD_SetClassConfig>
 8012fc4:	0003      	movs	r3, r0
 8012fc6:	2b02      	cmp	r3, #2
 8012fc8:	d106      	bne.n	8012fd8 <USBD_SetConfig+0x10c>
            USBD_CtlError(pdev, req);
 8012fca:	683a      	ldr	r2, [r7, #0]
 8012fcc:	687b      	ldr	r3, [r7, #4]
 8012fce:	0011      	movs	r1, r2
 8012fd0:	0018      	movs	r0, r3
 8012fd2:	f000 f90b 	bl	80131ec <USBD_CtlError>
            return;
 8012fd6:	e017      	b.n	8013008 <USBD_SetConfig+0x13c>
          USBD_CtlSendStatus(pdev);
 8012fd8:	687b      	ldr	r3, [r7, #4]
 8012fda:	0018      	movs	r0, r3
 8012fdc:	f000 f9ee 	bl	80133bc <USBD_CtlSendStatus>
        break;
 8012fe0:	e012      	b.n	8013008 <USBD_SetConfig+0x13c>
          USBD_CtlSendStatus(pdev);
 8012fe2:	687b      	ldr	r3, [r7, #4]
 8012fe4:	0018      	movs	r0, r3
 8012fe6:	f000 f9e9 	bl	80133bc <USBD_CtlSendStatus>
        break;
 8012fea:	e00d      	b.n	8013008 <USBD_SetConfig+0x13c>

      default:
        USBD_CtlError(pdev, req);
 8012fec:	683a      	ldr	r2, [r7, #0]
 8012fee:	687b      	ldr	r3, [r7, #4]
 8012ff0:	0011      	movs	r1, r2
 8012ff2:	0018      	movs	r0, r3
 8012ff4:	f000 f8fa 	bl	80131ec <USBD_CtlError>
        USBD_ClrClassConfig(pdev, cfgidx);
 8012ff8:	4b05      	ldr	r3, [pc, #20]	; (8013010 <USBD_SetConfig+0x144>)
 8012ffa:	781a      	ldrb	r2, [r3, #0]
 8012ffc:	687b      	ldr	r3, [r7, #4]
 8012ffe:	0011      	movs	r1, r2
 8013000:	0018      	movs	r0, r3
 8013002:	f7ff f882 	bl	801210a <USBD_ClrClassConfig>
        break;
 8013006:	46c0      	nop			; (mov r8, r8)
    }
  }
}
 8013008:	46bd      	mov	sp, r7
 801300a:	b002      	add	sp, #8
 801300c:	bd80      	pop	{r7, pc}
 801300e:	46c0      	nop			; (mov r8, r8)
 8013010:	200005cc 	.word	0x200005cc

08013014 <USBD_GetConfig>:
* @param  pdev: device instance
* @param  req: usb request
* @retval status
*/
static void USBD_GetConfig(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 8013014:	b580      	push	{r7, lr}
 8013016:	b082      	sub	sp, #8
 8013018:	af00      	add	r7, sp, #0
 801301a:	6078      	str	r0, [r7, #4]
 801301c:	6039      	str	r1, [r7, #0]
  if (req->wLength != 1U)
 801301e:	683b      	ldr	r3, [r7, #0]
 8013020:	88db      	ldrh	r3, [r3, #6]
 8013022:	2b01      	cmp	r3, #1
 8013024:	d006      	beq.n	8013034 <USBD_GetConfig+0x20>
  {
    USBD_CtlError(pdev, req);
 8013026:	683a      	ldr	r2, [r7, #0]
 8013028:	687b      	ldr	r3, [r7, #4]
 801302a:	0011      	movs	r1, r2
 801302c:	0018      	movs	r0, r3
 801302e:	f000 f8dd 	bl	80131ec <USBD_CtlError>
      default:
        USBD_CtlError(pdev, req);
        break;
    }
  }
}
 8013032:	e026      	b.n	8013082 <USBD_GetConfig+0x6e>
    switch (pdev->dev_state)
 8013034:	687a      	ldr	r2, [r7, #4]
 8013036:	23a7      	movs	r3, #167	; 0xa7
 8013038:	009b      	lsls	r3, r3, #2
 801303a:	5cd3      	ldrb	r3, [r2, r3]
 801303c:	2b02      	cmp	r3, #2
 801303e:	dc02      	bgt.n	8013046 <USBD_GetConfig+0x32>
 8013040:	2b00      	cmp	r3, #0
 8013042:	dc03      	bgt.n	801304c <USBD_GetConfig+0x38>
 8013044:	e016      	b.n	8013074 <USBD_GetConfig+0x60>
 8013046:	2b03      	cmp	r3, #3
 8013048:	d00c      	beq.n	8013064 <USBD_GetConfig+0x50>
 801304a:	e013      	b.n	8013074 <USBD_GetConfig+0x60>
        pdev->dev_default_config = 0U;
 801304c:	687b      	ldr	r3, [r7, #4]
 801304e:	2200      	movs	r2, #0
 8013050:	609a      	str	r2, [r3, #8]
        USBD_CtlSendData(pdev, (uint8_t *)(void *)&pdev->dev_default_config, 1U);
 8013052:	687b      	ldr	r3, [r7, #4]
 8013054:	3308      	adds	r3, #8
 8013056:	0019      	movs	r1, r3
 8013058:	687b      	ldr	r3, [r7, #4]
 801305a:	2201      	movs	r2, #1
 801305c:	0018      	movs	r0, r3
 801305e:	f000 f943 	bl	80132e8 <USBD_CtlSendData>
        break;
 8013062:	e00e      	b.n	8013082 <USBD_GetConfig+0x6e>
        USBD_CtlSendData(pdev, (uint8_t *)(void *)&pdev->dev_config, 1U);
 8013064:	687b      	ldr	r3, [r7, #4]
 8013066:	1d19      	adds	r1, r3, #4
 8013068:	687b      	ldr	r3, [r7, #4]
 801306a:	2201      	movs	r2, #1
 801306c:	0018      	movs	r0, r3
 801306e:	f000 f93b 	bl	80132e8 <USBD_CtlSendData>
        break;
 8013072:	e006      	b.n	8013082 <USBD_GetConfig+0x6e>
        USBD_CtlError(pdev, req);
 8013074:	683a      	ldr	r2, [r7, #0]
 8013076:	687b      	ldr	r3, [r7, #4]
 8013078:	0011      	movs	r1, r2
 801307a:	0018      	movs	r0, r3
 801307c:	f000 f8b6 	bl	80131ec <USBD_CtlError>
        break;
 8013080:	46c0      	nop			; (mov r8, r8)
}
 8013082:	46c0      	nop			; (mov r8, r8)
 8013084:	46bd      	mov	sp, r7
 8013086:	b002      	add	sp, #8
 8013088:	bd80      	pop	{r7, pc}

0801308a <USBD_GetStatus>:
* @param  pdev: device instance
* @param  req: usb request
* @retval status
*/
static void USBD_GetStatus(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 801308a:	b580      	push	{r7, lr}
 801308c:	b082      	sub	sp, #8
 801308e:	af00      	add	r7, sp, #0
 8013090:	6078      	str	r0, [r7, #4]
 8013092:	6039      	str	r1, [r7, #0]
  switch (pdev->dev_state)
 8013094:	687a      	ldr	r2, [r7, #4]
 8013096:	23a7      	movs	r3, #167	; 0xa7
 8013098:	009b      	lsls	r3, r3, #2
 801309a:	5cd3      	ldrb	r3, [r2, r3]
 801309c:	3b01      	subs	r3, #1
 801309e:	2b02      	cmp	r3, #2
 80130a0:	d822      	bhi.n	80130e8 <USBD_GetStatus+0x5e>
  {
    case USBD_STATE_DEFAULT:
    case USBD_STATE_ADDRESSED:
    case USBD_STATE_CONFIGURED:
      if (req->wLength != 0x2U)
 80130a2:	683b      	ldr	r3, [r7, #0]
 80130a4:	88db      	ldrh	r3, [r3, #6]
 80130a6:	2b02      	cmp	r3, #2
 80130a8:	d006      	beq.n	80130b8 <USBD_GetStatus+0x2e>
      {
        USBD_CtlError(pdev, req);
 80130aa:	683a      	ldr	r2, [r7, #0]
 80130ac:	687b      	ldr	r3, [r7, #4]
 80130ae:	0011      	movs	r1, r2
 80130b0:	0018      	movs	r0, r3
 80130b2:	f000 f89b 	bl	80131ec <USBD_CtlError>
        break;
 80130b6:	e01e      	b.n	80130f6 <USBD_GetStatus+0x6c>
      }

#if (USBD_SELF_POWERED == 1U)
      pdev->dev_config_status = USB_CONFIG_SELF_POWERED;
 80130b8:	687b      	ldr	r3, [r7, #4]
 80130ba:	2201      	movs	r2, #1
 80130bc:	60da      	str	r2, [r3, #12]
#else
      pdev->dev_config_status = 0U;
#endif

      if (pdev->dev_remote_wakeup)
 80130be:	687a      	ldr	r2, [r7, #4]
 80130c0:	23a9      	movs	r3, #169	; 0xa9
 80130c2:	009b      	lsls	r3, r3, #2
 80130c4:	58d3      	ldr	r3, [r2, r3]
 80130c6:	2b00      	cmp	r3, #0
 80130c8:	d005      	beq.n	80130d6 <USBD_GetStatus+0x4c>
      {
        pdev->dev_config_status |= USB_CONFIG_REMOTE_WAKEUP;
 80130ca:	687b      	ldr	r3, [r7, #4]
 80130cc:	68db      	ldr	r3, [r3, #12]
 80130ce:	2202      	movs	r2, #2
 80130d0:	431a      	orrs	r2, r3
 80130d2:	687b      	ldr	r3, [r7, #4]
 80130d4:	60da      	str	r2, [r3, #12]
      }

      USBD_CtlSendData(pdev, (uint8_t *)(void *)&pdev->dev_config_status, 2U);
 80130d6:	687b      	ldr	r3, [r7, #4]
 80130d8:	330c      	adds	r3, #12
 80130da:	0019      	movs	r1, r3
 80130dc:	687b      	ldr	r3, [r7, #4]
 80130de:	2202      	movs	r2, #2
 80130e0:	0018      	movs	r0, r3
 80130e2:	f000 f901 	bl	80132e8 <USBD_CtlSendData>
      break;
 80130e6:	e006      	b.n	80130f6 <USBD_GetStatus+0x6c>

    default:
      USBD_CtlError(pdev, req);
 80130e8:	683a      	ldr	r2, [r7, #0]
 80130ea:	687b      	ldr	r3, [r7, #4]
 80130ec:	0011      	movs	r1, r2
 80130ee:	0018      	movs	r0, r3
 80130f0:	f000 f87c 	bl	80131ec <USBD_CtlError>
      break;
 80130f4:	46c0      	nop			; (mov r8, r8)
  }
}
 80130f6:	46c0      	nop			; (mov r8, r8)
 80130f8:	46bd      	mov	sp, r7
 80130fa:	b002      	add	sp, #8
 80130fc:	bd80      	pop	{r7, pc}

080130fe <USBD_SetFeature>:
* @param  req: usb request
* @retval status
*/
static void USBD_SetFeature(USBD_HandleTypeDef *pdev,
                            USBD_SetupReqTypedef *req)
{
 80130fe:	b580      	push	{r7, lr}
 8013100:	b082      	sub	sp, #8
 8013102:	af00      	add	r7, sp, #0
 8013104:	6078      	str	r0, [r7, #4]
 8013106:	6039      	str	r1, [r7, #0]
  if (req->wValue == USB_FEATURE_REMOTE_WAKEUP)
 8013108:	683b      	ldr	r3, [r7, #0]
 801310a:	885b      	ldrh	r3, [r3, #2]
 801310c:	2b01      	cmp	r3, #1
 801310e:	d108      	bne.n	8013122 <USBD_SetFeature+0x24>
  {
    pdev->dev_remote_wakeup = 1U;
 8013110:	687a      	ldr	r2, [r7, #4]
 8013112:	23a9      	movs	r3, #169	; 0xa9
 8013114:	009b      	lsls	r3, r3, #2
 8013116:	2101      	movs	r1, #1
 8013118:	50d1      	str	r1, [r2, r3]
    USBD_CtlSendStatus(pdev);
 801311a:	687b      	ldr	r3, [r7, #4]
 801311c:	0018      	movs	r0, r3
 801311e:	f000 f94d 	bl	80133bc <USBD_CtlSendStatus>
  }
}
 8013122:	46c0      	nop			; (mov r8, r8)
 8013124:	46bd      	mov	sp, r7
 8013126:	b002      	add	sp, #8
 8013128:	bd80      	pop	{r7, pc}

0801312a <USBD_ClrFeature>:
* @param  req: usb request
* @retval status
*/
static void USBD_ClrFeature(USBD_HandleTypeDef *pdev,
                            USBD_SetupReqTypedef *req)
{
 801312a:	b580      	push	{r7, lr}
 801312c:	b082      	sub	sp, #8
 801312e:	af00      	add	r7, sp, #0
 8013130:	6078      	str	r0, [r7, #4]
 8013132:	6039      	str	r1, [r7, #0]
  switch (pdev->dev_state)
 8013134:	687a      	ldr	r2, [r7, #4]
 8013136:	23a7      	movs	r3, #167	; 0xa7
 8013138:	009b      	lsls	r3, r3, #2
 801313a:	5cd3      	ldrb	r3, [r2, r3]
 801313c:	3b01      	subs	r3, #1
 801313e:	2b02      	cmp	r3, #2
 8013140:	d80d      	bhi.n	801315e <USBD_ClrFeature+0x34>
  {
    case USBD_STATE_DEFAULT:
    case USBD_STATE_ADDRESSED:
    case USBD_STATE_CONFIGURED:
      if (req->wValue == USB_FEATURE_REMOTE_WAKEUP)
 8013142:	683b      	ldr	r3, [r7, #0]
 8013144:	885b      	ldrh	r3, [r3, #2]
 8013146:	2b01      	cmp	r3, #1
 8013148:	d110      	bne.n	801316c <USBD_ClrFeature+0x42>
      {
        pdev->dev_remote_wakeup = 0U;
 801314a:	687a      	ldr	r2, [r7, #4]
 801314c:	23a9      	movs	r3, #169	; 0xa9
 801314e:	009b      	lsls	r3, r3, #2
 8013150:	2100      	movs	r1, #0
 8013152:	50d1      	str	r1, [r2, r3]
        USBD_CtlSendStatus(pdev);
 8013154:	687b      	ldr	r3, [r7, #4]
 8013156:	0018      	movs	r0, r3
 8013158:	f000 f930 	bl	80133bc <USBD_CtlSendStatus>
      }
      break;
 801315c:	e006      	b.n	801316c <USBD_ClrFeature+0x42>

    default:
      USBD_CtlError(pdev, req);
 801315e:	683a      	ldr	r2, [r7, #0]
 8013160:	687b      	ldr	r3, [r7, #4]
 8013162:	0011      	movs	r1, r2
 8013164:	0018      	movs	r0, r3
 8013166:	f000 f841 	bl	80131ec <USBD_CtlError>
      break;
 801316a:	e000      	b.n	801316e <USBD_ClrFeature+0x44>
      break;
 801316c:	46c0      	nop			; (mov r8, r8)
  }
}
 801316e:	46c0      	nop			; (mov r8, r8)
 8013170:	46bd      	mov	sp, r7
 8013172:	b002      	add	sp, #8
 8013174:	bd80      	pop	{r7, pc}

08013176 <USBD_ParseSetupRequest>:
* @param  req: usb request
* @retval None
*/

void USBD_ParseSetupRequest(USBD_SetupReqTypedef *req, uint8_t *pdata)
{
 8013176:	b580      	push	{r7, lr}
 8013178:	b082      	sub	sp, #8
 801317a:	af00      	add	r7, sp, #0
 801317c:	6078      	str	r0, [r7, #4]
 801317e:	6039      	str	r1, [r7, #0]
  req->bmRequest = *(uint8_t *)(pdata);
 8013180:	683b      	ldr	r3, [r7, #0]
 8013182:	781a      	ldrb	r2, [r3, #0]
 8013184:	687b      	ldr	r3, [r7, #4]
 8013186:	701a      	strb	r2, [r3, #0]
  req->bRequest = *(uint8_t *)(pdata + 1U);
 8013188:	683b      	ldr	r3, [r7, #0]
 801318a:	785a      	ldrb	r2, [r3, #1]
 801318c:	687b      	ldr	r3, [r7, #4]
 801318e:	705a      	strb	r2, [r3, #1]
  req->wValue = SWAPBYTE(pdata + 2U);
 8013190:	683b      	ldr	r3, [r7, #0]
 8013192:	3302      	adds	r3, #2
 8013194:	781b      	ldrb	r3, [r3, #0]
 8013196:	b29a      	uxth	r2, r3
 8013198:	683b      	ldr	r3, [r7, #0]
 801319a:	3303      	adds	r3, #3
 801319c:	781b      	ldrb	r3, [r3, #0]
 801319e:	b29b      	uxth	r3, r3
 80131a0:	021b      	lsls	r3, r3, #8
 80131a2:	b29b      	uxth	r3, r3
 80131a4:	18d3      	adds	r3, r2, r3
 80131a6:	b29a      	uxth	r2, r3
 80131a8:	687b      	ldr	r3, [r7, #4]
 80131aa:	805a      	strh	r2, [r3, #2]
  req->wIndex = SWAPBYTE(pdata + 4U);
 80131ac:	683b      	ldr	r3, [r7, #0]
 80131ae:	3304      	adds	r3, #4
 80131b0:	781b      	ldrb	r3, [r3, #0]
 80131b2:	b29a      	uxth	r2, r3
 80131b4:	683b      	ldr	r3, [r7, #0]
 80131b6:	3305      	adds	r3, #5
 80131b8:	781b      	ldrb	r3, [r3, #0]
 80131ba:	b29b      	uxth	r3, r3
 80131bc:	021b      	lsls	r3, r3, #8
 80131be:	b29b      	uxth	r3, r3
 80131c0:	18d3      	adds	r3, r2, r3
 80131c2:	b29a      	uxth	r2, r3
 80131c4:	687b      	ldr	r3, [r7, #4]
 80131c6:	809a      	strh	r2, [r3, #4]
  req->wLength = SWAPBYTE(pdata + 6U);
 80131c8:	683b      	ldr	r3, [r7, #0]
 80131ca:	3306      	adds	r3, #6
 80131cc:	781b      	ldrb	r3, [r3, #0]
 80131ce:	b29a      	uxth	r2, r3
 80131d0:	683b      	ldr	r3, [r7, #0]
 80131d2:	3307      	adds	r3, #7
 80131d4:	781b      	ldrb	r3, [r3, #0]
 80131d6:	b29b      	uxth	r3, r3
 80131d8:	021b      	lsls	r3, r3, #8
 80131da:	b29b      	uxth	r3, r3
 80131dc:	18d3      	adds	r3, r2, r3
 80131de:	b29a      	uxth	r2, r3
 80131e0:	687b      	ldr	r3, [r7, #4]
 80131e2:	80da      	strh	r2, [r3, #6]

}
 80131e4:	46c0      	nop			; (mov r8, r8)
 80131e6:	46bd      	mov	sp, r7
 80131e8:	b002      	add	sp, #8
 80131ea:	bd80      	pop	{r7, pc}

080131ec <USBD_CtlError>:
* @retval None
*/

void USBD_CtlError(USBD_HandleTypeDef *pdev,
                   USBD_SetupReqTypedef *req)
{
 80131ec:	b580      	push	{r7, lr}
 80131ee:	b082      	sub	sp, #8
 80131f0:	af00      	add	r7, sp, #0
 80131f2:	6078      	str	r0, [r7, #4]
 80131f4:	6039      	str	r1, [r7, #0]
  USBD_LL_StallEP(pdev, 0x80U);
 80131f6:	687b      	ldr	r3, [r7, #4]
 80131f8:	2180      	movs	r1, #128	; 0x80
 80131fa:	0018      	movs	r0, r3
 80131fc:	f001 fd4d 	bl	8014c9a <USBD_LL_StallEP>
  USBD_LL_StallEP(pdev, 0U);
 8013200:	687b      	ldr	r3, [r7, #4]
 8013202:	2100      	movs	r1, #0
 8013204:	0018      	movs	r0, r3
 8013206:	f001 fd48 	bl	8014c9a <USBD_LL_StallEP>
}
 801320a:	46c0      	nop			; (mov r8, r8)
 801320c:	46bd      	mov	sp, r7
 801320e:	b002      	add	sp, #8
 8013210:	bd80      	pop	{r7, pc}

08013212 <USBD_GetString>:
  * @param  unicode : Formatted string buffer (unicode)
  * @param  len : descriptor length
  * @retval None
  */
void USBD_GetString(uint8_t *desc, uint8_t *unicode, uint16_t *len)
{
 8013212:	b590      	push	{r4, r7, lr}
 8013214:	b087      	sub	sp, #28
 8013216:	af00      	add	r7, sp, #0
 8013218:	60f8      	str	r0, [r7, #12]
 801321a:	60b9      	str	r1, [r7, #8]
 801321c:	607a      	str	r2, [r7, #4]
  uint8_t idx = 0U;
 801321e:	2417      	movs	r4, #23
 8013220:	193b      	adds	r3, r7, r4
 8013222:	2200      	movs	r2, #0
 8013224:	701a      	strb	r2, [r3, #0]

  if (desc != NULL)
 8013226:	68fb      	ldr	r3, [r7, #12]
 8013228:	2b00      	cmp	r3, #0
 801322a:	d03c      	beq.n	80132a6 <USBD_GetString+0x94>
  {
    *len = (uint16_t)USBD_GetLen(desc) * 2U + 2U;
 801322c:	68fb      	ldr	r3, [r7, #12]
 801322e:	0018      	movs	r0, r3
 8013230:	f000 f83d 	bl	80132ae <USBD_GetLen>
 8013234:	0003      	movs	r3, r0
 8013236:	3301      	adds	r3, #1
 8013238:	b29b      	uxth	r3, r3
 801323a:	18db      	adds	r3, r3, r3
 801323c:	b29a      	uxth	r2, r3
 801323e:	687b      	ldr	r3, [r7, #4]
 8013240:	801a      	strh	r2, [r3, #0]
    unicode[idx++] = *(uint8_t *)(void *)len;
 8013242:	193b      	adds	r3, r7, r4
 8013244:	781b      	ldrb	r3, [r3, #0]
 8013246:	193a      	adds	r2, r7, r4
 8013248:	1c59      	adds	r1, r3, #1
 801324a:	7011      	strb	r1, [r2, #0]
 801324c:	001a      	movs	r2, r3
 801324e:	68bb      	ldr	r3, [r7, #8]
 8013250:	189b      	adds	r3, r3, r2
 8013252:	687a      	ldr	r2, [r7, #4]
 8013254:	7812      	ldrb	r2, [r2, #0]
 8013256:	701a      	strb	r2, [r3, #0]
    unicode[idx++] = USB_DESC_TYPE_STRING;
 8013258:	193b      	adds	r3, r7, r4
 801325a:	781b      	ldrb	r3, [r3, #0]
 801325c:	193a      	adds	r2, r7, r4
 801325e:	1c59      	adds	r1, r3, #1
 8013260:	7011      	strb	r1, [r2, #0]
 8013262:	001a      	movs	r2, r3
 8013264:	68bb      	ldr	r3, [r7, #8]
 8013266:	189b      	adds	r3, r3, r2
 8013268:	2203      	movs	r2, #3
 801326a:	701a      	strb	r2, [r3, #0]

    while (*desc != '\0')
 801326c:	e017      	b.n	801329e <USBD_GetString+0x8c>
    {
      unicode[idx++] = *desc++;
 801326e:	68fb      	ldr	r3, [r7, #12]
 8013270:	1c5a      	adds	r2, r3, #1
 8013272:	60fa      	str	r2, [r7, #12]
 8013274:	2417      	movs	r4, #23
 8013276:	193a      	adds	r2, r7, r4
 8013278:	7812      	ldrb	r2, [r2, #0]
 801327a:	1939      	adds	r1, r7, r4
 801327c:	1c50      	adds	r0, r2, #1
 801327e:	7008      	strb	r0, [r1, #0]
 8013280:	0011      	movs	r1, r2
 8013282:	68ba      	ldr	r2, [r7, #8]
 8013284:	1852      	adds	r2, r2, r1
 8013286:	781b      	ldrb	r3, [r3, #0]
 8013288:	7013      	strb	r3, [r2, #0]
      unicode[idx++] =  0U;
 801328a:	193b      	adds	r3, r7, r4
 801328c:	781b      	ldrb	r3, [r3, #0]
 801328e:	193a      	adds	r2, r7, r4
 8013290:	1c59      	adds	r1, r3, #1
 8013292:	7011      	strb	r1, [r2, #0]
 8013294:	001a      	movs	r2, r3
 8013296:	68bb      	ldr	r3, [r7, #8]
 8013298:	189b      	adds	r3, r3, r2
 801329a:	2200      	movs	r2, #0
 801329c:	701a      	strb	r2, [r3, #0]
    while (*desc != '\0')
 801329e:	68fb      	ldr	r3, [r7, #12]
 80132a0:	781b      	ldrb	r3, [r3, #0]
 80132a2:	2b00      	cmp	r3, #0
 80132a4:	d1e3      	bne.n	801326e <USBD_GetString+0x5c>
    }
  }
}
 80132a6:	46c0      	nop			; (mov r8, r8)
 80132a8:	46bd      	mov	sp, r7
 80132aa:	b007      	add	sp, #28
 80132ac:	bd90      	pop	{r4, r7, pc}

080132ae <USBD_GetLen>:
  *         return the string length
   * @param  buf : pointer to the ascii string buffer
  * @retval string length
  */
static uint8_t USBD_GetLen(uint8_t *buf)
{
 80132ae:	b580      	push	{r7, lr}
 80132b0:	b084      	sub	sp, #16
 80132b2:	af00      	add	r7, sp, #0
 80132b4:	6078      	str	r0, [r7, #4]
  uint8_t  len = 0U;
 80132b6:	230f      	movs	r3, #15
 80132b8:	18fb      	adds	r3, r7, r3
 80132ba:	2200      	movs	r2, #0
 80132bc:	701a      	strb	r2, [r3, #0]

  while (*buf != '\0')
 80132be:	e008      	b.n	80132d2 <USBD_GetLen+0x24>
  {
    len++;
 80132c0:	210f      	movs	r1, #15
 80132c2:	187b      	adds	r3, r7, r1
 80132c4:	781a      	ldrb	r2, [r3, #0]
 80132c6:	187b      	adds	r3, r7, r1
 80132c8:	3201      	adds	r2, #1
 80132ca:	701a      	strb	r2, [r3, #0]
    buf++;
 80132cc:	687b      	ldr	r3, [r7, #4]
 80132ce:	3301      	adds	r3, #1
 80132d0:	607b      	str	r3, [r7, #4]
  while (*buf != '\0')
 80132d2:	687b      	ldr	r3, [r7, #4]
 80132d4:	781b      	ldrb	r3, [r3, #0]
 80132d6:	2b00      	cmp	r3, #0
 80132d8:	d1f2      	bne.n	80132c0 <USBD_GetLen+0x12>
  }

  return len;
 80132da:	230f      	movs	r3, #15
 80132dc:	18fb      	adds	r3, r7, r3
 80132de:	781b      	ldrb	r3, [r3, #0]
}
 80132e0:	0018      	movs	r0, r3
 80132e2:	46bd      	mov	sp, r7
 80132e4:	b004      	add	sp, #16
 80132e6:	bd80      	pop	{r7, pc}

080132e8 <USBD_CtlSendData>:
* @param  len: length of data to be sent
* @retval status
*/
USBD_StatusTypeDef USBD_CtlSendData(USBD_HandleTypeDef *pdev,
                                    uint8_t *pbuf, uint16_t len)
{
 80132e8:	b580      	push	{r7, lr}
 80132ea:	b084      	sub	sp, #16
 80132ec:	af00      	add	r7, sp, #0
 80132ee:	60f8      	str	r0, [r7, #12]
 80132f0:	60b9      	str	r1, [r7, #8]
 80132f2:	1dbb      	adds	r3, r7, #6
 80132f4:	801a      	strh	r2, [r3, #0]
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_DATA_IN;
 80132f6:	68fa      	ldr	r2, [r7, #12]
 80132f8:	23a5      	movs	r3, #165	; 0xa5
 80132fa:	009b      	lsls	r3, r3, #2
 80132fc:	2102      	movs	r1, #2
 80132fe:	50d1      	str	r1, [r2, r3]
  pdev->ep_in[0].total_length = len;
 8013300:	1dbb      	adds	r3, r7, #6
 8013302:	881a      	ldrh	r2, [r3, #0]
 8013304:	68fb      	ldr	r3, [r7, #12]
 8013306:	61da      	str	r2, [r3, #28]
  pdev->ep_in[0].rem_length   = len;
 8013308:	1dbb      	adds	r3, r7, #6
 801330a:	881a      	ldrh	r2, [r3, #0]
 801330c:	68fb      	ldr	r3, [r7, #12]
 801330e:	621a      	str	r2, [r3, #32]

  /* Start the transfer */
  USBD_LL_Transmit(pdev, 0x00U, pbuf, len);
 8013310:	1dbb      	adds	r3, r7, #6
 8013312:	881b      	ldrh	r3, [r3, #0]
 8013314:	68ba      	ldr	r2, [r7, #8]
 8013316:	68f8      	ldr	r0, [r7, #12]
 8013318:	2100      	movs	r1, #0
 801331a:	f001 fd70 	bl	8014dfe <USBD_LL_Transmit>

  return USBD_OK;
 801331e:	2300      	movs	r3, #0
}
 8013320:	0018      	movs	r0, r3
 8013322:	46bd      	mov	sp, r7
 8013324:	b004      	add	sp, #16
 8013326:	bd80      	pop	{r7, pc}

08013328 <USBD_CtlContinueSendData>:
* @param  len: length of data to be sent
* @retval status
*/
USBD_StatusTypeDef USBD_CtlContinueSendData(USBD_HandleTypeDef *pdev,
                                            uint8_t *pbuf, uint16_t len)
{
 8013328:	b580      	push	{r7, lr}
 801332a:	b084      	sub	sp, #16
 801332c:	af00      	add	r7, sp, #0
 801332e:	60f8      	str	r0, [r7, #12]
 8013330:	60b9      	str	r1, [r7, #8]
 8013332:	1dbb      	adds	r3, r7, #6
 8013334:	801a      	strh	r2, [r3, #0]
  /* Start the next transfer */
  USBD_LL_Transmit(pdev, 0x00U, pbuf, len);
 8013336:	1dbb      	adds	r3, r7, #6
 8013338:	881b      	ldrh	r3, [r3, #0]
 801333a:	68ba      	ldr	r2, [r7, #8]
 801333c:	68f8      	ldr	r0, [r7, #12]
 801333e:	2100      	movs	r1, #0
 8013340:	f001 fd5d 	bl	8014dfe <USBD_LL_Transmit>

  return USBD_OK;
 8013344:	2300      	movs	r3, #0
}
 8013346:	0018      	movs	r0, r3
 8013348:	46bd      	mov	sp, r7
 801334a:	b004      	add	sp, #16
 801334c:	bd80      	pop	{r7, pc}

0801334e <USBD_CtlPrepareRx>:
* @param  len: length of data to be received
* @retval status
*/
USBD_StatusTypeDef USBD_CtlPrepareRx(USBD_HandleTypeDef *pdev,
                                     uint8_t *pbuf, uint16_t len)
{
 801334e:	b580      	push	{r7, lr}
 8013350:	b084      	sub	sp, #16
 8013352:	af00      	add	r7, sp, #0
 8013354:	60f8      	str	r0, [r7, #12]
 8013356:	60b9      	str	r1, [r7, #8]
 8013358:	1dbb      	adds	r3, r7, #6
 801335a:	801a      	strh	r2, [r3, #0]
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_DATA_OUT;
 801335c:	68fa      	ldr	r2, [r7, #12]
 801335e:	23a5      	movs	r3, #165	; 0xa5
 8013360:	009b      	lsls	r3, r3, #2
 8013362:	2103      	movs	r1, #3
 8013364:	50d1      	str	r1, [r2, r3]
  pdev->ep_out[0].total_length = len;
 8013366:	1dbb      	adds	r3, r7, #6
 8013368:	8819      	ldrh	r1, [r3, #0]
 801336a:	68fa      	ldr	r2, [r7, #12]
 801336c:	23ae      	movs	r3, #174	; 0xae
 801336e:	005b      	lsls	r3, r3, #1
 8013370:	50d1      	str	r1, [r2, r3]
  pdev->ep_out[0].rem_length   = len;
 8013372:	1dbb      	adds	r3, r7, #6
 8013374:	8819      	ldrh	r1, [r3, #0]
 8013376:	68fa      	ldr	r2, [r7, #12]
 8013378:	23b0      	movs	r3, #176	; 0xb0
 801337a:	005b      	lsls	r3, r3, #1
 801337c:	50d1      	str	r1, [r2, r3]

  /* Start the transfer */
  USBD_LL_PrepareReceive(pdev, 0U, pbuf, len);
 801337e:	1dbb      	adds	r3, r7, #6
 8013380:	881b      	ldrh	r3, [r3, #0]
 8013382:	68ba      	ldr	r2, [r7, #8]
 8013384:	68f8      	ldr	r0, [r7, #12]
 8013386:	2100      	movs	r1, #0
 8013388:	f001 fd70 	bl	8014e6c <USBD_LL_PrepareReceive>

  return USBD_OK;
 801338c:	2300      	movs	r3, #0
}
 801338e:	0018      	movs	r0, r3
 8013390:	46bd      	mov	sp, r7
 8013392:	b004      	add	sp, #16
 8013394:	bd80      	pop	{r7, pc}

08013396 <USBD_CtlContinueRx>:
* @param  len: length of data to be received
* @retval status
*/
USBD_StatusTypeDef USBD_CtlContinueRx(USBD_HandleTypeDef *pdev,
                                      uint8_t *pbuf, uint16_t len)
{
 8013396:	b580      	push	{r7, lr}
 8013398:	b084      	sub	sp, #16
 801339a:	af00      	add	r7, sp, #0
 801339c:	60f8      	str	r0, [r7, #12]
 801339e:	60b9      	str	r1, [r7, #8]
 80133a0:	1dbb      	adds	r3, r7, #6
 80133a2:	801a      	strh	r2, [r3, #0]
  USBD_LL_PrepareReceive(pdev, 0U, pbuf, len);
 80133a4:	1dbb      	adds	r3, r7, #6
 80133a6:	881b      	ldrh	r3, [r3, #0]
 80133a8:	68ba      	ldr	r2, [r7, #8]
 80133aa:	68f8      	ldr	r0, [r7, #12]
 80133ac:	2100      	movs	r1, #0
 80133ae:	f001 fd5d 	bl	8014e6c <USBD_LL_PrepareReceive>

  return USBD_OK;
 80133b2:	2300      	movs	r3, #0
}
 80133b4:	0018      	movs	r0, r3
 80133b6:	46bd      	mov	sp, r7
 80133b8:	b004      	add	sp, #16
 80133ba:	bd80      	pop	{r7, pc}

080133bc <USBD_CtlSendStatus>:
*         send zero lzngth packet on the ctl pipe
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_CtlSendStatus(USBD_HandleTypeDef *pdev)
{
 80133bc:	b580      	push	{r7, lr}
 80133be:	b082      	sub	sp, #8
 80133c0:	af00      	add	r7, sp, #0
 80133c2:	6078      	str	r0, [r7, #4]
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_STATUS_IN;
 80133c4:	687a      	ldr	r2, [r7, #4]
 80133c6:	23a5      	movs	r3, #165	; 0xa5
 80133c8:	009b      	lsls	r3, r3, #2
 80133ca:	2104      	movs	r1, #4
 80133cc:	50d1      	str	r1, [r2, r3]

  /* Start the transfer */
  USBD_LL_Transmit(pdev, 0x00U, NULL, 0U);
 80133ce:	6878      	ldr	r0, [r7, #4]
 80133d0:	2300      	movs	r3, #0
 80133d2:	2200      	movs	r2, #0
 80133d4:	2100      	movs	r1, #0
 80133d6:	f001 fd12 	bl	8014dfe <USBD_LL_Transmit>

  return USBD_OK;
 80133da:	2300      	movs	r3, #0
}
 80133dc:	0018      	movs	r0, r3
 80133de:	46bd      	mov	sp, r7
 80133e0:	b002      	add	sp, #8
 80133e2:	bd80      	pop	{r7, pc}

080133e4 <USBD_CtlReceiveStatus>:
*         receive zero lzngth packet on the ctl pipe
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_CtlReceiveStatus(USBD_HandleTypeDef *pdev)
{
 80133e4:	b580      	push	{r7, lr}
 80133e6:	b082      	sub	sp, #8
 80133e8:	af00      	add	r7, sp, #0
 80133ea:	6078      	str	r0, [r7, #4]
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_STATUS_OUT;
 80133ec:	687a      	ldr	r2, [r7, #4]
 80133ee:	23a5      	movs	r3, #165	; 0xa5
 80133f0:	009b      	lsls	r3, r3, #2
 80133f2:	2105      	movs	r1, #5
 80133f4:	50d1      	str	r1, [r2, r3]

  /* Start the transfer */
  USBD_LL_PrepareReceive(pdev, 0U, NULL, 0U);
 80133f6:	6878      	ldr	r0, [r7, #4]
 80133f8:	2300      	movs	r3, #0
 80133fa:	2200      	movs	r2, #0
 80133fc:	2100      	movs	r1, #0
 80133fe:	f001 fd35 	bl	8014e6c <USBD_LL_PrepareReceive>

  return USBD_OK;
 8013402:	2300      	movs	r3, #0
}
 8013404:	0018      	movs	r0, r3
 8013406:	46bd      	mov	sp, r7
 8013408:	b002      	add	sp, #8
 801340a:	bd80      	pop	{r7, pc}

0801340c <makeFreeRtosPriority>:

extern void xPortSysTickHandler(void);

/* Convert from CMSIS type osPriority to FreeRTOS priority number */
static unsigned portBASE_TYPE makeFreeRtosPriority (osPriority priority)
{
 801340c:	b580      	push	{r7, lr}
 801340e:	b084      	sub	sp, #16
 8013410:	af00      	add	r7, sp, #0
 8013412:	0002      	movs	r2, r0
 8013414:	1dbb      	adds	r3, r7, #6
 8013416:	801a      	strh	r2, [r3, #0]
  unsigned portBASE_TYPE fpriority = tskIDLE_PRIORITY;
 8013418:	2300      	movs	r3, #0
 801341a:	60fb      	str	r3, [r7, #12]
  
  if (priority != osPriorityError) {
 801341c:	1dbb      	adds	r3, r7, #6
 801341e:	2200      	movs	r2, #0
 8013420:	5e9b      	ldrsh	r3, [r3, r2]
 8013422:	2b84      	cmp	r3, #132	; 0x84
 8013424:	d006      	beq.n	8013434 <makeFreeRtosPriority+0x28>
    fpriority += (priority - osPriorityIdle);
 8013426:	1dbb      	adds	r3, r7, #6
 8013428:	2200      	movs	r2, #0
 801342a:	5e9a      	ldrsh	r2, [r3, r2]
 801342c:	68fb      	ldr	r3, [r7, #12]
 801342e:	18d3      	adds	r3, r2, r3
 8013430:	3303      	adds	r3, #3
 8013432:	60fb      	str	r3, [r7, #12]
  }
  
  return fpriority;
 8013434:	68fb      	ldr	r3, [r7, #12]
}
 8013436:	0018      	movs	r0, r3
 8013438:	46bd      	mov	sp, r7
 801343a:	b004      	add	sp, #16
 801343c:	bd80      	pop	{r7, pc}

0801343e <osKernelStart>:
* @param  argument      pointer that is passed to the thread function as start argument.
* @retval status code that indicates the execution status of the function
* @note   MUST REMAIN UNCHANGED: \b osKernelStart shall be consistent in every CMSIS-RTOS.
*/
osStatus osKernelStart (void)
{
 801343e:	b580      	push	{r7, lr}
 8013440:	af00      	add	r7, sp, #0
  vTaskStartScheduler();
 8013442:	f000 faa1 	bl	8013988 <vTaskStartScheduler>
  
  return osOK;
 8013446:	2300      	movs	r3, #0
}
 8013448:	0018      	movs	r0, r3
 801344a:	46bd      	mov	sp, r7
 801344c:	bd80      	pop	{r7, pc}

0801344e <osThreadCreate>:
* @param  argument      pointer that is passed to the thread function as start argument.
* @retval thread ID for reference by other functions or NULL in case of error.
* @note   MUST REMAIN UNCHANGED: \b osThreadCreate shall be consistent in every CMSIS-RTOS.
*/
osThreadId osThreadCreate (const osThreadDef_t *thread_def, void *argument)
{
 801344e:	b5f0      	push	{r4, r5, r6, r7, lr}
 8013450:	b089      	sub	sp, #36	; 0x24
 8013452:	af04      	add	r7, sp, #16
 8013454:	6078      	str	r0, [r7, #4]
 8013456:	6039      	str	r1, [r7, #0]
  TaskHandle_t handle;
  
#if( configSUPPORT_STATIC_ALLOCATION == 1 ) &&  ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
  if((thread_def->buffer != NULL) && (thread_def->controlblock != NULL)) {
 8013458:	687b      	ldr	r3, [r7, #4]
 801345a:	695b      	ldr	r3, [r3, #20]
 801345c:	2b00      	cmp	r3, #0
 801345e:	d020      	beq.n	80134a2 <osThreadCreate+0x54>
 8013460:	687b      	ldr	r3, [r7, #4]
 8013462:	699b      	ldr	r3, [r3, #24]
 8013464:	2b00      	cmp	r3, #0
 8013466:	d01c      	beq.n	80134a2 <osThreadCreate+0x54>
    handle = xTaskCreateStatic((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
 8013468:	687b      	ldr	r3, [r7, #4]
 801346a:	685c      	ldr	r4, [r3, #4]
 801346c:	687b      	ldr	r3, [r7, #4]
 801346e:	681d      	ldr	r5, [r3, #0]
 8013470:	687b      	ldr	r3, [r7, #4]
 8013472:	691e      	ldr	r6, [r3, #16]
 8013474:	687b      	ldr	r3, [r7, #4]
 8013476:	2208      	movs	r2, #8
 8013478:	5e9b      	ldrsh	r3, [r3, r2]
 801347a:	0018      	movs	r0, r3
 801347c:	f7ff ffc6 	bl	801340c <makeFreeRtosPriority>
              thread_def->stacksize, argument, makeFreeRtosPriority(thread_def->tpriority),
              thread_def->buffer, thread_def->controlblock);
 8013480:	687b      	ldr	r3, [r7, #4]
 8013482:	695a      	ldr	r2, [r3, #20]
 8013484:	687b      	ldr	r3, [r7, #4]
 8013486:	699b      	ldr	r3, [r3, #24]
    handle = xTaskCreateStatic((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
 8013488:	6839      	ldr	r1, [r7, #0]
 801348a:	9302      	str	r3, [sp, #8]
 801348c:	9201      	str	r2, [sp, #4]
 801348e:	9000      	str	r0, [sp, #0]
 8013490:	000b      	movs	r3, r1
 8013492:	0032      	movs	r2, r6
 8013494:	0029      	movs	r1, r5
 8013496:	0020      	movs	r0, r4
 8013498:	f000 f8e3 	bl	8013662 <xTaskCreateStatic>
 801349c:	0003      	movs	r3, r0
 801349e:	60fb      	str	r3, [r7, #12]
 80134a0:	e01d      	b.n	80134de <osThreadCreate+0x90>
  }
  else {
    if (xTaskCreate((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
 80134a2:	687b      	ldr	r3, [r7, #4]
 80134a4:	685c      	ldr	r4, [r3, #4]
 80134a6:	687b      	ldr	r3, [r7, #4]
 80134a8:	681d      	ldr	r5, [r3, #0]
              thread_def->stacksize, argument, makeFreeRtosPriority(thread_def->tpriority),
 80134aa:	687b      	ldr	r3, [r7, #4]
 80134ac:	691b      	ldr	r3, [r3, #16]
    if (xTaskCreate((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
 80134ae:	b29e      	uxth	r6, r3
 80134b0:	687b      	ldr	r3, [r7, #4]
 80134b2:	2208      	movs	r2, #8
 80134b4:	5e9b      	ldrsh	r3, [r3, r2]
 80134b6:	0018      	movs	r0, r3
 80134b8:	f7ff ffa8 	bl	801340c <makeFreeRtosPriority>
 80134bc:	0001      	movs	r1, r0
 80134be:	683a      	ldr	r2, [r7, #0]
 80134c0:	230c      	movs	r3, #12
 80134c2:	18fb      	adds	r3, r7, r3
 80134c4:	9301      	str	r3, [sp, #4]
 80134c6:	9100      	str	r1, [sp, #0]
 80134c8:	0013      	movs	r3, r2
 80134ca:	0032      	movs	r2, r6
 80134cc:	0029      	movs	r1, r5
 80134ce:	0020      	movs	r0, r4
 80134d0:	f000 f90a 	bl	80136e8 <xTaskCreate>
 80134d4:	0003      	movs	r3, r0
 80134d6:	2b01      	cmp	r3, #1
 80134d8:	d001      	beq.n	80134de <osThreadCreate+0x90>
              &handle) != pdPASS)  {
      return NULL;
 80134da:	2300      	movs	r3, #0
 80134dc:	e000      	b.n	80134e0 <osThreadCreate+0x92>
                   &handle) != pdPASS)  {
    return NULL;
  }     
#endif
  
  return handle;
 80134de:	68fb      	ldr	r3, [r7, #12]
}
 80134e0:	0018      	movs	r0, r3
 80134e2:	46bd      	mov	sp, r7
 80134e4:	b005      	add	sp, #20
 80134e6:	bdf0      	pop	{r4, r5, r6, r7, pc}

080134e8 <osDelay>:
* @brief   Wait for Timeout (Time Delay)
* @param   millisec      time delay value
* @retval  status code that indicates the execution status of the function.
*/
osStatus osDelay (uint32_t millisec)
{
 80134e8:	b580      	push	{r7, lr}
 80134ea:	b084      	sub	sp, #16
 80134ec:	af00      	add	r7, sp, #0
 80134ee:	6078      	str	r0, [r7, #4]
#if INCLUDE_vTaskDelay
  TickType_t ticks = millisec / portTICK_PERIOD_MS;
 80134f0:	687b      	ldr	r3, [r7, #4]
 80134f2:	60fb      	str	r3, [r7, #12]
  
  vTaskDelay(ticks ? ticks : 1);          /* Minimum delay = 1 tick */
 80134f4:	68fb      	ldr	r3, [r7, #12]
 80134f6:	2b00      	cmp	r3, #0
 80134f8:	d001      	beq.n	80134fe <osDelay+0x16>
 80134fa:	68fb      	ldr	r3, [r7, #12]
 80134fc:	e000      	b.n	8013500 <osDelay+0x18>
 80134fe:	2301      	movs	r3, #1
 8013500:	0018      	movs	r0, r3
 8013502:	f000 fa1b 	bl	801393c <vTaskDelay>
  
  return osOK;
 8013506:	2300      	movs	r3, #0
#else
  (void) millisec;
  
  return osErrorResource;
#endif
}
 8013508:	0018      	movs	r0, r3
 801350a:	46bd      	mov	sp, r7
 801350c:	b004      	add	sp, #16
 801350e:	bd80      	pop	{r7, pc}

08013510 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
 8013510:	b580      	push	{r7, lr}
 8013512:	b082      	sub	sp, #8
 8013514:	af00      	add	r7, sp, #0
 8013516:	6078      	str	r0, [r7, #4]
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8013518:	687b      	ldr	r3, [r7, #4]
 801351a:	3308      	adds	r3, #8
 801351c:	001a      	movs	r2, r3
 801351e:	687b      	ldr	r3, [r7, #4]
 8013520:	605a      	str	r2, [r3, #4]

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 8013522:	687b      	ldr	r3, [r7, #4]
 8013524:	2201      	movs	r2, #1
 8013526:	4252      	negs	r2, r2
 8013528:	609a      	str	r2, [r3, #8]

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 801352a:	687b      	ldr	r3, [r7, #4]
 801352c:	3308      	adds	r3, #8
 801352e:	001a      	movs	r2, r3
 8013530:	687b      	ldr	r3, [r7, #4]
 8013532:	60da      	str	r2, [r3, #12]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8013534:	687b      	ldr	r3, [r7, #4]
 8013536:	3308      	adds	r3, #8
 8013538:	001a      	movs	r2, r3
 801353a:	687b      	ldr	r3, [r7, #4]
 801353c:	611a      	str	r2, [r3, #16]

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 801353e:	687b      	ldr	r3, [r7, #4]
 8013540:	2200      	movs	r2, #0
 8013542:	601a      	str	r2, [r3, #0]

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
 8013544:	46c0      	nop			; (mov r8, r8)
 8013546:	46bd      	mov	sp, r7
 8013548:	b002      	add	sp, #8
 801354a:	bd80      	pop	{r7, pc}

0801354c <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
 801354c:	b580      	push	{r7, lr}
 801354e:	b082      	sub	sp, #8
 8013550:	af00      	add	r7, sp, #0
 8013552:	6078      	str	r0, [r7, #4]
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
 8013554:	687b      	ldr	r3, [r7, #4]
 8013556:	2200      	movs	r2, #0
 8013558:	611a      	str	r2, [r3, #16]

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
 801355a:	46c0      	nop			; (mov r8, r8)
 801355c:	46bd      	mov	sp, r7
 801355e:	b002      	add	sp, #8
 8013560:	bd80      	pop	{r7, pc}

08013562 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 8013562:	b580      	push	{r7, lr}
 8013564:	b084      	sub	sp, #16
 8013566:	af00      	add	r7, sp, #0
 8013568:	6078      	str	r0, [r7, #4]
 801356a:	6039      	str	r1, [r7, #0]
ListItem_t * const pxIndex = pxList->pxIndex;
 801356c:	687b      	ldr	r3, [r7, #4]
 801356e:	685b      	ldr	r3, [r3, #4]
 8013570:	60fb      	str	r3, [r7, #12]
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
 8013572:	683b      	ldr	r3, [r7, #0]
 8013574:	68fa      	ldr	r2, [r7, #12]
 8013576:	605a      	str	r2, [r3, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 8013578:	68fb      	ldr	r3, [r7, #12]
 801357a:	689a      	ldr	r2, [r3, #8]
 801357c:	683b      	ldr	r3, [r7, #0]
 801357e:	609a      	str	r2, [r3, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
 8013580:	68fb      	ldr	r3, [r7, #12]
 8013582:	689b      	ldr	r3, [r3, #8]
 8013584:	683a      	ldr	r2, [r7, #0]
 8013586:	605a      	str	r2, [r3, #4]
	pxIndex->pxPrevious = pxNewListItem;
 8013588:	68fb      	ldr	r3, [r7, #12]
 801358a:	683a      	ldr	r2, [r7, #0]
 801358c:	609a      	str	r2, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 801358e:	683b      	ldr	r3, [r7, #0]
 8013590:	687a      	ldr	r2, [r7, #4]
 8013592:	611a      	str	r2, [r3, #16]

	( pxList->uxNumberOfItems )++;
 8013594:	687b      	ldr	r3, [r7, #4]
 8013596:	681b      	ldr	r3, [r3, #0]
 8013598:	1c5a      	adds	r2, r3, #1
 801359a:	687b      	ldr	r3, [r7, #4]
 801359c:	601a      	str	r2, [r3, #0]
}
 801359e:	46c0      	nop			; (mov r8, r8)
 80135a0:	46bd      	mov	sp, r7
 80135a2:	b004      	add	sp, #16
 80135a4:	bd80      	pop	{r7, pc}

080135a6 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 80135a6:	b580      	push	{r7, lr}
 80135a8:	b084      	sub	sp, #16
 80135aa:	af00      	add	r7, sp, #0
 80135ac:	6078      	str	r0, [r7, #4]
 80135ae:	6039      	str	r1, [r7, #0]
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 80135b0:	683b      	ldr	r3, [r7, #0]
 80135b2:	681b      	ldr	r3, [r3, #0]
 80135b4:	60bb      	str	r3, [r7, #8]
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 80135b6:	68bb      	ldr	r3, [r7, #8]
 80135b8:	3301      	adds	r3, #1
 80135ba:	d103      	bne.n	80135c4 <vListInsert+0x1e>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
 80135bc:	687b      	ldr	r3, [r7, #4]
 80135be:	691b      	ldr	r3, [r3, #16]
 80135c0:	60fb      	str	r3, [r7, #12]
 80135c2:	e00c      	b.n	80135de <vListInsert+0x38>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 80135c4:	687b      	ldr	r3, [r7, #4]
 80135c6:	3308      	adds	r3, #8
 80135c8:	60fb      	str	r3, [r7, #12]
 80135ca:	e002      	b.n	80135d2 <vListInsert+0x2c>
 80135cc:	68fb      	ldr	r3, [r7, #12]
 80135ce:	685b      	ldr	r3, [r3, #4]
 80135d0:	60fb      	str	r3, [r7, #12]
 80135d2:	68fb      	ldr	r3, [r7, #12]
 80135d4:	685b      	ldr	r3, [r3, #4]
 80135d6:	681b      	ldr	r3, [r3, #0]
 80135d8:	68ba      	ldr	r2, [r7, #8]
 80135da:	429a      	cmp	r2, r3
 80135dc:	d2f6      	bcs.n	80135cc <vListInsert+0x26>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 80135de:	68fb      	ldr	r3, [r7, #12]
 80135e0:	685a      	ldr	r2, [r3, #4]
 80135e2:	683b      	ldr	r3, [r7, #0]
 80135e4:	605a      	str	r2, [r3, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 80135e6:	683b      	ldr	r3, [r7, #0]
 80135e8:	685b      	ldr	r3, [r3, #4]
 80135ea:	683a      	ldr	r2, [r7, #0]
 80135ec:	609a      	str	r2, [r3, #8]
	pxNewListItem->pxPrevious = pxIterator;
 80135ee:	683b      	ldr	r3, [r7, #0]
 80135f0:	68fa      	ldr	r2, [r7, #12]
 80135f2:	609a      	str	r2, [r3, #8]
	pxIterator->pxNext = pxNewListItem;
 80135f4:	68fb      	ldr	r3, [r7, #12]
 80135f6:	683a      	ldr	r2, [r7, #0]
 80135f8:	605a      	str	r2, [r3, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 80135fa:	683b      	ldr	r3, [r7, #0]
 80135fc:	687a      	ldr	r2, [r7, #4]
 80135fe:	611a      	str	r2, [r3, #16]

	( pxList->uxNumberOfItems )++;
 8013600:	687b      	ldr	r3, [r7, #4]
 8013602:	681b      	ldr	r3, [r3, #0]
 8013604:	1c5a      	adds	r2, r3, #1
 8013606:	687b      	ldr	r3, [r7, #4]
 8013608:	601a      	str	r2, [r3, #0]
}
 801360a:	46c0      	nop			; (mov r8, r8)
 801360c:	46bd      	mov	sp, r7
 801360e:	b004      	add	sp, #16
 8013610:	bd80      	pop	{r7, pc}

08013612 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
 8013612:	b580      	push	{r7, lr}
 8013614:	b084      	sub	sp, #16
 8013616:	af00      	add	r7, sp, #0
 8013618:	6078      	str	r0, [r7, #4]
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
 801361a:	687b      	ldr	r3, [r7, #4]
 801361c:	691b      	ldr	r3, [r3, #16]
 801361e:	60fb      	str	r3, [r7, #12]

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 8013620:	687b      	ldr	r3, [r7, #4]
 8013622:	685b      	ldr	r3, [r3, #4]
 8013624:	687a      	ldr	r2, [r7, #4]
 8013626:	6892      	ldr	r2, [r2, #8]
 8013628:	609a      	str	r2, [r3, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 801362a:	687b      	ldr	r3, [r7, #4]
 801362c:	689b      	ldr	r3, [r3, #8]
 801362e:	687a      	ldr	r2, [r7, #4]
 8013630:	6852      	ldr	r2, [r2, #4]
 8013632:	605a      	str	r2, [r3, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 8013634:	68fb      	ldr	r3, [r7, #12]
 8013636:	685b      	ldr	r3, [r3, #4]
 8013638:	687a      	ldr	r2, [r7, #4]
 801363a:	429a      	cmp	r2, r3
 801363c:	d103      	bne.n	8013646 <uxListRemove+0x34>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 801363e:	687b      	ldr	r3, [r7, #4]
 8013640:	689a      	ldr	r2, [r3, #8]
 8013642:	68fb      	ldr	r3, [r7, #12]
 8013644:	605a      	str	r2, [r3, #4]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
 8013646:	687b      	ldr	r3, [r7, #4]
 8013648:	2200      	movs	r2, #0
 801364a:	611a      	str	r2, [r3, #16]
	( pxList->uxNumberOfItems )--;
 801364c:	68fb      	ldr	r3, [r7, #12]
 801364e:	681b      	ldr	r3, [r3, #0]
 8013650:	1e5a      	subs	r2, r3, #1
 8013652:	68fb      	ldr	r3, [r7, #12]
 8013654:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
 8013656:	68fb      	ldr	r3, [r7, #12]
 8013658:	681b      	ldr	r3, [r3, #0]
}
 801365a:	0018      	movs	r0, r3
 801365c:	46bd      	mov	sp, r7
 801365e:	b004      	add	sp, #16
 8013660:	bd80      	pop	{r7, pc}

08013662 <xTaskCreateStatic>:
									const uint32_t ulStackDepth,
									void * const pvParameters,
									UBaseType_t uxPriority,
									StackType_t * const puxStackBuffer,
									StaticTask_t * const pxTaskBuffer )
	{
 8013662:	b590      	push	{r4, r7, lr}
 8013664:	b08d      	sub	sp, #52	; 0x34
 8013666:	af04      	add	r7, sp, #16
 8013668:	60f8      	str	r0, [r7, #12]
 801366a:	60b9      	str	r1, [r7, #8]
 801366c:	607a      	str	r2, [r7, #4]
 801366e:	603b      	str	r3, [r7, #0]
	TCB_t *pxNewTCB;
	TaskHandle_t xReturn;

		configASSERT( puxStackBuffer != NULL );
 8013670:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8013672:	2b00      	cmp	r3, #0
 8013674:	d101      	bne.n	801367a <xTaskCreateStatic+0x18>
 8013676:	b672      	cpsid	i
 8013678:	e7fe      	b.n	8013678 <xTaskCreateStatic+0x16>
		configASSERT( pxTaskBuffer != NULL );
 801367a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801367c:	2b00      	cmp	r3, #0
 801367e:	d101      	bne.n	8013684 <xTaskCreateStatic+0x22>
 8013680:	b672      	cpsid	i
 8013682:	e7fe      	b.n	8013682 <xTaskCreateStatic+0x20>
		#if( configASSERT_DEFINED == 1 )
		{
			/* Sanity check that the size of the structure used to declare a
			variable of type StaticTask_t equals the size of the real task
			structure. */
			volatile size_t xSize = sizeof( StaticTask_t );
 8013684:	2354      	movs	r3, #84	; 0x54
 8013686:	617b      	str	r3, [r7, #20]
			configASSERT( xSize == sizeof( TCB_t ) );
 8013688:	697b      	ldr	r3, [r7, #20]
 801368a:	2b54      	cmp	r3, #84	; 0x54
 801368c:	d001      	beq.n	8013692 <xTaskCreateStatic+0x30>
 801368e:	b672      	cpsid	i
 8013690:	e7fe      	b.n	8013690 <xTaskCreateStatic+0x2e>
		}
		#endif /* configASSERT_DEFINED */


		if( ( pxTaskBuffer != NULL ) && ( puxStackBuffer != NULL ) )
 8013692:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8013694:	2b00      	cmp	r3, #0
 8013696:	d020      	beq.n	80136da <xTaskCreateStatic+0x78>
 8013698:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801369a:	2b00      	cmp	r3, #0
 801369c:	d01d      	beq.n	80136da <xTaskCreateStatic+0x78>
		{
			/* The memory used for the task's TCB and stack are passed into this
			function - use them. */
			pxNewTCB = ( TCB_t * ) pxTaskBuffer; /*lint !e740 Unusual cast is ok as the structures are designed to have the same alignment, and the size is checked by an assert. */
 801369e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80136a0:	61fb      	str	r3, [r7, #28]
			pxNewTCB->pxStack = ( StackType_t * ) puxStackBuffer;
 80136a2:	69fb      	ldr	r3, [r7, #28]
 80136a4:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 80136a6:	631a      	str	r2, [r3, #48]	; 0x30

			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 Macro has been consolidated for readability reasons. */
			{
				/* Tasks can be created statically or dynamically, so note this
				task was created statically in case the task is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
 80136a8:	69fb      	ldr	r3, [r7, #28]
 80136aa:	2251      	movs	r2, #81	; 0x51
 80136ac:	2102      	movs	r1, #2
 80136ae:	5499      	strb	r1, [r3, r2]
			}
			#endif /* configSUPPORT_DYNAMIC_ALLOCATION */

			prvInitialiseNewTask( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, &xReturn, pxNewTCB, NULL );
 80136b0:	683c      	ldr	r4, [r7, #0]
 80136b2:	687a      	ldr	r2, [r7, #4]
 80136b4:	68b9      	ldr	r1, [r7, #8]
 80136b6:	68f8      	ldr	r0, [r7, #12]
 80136b8:	2300      	movs	r3, #0
 80136ba:	9303      	str	r3, [sp, #12]
 80136bc:	69fb      	ldr	r3, [r7, #28]
 80136be:	9302      	str	r3, [sp, #8]
 80136c0:	2318      	movs	r3, #24
 80136c2:	18fb      	adds	r3, r7, r3
 80136c4:	9301      	str	r3, [sp, #4]
 80136c6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80136c8:	9300      	str	r3, [sp, #0]
 80136ca:	0023      	movs	r3, r4
 80136cc:	f000 f858 	bl	8013780 <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
 80136d0:	69fb      	ldr	r3, [r7, #28]
 80136d2:	0018      	movs	r0, r3
 80136d4:	f000 f8ce 	bl	8013874 <prvAddNewTaskToReadyList>
 80136d8:	e001      	b.n	80136de <xTaskCreateStatic+0x7c>
		}
		else
		{
			xReturn = NULL;
 80136da:	2300      	movs	r3, #0
 80136dc:	61bb      	str	r3, [r7, #24]
		}

		return xReturn;
 80136de:	69bb      	ldr	r3, [r7, #24]
	}
 80136e0:	0018      	movs	r0, r3
 80136e2:	46bd      	mov	sp, r7
 80136e4:	b009      	add	sp, #36	; 0x24
 80136e6:	bd90      	pop	{r4, r7, pc}

080136e8 <xTaskCreate>:
							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
							const configSTACK_DEPTH_TYPE usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask )
	{
 80136e8:	b590      	push	{r4, r7, lr}
 80136ea:	b08d      	sub	sp, #52	; 0x34
 80136ec:	af04      	add	r7, sp, #16
 80136ee:	60f8      	str	r0, [r7, #12]
 80136f0:	60b9      	str	r1, [r7, #8]
 80136f2:	603b      	str	r3, [r7, #0]
 80136f4:	1dbb      	adds	r3, r7, #6
 80136f6:	801a      	strh	r2, [r3, #0]
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 80136f8:	1dbb      	adds	r3, r7, #6
 80136fa:	881b      	ldrh	r3, [r3, #0]
 80136fc:	009b      	lsls	r3, r3, #2
 80136fe:	0018      	movs	r0, r3
 8013700:	f000 fd9e 	bl	8014240 <pvPortMalloc>
 8013704:	0003      	movs	r3, r0
 8013706:	617b      	str	r3, [r7, #20]

			if( pxStack != NULL )
 8013708:	697b      	ldr	r3, [r7, #20]
 801370a:	2b00      	cmp	r3, #0
 801370c:	d010      	beq.n	8013730 <xTaskCreate+0x48>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
 801370e:	2054      	movs	r0, #84	; 0x54
 8013710:	f000 fd96 	bl	8014240 <pvPortMalloc>
 8013714:	0003      	movs	r3, r0
 8013716:	61fb      	str	r3, [r7, #28]

				if( pxNewTCB != NULL )
 8013718:	69fb      	ldr	r3, [r7, #28]
 801371a:	2b00      	cmp	r3, #0
 801371c:	d003      	beq.n	8013726 <xTaskCreate+0x3e>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
 801371e:	69fb      	ldr	r3, [r7, #28]
 8013720:	697a      	ldr	r2, [r7, #20]
 8013722:	631a      	str	r2, [r3, #48]	; 0x30
 8013724:	e006      	b.n	8013734 <xTaskCreate+0x4c>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
 8013726:	697b      	ldr	r3, [r7, #20]
 8013728:	0018      	movs	r0, r3
 801372a:	f000 fe2f 	bl	801438c <vPortFree>
 801372e:	e001      	b.n	8013734 <xTaskCreate+0x4c>
				}
			}
			else
			{
				pxNewTCB = NULL;
 8013730:	2300      	movs	r3, #0
 8013732:	61fb      	str	r3, [r7, #28]
			}
		}
		#endif /* portSTACK_GROWTH */

		if( pxNewTCB != NULL )
 8013734:	69fb      	ldr	r3, [r7, #28]
 8013736:	2b00      	cmp	r3, #0
 8013738:	d01a      	beq.n	8013770 <xTaskCreate+0x88>
		{
			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 Macro has been consolidated for readability reasons. */
			{
				/* Tasks can be created statically or dynamically, so note this
				task was created dynamically in case it is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
 801373a:	69fb      	ldr	r3, [r7, #28]
 801373c:	2251      	movs	r2, #81	; 0x51
 801373e:	2100      	movs	r1, #0
 8013740:	5499      	strb	r1, [r3, r2]
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
 8013742:	1dbb      	adds	r3, r7, #6
 8013744:	881a      	ldrh	r2, [r3, #0]
 8013746:	683c      	ldr	r4, [r7, #0]
 8013748:	68b9      	ldr	r1, [r7, #8]
 801374a:	68f8      	ldr	r0, [r7, #12]
 801374c:	2300      	movs	r3, #0
 801374e:	9303      	str	r3, [sp, #12]
 8013750:	69fb      	ldr	r3, [r7, #28]
 8013752:	9302      	str	r3, [sp, #8]
 8013754:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8013756:	9301      	str	r3, [sp, #4]
 8013758:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801375a:	9300      	str	r3, [sp, #0]
 801375c:	0023      	movs	r3, r4
 801375e:	f000 f80f 	bl	8013780 <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
 8013762:	69fb      	ldr	r3, [r7, #28]
 8013764:	0018      	movs	r0, r3
 8013766:	f000 f885 	bl	8013874 <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
 801376a:	2301      	movs	r3, #1
 801376c:	61bb      	str	r3, [r7, #24]
 801376e:	e002      	b.n	8013776 <xTaskCreate+0x8e>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 8013770:	2301      	movs	r3, #1
 8013772:	425b      	negs	r3, r3
 8013774:	61bb      	str	r3, [r7, #24]
		}

		return xReturn;
 8013776:	69bb      	ldr	r3, [r7, #24]
	}
 8013778:	0018      	movs	r0, r3
 801377a:	46bd      	mov	sp, r7
 801377c:	b009      	add	sp, #36	; 0x24
 801377e:	bd90      	pop	{r4, r7, pc}

08013780 <prvInitialiseNewTask>:
									void * const pvParameters,
									UBaseType_t uxPriority,
									TaskHandle_t * const pxCreatedTask,
									TCB_t *pxNewTCB,
									const MemoryRegion_t * const xRegions )
{
 8013780:	b580      	push	{r7, lr}
 8013782:	b086      	sub	sp, #24
 8013784:	af00      	add	r7, sp, #0
 8013786:	60f8      	str	r0, [r7, #12]
 8013788:	60b9      	str	r1, [r7, #8]
 801378a:	607a      	str	r2, [r7, #4]
 801378c:	603b      	str	r3, [r7, #0]
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
 801378e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8013790:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8013792:	687b      	ldr	r3, [r7, #4]
 8013794:	4936      	ldr	r1, [pc, #216]	; (8013870 <prvInitialiseNewTask+0xf0>)
 8013796:	468c      	mov	ip, r1
 8013798:	4463      	add	r3, ip
 801379a:	009b      	lsls	r3, r3, #2
 801379c:	18d3      	adds	r3, r2, r3
 801379e:	613b      	str	r3, [r7, #16]
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
 80137a0:	693b      	ldr	r3, [r7, #16]
 80137a2:	2207      	movs	r2, #7
 80137a4:	4393      	bics	r3, r2
 80137a6:	613b      	str	r3, [r7, #16]

		/* Check the alignment of the calculated top of stack is correct. */
		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
 80137a8:	693b      	ldr	r3, [r7, #16]
 80137aa:	2207      	movs	r2, #7
 80137ac:	4013      	ands	r3, r2
 80137ae:	d001      	beq.n	80137b4 <prvInitialiseNewTask+0x34>
 80137b0:	b672      	cpsid	i
 80137b2:	e7fe      	b.n	80137b2 <prvInitialiseNewTask+0x32>
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 80137b4:	2300      	movs	r3, #0
 80137b6:	617b      	str	r3, [r7, #20]
 80137b8:	e013      	b.n	80137e2 <prvInitialiseNewTask+0x62>
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 80137ba:	68ba      	ldr	r2, [r7, #8]
 80137bc:	697b      	ldr	r3, [r7, #20]
 80137be:	18d3      	adds	r3, r2, r3
 80137c0:	7818      	ldrb	r0, [r3, #0]
 80137c2:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80137c4:	2134      	movs	r1, #52	; 0x34
 80137c6:	697b      	ldr	r3, [r7, #20]
 80137c8:	18d3      	adds	r3, r2, r3
 80137ca:	185b      	adds	r3, r3, r1
 80137cc:	1c02      	adds	r2, r0, #0
 80137ce:	701a      	strb	r2, [r3, #0]

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
 80137d0:	68ba      	ldr	r2, [r7, #8]
 80137d2:	697b      	ldr	r3, [r7, #20]
 80137d4:	18d3      	adds	r3, r2, r3
 80137d6:	781b      	ldrb	r3, [r3, #0]
 80137d8:	2b00      	cmp	r3, #0
 80137da:	d006      	beq.n	80137ea <prvInitialiseNewTask+0x6a>
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 80137dc:	697b      	ldr	r3, [r7, #20]
 80137de:	3301      	adds	r3, #1
 80137e0:	617b      	str	r3, [r7, #20]
 80137e2:	697b      	ldr	r3, [r7, #20]
 80137e4:	2b0f      	cmp	r3, #15
 80137e6:	d9e8      	bls.n	80137ba <prvInitialiseNewTask+0x3a>
 80137e8:	e000      	b.n	80137ec <prvInitialiseNewTask+0x6c>
		{
			break;
 80137ea:	46c0      	nop			; (mov r8, r8)
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 80137ec:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80137ee:	2243      	movs	r2, #67	; 0x43
 80137f0:	2100      	movs	r1, #0
 80137f2:	5499      	strb	r1, [r3, r2]

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 80137f4:	6a3b      	ldr	r3, [r7, #32]
 80137f6:	2b06      	cmp	r3, #6
 80137f8:	d901      	bls.n	80137fe <prvInitialiseNewTask+0x7e>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
 80137fa:	2306      	movs	r3, #6
 80137fc:	623b      	str	r3, [r7, #32]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
 80137fe:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8013800:	6a3a      	ldr	r2, [r7, #32]
 8013802:	62da      	str	r2, [r3, #44]	; 0x2c
	#if ( configUSE_MUTEXES == 1 )
	{
		pxNewTCB->uxBasePriority = uxPriority;
 8013804:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8013806:	6a3a      	ldr	r2, [r7, #32]
 8013808:	645a      	str	r2, [r3, #68]	; 0x44
		pxNewTCB->uxMutexesHeld = 0;
 801380a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801380c:	2200      	movs	r2, #0
 801380e:	649a      	str	r2, [r3, #72]	; 0x48
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 8013810:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8013812:	3304      	adds	r3, #4
 8013814:	0018      	movs	r0, r3
 8013816:	f7ff fe99 	bl	801354c <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 801381a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801381c:	3318      	adds	r3, #24
 801381e:	0018      	movs	r0, r3
 8013820:	f7ff fe94 	bl	801354c <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 8013824:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8013826:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8013828:	611a      	str	r2, [r3, #16]

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 801382a:	6a3b      	ldr	r3, [r7, #32]
 801382c:	2207      	movs	r2, #7
 801382e:	1ad2      	subs	r2, r2, r3
 8013830:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8013832:	619a      	str	r2, [r3, #24]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 8013834:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8013836:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8013838:	625a      	str	r2, [r3, #36]	; 0x24
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
 801383a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801383c:	2200      	movs	r2, #0
 801383e:	64da      	str	r2, [r3, #76]	; 0x4c
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 8013840:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8013842:	2250      	movs	r2, #80	; 0x50
 8013844:	2100      	movs	r1, #0
 8013846:	5499      	strb	r1, [r3, r2]
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
	}
	#else /* portUSING_MPU_WRAPPERS */
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 8013848:	683a      	ldr	r2, [r7, #0]
 801384a:	68f9      	ldr	r1, [r7, #12]
 801384c:	693b      	ldr	r3, [r7, #16]
 801384e:	0018      	movs	r0, r3
 8013850:	f000 fbc4 	bl	8013fdc <pxPortInitialiseStack>
 8013854:	0002      	movs	r2, r0
 8013856:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8013858:	601a      	str	r2, [r3, #0]
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( ( void * ) pxCreatedTask != NULL )
 801385a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801385c:	2b00      	cmp	r3, #0
 801385e:	d002      	beq.n	8013866 <prvInitialiseNewTask+0xe6>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 8013860:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013862:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8013864:	601a      	str	r2, [r3, #0]
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
 8013866:	46c0      	nop			; (mov r8, r8)
 8013868:	46bd      	mov	sp, r7
 801386a:	b006      	add	sp, #24
 801386c:	bd80      	pop	{r7, pc}
 801386e:	46c0      	nop			; (mov r8, r8)
 8013870:	3fffffff 	.word	0x3fffffff

08013874 <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
 8013874:	b580      	push	{r7, lr}
 8013876:	b082      	sub	sp, #8
 8013878:	af00      	add	r7, sp, #0
 801387a:	6078      	str	r0, [r7, #4]
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
 801387c:	f000 fc48 	bl	8014110 <vPortEnterCritical>
	{
		uxCurrentNumberOfTasks++;
 8013880:	4b28      	ldr	r3, [pc, #160]	; (8013924 <prvAddNewTaskToReadyList+0xb0>)
 8013882:	681b      	ldr	r3, [r3, #0]
 8013884:	1c5a      	adds	r2, r3, #1
 8013886:	4b27      	ldr	r3, [pc, #156]	; (8013924 <prvAddNewTaskToReadyList+0xb0>)
 8013888:	601a      	str	r2, [r3, #0]
		if( pxCurrentTCB == NULL )
 801388a:	4b27      	ldr	r3, [pc, #156]	; (8013928 <prvAddNewTaskToReadyList+0xb4>)
 801388c:	681b      	ldr	r3, [r3, #0]
 801388e:	2b00      	cmp	r3, #0
 8013890:	d109      	bne.n	80138a6 <prvAddNewTaskToReadyList+0x32>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
 8013892:	4b25      	ldr	r3, [pc, #148]	; (8013928 <prvAddNewTaskToReadyList+0xb4>)
 8013894:	687a      	ldr	r2, [r7, #4]
 8013896:	601a      	str	r2, [r3, #0]

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 8013898:	4b22      	ldr	r3, [pc, #136]	; (8013924 <prvAddNewTaskToReadyList+0xb0>)
 801389a:	681b      	ldr	r3, [r3, #0]
 801389c:	2b01      	cmp	r3, #1
 801389e:	d110      	bne.n	80138c2 <prvAddNewTaskToReadyList+0x4e>
			{
				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
 80138a0:	f000 fa6e 	bl	8013d80 <prvInitialiseTaskLists>
 80138a4:	e00d      	b.n	80138c2 <prvAddNewTaskToReadyList+0x4e>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
 80138a6:	4b21      	ldr	r3, [pc, #132]	; (801392c <prvAddNewTaskToReadyList+0xb8>)
 80138a8:	681b      	ldr	r3, [r3, #0]
 80138aa:	2b00      	cmp	r3, #0
 80138ac:	d109      	bne.n	80138c2 <prvAddNewTaskToReadyList+0x4e>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 80138ae:	4b1e      	ldr	r3, [pc, #120]	; (8013928 <prvAddNewTaskToReadyList+0xb4>)
 80138b0:	681b      	ldr	r3, [r3, #0]
 80138b2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80138b4:	687b      	ldr	r3, [r7, #4]
 80138b6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80138b8:	429a      	cmp	r2, r3
 80138ba:	d802      	bhi.n	80138c2 <prvAddNewTaskToReadyList+0x4e>
				{
					pxCurrentTCB = pxNewTCB;
 80138bc:	4b1a      	ldr	r3, [pc, #104]	; (8013928 <prvAddNewTaskToReadyList+0xb4>)
 80138be:	687a      	ldr	r2, [r7, #4]
 80138c0:	601a      	str	r2, [r3, #0]
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
 80138c2:	4b1b      	ldr	r3, [pc, #108]	; (8013930 <prvAddNewTaskToReadyList+0xbc>)
 80138c4:	681b      	ldr	r3, [r3, #0]
 80138c6:	1c5a      	adds	r2, r3, #1
 80138c8:	4b19      	ldr	r3, [pc, #100]	; (8013930 <prvAddNewTaskToReadyList+0xbc>)
 80138ca:	601a      	str	r2, [r3, #0]
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
 80138cc:	687b      	ldr	r3, [r7, #4]
 80138ce:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80138d0:	4b18      	ldr	r3, [pc, #96]	; (8013934 <prvAddNewTaskToReadyList+0xc0>)
 80138d2:	681b      	ldr	r3, [r3, #0]
 80138d4:	429a      	cmp	r2, r3
 80138d6:	d903      	bls.n	80138e0 <prvAddNewTaskToReadyList+0x6c>
 80138d8:	687b      	ldr	r3, [r7, #4]
 80138da:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80138dc:	4b15      	ldr	r3, [pc, #84]	; (8013934 <prvAddNewTaskToReadyList+0xc0>)
 80138de:	601a      	str	r2, [r3, #0]
 80138e0:	687b      	ldr	r3, [r7, #4]
 80138e2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80138e4:	0013      	movs	r3, r2
 80138e6:	009b      	lsls	r3, r3, #2
 80138e8:	189b      	adds	r3, r3, r2
 80138ea:	009b      	lsls	r3, r3, #2
 80138ec:	4a12      	ldr	r2, [pc, #72]	; (8013938 <prvAddNewTaskToReadyList+0xc4>)
 80138ee:	189a      	adds	r2, r3, r2
 80138f0:	687b      	ldr	r3, [r7, #4]
 80138f2:	3304      	adds	r3, #4
 80138f4:	0019      	movs	r1, r3
 80138f6:	0010      	movs	r0, r2
 80138f8:	f7ff fe33 	bl	8013562 <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
 80138fc:	f000 fc1a 	bl	8014134 <vPortExitCritical>

	if( xSchedulerRunning != pdFALSE )
 8013900:	4b0a      	ldr	r3, [pc, #40]	; (801392c <prvAddNewTaskToReadyList+0xb8>)
 8013902:	681b      	ldr	r3, [r3, #0]
 8013904:	2b00      	cmp	r3, #0
 8013906:	d008      	beq.n	801391a <prvAddNewTaskToReadyList+0xa6>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
 8013908:	4b07      	ldr	r3, [pc, #28]	; (8013928 <prvAddNewTaskToReadyList+0xb4>)
 801390a:	681b      	ldr	r3, [r3, #0]
 801390c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 801390e:	687b      	ldr	r3, [r7, #4]
 8013910:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8013912:	429a      	cmp	r2, r3
 8013914:	d201      	bcs.n	801391a <prvAddNewTaskToReadyList+0xa6>
		{
			taskYIELD_IF_USING_PREEMPTION();
 8013916:	f000 fbeb 	bl	80140f0 <vPortYield>
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
 801391a:	46c0      	nop			; (mov r8, r8)
 801391c:	46bd      	mov	sp, r7
 801391e:	b002      	add	sp, #8
 8013920:	bd80      	pop	{r7, pc}
 8013922:	46c0      	nop			; (mov r8, r8)
 8013924:	200006d0 	.word	0x200006d0
 8013928:	200005d0 	.word	0x200005d0
 801392c:	200006dc 	.word	0x200006dc
 8013930:	200006ec 	.word	0x200006ec
 8013934:	200006d8 	.word	0x200006d8
 8013938:	200005d4 	.word	0x200005d4

0801393c <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
 801393c:	b580      	push	{r7, lr}
 801393e:	b084      	sub	sp, #16
 8013940:	af00      	add	r7, sp, #0
 8013942:	6078      	str	r0, [r7, #4]
	BaseType_t xAlreadyYielded = pdFALSE;
 8013944:	2300      	movs	r3, #0
 8013946:	60fb      	str	r3, [r7, #12]

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
 8013948:	687b      	ldr	r3, [r7, #4]
 801394a:	2b00      	cmp	r3, #0
 801394c:	d010      	beq.n	8013970 <vTaskDelay+0x34>
		{
			configASSERT( uxSchedulerSuspended == 0 );
 801394e:	4b0d      	ldr	r3, [pc, #52]	; (8013984 <vTaskDelay+0x48>)
 8013950:	681b      	ldr	r3, [r3, #0]
 8013952:	2b00      	cmp	r3, #0
 8013954:	d001      	beq.n	801395a <vTaskDelay+0x1e>
 8013956:	b672      	cpsid	i
 8013958:	e7fe      	b.n	8013958 <vTaskDelay+0x1c>
			vTaskSuspendAll();
 801395a:	f000 f863 	bl	8013a24 <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
 801395e:	687b      	ldr	r3, [r7, #4]
 8013960:	2100      	movs	r1, #0
 8013962:	0018      	movs	r0, r3
 8013964:	f000 fae6 	bl	8013f34 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
 8013968:	f000 f868 	bl	8013a3c <xTaskResumeAll>
 801396c:	0003      	movs	r3, r0
 801396e:	60fb      	str	r3, [r7, #12]
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
 8013970:	68fb      	ldr	r3, [r7, #12]
 8013972:	2b00      	cmp	r3, #0
 8013974:	d101      	bne.n	801397a <vTaskDelay+0x3e>
		{
			portYIELD_WITHIN_API();
 8013976:	f000 fbbb 	bl	80140f0 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 801397a:	46c0      	nop			; (mov r8, r8)
 801397c:	46bd      	mov	sp, r7
 801397e:	b004      	add	sp, #16
 8013980:	bd80      	pop	{r7, pc}
 8013982:	46c0      	nop			; (mov r8, r8)
 8013984:	200006f8 	.word	0x200006f8

08013988 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
 8013988:	b590      	push	{r4, r7, lr}
 801398a:	b089      	sub	sp, #36	; 0x24
 801398c:	af04      	add	r7, sp, #16
BaseType_t xReturn;

	/* Add the idle task at the lowest priority. */
	#if( configSUPPORT_STATIC_ALLOCATION == 1 )
	{
		StaticTask_t *pxIdleTaskTCBBuffer = NULL;
 801398e:	2300      	movs	r3, #0
 8013990:	60bb      	str	r3, [r7, #8]
		StackType_t *pxIdleTaskStackBuffer = NULL;
 8013992:	2300      	movs	r3, #0
 8013994:	607b      	str	r3, [r7, #4]
		uint32_t ulIdleTaskStackSize;

		/* The Idle task is created using user provided RAM - obtain the
		address of the RAM then create the idle task. */
		vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize );
 8013996:	003a      	movs	r2, r7
 8013998:	1d39      	adds	r1, r7, #4
 801399a:	2308      	movs	r3, #8
 801399c:	18fb      	adds	r3, r7, r3
 801399e:	0018      	movs	r0, r3
 80139a0:	f7f6 fd82 	bl	800a4a8 <vApplicationGetIdleTaskMemory>
		xIdleTaskHandle = xTaskCreateStatic(	prvIdleTask,
 80139a4:	683c      	ldr	r4, [r7, #0]
 80139a6:	687b      	ldr	r3, [r7, #4]
 80139a8:	68ba      	ldr	r2, [r7, #8]
 80139aa:	4918      	ldr	r1, [pc, #96]	; (8013a0c <vTaskStartScheduler+0x84>)
 80139ac:	4818      	ldr	r0, [pc, #96]	; (8013a10 <vTaskStartScheduler+0x88>)
 80139ae:	9202      	str	r2, [sp, #8]
 80139b0:	9301      	str	r3, [sp, #4]
 80139b2:	2300      	movs	r3, #0
 80139b4:	9300      	str	r3, [sp, #0]
 80139b6:	2300      	movs	r3, #0
 80139b8:	0022      	movs	r2, r4
 80139ba:	f7ff fe52 	bl	8013662 <xTaskCreateStatic>
 80139be:	0002      	movs	r2, r0
 80139c0:	4b14      	ldr	r3, [pc, #80]	; (8013a14 <vTaskStartScheduler+0x8c>)
 80139c2:	601a      	str	r2, [r3, #0]
												( void * ) NULL, /*lint !e961.  The cast is not redundant for all compilers. */
												( tskIDLE_PRIORITY | portPRIVILEGE_BIT ),
												pxIdleTaskStackBuffer,
												pxIdleTaskTCBBuffer ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */

		if( xIdleTaskHandle != NULL )
 80139c4:	4b13      	ldr	r3, [pc, #76]	; (8013a14 <vTaskStartScheduler+0x8c>)
 80139c6:	681b      	ldr	r3, [r3, #0]
 80139c8:	2b00      	cmp	r3, #0
 80139ca:	d002      	beq.n	80139d2 <vTaskStartScheduler+0x4a>
		{
			xReturn = pdPASS;
 80139cc:	2301      	movs	r3, #1
 80139ce:	60fb      	str	r3, [r7, #12]
 80139d0:	e001      	b.n	80139d6 <vTaskStartScheduler+0x4e>
		}
		else
		{
			xReturn = pdFAIL;
 80139d2:	2300      	movs	r3, #0
 80139d4:	60fb      	str	r3, [r7, #12]
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
 80139d6:	68fb      	ldr	r3, [r7, #12]
 80139d8:	2b01      	cmp	r3, #1
 80139da:	d10d      	bne.n	80139f8 <vTaskStartScheduler+0x70>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
 80139dc:	b672      	cpsid	i
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
 80139de:	4b0e      	ldr	r3, [pc, #56]	; (8013a18 <vTaskStartScheduler+0x90>)
 80139e0:	2201      	movs	r2, #1
 80139e2:	4252      	negs	r2, r2
 80139e4:	601a      	str	r2, [r3, #0]
		xSchedulerRunning = pdTRUE;
 80139e6:	4b0d      	ldr	r3, [pc, #52]	; (8013a1c <vTaskStartScheduler+0x94>)
 80139e8:	2201      	movs	r2, #1
 80139ea:	601a      	str	r2, [r3, #0]
		xTickCount = ( TickType_t ) 0U;
 80139ec:	4b0c      	ldr	r3, [pc, #48]	; (8013a20 <vTaskStartScheduler+0x98>)
 80139ee:	2200      	movs	r2, #0
 80139f0:	601a      	str	r2, [r3, #0]
		FreeRTOSConfig.h file. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
 80139f2:	f000 fb59 	bl	80140a8 <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
 80139f6:	e004      	b.n	8013a02 <vTaskStartScheduler+0x7a>
		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
 80139f8:	68fb      	ldr	r3, [r7, #12]
 80139fa:	3301      	adds	r3, #1
 80139fc:	d101      	bne.n	8013a02 <vTaskStartScheduler+0x7a>
 80139fe:	b672      	cpsid	i
 8013a00:	e7fe      	b.n	8013a00 <vTaskStartScheduler+0x78>
}
 8013a02:	46c0      	nop			; (mov r8, r8)
 8013a04:	46bd      	mov	sp, r7
 8013a06:	b005      	add	sp, #20
 8013a08:	bd90      	pop	{r4, r7, pc}
 8013a0a:	46c0      	nop			; (mov r8, r8)
 8013a0c:	08015ca4 	.word	0x08015ca4
 8013a10:	08013d61 	.word	0x08013d61
 8013a14:	200006f4 	.word	0x200006f4
 8013a18:	200006f0 	.word	0x200006f0
 8013a1c:	200006dc 	.word	0x200006dc
 8013a20:	200006d4 	.word	0x200006d4

08013a24 <vTaskSuspendAll>:
	vPortEndScheduler();
}
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
 8013a24:	b580      	push	{r7, lr}
 8013a26:	af00      	add	r7, sp, #0
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
 8013a28:	4b03      	ldr	r3, [pc, #12]	; (8013a38 <vTaskSuspendAll+0x14>)
 8013a2a:	681b      	ldr	r3, [r3, #0]
 8013a2c:	1c5a      	adds	r2, r3, #1
 8013a2e:	4b02      	ldr	r3, [pc, #8]	; (8013a38 <vTaskSuspendAll+0x14>)
 8013a30:	601a      	str	r2, [r3, #0]
}
 8013a32:	46c0      	nop			; (mov r8, r8)
 8013a34:	46bd      	mov	sp, r7
 8013a36:	bd80      	pop	{r7, pc}
 8013a38:	200006f8 	.word	0x200006f8

08013a3c <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
 8013a3c:	b580      	push	{r7, lr}
 8013a3e:	b084      	sub	sp, #16
 8013a40:	af00      	add	r7, sp, #0
TCB_t *pxTCB = NULL;
 8013a42:	2300      	movs	r3, #0
 8013a44:	60fb      	str	r3, [r7, #12]
BaseType_t xAlreadyYielded = pdFALSE;
 8013a46:	2300      	movs	r3, #0
 8013a48:	60bb      	str	r3, [r7, #8]

	/* If uxSchedulerSuspended is zero then this function does not match a
	previous call to vTaskSuspendAll(). */
	configASSERT( uxSchedulerSuspended );
 8013a4a:	4b3a      	ldr	r3, [pc, #232]	; (8013b34 <xTaskResumeAll+0xf8>)
 8013a4c:	681b      	ldr	r3, [r3, #0]
 8013a4e:	2b00      	cmp	r3, #0
 8013a50:	d101      	bne.n	8013a56 <xTaskResumeAll+0x1a>
 8013a52:	b672      	cpsid	i
 8013a54:	e7fe      	b.n	8013a54 <xTaskResumeAll+0x18>
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
 8013a56:	f000 fb5b 	bl	8014110 <vPortEnterCritical>
	{
		--uxSchedulerSuspended;
 8013a5a:	4b36      	ldr	r3, [pc, #216]	; (8013b34 <xTaskResumeAll+0xf8>)
 8013a5c:	681b      	ldr	r3, [r3, #0]
 8013a5e:	1e5a      	subs	r2, r3, #1
 8013a60:	4b34      	ldr	r3, [pc, #208]	; (8013b34 <xTaskResumeAll+0xf8>)
 8013a62:	601a      	str	r2, [r3, #0]

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8013a64:	4b33      	ldr	r3, [pc, #204]	; (8013b34 <xTaskResumeAll+0xf8>)
 8013a66:	681b      	ldr	r3, [r3, #0]
 8013a68:	2b00      	cmp	r3, #0
 8013a6a:	d15b      	bne.n	8013b24 <xTaskResumeAll+0xe8>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 8013a6c:	4b32      	ldr	r3, [pc, #200]	; (8013b38 <xTaskResumeAll+0xfc>)
 8013a6e:	681b      	ldr	r3, [r3, #0]
 8013a70:	2b00      	cmp	r3, #0
 8013a72:	d057      	beq.n	8013b24 <xTaskResumeAll+0xe8>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 8013a74:	e02f      	b.n	8013ad6 <xTaskResumeAll+0x9a>
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
 8013a76:	4b31      	ldr	r3, [pc, #196]	; (8013b3c <xTaskResumeAll+0x100>)
 8013a78:	68db      	ldr	r3, [r3, #12]
 8013a7a:	68db      	ldr	r3, [r3, #12]
 8013a7c:	60fb      	str	r3, [r7, #12]
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 8013a7e:	68fb      	ldr	r3, [r7, #12]
 8013a80:	3318      	adds	r3, #24
 8013a82:	0018      	movs	r0, r3
 8013a84:	f7ff fdc5 	bl	8013612 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8013a88:	68fb      	ldr	r3, [r7, #12]
 8013a8a:	3304      	adds	r3, #4
 8013a8c:	0018      	movs	r0, r3
 8013a8e:	f7ff fdc0 	bl	8013612 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 8013a92:	68fb      	ldr	r3, [r7, #12]
 8013a94:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8013a96:	4b2a      	ldr	r3, [pc, #168]	; (8013b40 <xTaskResumeAll+0x104>)
 8013a98:	681b      	ldr	r3, [r3, #0]
 8013a9a:	429a      	cmp	r2, r3
 8013a9c:	d903      	bls.n	8013aa6 <xTaskResumeAll+0x6a>
 8013a9e:	68fb      	ldr	r3, [r7, #12]
 8013aa0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8013aa2:	4b27      	ldr	r3, [pc, #156]	; (8013b40 <xTaskResumeAll+0x104>)
 8013aa4:	601a      	str	r2, [r3, #0]
 8013aa6:	68fb      	ldr	r3, [r7, #12]
 8013aa8:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8013aaa:	0013      	movs	r3, r2
 8013aac:	009b      	lsls	r3, r3, #2
 8013aae:	189b      	adds	r3, r3, r2
 8013ab0:	009b      	lsls	r3, r3, #2
 8013ab2:	4a24      	ldr	r2, [pc, #144]	; (8013b44 <xTaskResumeAll+0x108>)
 8013ab4:	189a      	adds	r2, r3, r2
 8013ab6:	68fb      	ldr	r3, [r7, #12]
 8013ab8:	3304      	adds	r3, #4
 8013aba:	0019      	movs	r1, r3
 8013abc:	0010      	movs	r0, r2
 8013abe:	f7ff fd50 	bl	8013562 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8013ac2:	68fb      	ldr	r3, [r7, #12]
 8013ac4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8013ac6:	4b20      	ldr	r3, [pc, #128]	; (8013b48 <xTaskResumeAll+0x10c>)
 8013ac8:	681b      	ldr	r3, [r3, #0]
 8013aca:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8013acc:	429a      	cmp	r2, r3
 8013ace:	d302      	bcc.n	8013ad6 <xTaskResumeAll+0x9a>
					{
						xYieldPending = pdTRUE;
 8013ad0:	4b1e      	ldr	r3, [pc, #120]	; (8013b4c <xTaskResumeAll+0x110>)
 8013ad2:	2201      	movs	r2, #1
 8013ad4:	601a      	str	r2, [r3, #0]
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 8013ad6:	4b19      	ldr	r3, [pc, #100]	; (8013b3c <xTaskResumeAll+0x100>)
 8013ad8:	681b      	ldr	r3, [r3, #0]
 8013ada:	2b00      	cmp	r3, #0
 8013adc:	d1cb      	bne.n	8013a76 <xTaskResumeAll+0x3a>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
 8013ade:	68fb      	ldr	r3, [r7, #12]
 8013ae0:	2b00      	cmp	r3, #0
 8013ae2:	d001      	beq.n	8013ae8 <xTaskResumeAll+0xac>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
 8013ae4:	f000 f9e6 	bl	8013eb4 <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
 8013ae8:	4b19      	ldr	r3, [pc, #100]	; (8013b50 <xTaskResumeAll+0x114>)
 8013aea:	681b      	ldr	r3, [r3, #0]
 8013aec:	607b      	str	r3, [r7, #4]

					if( uxPendedCounts > ( UBaseType_t ) 0U )
 8013aee:	687b      	ldr	r3, [r7, #4]
 8013af0:	2b00      	cmp	r3, #0
 8013af2:	d00f      	beq.n	8013b14 <xTaskResumeAll+0xd8>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
 8013af4:	f000 f82e 	bl	8013b54 <xTaskIncrementTick>
 8013af8:	1e03      	subs	r3, r0, #0
 8013afa:	d002      	beq.n	8013b02 <xTaskResumeAll+0xc6>
							{
								xYieldPending = pdTRUE;
 8013afc:	4b13      	ldr	r3, [pc, #76]	; (8013b4c <xTaskResumeAll+0x110>)
 8013afe:	2201      	movs	r2, #1
 8013b00:	601a      	str	r2, [r3, #0]
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
 8013b02:	687b      	ldr	r3, [r7, #4]
 8013b04:	3b01      	subs	r3, #1
 8013b06:	607b      	str	r3, [r7, #4]
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
 8013b08:	687b      	ldr	r3, [r7, #4]
 8013b0a:	2b00      	cmp	r3, #0
 8013b0c:	d1f2      	bne.n	8013af4 <xTaskResumeAll+0xb8>

						uxPendedTicks = 0;
 8013b0e:	4b10      	ldr	r3, [pc, #64]	; (8013b50 <xTaskResumeAll+0x114>)
 8013b10:	2200      	movs	r2, #0
 8013b12:	601a      	str	r2, [r3, #0]
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
 8013b14:	4b0d      	ldr	r3, [pc, #52]	; (8013b4c <xTaskResumeAll+0x110>)
 8013b16:	681b      	ldr	r3, [r3, #0]
 8013b18:	2b00      	cmp	r3, #0
 8013b1a:	d003      	beq.n	8013b24 <xTaskResumeAll+0xe8>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
 8013b1c:	2301      	movs	r3, #1
 8013b1e:	60bb      	str	r3, [r7, #8]
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
 8013b20:	f000 fae6 	bl	80140f0 <vPortYield>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
 8013b24:	f000 fb06 	bl	8014134 <vPortExitCritical>

	return xAlreadyYielded;
 8013b28:	68bb      	ldr	r3, [r7, #8]
}
 8013b2a:	0018      	movs	r0, r3
 8013b2c:	46bd      	mov	sp, r7
 8013b2e:	b004      	add	sp, #16
 8013b30:	bd80      	pop	{r7, pc}
 8013b32:	46c0      	nop			; (mov r8, r8)
 8013b34:	200006f8 	.word	0x200006f8
 8013b38:	200006d0 	.word	0x200006d0
 8013b3c:	20000690 	.word	0x20000690
 8013b40:	200006d8 	.word	0x200006d8
 8013b44:	200005d4 	.word	0x200005d4
 8013b48:	200005d0 	.word	0x200005d0
 8013b4c:	200006e4 	.word	0x200006e4
 8013b50:	200006e0 	.word	0x200006e0

08013b54 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
 8013b54:	b580      	push	{r7, lr}
 8013b56:	b086      	sub	sp, #24
 8013b58:	af00      	add	r7, sp, #0
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
 8013b5a:	2300      	movs	r3, #0
 8013b5c:	617b      	str	r3, [r7, #20]

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8013b5e:	4b4c      	ldr	r3, [pc, #304]	; (8013c90 <xTaskIncrementTick+0x13c>)
 8013b60:	681b      	ldr	r3, [r3, #0]
 8013b62:	2b00      	cmp	r3, #0
 8013b64:	d000      	beq.n	8013b68 <xTaskIncrementTick+0x14>
 8013b66:	e083      	b.n	8013c70 <xTaskIncrementTick+0x11c>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
 8013b68:	4b4a      	ldr	r3, [pc, #296]	; (8013c94 <xTaskIncrementTick+0x140>)
 8013b6a:	681b      	ldr	r3, [r3, #0]
 8013b6c:	3301      	adds	r3, #1
 8013b6e:	613b      	str	r3, [r7, #16]

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
 8013b70:	4b48      	ldr	r3, [pc, #288]	; (8013c94 <xTaskIncrementTick+0x140>)
 8013b72:	693a      	ldr	r2, [r7, #16]
 8013b74:	601a      	str	r2, [r3, #0]

		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
 8013b76:	693b      	ldr	r3, [r7, #16]
 8013b78:	2b00      	cmp	r3, #0
 8013b7a:	d117      	bne.n	8013bac <xTaskIncrementTick+0x58>
		{
			taskSWITCH_DELAYED_LISTS();
 8013b7c:	4b46      	ldr	r3, [pc, #280]	; (8013c98 <xTaskIncrementTick+0x144>)
 8013b7e:	681b      	ldr	r3, [r3, #0]
 8013b80:	681b      	ldr	r3, [r3, #0]
 8013b82:	2b00      	cmp	r3, #0
 8013b84:	d001      	beq.n	8013b8a <xTaskIncrementTick+0x36>
 8013b86:	b672      	cpsid	i
 8013b88:	e7fe      	b.n	8013b88 <xTaskIncrementTick+0x34>
 8013b8a:	4b43      	ldr	r3, [pc, #268]	; (8013c98 <xTaskIncrementTick+0x144>)
 8013b8c:	681b      	ldr	r3, [r3, #0]
 8013b8e:	60fb      	str	r3, [r7, #12]
 8013b90:	4b42      	ldr	r3, [pc, #264]	; (8013c9c <xTaskIncrementTick+0x148>)
 8013b92:	681a      	ldr	r2, [r3, #0]
 8013b94:	4b40      	ldr	r3, [pc, #256]	; (8013c98 <xTaskIncrementTick+0x144>)
 8013b96:	601a      	str	r2, [r3, #0]
 8013b98:	4b40      	ldr	r3, [pc, #256]	; (8013c9c <xTaskIncrementTick+0x148>)
 8013b9a:	68fa      	ldr	r2, [r7, #12]
 8013b9c:	601a      	str	r2, [r3, #0]
 8013b9e:	4b40      	ldr	r3, [pc, #256]	; (8013ca0 <xTaskIncrementTick+0x14c>)
 8013ba0:	681b      	ldr	r3, [r3, #0]
 8013ba2:	1c5a      	adds	r2, r3, #1
 8013ba4:	4b3e      	ldr	r3, [pc, #248]	; (8013ca0 <xTaskIncrementTick+0x14c>)
 8013ba6:	601a      	str	r2, [r3, #0]
 8013ba8:	f000 f984 	bl	8013eb4 <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
 8013bac:	4b3d      	ldr	r3, [pc, #244]	; (8013ca4 <xTaskIncrementTick+0x150>)
 8013bae:	681b      	ldr	r3, [r3, #0]
 8013bb0:	693a      	ldr	r2, [r7, #16]
 8013bb2:	429a      	cmp	r2, r3
 8013bb4:	d34e      	bcc.n	8013c54 <xTaskIncrementTick+0x100>
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8013bb6:	4b38      	ldr	r3, [pc, #224]	; (8013c98 <xTaskIncrementTick+0x144>)
 8013bb8:	681b      	ldr	r3, [r3, #0]
 8013bba:	681b      	ldr	r3, [r3, #0]
 8013bbc:	2b00      	cmp	r3, #0
 8013bbe:	d101      	bne.n	8013bc4 <xTaskIncrementTick+0x70>
 8013bc0:	2301      	movs	r3, #1
 8013bc2:	e000      	b.n	8013bc6 <xTaskIncrementTick+0x72>
 8013bc4:	2300      	movs	r3, #0
 8013bc6:	2b00      	cmp	r3, #0
 8013bc8:	d004      	beq.n	8013bd4 <xTaskIncrementTick+0x80>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8013bca:	4b36      	ldr	r3, [pc, #216]	; (8013ca4 <xTaskIncrementTick+0x150>)
 8013bcc:	2201      	movs	r2, #1
 8013bce:	4252      	negs	r2, r2
 8013bd0:	601a      	str	r2, [r3, #0]
					break;
 8013bd2:	e03f      	b.n	8013c54 <xTaskIncrementTick+0x100>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 8013bd4:	4b30      	ldr	r3, [pc, #192]	; (8013c98 <xTaskIncrementTick+0x144>)
 8013bd6:	681b      	ldr	r3, [r3, #0]
 8013bd8:	68db      	ldr	r3, [r3, #12]
 8013bda:	68db      	ldr	r3, [r3, #12]
 8013bdc:	60bb      	str	r3, [r7, #8]
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 8013bde:	68bb      	ldr	r3, [r7, #8]
 8013be0:	685b      	ldr	r3, [r3, #4]
 8013be2:	607b      	str	r3, [r7, #4]

					if( xConstTickCount < xItemValue )
 8013be4:	693a      	ldr	r2, [r7, #16]
 8013be6:	687b      	ldr	r3, [r7, #4]
 8013be8:	429a      	cmp	r2, r3
 8013bea:	d203      	bcs.n	8013bf4 <xTaskIncrementTick+0xa0>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
 8013bec:	4b2d      	ldr	r3, [pc, #180]	; (8013ca4 <xTaskIncrementTick+0x150>)
 8013bee:	687a      	ldr	r2, [r7, #4]
 8013bf0:	601a      	str	r2, [r3, #0]
						break;
 8013bf2:	e02f      	b.n	8013c54 <xTaskIncrementTick+0x100>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8013bf4:	68bb      	ldr	r3, [r7, #8]
 8013bf6:	3304      	adds	r3, #4
 8013bf8:	0018      	movs	r0, r3
 8013bfa:	f7ff fd0a 	bl	8013612 <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 8013bfe:	68bb      	ldr	r3, [r7, #8]
 8013c00:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8013c02:	2b00      	cmp	r3, #0
 8013c04:	d004      	beq.n	8013c10 <xTaskIncrementTick+0xbc>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 8013c06:	68bb      	ldr	r3, [r7, #8]
 8013c08:	3318      	adds	r3, #24
 8013c0a:	0018      	movs	r0, r3
 8013c0c:	f7ff fd01 	bl	8013612 <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
 8013c10:	68bb      	ldr	r3, [r7, #8]
 8013c12:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8013c14:	4b24      	ldr	r3, [pc, #144]	; (8013ca8 <xTaskIncrementTick+0x154>)
 8013c16:	681b      	ldr	r3, [r3, #0]
 8013c18:	429a      	cmp	r2, r3
 8013c1a:	d903      	bls.n	8013c24 <xTaskIncrementTick+0xd0>
 8013c1c:	68bb      	ldr	r3, [r7, #8]
 8013c1e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8013c20:	4b21      	ldr	r3, [pc, #132]	; (8013ca8 <xTaskIncrementTick+0x154>)
 8013c22:	601a      	str	r2, [r3, #0]
 8013c24:	68bb      	ldr	r3, [r7, #8]
 8013c26:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8013c28:	0013      	movs	r3, r2
 8013c2a:	009b      	lsls	r3, r3, #2
 8013c2c:	189b      	adds	r3, r3, r2
 8013c2e:	009b      	lsls	r3, r3, #2
 8013c30:	4a1e      	ldr	r2, [pc, #120]	; (8013cac <xTaskIncrementTick+0x158>)
 8013c32:	189a      	adds	r2, r3, r2
 8013c34:	68bb      	ldr	r3, [r7, #8]
 8013c36:	3304      	adds	r3, #4
 8013c38:	0019      	movs	r1, r3
 8013c3a:	0010      	movs	r0, r2
 8013c3c:	f7ff fc91 	bl	8013562 <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8013c40:	68bb      	ldr	r3, [r7, #8]
 8013c42:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8013c44:	4b1a      	ldr	r3, [pc, #104]	; (8013cb0 <xTaskIncrementTick+0x15c>)
 8013c46:	681b      	ldr	r3, [r3, #0]
 8013c48:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8013c4a:	429a      	cmp	r2, r3
 8013c4c:	d3b3      	bcc.n	8013bb6 <xTaskIncrementTick+0x62>
						{
							xSwitchRequired = pdTRUE;
 8013c4e:	2301      	movs	r3, #1
 8013c50:	617b      	str	r3, [r7, #20]
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8013c52:	e7b0      	b.n	8013bb6 <xTaskIncrementTick+0x62>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
 8013c54:	4b16      	ldr	r3, [pc, #88]	; (8013cb0 <xTaskIncrementTick+0x15c>)
 8013c56:	681b      	ldr	r3, [r3, #0]
 8013c58:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8013c5a:	4914      	ldr	r1, [pc, #80]	; (8013cac <xTaskIncrementTick+0x158>)
 8013c5c:	0013      	movs	r3, r2
 8013c5e:	009b      	lsls	r3, r3, #2
 8013c60:	189b      	adds	r3, r3, r2
 8013c62:	009b      	lsls	r3, r3, #2
 8013c64:	585b      	ldr	r3, [r3, r1]
 8013c66:	2b01      	cmp	r3, #1
 8013c68:	d907      	bls.n	8013c7a <xTaskIncrementTick+0x126>
			{
				xSwitchRequired = pdTRUE;
 8013c6a:	2301      	movs	r3, #1
 8013c6c:	617b      	str	r3, [r7, #20]
 8013c6e:	e004      	b.n	8013c7a <xTaskIncrementTick+0x126>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
 8013c70:	4b10      	ldr	r3, [pc, #64]	; (8013cb4 <xTaskIncrementTick+0x160>)
 8013c72:	681b      	ldr	r3, [r3, #0]
 8013c74:	1c5a      	adds	r2, r3, #1
 8013c76:	4b0f      	ldr	r3, [pc, #60]	; (8013cb4 <xTaskIncrementTick+0x160>)
 8013c78:	601a      	str	r2, [r3, #0]
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
 8013c7a:	4b0f      	ldr	r3, [pc, #60]	; (8013cb8 <xTaskIncrementTick+0x164>)
 8013c7c:	681b      	ldr	r3, [r3, #0]
 8013c7e:	2b00      	cmp	r3, #0
 8013c80:	d001      	beq.n	8013c86 <xTaskIncrementTick+0x132>
		{
			xSwitchRequired = pdTRUE;
 8013c82:	2301      	movs	r3, #1
 8013c84:	617b      	str	r3, [r7, #20]
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
 8013c86:	697b      	ldr	r3, [r7, #20]
}
 8013c88:	0018      	movs	r0, r3
 8013c8a:	46bd      	mov	sp, r7
 8013c8c:	b006      	add	sp, #24
 8013c8e:	bd80      	pop	{r7, pc}
 8013c90:	200006f8 	.word	0x200006f8
 8013c94:	200006d4 	.word	0x200006d4
 8013c98:	20000688 	.word	0x20000688
 8013c9c:	2000068c 	.word	0x2000068c
 8013ca0:	200006e8 	.word	0x200006e8
 8013ca4:	200006f0 	.word	0x200006f0
 8013ca8:	200006d8 	.word	0x200006d8
 8013cac:	200005d4 	.word	0x200005d4
 8013cb0:	200005d0 	.word	0x200005d0
 8013cb4:	200006e0 	.word	0x200006e0
 8013cb8:	200006e4 	.word	0x200006e4

08013cbc <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
 8013cbc:	b580      	push	{r7, lr}
 8013cbe:	b082      	sub	sp, #8
 8013cc0:	af00      	add	r7, sp, #0
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 8013cc2:	4b22      	ldr	r3, [pc, #136]	; (8013d4c <vTaskSwitchContext+0x90>)
 8013cc4:	681b      	ldr	r3, [r3, #0]
 8013cc6:	2b00      	cmp	r3, #0
 8013cc8:	d003      	beq.n	8013cd2 <vTaskSwitchContext+0x16>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
 8013cca:	4b21      	ldr	r3, [pc, #132]	; (8013d50 <vTaskSwitchContext+0x94>)
 8013ccc:	2201      	movs	r2, #1
 8013cce:	601a      	str	r2, [r3, #0]
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
 8013cd0:	e037      	b.n	8013d42 <vTaskSwitchContext+0x86>
		xYieldPending = pdFALSE;
 8013cd2:	4b1f      	ldr	r3, [pc, #124]	; (8013d50 <vTaskSwitchContext+0x94>)
 8013cd4:	2200      	movs	r2, #0
 8013cd6:	601a      	str	r2, [r3, #0]
		taskSELECT_HIGHEST_PRIORITY_TASK();
 8013cd8:	4b1e      	ldr	r3, [pc, #120]	; (8013d54 <vTaskSwitchContext+0x98>)
 8013cda:	681b      	ldr	r3, [r3, #0]
 8013cdc:	607b      	str	r3, [r7, #4]
 8013cde:	e007      	b.n	8013cf0 <vTaskSwitchContext+0x34>
 8013ce0:	687b      	ldr	r3, [r7, #4]
 8013ce2:	2b00      	cmp	r3, #0
 8013ce4:	d101      	bne.n	8013cea <vTaskSwitchContext+0x2e>
 8013ce6:	b672      	cpsid	i
 8013ce8:	e7fe      	b.n	8013ce8 <vTaskSwitchContext+0x2c>
 8013cea:	687b      	ldr	r3, [r7, #4]
 8013cec:	3b01      	subs	r3, #1
 8013cee:	607b      	str	r3, [r7, #4]
 8013cf0:	4919      	ldr	r1, [pc, #100]	; (8013d58 <vTaskSwitchContext+0x9c>)
 8013cf2:	687a      	ldr	r2, [r7, #4]
 8013cf4:	0013      	movs	r3, r2
 8013cf6:	009b      	lsls	r3, r3, #2
 8013cf8:	189b      	adds	r3, r3, r2
 8013cfa:	009b      	lsls	r3, r3, #2
 8013cfc:	585b      	ldr	r3, [r3, r1]
 8013cfe:	2b00      	cmp	r3, #0
 8013d00:	d0ee      	beq.n	8013ce0 <vTaskSwitchContext+0x24>
 8013d02:	687a      	ldr	r2, [r7, #4]
 8013d04:	0013      	movs	r3, r2
 8013d06:	009b      	lsls	r3, r3, #2
 8013d08:	189b      	adds	r3, r3, r2
 8013d0a:	009b      	lsls	r3, r3, #2
 8013d0c:	4a12      	ldr	r2, [pc, #72]	; (8013d58 <vTaskSwitchContext+0x9c>)
 8013d0e:	189b      	adds	r3, r3, r2
 8013d10:	603b      	str	r3, [r7, #0]
 8013d12:	683b      	ldr	r3, [r7, #0]
 8013d14:	685b      	ldr	r3, [r3, #4]
 8013d16:	685a      	ldr	r2, [r3, #4]
 8013d18:	683b      	ldr	r3, [r7, #0]
 8013d1a:	605a      	str	r2, [r3, #4]
 8013d1c:	683b      	ldr	r3, [r7, #0]
 8013d1e:	685a      	ldr	r2, [r3, #4]
 8013d20:	683b      	ldr	r3, [r7, #0]
 8013d22:	3308      	adds	r3, #8
 8013d24:	429a      	cmp	r2, r3
 8013d26:	d104      	bne.n	8013d32 <vTaskSwitchContext+0x76>
 8013d28:	683b      	ldr	r3, [r7, #0]
 8013d2a:	685b      	ldr	r3, [r3, #4]
 8013d2c:	685a      	ldr	r2, [r3, #4]
 8013d2e:	683b      	ldr	r3, [r7, #0]
 8013d30:	605a      	str	r2, [r3, #4]
 8013d32:	683b      	ldr	r3, [r7, #0]
 8013d34:	685b      	ldr	r3, [r3, #4]
 8013d36:	68da      	ldr	r2, [r3, #12]
 8013d38:	4b08      	ldr	r3, [pc, #32]	; (8013d5c <vTaskSwitchContext+0xa0>)
 8013d3a:	601a      	str	r2, [r3, #0]
 8013d3c:	4b05      	ldr	r3, [pc, #20]	; (8013d54 <vTaskSwitchContext+0x98>)
 8013d3e:	687a      	ldr	r2, [r7, #4]
 8013d40:	601a      	str	r2, [r3, #0]
}
 8013d42:	46c0      	nop			; (mov r8, r8)
 8013d44:	46bd      	mov	sp, r7
 8013d46:	b002      	add	sp, #8
 8013d48:	bd80      	pop	{r7, pc}
 8013d4a:	46c0      	nop			; (mov r8, r8)
 8013d4c:	200006f8 	.word	0x200006f8
 8013d50:	200006e4 	.word	0x200006e4
 8013d54:	200006d8 	.word	0x200006d8
 8013d58:	200005d4 	.word	0x200005d4
 8013d5c:	200005d0 	.word	0x200005d0

08013d60 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
 8013d60:	b580      	push	{r7, lr}
 8013d62:	b082      	sub	sp, #8
 8013d64:	af00      	add	r7, sp, #0
 8013d66:	6078      	str	r0, [r7, #4]

	for( ;; )
	{
		/* See if any tasks have deleted themselves - if so then the idle task
		is responsible for freeing the deleted task's TCB and stack. */
		prvCheckTasksWaitingTermination();
 8013d68:	f000 f84e 	bl	8013e08 <prvCheckTasksWaitingTermination>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 8013d6c:	4b03      	ldr	r3, [pc, #12]	; (8013d7c <prvIdleTask+0x1c>)
 8013d6e:	681b      	ldr	r3, [r3, #0]
 8013d70:	2b01      	cmp	r3, #1
 8013d72:	d9f9      	bls.n	8013d68 <prvIdleTask+0x8>
			{
				taskYIELD();
 8013d74:	f000 f9bc 	bl	80140f0 <vPortYield>
		prvCheckTasksWaitingTermination();
 8013d78:	e7f6      	b.n	8013d68 <prvIdleTask+0x8>
 8013d7a:	46c0      	nop			; (mov r8, r8)
 8013d7c:	200005d4 	.word	0x200005d4

08013d80 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
 8013d80:	b580      	push	{r7, lr}
 8013d82:	b082      	sub	sp, #8
 8013d84:	af00      	add	r7, sp, #0
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 8013d86:	2300      	movs	r3, #0
 8013d88:	607b      	str	r3, [r7, #4]
 8013d8a:	e00c      	b.n	8013da6 <prvInitialiseTaskLists+0x26>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 8013d8c:	687a      	ldr	r2, [r7, #4]
 8013d8e:	0013      	movs	r3, r2
 8013d90:	009b      	lsls	r3, r3, #2
 8013d92:	189b      	adds	r3, r3, r2
 8013d94:	009b      	lsls	r3, r3, #2
 8013d96:	4a14      	ldr	r2, [pc, #80]	; (8013de8 <prvInitialiseTaskLists+0x68>)
 8013d98:	189b      	adds	r3, r3, r2
 8013d9a:	0018      	movs	r0, r3
 8013d9c:	f7ff fbb8 	bl	8013510 <vListInitialise>
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 8013da0:	687b      	ldr	r3, [r7, #4]
 8013da2:	3301      	adds	r3, #1
 8013da4:	607b      	str	r3, [r7, #4]
 8013da6:	687b      	ldr	r3, [r7, #4]
 8013da8:	2b06      	cmp	r3, #6
 8013daa:	d9ef      	bls.n	8013d8c <prvInitialiseTaskLists+0xc>
	}

	vListInitialise( &xDelayedTaskList1 );
 8013dac:	4b0f      	ldr	r3, [pc, #60]	; (8013dec <prvInitialiseTaskLists+0x6c>)
 8013dae:	0018      	movs	r0, r3
 8013db0:	f7ff fbae 	bl	8013510 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
 8013db4:	4b0e      	ldr	r3, [pc, #56]	; (8013df0 <prvInitialiseTaskLists+0x70>)
 8013db6:	0018      	movs	r0, r3
 8013db8:	f7ff fbaa 	bl	8013510 <vListInitialise>
	vListInitialise( &xPendingReadyList );
 8013dbc:	4b0d      	ldr	r3, [pc, #52]	; (8013df4 <prvInitialiseTaskLists+0x74>)
 8013dbe:	0018      	movs	r0, r3
 8013dc0:	f7ff fba6 	bl	8013510 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
 8013dc4:	4b0c      	ldr	r3, [pc, #48]	; (8013df8 <prvInitialiseTaskLists+0x78>)
 8013dc6:	0018      	movs	r0, r3
 8013dc8:	f7ff fba2 	bl	8013510 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
 8013dcc:	4b0b      	ldr	r3, [pc, #44]	; (8013dfc <prvInitialiseTaskLists+0x7c>)
 8013dce:	0018      	movs	r0, r3
 8013dd0:	f7ff fb9e 	bl	8013510 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
 8013dd4:	4b0a      	ldr	r3, [pc, #40]	; (8013e00 <prvInitialiseTaskLists+0x80>)
 8013dd6:	4a05      	ldr	r2, [pc, #20]	; (8013dec <prvInitialiseTaskLists+0x6c>)
 8013dd8:	601a      	str	r2, [r3, #0]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 8013dda:	4b0a      	ldr	r3, [pc, #40]	; (8013e04 <prvInitialiseTaskLists+0x84>)
 8013ddc:	4a04      	ldr	r2, [pc, #16]	; (8013df0 <prvInitialiseTaskLists+0x70>)
 8013dde:	601a      	str	r2, [r3, #0]
}
 8013de0:	46c0      	nop			; (mov r8, r8)
 8013de2:	46bd      	mov	sp, r7
 8013de4:	b002      	add	sp, #8
 8013de6:	bd80      	pop	{r7, pc}
 8013de8:	200005d4 	.word	0x200005d4
 8013dec:	20000660 	.word	0x20000660
 8013df0:	20000674 	.word	0x20000674
 8013df4:	20000690 	.word	0x20000690
 8013df8:	200006a4 	.word	0x200006a4
 8013dfc:	200006bc 	.word	0x200006bc
 8013e00:	20000688 	.word	0x20000688
 8013e04:	2000068c 	.word	0x2000068c

08013e08 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
 8013e08:	b580      	push	{r7, lr}
 8013e0a:	b082      	sub	sp, #8
 8013e0c:	af00      	add	r7, sp, #0
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent vTaskSuspendAll()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 8013e0e:	e01a      	b.n	8013e46 <prvCheckTasksWaitingTermination+0x3e>
		{
			taskENTER_CRITICAL();
 8013e10:	f000 f97e 	bl	8014110 <vPortEnterCritical>
			{
				pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
 8013e14:	4b10      	ldr	r3, [pc, #64]	; (8013e58 <prvCheckTasksWaitingTermination+0x50>)
 8013e16:	68db      	ldr	r3, [r3, #12]
 8013e18:	68db      	ldr	r3, [r3, #12]
 8013e1a:	607b      	str	r3, [r7, #4]
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8013e1c:	687b      	ldr	r3, [r7, #4]
 8013e1e:	3304      	adds	r3, #4
 8013e20:	0018      	movs	r0, r3
 8013e22:	f7ff fbf6 	bl	8013612 <uxListRemove>
				--uxCurrentNumberOfTasks;
 8013e26:	4b0d      	ldr	r3, [pc, #52]	; (8013e5c <prvCheckTasksWaitingTermination+0x54>)
 8013e28:	681b      	ldr	r3, [r3, #0]
 8013e2a:	1e5a      	subs	r2, r3, #1
 8013e2c:	4b0b      	ldr	r3, [pc, #44]	; (8013e5c <prvCheckTasksWaitingTermination+0x54>)
 8013e2e:	601a      	str	r2, [r3, #0]
				--uxDeletedTasksWaitingCleanUp;
 8013e30:	4b0b      	ldr	r3, [pc, #44]	; (8013e60 <prvCheckTasksWaitingTermination+0x58>)
 8013e32:	681b      	ldr	r3, [r3, #0]
 8013e34:	1e5a      	subs	r2, r3, #1
 8013e36:	4b0a      	ldr	r3, [pc, #40]	; (8013e60 <prvCheckTasksWaitingTermination+0x58>)
 8013e38:	601a      	str	r2, [r3, #0]
			}
			taskEXIT_CRITICAL();
 8013e3a:	f000 f97b 	bl	8014134 <vPortExitCritical>

			prvDeleteTCB( pxTCB );
 8013e3e:	687b      	ldr	r3, [r7, #4]
 8013e40:	0018      	movs	r0, r3
 8013e42:	f000 f80f 	bl	8013e64 <prvDeleteTCB>
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 8013e46:	4b06      	ldr	r3, [pc, #24]	; (8013e60 <prvCheckTasksWaitingTermination+0x58>)
 8013e48:	681b      	ldr	r3, [r3, #0]
 8013e4a:	2b00      	cmp	r3, #0
 8013e4c:	d1e0      	bne.n	8013e10 <prvCheckTasksWaitingTermination+0x8>
		}
	}
	#endif /* INCLUDE_vTaskDelete */
}
 8013e4e:	46c0      	nop			; (mov r8, r8)
 8013e50:	46c0      	nop			; (mov r8, r8)
 8013e52:	46bd      	mov	sp, r7
 8013e54:	b002      	add	sp, #8
 8013e56:	bd80      	pop	{r7, pc}
 8013e58:	200006a4 	.word	0x200006a4
 8013e5c:	200006d0 	.word	0x200006d0
 8013e60:	200006b8 	.word	0x200006b8

08013e64 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
 8013e64:	b580      	push	{r7, lr}
 8013e66:	b082      	sub	sp, #8
 8013e68:	af00      	add	r7, sp, #0
 8013e6a:	6078      	str	r0, [r7, #4]
		#elif( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 Macro has been consolidated for readability reasons. */
		{
			/* The task could have been allocated statically or dynamically, so
			check what was statically allocated before trying to free the
			memory. */
			if( pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )
 8013e6c:	687b      	ldr	r3, [r7, #4]
 8013e6e:	2251      	movs	r2, #81	; 0x51
 8013e70:	5c9b      	ldrb	r3, [r3, r2]
 8013e72:	2b00      	cmp	r3, #0
 8013e74:	d109      	bne.n	8013e8a <prvDeleteTCB+0x26>
			{
				/* Both the stack and TCB were allocated dynamically, so both
				must be freed. */
				vPortFree( pxTCB->pxStack );
 8013e76:	687b      	ldr	r3, [r7, #4]
 8013e78:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8013e7a:	0018      	movs	r0, r3
 8013e7c:	f000 fa86 	bl	801438c <vPortFree>
				vPortFree( pxTCB );
 8013e80:	687b      	ldr	r3, [r7, #4]
 8013e82:	0018      	movs	r0, r3
 8013e84:	f000 fa82 	bl	801438c <vPortFree>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
 8013e88:	e010      	b.n	8013eac <prvDeleteTCB+0x48>
			else if( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_ONLY )
 8013e8a:	687b      	ldr	r3, [r7, #4]
 8013e8c:	2251      	movs	r2, #81	; 0x51
 8013e8e:	5c9b      	ldrb	r3, [r3, r2]
 8013e90:	2b01      	cmp	r3, #1
 8013e92:	d104      	bne.n	8013e9e <prvDeleteTCB+0x3a>
				vPortFree( pxTCB );
 8013e94:	687b      	ldr	r3, [r7, #4]
 8013e96:	0018      	movs	r0, r3
 8013e98:	f000 fa78 	bl	801438c <vPortFree>
	}
 8013e9c:	e006      	b.n	8013eac <prvDeleteTCB+0x48>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
 8013e9e:	687b      	ldr	r3, [r7, #4]
 8013ea0:	2251      	movs	r2, #81	; 0x51
 8013ea2:	5c9b      	ldrb	r3, [r3, r2]
 8013ea4:	2b02      	cmp	r3, #2
 8013ea6:	d001      	beq.n	8013eac <prvDeleteTCB+0x48>
 8013ea8:	b672      	cpsid	i
 8013eaa:	e7fe      	b.n	8013eaa <prvDeleteTCB+0x46>
	}
 8013eac:	46c0      	nop			; (mov r8, r8)
 8013eae:	46bd      	mov	sp, r7
 8013eb0:	b002      	add	sp, #8
 8013eb2:	bd80      	pop	{r7, pc}

08013eb4 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
 8013eb4:	b580      	push	{r7, lr}
 8013eb6:	b082      	sub	sp, #8
 8013eb8:	af00      	add	r7, sp, #0
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8013eba:	4b0e      	ldr	r3, [pc, #56]	; (8013ef4 <prvResetNextTaskUnblockTime+0x40>)
 8013ebc:	681b      	ldr	r3, [r3, #0]
 8013ebe:	681b      	ldr	r3, [r3, #0]
 8013ec0:	2b00      	cmp	r3, #0
 8013ec2:	d101      	bne.n	8013ec8 <prvResetNextTaskUnblockTime+0x14>
 8013ec4:	2301      	movs	r3, #1
 8013ec6:	e000      	b.n	8013eca <prvResetNextTaskUnblockTime+0x16>
 8013ec8:	2300      	movs	r3, #0
 8013eca:	2b00      	cmp	r3, #0
 8013ecc:	d004      	beq.n	8013ed8 <prvResetNextTaskUnblockTime+0x24>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
 8013ece:	4b0a      	ldr	r3, [pc, #40]	; (8013ef8 <prvResetNextTaskUnblockTime+0x44>)
 8013ed0:	2201      	movs	r2, #1
 8013ed2:	4252      	negs	r2, r2
 8013ed4:	601a      	str	r2, [r3, #0]
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
	}
}
 8013ed6:	e008      	b.n	8013eea <prvResetNextTaskUnblockTime+0x36>
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 8013ed8:	4b06      	ldr	r3, [pc, #24]	; (8013ef4 <prvResetNextTaskUnblockTime+0x40>)
 8013eda:	681b      	ldr	r3, [r3, #0]
 8013edc:	68db      	ldr	r3, [r3, #12]
 8013ede:	68db      	ldr	r3, [r3, #12]
 8013ee0:	607b      	str	r3, [r7, #4]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 8013ee2:	687b      	ldr	r3, [r7, #4]
 8013ee4:	685a      	ldr	r2, [r3, #4]
 8013ee6:	4b04      	ldr	r3, [pc, #16]	; (8013ef8 <prvResetNextTaskUnblockTime+0x44>)
 8013ee8:	601a      	str	r2, [r3, #0]
}
 8013eea:	46c0      	nop			; (mov r8, r8)
 8013eec:	46bd      	mov	sp, r7
 8013eee:	b002      	add	sp, #8
 8013ef0:	bd80      	pop	{r7, pc}
 8013ef2:	46c0      	nop			; (mov r8, r8)
 8013ef4:	20000688 	.word	0x20000688
 8013ef8:	200006f0 	.word	0x200006f0

08013efc <xTaskGetSchedulerState>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )

	BaseType_t xTaskGetSchedulerState( void )
	{
 8013efc:	b580      	push	{r7, lr}
 8013efe:	b082      	sub	sp, #8
 8013f00:	af00      	add	r7, sp, #0
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
 8013f02:	4b0a      	ldr	r3, [pc, #40]	; (8013f2c <xTaskGetSchedulerState+0x30>)
 8013f04:	681b      	ldr	r3, [r3, #0]
 8013f06:	2b00      	cmp	r3, #0
 8013f08:	d102      	bne.n	8013f10 <xTaskGetSchedulerState+0x14>
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
 8013f0a:	2301      	movs	r3, #1
 8013f0c:	607b      	str	r3, [r7, #4]
 8013f0e:	e008      	b.n	8013f22 <xTaskGetSchedulerState+0x26>
		}
		else
		{
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8013f10:	4b07      	ldr	r3, [pc, #28]	; (8013f30 <xTaskGetSchedulerState+0x34>)
 8013f12:	681b      	ldr	r3, [r3, #0]
 8013f14:	2b00      	cmp	r3, #0
 8013f16:	d102      	bne.n	8013f1e <xTaskGetSchedulerState+0x22>
			{
				xReturn = taskSCHEDULER_RUNNING;
 8013f18:	2302      	movs	r3, #2
 8013f1a:	607b      	str	r3, [r7, #4]
 8013f1c:	e001      	b.n	8013f22 <xTaskGetSchedulerState+0x26>
			}
			else
			{
				xReturn = taskSCHEDULER_SUSPENDED;
 8013f1e:	2300      	movs	r3, #0
 8013f20:	607b      	str	r3, [r7, #4]
			}
		}

		return xReturn;
 8013f22:	687b      	ldr	r3, [r7, #4]
	}
 8013f24:	0018      	movs	r0, r3
 8013f26:	46bd      	mov	sp, r7
 8013f28:	b002      	add	sp, #8
 8013f2a:	bd80      	pop	{r7, pc}
 8013f2c:	200006dc 	.word	0x200006dc
 8013f30:	200006f8 	.word	0x200006f8

08013f34 <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
 8013f34:	b580      	push	{r7, lr}
 8013f36:	b084      	sub	sp, #16
 8013f38:	af00      	add	r7, sp, #0
 8013f3a:	6078      	str	r0, [r7, #4]
 8013f3c:	6039      	str	r1, [r7, #0]
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
 8013f3e:	4b21      	ldr	r3, [pc, #132]	; (8013fc4 <prvAddCurrentTaskToDelayedList+0x90>)
 8013f40:	681b      	ldr	r3, [r3, #0]
 8013f42:	60fb      	str	r3, [r7, #12]
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8013f44:	4b20      	ldr	r3, [pc, #128]	; (8013fc8 <prvAddCurrentTaskToDelayedList+0x94>)
 8013f46:	681b      	ldr	r3, [r3, #0]
 8013f48:	3304      	adds	r3, #4
 8013f4a:	0018      	movs	r0, r3
 8013f4c:	f7ff fb61 	bl	8013612 <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 8013f50:	687b      	ldr	r3, [r7, #4]
 8013f52:	3301      	adds	r3, #1
 8013f54:	d10b      	bne.n	8013f6e <prvAddCurrentTaskToDelayedList+0x3a>
 8013f56:	683b      	ldr	r3, [r7, #0]
 8013f58:	2b00      	cmp	r3, #0
 8013f5a:	d008      	beq.n	8013f6e <prvAddCurrentTaskToDelayedList+0x3a>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8013f5c:	4b1a      	ldr	r3, [pc, #104]	; (8013fc8 <prvAddCurrentTaskToDelayedList+0x94>)
 8013f5e:	681b      	ldr	r3, [r3, #0]
 8013f60:	1d1a      	adds	r2, r3, #4
 8013f62:	4b1a      	ldr	r3, [pc, #104]	; (8013fcc <prvAddCurrentTaskToDelayedList+0x98>)
 8013f64:	0011      	movs	r1, r2
 8013f66:	0018      	movs	r0, r3
 8013f68:	f7ff fafb 	bl	8013562 <vListInsertEnd>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
 8013f6c:	e026      	b.n	8013fbc <prvAddCurrentTaskToDelayedList+0x88>
			xTimeToWake = xConstTickCount + xTicksToWait;
 8013f6e:	68fa      	ldr	r2, [r7, #12]
 8013f70:	687b      	ldr	r3, [r7, #4]
 8013f72:	18d3      	adds	r3, r2, r3
 8013f74:	60bb      	str	r3, [r7, #8]
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 8013f76:	4b14      	ldr	r3, [pc, #80]	; (8013fc8 <prvAddCurrentTaskToDelayedList+0x94>)
 8013f78:	681b      	ldr	r3, [r3, #0]
 8013f7a:	68ba      	ldr	r2, [r7, #8]
 8013f7c:	605a      	str	r2, [r3, #4]
			if( xTimeToWake < xConstTickCount )
 8013f7e:	68ba      	ldr	r2, [r7, #8]
 8013f80:	68fb      	ldr	r3, [r7, #12]
 8013f82:	429a      	cmp	r2, r3
 8013f84:	d209      	bcs.n	8013f9a <prvAddCurrentTaskToDelayedList+0x66>
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8013f86:	4b12      	ldr	r3, [pc, #72]	; (8013fd0 <prvAddCurrentTaskToDelayedList+0x9c>)
 8013f88:	681a      	ldr	r2, [r3, #0]
 8013f8a:	4b0f      	ldr	r3, [pc, #60]	; (8013fc8 <prvAddCurrentTaskToDelayedList+0x94>)
 8013f8c:	681b      	ldr	r3, [r3, #0]
 8013f8e:	3304      	adds	r3, #4
 8013f90:	0019      	movs	r1, r3
 8013f92:	0010      	movs	r0, r2
 8013f94:	f7ff fb07 	bl	80135a6 <vListInsert>
}
 8013f98:	e010      	b.n	8013fbc <prvAddCurrentTaskToDelayedList+0x88>
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8013f9a:	4b0e      	ldr	r3, [pc, #56]	; (8013fd4 <prvAddCurrentTaskToDelayedList+0xa0>)
 8013f9c:	681a      	ldr	r2, [r3, #0]
 8013f9e:	4b0a      	ldr	r3, [pc, #40]	; (8013fc8 <prvAddCurrentTaskToDelayedList+0x94>)
 8013fa0:	681b      	ldr	r3, [r3, #0]
 8013fa2:	3304      	adds	r3, #4
 8013fa4:	0019      	movs	r1, r3
 8013fa6:	0010      	movs	r0, r2
 8013fa8:	f7ff fafd 	bl	80135a6 <vListInsert>
				if( xTimeToWake < xNextTaskUnblockTime )
 8013fac:	4b0a      	ldr	r3, [pc, #40]	; (8013fd8 <prvAddCurrentTaskToDelayedList+0xa4>)
 8013fae:	681b      	ldr	r3, [r3, #0]
 8013fb0:	68ba      	ldr	r2, [r7, #8]
 8013fb2:	429a      	cmp	r2, r3
 8013fb4:	d202      	bcs.n	8013fbc <prvAddCurrentTaskToDelayedList+0x88>
					xNextTaskUnblockTime = xTimeToWake;
 8013fb6:	4b08      	ldr	r3, [pc, #32]	; (8013fd8 <prvAddCurrentTaskToDelayedList+0xa4>)
 8013fb8:	68ba      	ldr	r2, [r7, #8]
 8013fba:	601a      	str	r2, [r3, #0]
}
 8013fbc:	46c0      	nop			; (mov r8, r8)
 8013fbe:	46bd      	mov	sp, r7
 8013fc0:	b004      	add	sp, #16
 8013fc2:	bd80      	pop	{r7, pc}
 8013fc4:	200006d4 	.word	0x200006d4
 8013fc8:	200005d0 	.word	0x200005d0
 8013fcc:	200006bc 	.word	0x200006bc
 8013fd0:	2000068c 	.word	0x2000068c
 8013fd4:	20000688 	.word	0x20000688
 8013fd8:	200006f0 	.word	0x200006f0

08013fdc <pxPortInitialiseStack>:

/*
 * See header file for description.
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
 8013fdc:	b580      	push	{r7, lr}
 8013fde:	b084      	sub	sp, #16
 8013fe0:	af00      	add	r7, sp, #0
 8013fe2:	60f8      	str	r0, [r7, #12]
 8013fe4:	60b9      	str	r1, [r7, #8]
 8013fe6:	607a      	str	r2, [r7, #4]
	/* Simulate the stack frame as it would be created by a context switch
	interrupt. */
	pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
 8013fe8:	68fb      	ldr	r3, [r7, #12]
 8013fea:	3b04      	subs	r3, #4
 8013fec:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
 8013fee:	68fb      	ldr	r3, [r7, #12]
 8013ff0:	2280      	movs	r2, #128	; 0x80
 8013ff2:	0452      	lsls	r2, r2, #17
 8013ff4:	601a      	str	r2, [r3, #0]
	pxTopOfStack--;
 8013ff6:	68fb      	ldr	r3, [r7, #12]
 8013ff8:	3b04      	subs	r3, #4
 8013ffa:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( StackType_t ) pxCode;	/* PC */
 8013ffc:	68ba      	ldr	r2, [r7, #8]
 8013ffe:	68fb      	ldr	r3, [r7, #12]
 8014000:	601a      	str	r2, [r3, #0]
	pxTopOfStack--;
 8014002:	68fb      	ldr	r3, [r7, #12]
 8014004:	3b04      	subs	r3, #4
 8014006:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
 8014008:	4a08      	ldr	r2, [pc, #32]	; (801402c <pxPortInitialiseStack+0x50>)
 801400a:	68fb      	ldr	r3, [r7, #12]
 801400c:	601a      	str	r2, [r3, #0]
	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
 801400e:	68fb      	ldr	r3, [r7, #12]
 8014010:	3b14      	subs	r3, #20
 8014012:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
 8014014:	687a      	ldr	r2, [r7, #4]
 8014016:	68fb      	ldr	r3, [r7, #12]
 8014018:	601a      	str	r2, [r3, #0]
	pxTopOfStack -= 8; /* R11..R4. */
 801401a:	68fb      	ldr	r3, [r7, #12]
 801401c:	3b20      	subs	r3, #32
 801401e:	60fb      	str	r3, [r7, #12]

	return pxTopOfStack;
 8014020:	68fb      	ldr	r3, [r7, #12]
}
 8014022:	0018      	movs	r0, r3
 8014024:	46bd      	mov	sp, r7
 8014026:	b004      	add	sp, #16
 8014028:	bd80      	pop	{r7, pc}
 801402a:	46c0      	nop			; (mov r8, r8)
 801402c:	08014031 	.word	0x08014031

08014030 <prvTaskExitError>:
/*-----------------------------------------------------------*/

static void prvTaskExitError( void )
{
 8014030:	b580      	push	{r7, lr}
 8014032:	b082      	sub	sp, #8
 8014034:	af00      	add	r7, sp, #0
volatile uint32_t ulDummy = 0UL;
 8014036:	2300      	movs	r3, #0
 8014038:	607b      	str	r3, [r7, #4]
	its caller as there is nothing to return to.  If a task wants to exit it
	should instead call vTaskDelete( NULL ).

	Artificially force an assert() to be triggered if configASSERT() is
	defined, then stop here so application writers can catch the error. */
	configASSERT( uxCriticalNesting == ~0UL );
 801403a:	4b08      	ldr	r3, [pc, #32]	; (801405c <prvTaskExitError+0x2c>)
 801403c:	681b      	ldr	r3, [r3, #0]
 801403e:	3301      	adds	r3, #1
 8014040:	d001      	beq.n	8014046 <prvTaskExitError+0x16>
 8014042:	b672      	cpsid	i
 8014044:	e7fe      	b.n	8014044 <prvTaskExitError+0x14>
	portDISABLE_INTERRUPTS();
 8014046:	b672      	cpsid	i
	while( ulDummy == 0 )
 8014048:	46c0      	nop			; (mov r8, r8)
 801404a:	687b      	ldr	r3, [r7, #4]
 801404c:	2b00      	cmp	r3, #0
 801404e:	d0fc      	beq.n	801404a <prvTaskExitError+0x1a>
		about code appearing after this function is called - making ulDummy
		volatile makes the compiler think the function could return and
		therefore not output an 'unreachable code' warning for code that appears
		after it. */
	}
}
 8014050:	46c0      	nop			; (mov r8, r8)
 8014052:	46c0      	nop			; (mov r8, r8)
 8014054:	46bd      	mov	sp, r7
 8014056:	b002      	add	sp, #8
 8014058:	bd80      	pop	{r7, pc}
 801405a:	46c0      	nop			; (mov r8, r8)
 801405c:	20000278 	.word	0x20000278

08014060 <SVC_Handler>:
/*-----------------------------------------------------------*/

void vPortSVCHandler( void )
{
 8014060:	b580      	push	{r7, lr}
 8014062:	af00      	add	r7, sp, #0
	/* This function is no longer used, but retained for backward
	compatibility. */
}
 8014064:	46c0      	nop			; (mov r8, r8)
 8014066:	46bd      	mov	sp, r7
 8014068:	bd80      	pop	{r7, pc}
 801406a:	0000      	movs	r0, r0
 801406c:	0000      	movs	r0, r0
	...

08014070 <vPortStartFirstTask>:
void vPortStartFirstTask( void )
{
	/* The MSP stack is not reset as, unlike on M3/4 parts, there is no vector
	table offset register that can be used to locate the initial stack value.
	Not all M0 parts have the application vector table at address 0. */
	__asm volatile(
 8014070:	4a0b      	ldr	r2, [pc, #44]	; (80140a0 <pxCurrentTCBConst2>)
 8014072:	6813      	ldr	r3, [r2, #0]
 8014074:	6818      	ldr	r0, [r3, #0]
 8014076:	3020      	adds	r0, #32
 8014078:	f380 8809 	msr	PSP, r0
 801407c:	2002      	movs	r0, #2
 801407e:	f380 8814 	msr	CONTROL, r0
 8014082:	f3bf 8f6f 	isb	sy
 8014086:	bc3f      	pop	{r0, r1, r2, r3, r4, r5}
 8014088:	46ae      	mov	lr, r5
 801408a:	bc08      	pop	{r3}
 801408c:	bc04      	pop	{r2}
 801408e:	b662      	cpsie	i
 8014090:	4718      	bx	r3
 8014092:	46c0      	nop			; (mov r8, r8)
 8014094:	46c0      	nop			; (mov r8, r8)
 8014096:	46c0      	nop			; (mov r8, r8)
 8014098:	46c0      	nop			; (mov r8, r8)
 801409a:	46c0      	nop			; (mov r8, r8)
 801409c:	46c0      	nop			; (mov r8, r8)
 801409e:	46c0      	nop			; (mov r8, r8)

080140a0 <pxCurrentTCBConst2>:
 80140a0:	200005d0 	.word	0x200005d0
	"	bx   r3						\n" /* Finally, jump to the user defined task code. */
	"								\n"
	"	.align 4					\n"
	"pxCurrentTCBConst2: .word pxCurrentTCB	  "
				  );
}
 80140a4:	46c0      	nop			; (mov r8, r8)
 80140a6:	46c0      	nop			; (mov r8, r8)

080140a8 <xPortStartScheduler>:

/*
 * See header file for description.
 */
BaseType_t xPortStartScheduler( void )
{
 80140a8:	b580      	push	{r7, lr}
 80140aa:	af00      	add	r7, sp, #0
	/* Make PendSV, CallSV and SysTick the same priroity as the kernel. */
	*(portNVIC_SYSPRI2) |= portNVIC_PENDSV_PRI;
 80140ac:	4b0e      	ldr	r3, [pc, #56]	; (80140e8 <xPortStartScheduler+0x40>)
 80140ae:	681a      	ldr	r2, [r3, #0]
 80140b0:	4b0d      	ldr	r3, [pc, #52]	; (80140e8 <xPortStartScheduler+0x40>)
 80140b2:	21ff      	movs	r1, #255	; 0xff
 80140b4:	0409      	lsls	r1, r1, #16
 80140b6:	430a      	orrs	r2, r1
 80140b8:	601a      	str	r2, [r3, #0]
	*(portNVIC_SYSPRI2) |= portNVIC_SYSTICK_PRI;
 80140ba:	4b0b      	ldr	r3, [pc, #44]	; (80140e8 <xPortStartScheduler+0x40>)
 80140bc:	681a      	ldr	r2, [r3, #0]
 80140be:	4b0a      	ldr	r3, [pc, #40]	; (80140e8 <xPortStartScheduler+0x40>)
 80140c0:	21ff      	movs	r1, #255	; 0xff
 80140c2:	0609      	lsls	r1, r1, #24
 80140c4:	430a      	orrs	r2, r1
 80140c6:	601a      	str	r2, [r3, #0]

	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();
 80140c8:	f000 f898 	bl	80141fc <prvSetupTimerInterrupt>

	/* Initialise the critical nesting count ready for the first task. */
	uxCriticalNesting = 0;
 80140cc:	4b07      	ldr	r3, [pc, #28]	; (80140ec <xPortStartScheduler+0x44>)
 80140ce:	2200      	movs	r2, #0
 80140d0:	601a      	str	r2, [r3, #0]

	/* Start the first task. */
	vPortStartFirstTask();
 80140d2:	f7ff ffcd 	bl	8014070 <vPortStartFirstTask>
	exit error function to prevent compiler warnings about a static function
	not being called in the case that the application writer overrides this
	functionality by defining configTASK_RETURN_ADDRESS.  Call
	vTaskSwitchContext() so link time optimisation does not remove the
	symbol. */
	vTaskSwitchContext();
 80140d6:	f7ff fdf1 	bl	8013cbc <vTaskSwitchContext>
	prvTaskExitError();
 80140da:	f7ff ffa9 	bl	8014030 <prvTaskExitError>

	/* Should not get here! */
	return 0;
 80140de:	2300      	movs	r3, #0
}
 80140e0:	0018      	movs	r0, r3
 80140e2:	46bd      	mov	sp, r7
 80140e4:	bd80      	pop	{r7, pc}
 80140e6:	46c0      	nop			; (mov r8, r8)
 80140e8:	e000ed20 	.word	0xe000ed20
 80140ec:	20000278 	.word	0x20000278

080140f0 <vPortYield>:
	configASSERT( uxCriticalNesting == 1000UL );
}
/*-----------------------------------------------------------*/

void vPortYield( void )
{
 80140f0:	b580      	push	{r7, lr}
 80140f2:	af00      	add	r7, sp, #0
	/* Set a PendSV to request a context switch. */
	*( portNVIC_INT_CTRL ) = portNVIC_PENDSVSET;
 80140f4:	4b05      	ldr	r3, [pc, #20]	; (801410c <vPortYield+0x1c>)
 80140f6:	2280      	movs	r2, #128	; 0x80
 80140f8:	0552      	lsls	r2, r2, #21
 80140fa:	601a      	str	r2, [r3, #0]

	/* Barriers are normally not required but do ensure the code is completely
	within the specified behaviour for the architecture. */
	__asm volatile( "dsb" ::: "memory" );
 80140fc:	f3bf 8f4f 	dsb	sy
	__asm volatile( "isb" );
 8014100:	f3bf 8f6f 	isb	sy
}
 8014104:	46c0      	nop			; (mov r8, r8)
 8014106:	46bd      	mov	sp, r7
 8014108:	bd80      	pop	{r7, pc}
 801410a:	46c0      	nop			; (mov r8, r8)
 801410c:	e000ed04 	.word	0xe000ed04

08014110 <vPortEnterCritical>:
/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
 8014110:	b580      	push	{r7, lr}
 8014112:	af00      	add	r7, sp, #0
    portDISABLE_INTERRUPTS();
 8014114:	b672      	cpsid	i
    uxCriticalNesting++;
 8014116:	4b06      	ldr	r3, [pc, #24]	; (8014130 <vPortEnterCritical+0x20>)
 8014118:	681b      	ldr	r3, [r3, #0]
 801411a:	1c5a      	adds	r2, r3, #1
 801411c:	4b04      	ldr	r3, [pc, #16]	; (8014130 <vPortEnterCritical+0x20>)
 801411e:	601a      	str	r2, [r3, #0]
	__asm volatile( "dsb" ::: "memory" );
 8014120:	f3bf 8f4f 	dsb	sy
	__asm volatile( "isb" );
 8014124:	f3bf 8f6f 	isb	sy
}
 8014128:	46c0      	nop			; (mov r8, r8)
 801412a:	46bd      	mov	sp, r7
 801412c:	bd80      	pop	{r7, pc}
 801412e:	46c0      	nop			; (mov r8, r8)
 8014130:	20000278 	.word	0x20000278

08014134 <vPortExitCritical>:
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
 8014134:	b580      	push	{r7, lr}
 8014136:	af00      	add	r7, sp, #0
	configASSERT( uxCriticalNesting );
 8014138:	4b09      	ldr	r3, [pc, #36]	; (8014160 <vPortExitCritical+0x2c>)
 801413a:	681b      	ldr	r3, [r3, #0]
 801413c:	2b00      	cmp	r3, #0
 801413e:	d101      	bne.n	8014144 <vPortExitCritical+0x10>
 8014140:	b672      	cpsid	i
 8014142:	e7fe      	b.n	8014142 <vPortExitCritical+0xe>
    uxCriticalNesting--;
 8014144:	4b06      	ldr	r3, [pc, #24]	; (8014160 <vPortExitCritical+0x2c>)
 8014146:	681b      	ldr	r3, [r3, #0]
 8014148:	1e5a      	subs	r2, r3, #1
 801414a:	4b05      	ldr	r3, [pc, #20]	; (8014160 <vPortExitCritical+0x2c>)
 801414c:	601a      	str	r2, [r3, #0]
    if( uxCriticalNesting == 0 )
 801414e:	4b04      	ldr	r3, [pc, #16]	; (8014160 <vPortExitCritical+0x2c>)
 8014150:	681b      	ldr	r3, [r3, #0]
 8014152:	2b00      	cmp	r3, #0
 8014154:	d100      	bne.n	8014158 <vPortExitCritical+0x24>
    {
        portENABLE_INTERRUPTS();
 8014156:	b662      	cpsie	i
    }
}
 8014158:	46c0      	nop			; (mov r8, r8)
 801415a:	46bd      	mov	sp, r7
 801415c:	bd80      	pop	{r7, pc}
 801415e:	46c0      	nop			; (mov r8, r8)
 8014160:	20000278 	.word	0x20000278

08014164 <ulSetInterruptMaskFromISR>:
/*-----------------------------------------------------------*/

uint32_t ulSetInterruptMaskFromISR( void )
{
	__asm volatile(
 8014164:	f3ef 8010 	mrs	r0, PRIMASK
 8014168:	b672      	cpsid	i
 801416a:	4770      	bx	lr
	/* To avoid compiler warnings.  The return statement will nevere be reached,
	but some compilers warn if it is not included, while others won't compile if
	it is. */
	return 0;
#endif
}
 801416c:	46c0      	nop			; (mov r8, r8)
 801416e:	0018      	movs	r0, r3

08014170 <vClearInterruptMaskFromISR>:
/*-----------------------------------------------------------*/

void vClearInterruptMaskFromISR( __attribute__( ( unused ) ) uint32_t ulMask )
{
	__asm volatile(
 8014170:	f380 8810 	msr	PRIMASK, r0
 8014174:	4770      	bx	lr
	/* Just to avoid compiler warning.  ulMask is used from the asm code but
	the compiler can't see that.  Some compilers generate warnings without the
	following line, while others generate warnings if the line is included. */
	( void ) ulMask;
#endif
}
 8014176:	46c0      	nop			; (mov r8, r8)
	...

08014180 <PendSV_Handler>:

void xPortPendSVHandler( void )
{
	/* This is a naked function. */

	__asm volatile
 8014180:	f3ef 8009 	mrs	r0, PSP
 8014184:	4b0e      	ldr	r3, [pc, #56]	; (80141c0 <pxCurrentTCBConst>)
 8014186:	681a      	ldr	r2, [r3, #0]
 8014188:	3820      	subs	r0, #32
 801418a:	6010      	str	r0, [r2, #0]
 801418c:	c0f0      	stmia	r0!, {r4, r5, r6, r7}
 801418e:	4644      	mov	r4, r8
 8014190:	464d      	mov	r5, r9
 8014192:	4656      	mov	r6, sl
 8014194:	465f      	mov	r7, fp
 8014196:	c0f0      	stmia	r0!, {r4, r5, r6, r7}
 8014198:	b508      	push	{r3, lr}
 801419a:	b672      	cpsid	i
 801419c:	f7ff fd8e 	bl	8013cbc <vTaskSwitchContext>
 80141a0:	b662      	cpsie	i
 80141a2:	bc0c      	pop	{r2, r3}
 80141a4:	6811      	ldr	r1, [r2, #0]
 80141a6:	6808      	ldr	r0, [r1, #0]
 80141a8:	3010      	adds	r0, #16
 80141aa:	c8f0      	ldmia	r0!, {r4, r5, r6, r7}
 80141ac:	46a0      	mov	r8, r4
 80141ae:	46a9      	mov	r9, r5
 80141b0:	46b2      	mov	sl, r6
 80141b2:	46bb      	mov	fp, r7
 80141b4:	f380 8809 	msr	PSP, r0
 80141b8:	3820      	subs	r0, #32
 80141ba:	c8f0      	ldmia	r0!, {r4, r5, r6, r7}
 80141bc:	4718      	bx	r3
 80141be:	46c0      	nop			; (mov r8, r8)

080141c0 <pxCurrentTCBConst>:
 80141c0:	200005d0 	.word	0x200005d0
	"	bx r3								\n"
	"										\n"
	"	.align 4							\n"
	"pxCurrentTCBConst: .word pxCurrentTCB	  "
	);
}
 80141c4:	46c0      	nop			; (mov r8, r8)
 80141c6:	46c0      	nop			; (mov r8, r8)

080141c8 <xPortSysTickHandler>:
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
 80141c8:	b580      	push	{r7, lr}
 80141ca:	b082      	sub	sp, #8
 80141cc:	af00      	add	r7, sp, #0
uint32_t ulPreviousMask;

	ulPreviousMask = portSET_INTERRUPT_MASK_FROM_ISR();
 80141ce:	f7ff ffc9 	bl	8014164 <ulSetInterruptMaskFromISR>
 80141d2:	0003      	movs	r3, r0
 80141d4:	607b      	str	r3, [r7, #4]
	{
		/* Increment the RTOS tick. */
		if( xTaskIncrementTick() != pdFALSE )
 80141d6:	f7ff fcbd 	bl	8013b54 <xTaskIncrementTick>
 80141da:	1e03      	subs	r3, r0, #0
 80141dc:	d003      	beq.n	80141e6 <xPortSysTickHandler+0x1e>
		{
			/* Pend a context switch. */
			*(portNVIC_INT_CTRL) = portNVIC_PENDSVSET;
 80141de:	4b06      	ldr	r3, [pc, #24]	; (80141f8 <xPortSysTickHandler+0x30>)
 80141e0:	2280      	movs	r2, #128	; 0x80
 80141e2:	0552      	lsls	r2, r2, #21
 80141e4:	601a      	str	r2, [r3, #0]
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( ulPreviousMask );
 80141e6:	687b      	ldr	r3, [r7, #4]
 80141e8:	0018      	movs	r0, r3
 80141ea:	f7ff ffc1 	bl	8014170 <vClearInterruptMaskFromISR>
}
 80141ee:	46c0      	nop			; (mov r8, r8)
 80141f0:	46bd      	mov	sp, r7
 80141f2:	b002      	add	sp, #8
 80141f4:	bd80      	pop	{r7, pc}
 80141f6:	46c0      	nop			; (mov r8, r8)
 80141f8:	e000ed04 	.word	0xe000ed04

080141fc <prvSetupTimerInterrupt>:
/*
 * Setup the systick timer to generate the tick interrupts at the required
 * frequency.
 */
void prvSetupTimerInterrupt( void )
{
 80141fc:	b580      	push	{r7, lr}
 80141fe:	af00      	add	r7, sp, #0
   ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
 }
 #endif /* configUSE_TICKLESS_IDLE */

/* Stop and reset the SysTick. */
	portNVIC_SYSTICK_CTRL = 0UL;
 8014200:	4b0b      	ldr	r3, [pc, #44]	; (8014230 <prvSetupTimerInterrupt+0x34>)
 8014202:	2200      	movs	r2, #0
 8014204:	601a      	str	r2, [r3, #0]
	portNVIC_SYSTICK_CURRENT_VALUE = 0UL;
 8014206:	4b0b      	ldr	r3, [pc, #44]	; (8014234 <prvSetupTimerInterrupt+0x38>)
 8014208:	2200      	movs	r2, #0
 801420a:	601a      	str	r2, [r3, #0]

 /* Configure SysTick to interrupt at the requested rate. */
 portNVIC_SYSTICK_LOAD = ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 801420c:	4b0a      	ldr	r3, [pc, #40]	; (8014238 <prvSetupTimerInterrupt+0x3c>)
 801420e:	681b      	ldr	r3, [r3, #0]
 8014210:	22fa      	movs	r2, #250	; 0xfa
 8014212:	0091      	lsls	r1, r2, #2
 8014214:	0018      	movs	r0, r3
 8014216:	f7f4 ff89 	bl	800912c <__udivsi3>
 801421a:	0003      	movs	r3, r0
 801421c:	001a      	movs	r2, r3
 801421e:	4b07      	ldr	r3, [pc, #28]	; (801423c <prvSetupTimerInterrupt+0x40>)
 8014220:	3a01      	subs	r2, #1
 8014222:	601a      	str	r2, [r3, #0]
 portNVIC_SYSTICK_CTRL = portNVIC_SYSTICK_CLK | portNVIC_SYSTICK_INT | portNVIC_SYSTICK_ENABLE;
 8014224:	4b02      	ldr	r3, [pc, #8]	; (8014230 <prvSetupTimerInterrupt+0x34>)
 8014226:	2207      	movs	r2, #7
 8014228:	601a      	str	r2, [r3, #0]
}
 801422a:	46c0      	nop			; (mov r8, r8)
 801422c:	46bd      	mov	sp, r7
 801422e:	bd80      	pop	{r7, pc}
 8014230:	e000e010 	.word	0xe000e010
 8014234:	e000e018 	.word	0xe000e018
 8014238:	2000015c 	.word	0x2000015c
 801423c:	e000e014 	.word	0xe000e014

08014240 <pvPortMalloc>:
static size_t xBlockAllocatedBit = 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
 8014240:	b580      	push	{r7, lr}
 8014242:	b086      	sub	sp, #24
 8014244:	af00      	add	r7, sp, #0
 8014246:	6078      	str	r0, [r7, #4]
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;
 8014248:	2300      	movs	r3, #0
 801424a:	60fb      	str	r3, [r7, #12]

	vTaskSuspendAll();
 801424c:	f7ff fbea 	bl	8013a24 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( pxEnd == NULL )
 8014250:	4b49      	ldr	r3, [pc, #292]	; (8014378 <pvPortMalloc+0x138>)
 8014252:	681b      	ldr	r3, [r3, #0]
 8014254:	2b00      	cmp	r3, #0
 8014256:	d101      	bne.n	801425c <pvPortMalloc+0x1c>
		{
			prvHeapInit();
 8014258:	f000 f8e0 	bl	801441c <prvHeapInit>

		/* Check the requested block size is not so large that the top bit is
		set.  The top bit of the block size member of the BlockLink_t structure
		is used to determine who owns the block - the application or the
		kernel, so it must be free. */
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
 801425c:	4b47      	ldr	r3, [pc, #284]	; (801437c <pvPortMalloc+0x13c>)
 801425e:	681b      	ldr	r3, [r3, #0]
 8014260:	687a      	ldr	r2, [r7, #4]
 8014262:	4013      	ands	r3, r2
 8014264:	d000      	beq.n	8014268 <pvPortMalloc+0x28>
 8014266:	e079      	b.n	801435c <pvPortMalloc+0x11c>
		{
			/* The wanted size is increased so it can contain a BlockLink_t
			structure in addition to the requested amount of bytes. */
			if( xWantedSize > 0 )
 8014268:	687b      	ldr	r3, [r7, #4]
 801426a:	2b00      	cmp	r3, #0
 801426c:	d012      	beq.n	8014294 <pvPortMalloc+0x54>
			{
				xWantedSize += xHeapStructSize;
 801426e:	2208      	movs	r2, #8
 8014270:	687b      	ldr	r3, [r7, #4]
 8014272:	189b      	adds	r3, r3, r2
 8014274:	607b      	str	r3, [r7, #4]

				/* Ensure that blocks are always aligned to the required number
				of bytes. */
				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
 8014276:	687b      	ldr	r3, [r7, #4]
 8014278:	2207      	movs	r2, #7
 801427a:	4013      	ands	r3, r2
 801427c:	d00a      	beq.n	8014294 <pvPortMalloc+0x54>
				{
					/* Byte alignment required. */
					xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
 801427e:	687b      	ldr	r3, [r7, #4]
 8014280:	2207      	movs	r2, #7
 8014282:	4393      	bics	r3, r2
 8014284:	3308      	adds	r3, #8
 8014286:	607b      	str	r3, [r7, #4]
					configASSERT( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) == 0 );
 8014288:	687b      	ldr	r3, [r7, #4]
 801428a:	2207      	movs	r2, #7
 801428c:	4013      	ands	r3, r2
 801428e:	d001      	beq.n	8014294 <pvPortMalloc+0x54>
 8014290:	b672      	cpsid	i
 8014292:	e7fe      	b.n	8014292 <pvPortMalloc+0x52>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
 8014294:	687b      	ldr	r3, [r7, #4]
 8014296:	2b00      	cmp	r3, #0
 8014298:	d060      	beq.n	801435c <pvPortMalloc+0x11c>
 801429a:	4b39      	ldr	r3, [pc, #228]	; (8014380 <pvPortMalloc+0x140>)
 801429c:	681b      	ldr	r3, [r3, #0]
 801429e:	687a      	ldr	r2, [r7, #4]
 80142a0:	429a      	cmp	r2, r3
 80142a2:	d85b      	bhi.n	801435c <pvPortMalloc+0x11c>
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
 80142a4:	4b37      	ldr	r3, [pc, #220]	; (8014384 <pvPortMalloc+0x144>)
 80142a6:	613b      	str	r3, [r7, #16]
				pxBlock = xStart.pxNextFreeBlock;
 80142a8:	4b36      	ldr	r3, [pc, #216]	; (8014384 <pvPortMalloc+0x144>)
 80142aa:	681b      	ldr	r3, [r3, #0]
 80142ac:	617b      	str	r3, [r7, #20]
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 80142ae:	e004      	b.n	80142ba <pvPortMalloc+0x7a>
				{
					pxPreviousBlock = pxBlock;
 80142b0:	697b      	ldr	r3, [r7, #20]
 80142b2:	613b      	str	r3, [r7, #16]
					pxBlock = pxBlock->pxNextFreeBlock;
 80142b4:	697b      	ldr	r3, [r7, #20]
 80142b6:	681b      	ldr	r3, [r3, #0]
 80142b8:	617b      	str	r3, [r7, #20]
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 80142ba:	697b      	ldr	r3, [r7, #20]
 80142bc:	685b      	ldr	r3, [r3, #4]
 80142be:	687a      	ldr	r2, [r7, #4]
 80142c0:	429a      	cmp	r2, r3
 80142c2:	d903      	bls.n	80142cc <pvPortMalloc+0x8c>
 80142c4:	697b      	ldr	r3, [r7, #20]
 80142c6:	681b      	ldr	r3, [r3, #0]
 80142c8:	2b00      	cmp	r3, #0
 80142ca:	d1f1      	bne.n	80142b0 <pvPortMalloc+0x70>
				}

				/* If the end marker was reached then a block of adequate size
				was	not found. */
				if( pxBlock != pxEnd )
 80142cc:	4b2a      	ldr	r3, [pc, #168]	; (8014378 <pvPortMalloc+0x138>)
 80142ce:	681b      	ldr	r3, [r3, #0]
 80142d0:	697a      	ldr	r2, [r7, #20]
 80142d2:	429a      	cmp	r2, r3
 80142d4:	d042      	beq.n	801435c <pvPortMalloc+0x11c>
				{
					/* Return the memory space pointed to - jumping over the
					BlockLink_t structure at its start. */
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 80142d6:	693b      	ldr	r3, [r7, #16]
 80142d8:	681b      	ldr	r3, [r3, #0]
 80142da:	2208      	movs	r2, #8
 80142dc:	189b      	adds	r3, r3, r2
 80142de:	60fb      	str	r3, [r7, #12]

					/* This block is being returned for use so must be taken out
					of the list of free blocks. */
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 80142e0:	697b      	ldr	r3, [r7, #20]
 80142e2:	681a      	ldr	r2, [r3, #0]
 80142e4:	693b      	ldr	r3, [r7, #16]
 80142e6:	601a      	str	r2, [r3, #0]

					/* If the block is larger than required it can be split into
					two. */
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 80142e8:	697b      	ldr	r3, [r7, #20]
 80142ea:	685a      	ldr	r2, [r3, #4]
 80142ec:	687b      	ldr	r3, [r7, #4]
 80142ee:	1ad2      	subs	r2, r2, r3
 80142f0:	2308      	movs	r3, #8
 80142f2:	005b      	lsls	r3, r3, #1
 80142f4:	429a      	cmp	r2, r3
 80142f6:	d916      	bls.n	8014326 <pvPortMalloc+0xe6>
					{
						/* This block is to be split into two.  Create a new
						block following the number of bytes requested. The void
						cast is used to prevent byte alignment warnings from the
						compiler. */
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
 80142f8:	697a      	ldr	r2, [r7, #20]
 80142fa:	687b      	ldr	r3, [r7, #4]
 80142fc:	18d3      	adds	r3, r2, r3
 80142fe:	60bb      	str	r3, [r7, #8]
						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );
 8014300:	68bb      	ldr	r3, [r7, #8]
 8014302:	2207      	movs	r2, #7
 8014304:	4013      	ands	r3, r2
 8014306:	d001      	beq.n	801430c <pvPortMalloc+0xcc>
 8014308:	b672      	cpsid	i
 801430a:	e7fe      	b.n	801430a <pvPortMalloc+0xca>

						/* Calculate the sizes of two blocks split from the
						single block. */
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
 801430c:	697b      	ldr	r3, [r7, #20]
 801430e:	685a      	ldr	r2, [r3, #4]
 8014310:	687b      	ldr	r3, [r7, #4]
 8014312:	1ad2      	subs	r2, r2, r3
 8014314:	68bb      	ldr	r3, [r7, #8]
 8014316:	605a      	str	r2, [r3, #4]
						pxBlock->xBlockSize = xWantedSize;
 8014318:	697b      	ldr	r3, [r7, #20]
 801431a:	687a      	ldr	r2, [r7, #4]
 801431c:	605a      	str	r2, [r3, #4]

						/* Insert the new block into the list of free blocks. */
						prvInsertBlockIntoFreeList( pxNewBlockLink );
 801431e:	68bb      	ldr	r3, [r7, #8]
 8014320:	0018      	movs	r0, r3
 8014322:	f000 f8db 	bl	80144dc <prvInsertBlockIntoFreeList>
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					xFreeBytesRemaining -= pxBlock->xBlockSize;
 8014326:	4b16      	ldr	r3, [pc, #88]	; (8014380 <pvPortMalloc+0x140>)
 8014328:	681a      	ldr	r2, [r3, #0]
 801432a:	697b      	ldr	r3, [r7, #20]
 801432c:	685b      	ldr	r3, [r3, #4]
 801432e:	1ad2      	subs	r2, r2, r3
 8014330:	4b13      	ldr	r3, [pc, #76]	; (8014380 <pvPortMalloc+0x140>)
 8014332:	601a      	str	r2, [r3, #0]

					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 8014334:	4b12      	ldr	r3, [pc, #72]	; (8014380 <pvPortMalloc+0x140>)
 8014336:	681a      	ldr	r2, [r3, #0]
 8014338:	4b13      	ldr	r3, [pc, #76]	; (8014388 <pvPortMalloc+0x148>)
 801433a:	681b      	ldr	r3, [r3, #0]
 801433c:	429a      	cmp	r2, r3
 801433e:	d203      	bcs.n	8014348 <pvPortMalloc+0x108>
					{
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
 8014340:	4b0f      	ldr	r3, [pc, #60]	; (8014380 <pvPortMalloc+0x140>)
 8014342:	681a      	ldr	r2, [r3, #0]
 8014344:	4b10      	ldr	r3, [pc, #64]	; (8014388 <pvPortMalloc+0x148>)
 8014346:	601a      	str	r2, [r3, #0]
						mtCOVERAGE_TEST_MARKER();
					}

					/* The block is being returned - it is allocated and owned
					by the application and has no "next" block. */
					pxBlock->xBlockSize |= xBlockAllocatedBit;
 8014348:	697b      	ldr	r3, [r7, #20]
 801434a:	685a      	ldr	r2, [r3, #4]
 801434c:	4b0b      	ldr	r3, [pc, #44]	; (801437c <pvPortMalloc+0x13c>)
 801434e:	681b      	ldr	r3, [r3, #0]
 8014350:	431a      	orrs	r2, r3
 8014352:	697b      	ldr	r3, [r7, #20]
 8014354:	605a      	str	r2, [r3, #4]
					pxBlock->pxNextFreeBlock = NULL;
 8014356:	697b      	ldr	r3, [r7, #20]
 8014358:	2200      	movs	r2, #0
 801435a:	601a      	str	r2, [r3, #0]
			mtCOVERAGE_TEST_MARKER();
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
 801435c:	f7ff fb6e 	bl	8013a3c <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif

	configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
 8014360:	68fb      	ldr	r3, [r7, #12]
 8014362:	2207      	movs	r2, #7
 8014364:	4013      	ands	r3, r2
 8014366:	d001      	beq.n	801436c <pvPortMalloc+0x12c>
 8014368:	b672      	cpsid	i
 801436a:	e7fe      	b.n	801436a <pvPortMalloc+0x12a>
	return pvReturn;
 801436c:	68fb      	ldr	r3, [r7, #12]
}
 801436e:	0018      	movs	r0, r3
 8014370:	46bd      	mov	sp, r7
 8014372:	b006      	add	sp, #24
 8014374:	bd80      	pop	{r7, pc}
 8014376:	46c0      	nop			; (mov r8, r8)
 8014378:	20001304 	.word	0x20001304
 801437c:	20001310 	.word	0x20001310
 8014380:	20001308 	.word	0x20001308
 8014384:	200012fc 	.word	0x200012fc
 8014388:	2000130c 	.word	0x2000130c

0801438c <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
 801438c:	b580      	push	{r7, lr}
 801438e:	b084      	sub	sp, #16
 8014390:	af00      	add	r7, sp, #0
 8014392:	6078      	str	r0, [r7, #4]
uint8_t *puc = ( uint8_t * ) pv;
 8014394:	687b      	ldr	r3, [r7, #4]
 8014396:	60fb      	str	r3, [r7, #12]
BlockLink_t *pxLink;

	if( pv != NULL )
 8014398:	687b      	ldr	r3, [r7, #4]
 801439a:	2b00      	cmp	r3, #0
 801439c:	d035      	beq.n	801440a <vPortFree+0x7e>
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= xHeapStructSize;
 801439e:	2308      	movs	r3, #8
 80143a0:	425b      	negs	r3, r3
 80143a2:	68fa      	ldr	r2, [r7, #12]
 80143a4:	18d3      	adds	r3, r2, r3
 80143a6:	60fb      	str	r3, [r7, #12]

		/* This casting is to keep the compiler from issuing warnings. */
		pxLink = ( void * ) puc;
 80143a8:	68fb      	ldr	r3, [r7, #12]
 80143aa:	60bb      	str	r3, [r7, #8]

		/* Check the block is actually allocated. */
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
 80143ac:	68bb      	ldr	r3, [r7, #8]
 80143ae:	685a      	ldr	r2, [r3, #4]
 80143b0:	4b18      	ldr	r3, [pc, #96]	; (8014414 <vPortFree+0x88>)
 80143b2:	681b      	ldr	r3, [r3, #0]
 80143b4:	4013      	ands	r3, r2
 80143b6:	d101      	bne.n	80143bc <vPortFree+0x30>
 80143b8:	b672      	cpsid	i
 80143ba:	e7fe      	b.n	80143ba <vPortFree+0x2e>
		configASSERT( pxLink->pxNextFreeBlock == NULL );
 80143bc:	68bb      	ldr	r3, [r7, #8]
 80143be:	681b      	ldr	r3, [r3, #0]
 80143c0:	2b00      	cmp	r3, #0
 80143c2:	d001      	beq.n	80143c8 <vPortFree+0x3c>
 80143c4:	b672      	cpsid	i
 80143c6:	e7fe      	b.n	80143c6 <vPortFree+0x3a>

		if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )
 80143c8:	68bb      	ldr	r3, [r7, #8]
 80143ca:	685a      	ldr	r2, [r3, #4]
 80143cc:	4b11      	ldr	r3, [pc, #68]	; (8014414 <vPortFree+0x88>)
 80143ce:	681b      	ldr	r3, [r3, #0]
 80143d0:	4013      	ands	r3, r2
 80143d2:	d01a      	beq.n	801440a <vPortFree+0x7e>
		{
			if( pxLink->pxNextFreeBlock == NULL )
 80143d4:	68bb      	ldr	r3, [r7, #8]
 80143d6:	681b      	ldr	r3, [r3, #0]
 80143d8:	2b00      	cmp	r3, #0
 80143da:	d116      	bne.n	801440a <vPortFree+0x7e>
			{
				/* The block is being returned to the heap - it is no longer
				allocated. */
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
 80143dc:	68bb      	ldr	r3, [r7, #8]
 80143de:	685a      	ldr	r2, [r3, #4]
 80143e0:	4b0c      	ldr	r3, [pc, #48]	; (8014414 <vPortFree+0x88>)
 80143e2:	681b      	ldr	r3, [r3, #0]
 80143e4:	43db      	mvns	r3, r3
 80143e6:	401a      	ands	r2, r3
 80143e8:	68bb      	ldr	r3, [r7, #8]
 80143ea:	605a      	str	r2, [r3, #4]

				vTaskSuspendAll();
 80143ec:	f7ff fb1a 	bl	8013a24 <vTaskSuspendAll>
				{
					/* Add this block to the list of free blocks. */
					xFreeBytesRemaining += pxLink->xBlockSize;
 80143f0:	68bb      	ldr	r3, [r7, #8]
 80143f2:	685a      	ldr	r2, [r3, #4]
 80143f4:	4b08      	ldr	r3, [pc, #32]	; (8014418 <vPortFree+0x8c>)
 80143f6:	681b      	ldr	r3, [r3, #0]
 80143f8:	18d2      	adds	r2, r2, r3
 80143fa:	4b07      	ldr	r3, [pc, #28]	; (8014418 <vPortFree+0x8c>)
 80143fc:	601a      	str	r2, [r3, #0]
					traceFREE( pv, pxLink->xBlockSize );
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
 80143fe:	68bb      	ldr	r3, [r7, #8]
 8014400:	0018      	movs	r0, r3
 8014402:	f000 f86b 	bl	80144dc <prvInsertBlockIntoFreeList>
				}
				( void ) xTaskResumeAll();
 8014406:	f7ff fb19 	bl	8013a3c <xTaskResumeAll>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
 801440a:	46c0      	nop			; (mov r8, r8)
 801440c:	46bd      	mov	sp, r7
 801440e:	b004      	add	sp, #16
 8014410:	bd80      	pop	{r7, pc}
 8014412:	46c0      	nop			; (mov r8, r8)
 8014414:	20001310 	.word	0x20001310
 8014418:	20001308 	.word	0x20001308

0801441c <prvHeapInit>:
	/* This just exists to keep the linker quiet. */
}
/*-----------------------------------------------------------*/

static void prvHeapInit( void )
{
 801441c:	b580      	push	{r7, lr}
 801441e:	b084      	sub	sp, #16
 8014420:	af00      	add	r7, sp, #0
BlockLink_t *pxFirstFreeBlock;
uint8_t *pucAlignedHeap;
size_t uxAddress;
size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;
 8014422:	23c0      	movs	r3, #192	; 0xc0
 8014424:	011b      	lsls	r3, r3, #4
 8014426:	60bb      	str	r3, [r7, #8]

	/* Ensure the heap starts on a correctly aligned boundary. */
	uxAddress = ( size_t ) ucHeap;
 8014428:	4b26      	ldr	r3, [pc, #152]	; (80144c4 <prvHeapInit+0xa8>)
 801442a:	60fb      	str	r3, [r7, #12]

	if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
 801442c:	68fb      	ldr	r3, [r7, #12]
 801442e:	2207      	movs	r2, #7
 8014430:	4013      	ands	r3, r2
 8014432:	d00c      	beq.n	801444e <prvHeapInit+0x32>
	{
		uxAddress += ( portBYTE_ALIGNMENT - 1 );
 8014434:	68fb      	ldr	r3, [r7, #12]
 8014436:	3307      	adds	r3, #7
 8014438:	60fb      	str	r3, [r7, #12]
		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 801443a:	68fb      	ldr	r3, [r7, #12]
 801443c:	2207      	movs	r2, #7
 801443e:	4393      	bics	r3, r2
 8014440:	60fb      	str	r3, [r7, #12]
		xTotalHeapSize -= uxAddress - ( size_t ) ucHeap;
 8014442:	68ba      	ldr	r2, [r7, #8]
 8014444:	68fb      	ldr	r3, [r7, #12]
 8014446:	1ad2      	subs	r2, r2, r3
 8014448:	4b1e      	ldr	r3, [pc, #120]	; (80144c4 <prvHeapInit+0xa8>)
 801444a:	18d3      	adds	r3, r2, r3
 801444c:	60bb      	str	r3, [r7, #8]
	}

	pucAlignedHeap = ( uint8_t * ) uxAddress;
 801444e:	68fb      	ldr	r3, [r7, #12]
 8014450:	607b      	str	r3, [r7, #4]

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 8014452:	4b1d      	ldr	r3, [pc, #116]	; (80144c8 <prvHeapInit+0xac>)
 8014454:	687a      	ldr	r2, [r7, #4]
 8014456:	601a      	str	r2, [r3, #0]
	xStart.xBlockSize = ( size_t ) 0;
 8014458:	4b1b      	ldr	r3, [pc, #108]	; (80144c8 <prvHeapInit+0xac>)
 801445a:	2200      	movs	r2, #0
 801445c:	605a      	str	r2, [r3, #4]

	/* pxEnd is used to mark the end of the list of free blocks and is inserted
	at the end of the heap space. */
	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
 801445e:	687b      	ldr	r3, [r7, #4]
 8014460:	68ba      	ldr	r2, [r7, #8]
 8014462:	18d3      	adds	r3, r2, r3
 8014464:	60fb      	str	r3, [r7, #12]
	uxAddress -= xHeapStructSize;
 8014466:	2208      	movs	r2, #8
 8014468:	68fb      	ldr	r3, [r7, #12]
 801446a:	1a9b      	subs	r3, r3, r2
 801446c:	60fb      	str	r3, [r7, #12]
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 801446e:	68fb      	ldr	r3, [r7, #12]
 8014470:	2207      	movs	r2, #7
 8014472:	4393      	bics	r3, r2
 8014474:	60fb      	str	r3, [r7, #12]
	pxEnd = ( void * ) uxAddress;
 8014476:	68fa      	ldr	r2, [r7, #12]
 8014478:	4b14      	ldr	r3, [pc, #80]	; (80144cc <prvHeapInit+0xb0>)
 801447a:	601a      	str	r2, [r3, #0]
	pxEnd->xBlockSize = 0;
 801447c:	4b13      	ldr	r3, [pc, #76]	; (80144cc <prvHeapInit+0xb0>)
 801447e:	681b      	ldr	r3, [r3, #0]
 8014480:	2200      	movs	r2, #0
 8014482:	605a      	str	r2, [r3, #4]
	pxEnd->pxNextFreeBlock = NULL;
 8014484:	4b11      	ldr	r3, [pc, #68]	; (80144cc <prvHeapInit+0xb0>)
 8014486:	681b      	ldr	r3, [r3, #0]
 8014488:	2200      	movs	r2, #0
 801448a:	601a      	str	r2, [r3, #0]

	/* To start with there is a single free block that is sized to take up the
	entire heap space, minus the space taken by pxEnd. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
 801448c:	687b      	ldr	r3, [r7, #4]
 801448e:	603b      	str	r3, [r7, #0]
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
 8014490:	683b      	ldr	r3, [r7, #0]
 8014492:	68fa      	ldr	r2, [r7, #12]
 8014494:	1ad2      	subs	r2, r2, r3
 8014496:	683b      	ldr	r3, [r7, #0]
 8014498:	605a      	str	r2, [r3, #4]
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
 801449a:	4b0c      	ldr	r3, [pc, #48]	; (80144cc <prvHeapInit+0xb0>)
 801449c:	681a      	ldr	r2, [r3, #0]
 801449e:	683b      	ldr	r3, [r7, #0]
 80144a0:	601a      	str	r2, [r3, #0]

	/* Only one block exists - and it covers the entire usable heap space. */
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 80144a2:	683b      	ldr	r3, [r7, #0]
 80144a4:	685a      	ldr	r2, [r3, #4]
 80144a6:	4b0a      	ldr	r3, [pc, #40]	; (80144d0 <prvHeapInit+0xb4>)
 80144a8:	601a      	str	r2, [r3, #0]
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 80144aa:	683b      	ldr	r3, [r7, #0]
 80144ac:	685a      	ldr	r2, [r3, #4]
 80144ae:	4b09      	ldr	r3, [pc, #36]	; (80144d4 <prvHeapInit+0xb8>)
 80144b0:	601a      	str	r2, [r3, #0]

	/* Work out the position of the top bit in a size_t variable. */
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
 80144b2:	4b09      	ldr	r3, [pc, #36]	; (80144d8 <prvHeapInit+0xbc>)
 80144b4:	2280      	movs	r2, #128	; 0x80
 80144b6:	0612      	lsls	r2, r2, #24
 80144b8:	601a      	str	r2, [r3, #0]
}
 80144ba:	46c0      	nop			; (mov r8, r8)
 80144bc:	46bd      	mov	sp, r7
 80144be:	b004      	add	sp, #16
 80144c0:	bd80      	pop	{r7, pc}
 80144c2:	46c0      	nop			; (mov r8, r8)
 80144c4:	200006fc 	.word	0x200006fc
 80144c8:	200012fc 	.word	0x200012fc
 80144cc:	20001304 	.word	0x20001304
 80144d0:	2000130c 	.word	0x2000130c
 80144d4:	20001308 	.word	0x20001308
 80144d8:	20001310 	.word	0x20001310

080144dc <prvInsertBlockIntoFreeList>:
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
{
 80144dc:	b580      	push	{r7, lr}
 80144de:	b084      	sub	sp, #16
 80144e0:	af00      	add	r7, sp, #0
 80144e2:	6078      	str	r0, [r7, #4]
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
 80144e4:	4b27      	ldr	r3, [pc, #156]	; (8014584 <prvInsertBlockIntoFreeList+0xa8>)
 80144e6:	60fb      	str	r3, [r7, #12]
 80144e8:	e002      	b.n	80144f0 <prvInsertBlockIntoFreeList+0x14>
 80144ea:	68fb      	ldr	r3, [r7, #12]
 80144ec:	681b      	ldr	r3, [r3, #0]
 80144ee:	60fb      	str	r3, [r7, #12]
 80144f0:	68fb      	ldr	r3, [r7, #12]
 80144f2:	681b      	ldr	r3, [r3, #0]
 80144f4:	687a      	ldr	r2, [r7, #4]
 80144f6:	429a      	cmp	r2, r3
 80144f8:	d8f7      	bhi.n	80144ea <prvInsertBlockIntoFreeList+0xe>
		/* Nothing to do here, just iterate to the right position. */
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
 80144fa:	68fb      	ldr	r3, [r7, #12]
 80144fc:	60bb      	str	r3, [r7, #8]
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
 80144fe:	68fb      	ldr	r3, [r7, #12]
 8014500:	685b      	ldr	r3, [r3, #4]
 8014502:	68ba      	ldr	r2, [r7, #8]
 8014504:	18d3      	adds	r3, r2, r3
 8014506:	687a      	ldr	r2, [r7, #4]
 8014508:	429a      	cmp	r2, r3
 801450a:	d108      	bne.n	801451e <prvInsertBlockIntoFreeList+0x42>
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
 801450c:	68fb      	ldr	r3, [r7, #12]
 801450e:	685a      	ldr	r2, [r3, #4]
 8014510:	687b      	ldr	r3, [r7, #4]
 8014512:	685b      	ldr	r3, [r3, #4]
 8014514:	18d2      	adds	r2, r2, r3
 8014516:	68fb      	ldr	r3, [r7, #12]
 8014518:	605a      	str	r2, [r3, #4]
		pxBlockToInsert = pxIterator;
 801451a:	68fb      	ldr	r3, [r7, #12]
 801451c:	607b      	str	r3, [r7, #4]
		mtCOVERAGE_TEST_MARKER();
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
 801451e:	687b      	ldr	r3, [r7, #4]
 8014520:	60bb      	str	r3, [r7, #8]
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
 8014522:	687b      	ldr	r3, [r7, #4]
 8014524:	685b      	ldr	r3, [r3, #4]
 8014526:	68ba      	ldr	r2, [r7, #8]
 8014528:	18d2      	adds	r2, r2, r3
 801452a:	68fb      	ldr	r3, [r7, #12]
 801452c:	681b      	ldr	r3, [r3, #0]
 801452e:	429a      	cmp	r2, r3
 8014530:	d118      	bne.n	8014564 <prvInsertBlockIntoFreeList+0x88>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
 8014532:	68fb      	ldr	r3, [r7, #12]
 8014534:	681a      	ldr	r2, [r3, #0]
 8014536:	4b14      	ldr	r3, [pc, #80]	; (8014588 <prvInsertBlockIntoFreeList+0xac>)
 8014538:	681b      	ldr	r3, [r3, #0]
 801453a:	429a      	cmp	r2, r3
 801453c:	d00d      	beq.n	801455a <prvInsertBlockIntoFreeList+0x7e>
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 801453e:	687b      	ldr	r3, [r7, #4]
 8014540:	685a      	ldr	r2, [r3, #4]
 8014542:	68fb      	ldr	r3, [r7, #12]
 8014544:	681b      	ldr	r3, [r3, #0]
 8014546:	685b      	ldr	r3, [r3, #4]
 8014548:	18d2      	adds	r2, r2, r3
 801454a:	687b      	ldr	r3, [r7, #4]
 801454c:	605a      	str	r2, [r3, #4]
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
 801454e:	68fb      	ldr	r3, [r7, #12]
 8014550:	681b      	ldr	r3, [r3, #0]
 8014552:	681a      	ldr	r2, [r3, #0]
 8014554:	687b      	ldr	r3, [r7, #4]
 8014556:	601a      	str	r2, [r3, #0]
 8014558:	e008      	b.n	801456c <prvInsertBlockIntoFreeList+0x90>
		}
		else
		{
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
 801455a:	4b0b      	ldr	r3, [pc, #44]	; (8014588 <prvInsertBlockIntoFreeList+0xac>)
 801455c:	681a      	ldr	r2, [r3, #0]
 801455e:	687b      	ldr	r3, [r7, #4]
 8014560:	601a      	str	r2, [r3, #0]
 8014562:	e003      	b.n	801456c <prvInsertBlockIntoFreeList+0x90>
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
 8014564:	68fb      	ldr	r3, [r7, #12]
 8014566:	681a      	ldr	r2, [r3, #0]
 8014568:	687b      	ldr	r3, [r7, #4]
 801456a:	601a      	str	r2, [r3, #0]

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
 801456c:	68fa      	ldr	r2, [r7, #12]
 801456e:	687b      	ldr	r3, [r7, #4]
 8014570:	429a      	cmp	r2, r3
 8014572:	d002      	beq.n	801457a <prvInsertBlockIntoFreeList+0x9e>
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
 8014574:	68fb      	ldr	r3, [r7, #12]
 8014576:	687a      	ldr	r2, [r7, #4]
 8014578:	601a      	str	r2, [r3, #0]
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
 801457a:	46c0      	nop			; (mov r8, r8)
 801457c:	46bd      	mov	sp, r7
 801457e:	b004      	add	sp, #16
 8014580:	bd80      	pop	{r7, pc}
 8014582:	46c0      	nop			; (mov r8, r8)
 8014584:	200012fc 	.word	0x200012fc
 8014588:	20001304 	.word	0x20001304

0801458c <MX_USB_DEVICE_Init>:
/**
  * Init USB device Library, add supported class and start the library
  * @retval None
  */
void MX_USB_DEVICE_Init(void)
{
 801458c:	b580      	push	{r7, lr}
 801458e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN USB_DEVICE_Init_PreTreatment */

  /* USER CODE END USB_DEVICE_Init_PreTreatment */

  /* Init Device Library, add supported class and start the library. */
  if (USBD_Init(&hUsbDeviceFS, &FS_Desc, DEVICE_FS) != USBD_OK)
 8014590:	4914      	ldr	r1, [pc, #80]	; (80145e4 <MX_USB_DEVICE_Init+0x58>)
 8014592:	4b15      	ldr	r3, [pc, #84]	; (80145e8 <MX_USB_DEVICE_Init+0x5c>)
 8014594:	2200      	movs	r2, #0
 8014596:	0018      	movs	r0, r3
 8014598:	f7fd fd29 	bl	8011fee <USBD_Init>
 801459c:	1e03      	subs	r3, r0, #0
 801459e:	d001      	beq.n	80145a4 <MX_USB_DEVICE_Init+0x18>
  {
    Error_Handler();
 80145a0:	f7f6 f9dc 	bl	800a95c <Error_Handler>
  }
  if (USBD_RegisterClass(&hUsbDeviceFS, &USBD_CDC) != USBD_OK)
 80145a4:	4a11      	ldr	r2, [pc, #68]	; (80145ec <MX_USB_DEVICE_Init+0x60>)
 80145a6:	4b10      	ldr	r3, [pc, #64]	; (80145e8 <MX_USB_DEVICE_Init+0x5c>)
 80145a8:	0011      	movs	r1, r2
 80145aa:	0018      	movs	r0, r3
 80145ac:	f7fd fd50 	bl	8012050 <USBD_RegisterClass>
 80145b0:	1e03      	subs	r3, r0, #0
 80145b2:	d001      	beq.n	80145b8 <MX_USB_DEVICE_Init+0x2c>
  {
    Error_Handler();
 80145b4:	f7f6 f9d2 	bl	800a95c <Error_Handler>
  }
  if (USBD_CDC_RegisterInterface(&hUsbDeviceFS, &USBD_Interface_fops_FS) != USBD_OK)
 80145b8:	4a0d      	ldr	r2, [pc, #52]	; (80145f0 <MX_USB_DEVICE_Init+0x64>)
 80145ba:	4b0b      	ldr	r3, [pc, #44]	; (80145e8 <MX_USB_DEVICE_Init+0x5c>)
 80145bc:	0011      	movs	r1, r2
 80145be:	0018      	movs	r0, r3
 80145c0:	f7fd fc9c 	bl	8011efc <USBD_CDC_RegisterInterface>
 80145c4:	1e03      	subs	r3, r0, #0
 80145c6:	d001      	beq.n	80145cc <MX_USB_DEVICE_Init+0x40>
  {
    Error_Handler();
 80145c8:	f7f6 f9c8 	bl	800a95c <Error_Handler>
  }
  if (USBD_Start(&hUsbDeviceFS) != USBD_OK)
 80145cc:	4b06      	ldr	r3, [pc, #24]	; (80145e8 <MX_USB_DEVICE_Init+0x5c>)
 80145ce:	0018      	movs	r0, r3
 80145d0:	f7fd fd5e 	bl	8012090 <USBD_Start>
 80145d4:	1e03      	subs	r3, r0, #0
 80145d6:	d001      	beq.n	80145dc <MX_USB_DEVICE_Init+0x50>
  {
    Error_Handler();
 80145d8:	f7f6 f9c0 	bl	800a95c <Error_Handler>
  }

  /* USER CODE BEGIN USB_DEVICE_Init_PostTreatment */

  /* USER CODE END USB_DEVICE_Init_PostTreatment */
}
 80145dc:	46c0      	nop			; (mov r8, r8)
 80145de:	46bd      	mov	sp, r7
 80145e0:	bd80      	pop	{r7, pc}
 80145e2:	46c0      	nop			; (mov r8, r8)
 80145e4:	2000028c 	.word	0x2000028c
 80145e8:	200027e4 	.word	0x200027e4
 80145ec:	20000174 	.word	0x20000174
 80145f0:	2000027c 	.word	0x2000027c

080145f4 <CDC_Init_FS>:
/**
  * @brief  Initializes the CDC media low layer over the FS USB IP
  * @retval USBD_OK if all operations are OK else USBD_FAIL
  */
static int8_t CDC_Init_FS(void)
{
 80145f4:	b580      	push	{r7, lr}
 80145f6:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN 3 */
  /* Set Application Buffers */
  USBD_CDC_SetTxBuffer(&hUsbDeviceFS, UserTxBufferFS, 0);
 80145f8:	4907      	ldr	r1, [pc, #28]	; (8014618 <CDC_Init_FS+0x24>)
 80145fa:	4b08      	ldr	r3, [pc, #32]	; (801461c <CDC_Init_FS+0x28>)
 80145fc:	2200      	movs	r2, #0
 80145fe:	0018      	movs	r0, r3
 8014600:	f7fd fc97 	bl	8011f32 <USBD_CDC_SetTxBuffer>
  USBD_CDC_SetRxBuffer(&hUsbDeviceFS, UserRxBufferFS);
 8014604:	4a06      	ldr	r2, [pc, #24]	; (8014620 <CDC_Init_FS+0x2c>)
 8014606:	4b05      	ldr	r3, [pc, #20]	; (801461c <CDC_Init_FS+0x28>)
 8014608:	0011      	movs	r1, r2
 801460a:	0018      	movs	r0, r3
 801460c:	f7fd fcad 	bl	8011f6a <USBD_CDC_SetRxBuffer>
  return (USBD_OK);
 8014610:	2300      	movs	r3, #0
  /* USER CODE END 3 */
}
 8014612:	0018      	movs	r0, r3
 8014614:	46bd      	mov	sp, r7
 8014616:	bd80      	pop	{r7, pc}
 8014618:	20002e90 	.word	0x20002e90
 801461c:	200027e4 	.word	0x200027e4
 8014620:	20002aa8 	.word	0x20002aa8

08014624 <CDC_DeInit_FS>:
/**
  * @brief  DeInitializes the CDC media low layer
  * @retval USBD_OK if all operations are OK else USBD_FAIL
  */
static int8_t CDC_DeInit_FS(void)
{
 8014624:	b580      	push	{r7, lr}
 8014626:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN 4 */
  return (USBD_OK);
 8014628:	2300      	movs	r3, #0
  /* USER CODE END 4 */
}
 801462a:	0018      	movs	r0, r3
 801462c:	46bd      	mov	sp, r7
 801462e:	bd80      	pop	{r7, pc}

08014630 <CDC_Control_FS>:
  * @param  pbuf: Buffer containing command data (request parameters)
  * @param  length: Number of data to be sent (in bytes)
  * @retval Result of the operation: USBD_OK if all operations are OK else USBD_FAIL
  */
static int8_t CDC_Control_FS(uint8_t cmd, uint8_t* pbuf, uint16_t length)
{
 8014630:	b580      	push	{r7, lr}
 8014632:	b082      	sub	sp, #8
 8014634:	af00      	add	r7, sp, #0
 8014636:	6039      	str	r1, [r7, #0]
 8014638:	0011      	movs	r1, r2
 801463a:	1dfb      	adds	r3, r7, #7
 801463c:	1c02      	adds	r2, r0, #0
 801463e:	701a      	strb	r2, [r3, #0]
 8014640:	1d3b      	adds	r3, r7, #4
 8014642:	1c0a      	adds	r2, r1, #0
 8014644:	801a      	strh	r2, [r3, #0]
  /* USER CODE BEGIN 5 */
  switch(cmd)
 8014646:	1dfb      	adds	r3, r7, #7
 8014648:	781b      	ldrb	r3, [r3, #0]
 801464a:	2b23      	cmp	r3, #35	; 0x23
 801464c:	d804      	bhi.n	8014658 <CDC_Control_FS+0x28>
 801464e:	009a      	lsls	r2, r3, #2
 8014650:	4b04      	ldr	r3, [pc, #16]	; (8014664 <CDC_Control_FS+0x34>)
 8014652:	18d3      	adds	r3, r2, r3
 8014654:	681b      	ldr	r3, [r3, #0]
 8014656:	469f      	mov	pc, r3
    case CDC_SEND_BREAK:

    break;

  default:
    break;
 8014658:	46c0      	nop			; (mov r8, r8)
  }

  return (USBD_OK);
 801465a:	2300      	movs	r3, #0
  /* USER CODE END 5 */
}
 801465c:	0018      	movs	r0, r3
 801465e:	46bd      	mov	sp, r7
 8014660:	b002      	add	sp, #8
 8014662:	bd80      	pop	{r7, pc}
 8014664:	08015db4 	.word	0x08015db4

08014668 <CDC_Receive_FS>:
  * @param  Buf: Buffer of data to be received
  * @param  Len: Number of data received (in bytes)
  * @retval Result of the operation: USBD_OK if all operations are OK else USBD_FAIL
  */
static int8_t CDC_Receive_FS(uint8_t* Buf, uint32_t *Len)
{
 8014668:	b580      	push	{r7, lr}
 801466a:	b082      	sub	sp, #8
 801466c:	af00      	add	r7, sp, #0
 801466e:	6078      	str	r0, [r7, #4]
 8014670:	6039      	str	r1, [r7, #0]
  /* USER CODE BEGIN 6 */
  USBD_CDC_SetRxBuffer(&hUsbDeviceFS, &Buf[0]);
 8014672:	687a      	ldr	r2, [r7, #4]
 8014674:	4b06      	ldr	r3, [pc, #24]	; (8014690 <CDC_Receive_FS+0x28>)
 8014676:	0011      	movs	r1, r2
 8014678:	0018      	movs	r0, r3
 801467a:	f7fd fc76 	bl	8011f6a <USBD_CDC_SetRxBuffer>
  USBD_CDC_ReceivePacket(&hUsbDeviceFS);
 801467e:	4b04      	ldr	r3, [pc, #16]	; (8014690 <CDC_Receive_FS+0x28>)
 8014680:	0018      	movs	r0, r3
 8014682:	f7fd fc86 	bl	8011f92 <USBD_CDC_ReceivePacket>
  return (USBD_OK);
 8014686:	2300      	movs	r3, #0
  /* USER CODE END 6 */
}
 8014688:	0018      	movs	r0, r3
 801468a:	46bd      	mov	sp, r7
 801468c:	b002      	add	sp, #8
 801468e:	bd80      	pop	{r7, pc}
 8014690:	200027e4 	.word	0x200027e4

08014694 <USBD_FS_DeviceDescriptor>:
  * @param  speed : Current device speed
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_DeviceDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 8014694:	b580      	push	{r7, lr}
 8014696:	b082      	sub	sp, #8
 8014698:	af00      	add	r7, sp, #0
 801469a:	0002      	movs	r2, r0
 801469c:	6039      	str	r1, [r7, #0]
 801469e:	1dfb      	adds	r3, r7, #7
 80146a0:	701a      	strb	r2, [r3, #0]
  UNUSED(speed);
  *length = sizeof(USBD_FS_DeviceDesc);
 80146a2:	683b      	ldr	r3, [r7, #0]
 80146a4:	2212      	movs	r2, #18
 80146a6:	801a      	strh	r2, [r3, #0]
  return USBD_FS_DeviceDesc;
 80146a8:	4b02      	ldr	r3, [pc, #8]	; (80146b4 <USBD_FS_DeviceDescriptor+0x20>)
}
 80146aa:	0018      	movs	r0, r3
 80146ac:	46bd      	mov	sp, r7
 80146ae:	b002      	add	sp, #8
 80146b0:	bd80      	pop	{r7, pc}
 80146b2:	46c0      	nop			; (mov r8, r8)
 80146b4:	200002a8 	.word	0x200002a8

080146b8 <USBD_FS_LangIDStrDescriptor>:
  * @param  speed : Current device speed
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_LangIDStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 80146b8:	b580      	push	{r7, lr}
 80146ba:	b082      	sub	sp, #8
 80146bc:	af00      	add	r7, sp, #0
 80146be:	0002      	movs	r2, r0
 80146c0:	6039      	str	r1, [r7, #0]
 80146c2:	1dfb      	adds	r3, r7, #7
 80146c4:	701a      	strb	r2, [r3, #0]
  UNUSED(speed);
  *length = sizeof(USBD_LangIDDesc);
 80146c6:	683b      	ldr	r3, [r7, #0]
 80146c8:	2204      	movs	r2, #4
 80146ca:	801a      	strh	r2, [r3, #0]
  return USBD_LangIDDesc;
 80146cc:	4b02      	ldr	r3, [pc, #8]	; (80146d8 <USBD_FS_LangIDStrDescriptor+0x20>)
}
 80146ce:	0018      	movs	r0, r3
 80146d0:	46bd      	mov	sp, r7
 80146d2:	b002      	add	sp, #8
 80146d4:	bd80      	pop	{r7, pc}
 80146d6:	46c0      	nop			; (mov r8, r8)
 80146d8:	200002bc 	.word	0x200002bc

080146dc <USBD_FS_ProductStrDescriptor>:
  * @param  speed : Current device speed
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_ProductStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 80146dc:	b580      	push	{r7, lr}
 80146de:	b082      	sub	sp, #8
 80146e0:	af00      	add	r7, sp, #0
 80146e2:	0002      	movs	r2, r0
 80146e4:	6039      	str	r1, [r7, #0]
 80146e6:	1dfb      	adds	r3, r7, #7
 80146e8:	701a      	strb	r2, [r3, #0]
  if(speed == 0)
 80146ea:	1dfb      	adds	r3, r7, #7
 80146ec:	781b      	ldrb	r3, [r3, #0]
 80146ee:	2b00      	cmp	r3, #0
 80146f0:	d106      	bne.n	8014700 <USBD_FS_ProductStrDescriptor+0x24>
  {
    USBD_GetString((uint8_t *)USBD_PRODUCT_STRING_FS, USBD_StrDesc, length);
 80146f2:	683a      	ldr	r2, [r7, #0]
 80146f4:	4908      	ldr	r1, [pc, #32]	; (8014718 <USBD_FS_ProductStrDescriptor+0x3c>)
 80146f6:	4b09      	ldr	r3, [pc, #36]	; (801471c <USBD_FS_ProductStrDescriptor+0x40>)
 80146f8:	0018      	movs	r0, r3
 80146fa:	f7fe fd8a 	bl	8013212 <USBD_GetString>
 80146fe:	e005      	b.n	801470c <USBD_FS_ProductStrDescriptor+0x30>
  }
  else
  {
    USBD_GetString((uint8_t *)USBD_PRODUCT_STRING_FS, USBD_StrDesc, length);
 8014700:	683a      	ldr	r2, [r7, #0]
 8014702:	4905      	ldr	r1, [pc, #20]	; (8014718 <USBD_FS_ProductStrDescriptor+0x3c>)
 8014704:	4b05      	ldr	r3, [pc, #20]	; (801471c <USBD_FS_ProductStrDescriptor+0x40>)
 8014706:	0018      	movs	r0, r3
 8014708:	f7fe fd83 	bl	8013212 <USBD_GetString>
  }
  return USBD_StrDesc;
 801470c:	4b02      	ldr	r3, [pc, #8]	; (8014718 <USBD_FS_ProductStrDescriptor+0x3c>)
}
 801470e:	0018      	movs	r0, r3
 8014710:	46bd      	mov	sp, r7
 8014712:	b002      	add	sp, #8
 8014714:	bd80      	pop	{r7, pc}
 8014716:	46c0      	nop			; (mov r8, r8)
 8014718:	20003278 	.word	0x20003278
 801471c:	08015cac 	.word	0x08015cac

08014720 <USBD_FS_ManufacturerStrDescriptor>:
  * @param  speed : Current device speed
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_ManufacturerStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 8014720:	b580      	push	{r7, lr}
 8014722:	b082      	sub	sp, #8
 8014724:	af00      	add	r7, sp, #0
 8014726:	0002      	movs	r2, r0
 8014728:	6039      	str	r1, [r7, #0]
 801472a:	1dfb      	adds	r3, r7, #7
 801472c:	701a      	strb	r2, [r3, #0]
  UNUSED(speed);
  USBD_GetString((uint8_t *)USBD_MANUFACTURER_STRING, USBD_StrDesc, length);
 801472e:	683a      	ldr	r2, [r7, #0]
 8014730:	4904      	ldr	r1, [pc, #16]	; (8014744 <USBD_FS_ManufacturerStrDescriptor+0x24>)
 8014732:	4b05      	ldr	r3, [pc, #20]	; (8014748 <USBD_FS_ManufacturerStrDescriptor+0x28>)
 8014734:	0018      	movs	r0, r3
 8014736:	f7fe fd6c 	bl	8013212 <USBD_GetString>
  return USBD_StrDesc;
 801473a:	4b02      	ldr	r3, [pc, #8]	; (8014744 <USBD_FS_ManufacturerStrDescriptor+0x24>)
}
 801473c:	0018      	movs	r0, r3
 801473e:	46bd      	mov	sp, r7
 8014740:	b002      	add	sp, #8
 8014742:	bd80      	pop	{r7, pc}
 8014744:	20003278 	.word	0x20003278
 8014748:	08015cc4 	.word	0x08015cc4

0801474c <USBD_FS_SerialStrDescriptor>:
  * @param  speed : Current device speed
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_SerialStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 801474c:	b580      	push	{r7, lr}
 801474e:	b082      	sub	sp, #8
 8014750:	af00      	add	r7, sp, #0
 8014752:	0002      	movs	r2, r0
 8014754:	6039      	str	r1, [r7, #0]
 8014756:	1dfb      	adds	r3, r7, #7
 8014758:	701a      	strb	r2, [r3, #0]
  UNUSED(speed);
  *length = USB_SIZ_STRING_SERIAL;
 801475a:	683b      	ldr	r3, [r7, #0]
 801475c:	221a      	movs	r2, #26
 801475e:	801a      	strh	r2, [r3, #0]

  /* Update the serial number string descriptor with the data from the unique
   * ID */
  Get_SerialNum();
 8014760:	f000 f84c 	bl	80147fc <Get_SerialNum>
  /* USER CODE BEGIN USBD_FS_SerialStrDescriptor */

  /* USER CODE END USBD_FS_SerialStrDescriptor */
  return (uint8_t *) USBD_StringSerial;
 8014764:	4b02      	ldr	r3, [pc, #8]	; (8014770 <USBD_FS_SerialStrDescriptor+0x24>)
}
 8014766:	0018      	movs	r0, r3
 8014768:	46bd      	mov	sp, r7
 801476a:	b002      	add	sp, #8
 801476c:	bd80      	pop	{r7, pc}
 801476e:	46c0      	nop			; (mov r8, r8)
 8014770:	200002c0 	.word	0x200002c0

08014774 <USBD_FS_ConfigStrDescriptor>:
  * @param  speed : Current device speed
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_ConfigStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 8014774:	b580      	push	{r7, lr}
 8014776:	b082      	sub	sp, #8
 8014778:	af00      	add	r7, sp, #0
 801477a:	0002      	movs	r2, r0
 801477c:	6039      	str	r1, [r7, #0]
 801477e:	1dfb      	adds	r3, r7, #7
 8014780:	701a      	strb	r2, [r3, #0]
  if(speed == USBD_SPEED_HIGH)
 8014782:	1dfb      	adds	r3, r7, #7
 8014784:	781b      	ldrb	r3, [r3, #0]
 8014786:	2b00      	cmp	r3, #0
 8014788:	d106      	bne.n	8014798 <USBD_FS_ConfigStrDescriptor+0x24>
  {
    USBD_GetString((uint8_t *)USBD_CONFIGURATION_STRING_FS, USBD_StrDesc, length);
 801478a:	683a      	ldr	r2, [r7, #0]
 801478c:	4908      	ldr	r1, [pc, #32]	; (80147b0 <USBD_FS_ConfigStrDescriptor+0x3c>)
 801478e:	4b09      	ldr	r3, [pc, #36]	; (80147b4 <USBD_FS_ConfigStrDescriptor+0x40>)
 8014790:	0018      	movs	r0, r3
 8014792:	f7fe fd3e 	bl	8013212 <USBD_GetString>
 8014796:	e005      	b.n	80147a4 <USBD_FS_ConfigStrDescriptor+0x30>
  }
  else
  {
    USBD_GetString((uint8_t *)USBD_CONFIGURATION_STRING_FS, USBD_StrDesc, length);
 8014798:	683a      	ldr	r2, [r7, #0]
 801479a:	4905      	ldr	r1, [pc, #20]	; (80147b0 <USBD_FS_ConfigStrDescriptor+0x3c>)
 801479c:	4b05      	ldr	r3, [pc, #20]	; (80147b4 <USBD_FS_ConfigStrDescriptor+0x40>)
 801479e:	0018      	movs	r0, r3
 80147a0:	f7fe fd37 	bl	8013212 <USBD_GetString>
  }
  return USBD_StrDesc;
 80147a4:	4b02      	ldr	r3, [pc, #8]	; (80147b0 <USBD_FS_ConfigStrDescriptor+0x3c>)
}
 80147a6:	0018      	movs	r0, r3
 80147a8:	46bd      	mov	sp, r7
 80147aa:	b002      	add	sp, #8
 80147ac:	bd80      	pop	{r7, pc}
 80147ae:	46c0      	nop			; (mov r8, r8)
 80147b0:	20003278 	.word	0x20003278
 80147b4:	08015cd8 	.word	0x08015cd8

080147b8 <USBD_FS_InterfaceStrDescriptor>:
  * @param  speed : Current device speed
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_InterfaceStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 80147b8:	b580      	push	{r7, lr}
 80147ba:	b082      	sub	sp, #8
 80147bc:	af00      	add	r7, sp, #0
 80147be:	0002      	movs	r2, r0
 80147c0:	6039      	str	r1, [r7, #0]
 80147c2:	1dfb      	adds	r3, r7, #7
 80147c4:	701a      	strb	r2, [r3, #0]
  if(speed == 0)
 80147c6:	1dfb      	adds	r3, r7, #7
 80147c8:	781b      	ldrb	r3, [r3, #0]
 80147ca:	2b00      	cmp	r3, #0
 80147cc:	d106      	bne.n	80147dc <USBD_FS_InterfaceStrDescriptor+0x24>
  {
    USBD_GetString((uint8_t *)USBD_INTERFACE_STRING_FS, USBD_StrDesc, length);
 80147ce:	683a      	ldr	r2, [r7, #0]
 80147d0:	4908      	ldr	r1, [pc, #32]	; (80147f4 <USBD_FS_InterfaceStrDescriptor+0x3c>)
 80147d2:	4b09      	ldr	r3, [pc, #36]	; (80147f8 <USBD_FS_InterfaceStrDescriptor+0x40>)
 80147d4:	0018      	movs	r0, r3
 80147d6:	f7fe fd1c 	bl	8013212 <USBD_GetString>
 80147da:	e005      	b.n	80147e8 <USBD_FS_InterfaceStrDescriptor+0x30>
  }
  else
  {
    USBD_GetString((uint8_t *)USBD_INTERFACE_STRING_FS, USBD_StrDesc, length);
 80147dc:	683a      	ldr	r2, [r7, #0]
 80147de:	4905      	ldr	r1, [pc, #20]	; (80147f4 <USBD_FS_InterfaceStrDescriptor+0x3c>)
 80147e0:	4b05      	ldr	r3, [pc, #20]	; (80147f8 <USBD_FS_InterfaceStrDescriptor+0x40>)
 80147e2:	0018      	movs	r0, r3
 80147e4:	f7fe fd15 	bl	8013212 <USBD_GetString>
  }
  return USBD_StrDesc;
 80147e8:	4b02      	ldr	r3, [pc, #8]	; (80147f4 <USBD_FS_InterfaceStrDescriptor+0x3c>)
}
 80147ea:	0018      	movs	r0, r3
 80147ec:	46bd      	mov	sp, r7
 80147ee:	b002      	add	sp, #8
 80147f0:	bd80      	pop	{r7, pc}
 80147f2:	46c0      	nop			; (mov r8, r8)
 80147f4:	20003278 	.word	0x20003278
 80147f8:	08015ce4 	.word	0x08015ce4

080147fc <Get_SerialNum>:
  * @brief  Create the serial number string descriptor
  * @param  None
  * @retval None
  */
static void Get_SerialNum(void)
{
 80147fc:	b580      	push	{r7, lr}
 80147fe:	b084      	sub	sp, #16
 8014800:	af00      	add	r7, sp, #0
  uint32_t deviceserial0, deviceserial1, deviceserial2;

  deviceserial0 = *(uint32_t *) DEVICE_ID1;
 8014802:	4b10      	ldr	r3, [pc, #64]	; (8014844 <Get_SerialNum+0x48>)
 8014804:	681b      	ldr	r3, [r3, #0]
 8014806:	60fb      	str	r3, [r7, #12]
  deviceserial1 = *(uint32_t *) DEVICE_ID2;
 8014808:	4b0f      	ldr	r3, [pc, #60]	; (8014848 <Get_SerialNum+0x4c>)
 801480a:	681b      	ldr	r3, [r3, #0]
 801480c:	60bb      	str	r3, [r7, #8]
  deviceserial2 = *(uint32_t *) DEVICE_ID3;
 801480e:	4b0f      	ldr	r3, [pc, #60]	; (801484c <Get_SerialNum+0x50>)
 8014810:	681b      	ldr	r3, [r3, #0]
 8014812:	607b      	str	r3, [r7, #4]

  deviceserial0 += deviceserial2;
 8014814:	68fa      	ldr	r2, [r7, #12]
 8014816:	687b      	ldr	r3, [r7, #4]
 8014818:	18d3      	adds	r3, r2, r3
 801481a:	60fb      	str	r3, [r7, #12]

  if (deviceserial0 != 0)
 801481c:	68fb      	ldr	r3, [r7, #12]
 801481e:	2b00      	cmp	r3, #0
 8014820:	d00b      	beq.n	801483a <Get_SerialNum+0x3e>
  {
    IntToUnicode(deviceserial0, &USBD_StringSerial[2], 8);
 8014822:	490b      	ldr	r1, [pc, #44]	; (8014850 <Get_SerialNum+0x54>)
 8014824:	68fb      	ldr	r3, [r7, #12]
 8014826:	2208      	movs	r2, #8
 8014828:	0018      	movs	r0, r3
 801482a:	f000 f815 	bl	8014858 <IntToUnicode>
    IntToUnicode(deviceserial1, &USBD_StringSerial[18], 4);
 801482e:	4909      	ldr	r1, [pc, #36]	; (8014854 <Get_SerialNum+0x58>)
 8014830:	68bb      	ldr	r3, [r7, #8]
 8014832:	2204      	movs	r2, #4
 8014834:	0018      	movs	r0, r3
 8014836:	f000 f80f 	bl	8014858 <IntToUnicode>
  }
}
 801483a:	46c0      	nop			; (mov r8, r8)
 801483c:	46bd      	mov	sp, r7
 801483e:	b004      	add	sp, #16
 8014840:	bd80      	pop	{r7, pc}
 8014842:	46c0      	nop			; (mov r8, r8)
 8014844:	1ffff7ac 	.word	0x1ffff7ac
 8014848:	1ffff7b0 	.word	0x1ffff7b0
 801484c:	1ffff7b4 	.word	0x1ffff7b4
 8014850:	200002c2 	.word	0x200002c2
 8014854:	200002d2 	.word	0x200002d2

08014858 <IntToUnicode>:
  * @param  pbuf: pointer to the buffer
  * @param  len: buffer length
  * @retval None
  */
static void IntToUnicode(uint32_t value, uint8_t * pbuf, uint8_t len)
{
 8014858:	b580      	push	{r7, lr}
 801485a:	b086      	sub	sp, #24
 801485c:	af00      	add	r7, sp, #0
 801485e:	60f8      	str	r0, [r7, #12]
 8014860:	60b9      	str	r1, [r7, #8]
 8014862:	1dfb      	adds	r3, r7, #7
 8014864:	701a      	strb	r2, [r3, #0]
  uint8_t idx = 0;
 8014866:	2117      	movs	r1, #23
 8014868:	187b      	adds	r3, r7, r1
 801486a:	2200      	movs	r2, #0
 801486c:	701a      	strb	r2, [r3, #0]

  for (idx = 0; idx < len; idx++)
 801486e:	187b      	adds	r3, r7, r1
 8014870:	2200      	movs	r2, #0
 8014872:	701a      	strb	r2, [r3, #0]
 8014874:	e02f      	b.n	80148d6 <IntToUnicode+0x7e>
  {
    if (((value >> 28)) < 0xA)
 8014876:	68fb      	ldr	r3, [r7, #12]
 8014878:	0f1b      	lsrs	r3, r3, #28
 801487a:	2b09      	cmp	r3, #9
 801487c:	d80d      	bhi.n	801489a <IntToUnicode+0x42>
    {
      pbuf[2 * idx] = (value >> 28) + '0';
 801487e:	68fb      	ldr	r3, [r7, #12]
 8014880:	0f1b      	lsrs	r3, r3, #28
 8014882:	b2da      	uxtb	r2, r3
 8014884:	2317      	movs	r3, #23
 8014886:	18fb      	adds	r3, r7, r3
 8014888:	781b      	ldrb	r3, [r3, #0]
 801488a:	005b      	lsls	r3, r3, #1
 801488c:	0019      	movs	r1, r3
 801488e:	68bb      	ldr	r3, [r7, #8]
 8014890:	185b      	adds	r3, r3, r1
 8014892:	3230      	adds	r2, #48	; 0x30
 8014894:	b2d2      	uxtb	r2, r2
 8014896:	701a      	strb	r2, [r3, #0]
 8014898:	e00c      	b.n	80148b4 <IntToUnicode+0x5c>
    }
    else
    {
      pbuf[2 * idx] = (value >> 28) + 'A' - 10;
 801489a:	68fb      	ldr	r3, [r7, #12]
 801489c:	0f1b      	lsrs	r3, r3, #28
 801489e:	b2da      	uxtb	r2, r3
 80148a0:	2317      	movs	r3, #23
 80148a2:	18fb      	adds	r3, r7, r3
 80148a4:	781b      	ldrb	r3, [r3, #0]
 80148a6:	005b      	lsls	r3, r3, #1
 80148a8:	0019      	movs	r1, r3
 80148aa:	68bb      	ldr	r3, [r7, #8]
 80148ac:	185b      	adds	r3, r3, r1
 80148ae:	3237      	adds	r2, #55	; 0x37
 80148b0:	b2d2      	uxtb	r2, r2
 80148b2:	701a      	strb	r2, [r3, #0]
    }

    value = value << 4;
 80148b4:	68fb      	ldr	r3, [r7, #12]
 80148b6:	011b      	lsls	r3, r3, #4
 80148b8:	60fb      	str	r3, [r7, #12]

    pbuf[2 * idx + 1] = 0;
 80148ba:	2117      	movs	r1, #23
 80148bc:	187b      	adds	r3, r7, r1
 80148be:	781b      	ldrb	r3, [r3, #0]
 80148c0:	005b      	lsls	r3, r3, #1
 80148c2:	3301      	adds	r3, #1
 80148c4:	68ba      	ldr	r2, [r7, #8]
 80148c6:	18d3      	adds	r3, r2, r3
 80148c8:	2200      	movs	r2, #0
 80148ca:	701a      	strb	r2, [r3, #0]
  for (idx = 0; idx < len; idx++)
 80148cc:	187b      	adds	r3, r7, r1
 80148ce:	781a      	ldrb	r2, [r3, #0]
 80148d0:	187b      	adds	r3, r7, r1
 80148d2:	3201      	adds	r2, #1
 80148d4:	701a      	strb	r2, [r3, #0]
 80148d6:	2317      	movs	r3, #23
 80148d8:	18fa      	adds	r2, r7, r3
 80148da:	1dfb      	adds	r3, r7, #7
 80148dc:	7812      	ldrb	r2, [r2, #0]
 80148de:	781b      	ldrb	r3, [r3, #0]
 80148e0:	429a      	cmp	r2, r3
 80148e2:	d3c8      	bcc.n	8014876 <IntToUnicode+0x1e>
  }
}
 80148e4:	46c0      	nop			; (mov r8, r8)
 80148e6:	46c0      	nop			; (mov r8, r8)
 80148e8:	46bd      	mov	sp, r7
 80148ea:	b006      	add	sp, #24
 80148ec:	bd80      	pop	{r7, pc}
	...

080148f0 <HAL_PCD_MspInit>:
                       LL Driver Callbacks (PCD -> USB Device Library)
*******************************************************************************/
/* MSP Init */

void HAL_PCD_MspInit(PCD_HandleTypeDef* pcdHandle)
{
 80148f0:	b580      	push	{r7, lr}
 80148f2:	b084      	sub	sp, #16
 80148f4:	af00      	add	r7, sp, #0
 80148f6:	6078      	str	r0, [r7, #4]
  if(pcdHandle->Instance==USB)
 80148f8:	687b      	ldr	r3, [r7, #4]
 80148fa:	681b      	ldr	r3, [r3, #0]
 80148fc:	4a0e      	ldr	r2, [pc, #56]	; (8014938 <HAL_PCD_MspInit+0x48>)
 80148fe:	4293      	cmp	r3, r2
 8014900:	d115      	bne.n	801492e <HAL_PCD_MspInit+0x3e>
  {
  /* USER CODE BEGIN USB_MspInit 0 */

  /* USER CODE END USB_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_USB_CLK_ENABLE();
 8014902:	4b0e      	ldr	r3, [pc, #56]	; (801493c <HAL_PCD_MspInit+0x4c>)
 8014904:	69da      	ldr	r2, [r3, #28]
 8014906:	4b0d      	ldr	r3, [pc, #52]	; (801493c <HAL_PCD_MspInit+0x4c>)
 8014908:	2180      	movs	r1, #128	; 0x80
 801490a:	0409      	lsls	r1, r1, #16
 801490c:	430a      	orrs	r2, r1
 801490e:	61da      	str	r2, [r3, #28]
 8014910:	4b0a      	ldr	r3, [pc, #40]	; (801493c <HAL_PCD_MspInit+0x4c>)
 8014912:	69da      	ldr	r2, [r3, #28]
 8014914:	2380      	movs	r3, #128	; 0x80
 8014916:	041b      	lsls	r3, r3, #16
 8014918:	4013      	ands	r3, r2
 801491a:	60fb      	str	r3, [r7, #12]
 801491c:	68fb      	ldr	r3, [r7, #12]

    /* Peripheral interrupt init */
    HAL_NVIC_SetPriority(USB_IRQn, 3, 0);
 801491e:	2200      	movs	r2, #0
 8014920:	2103      	movs	r1, #3
 8014922:	201f      	movs	r0, #31
 8014924:	f7f6 fd04 	bl	800b330 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(USB_IRQn);
 8014928:	201f      	movs	r0, #31
 801492a:	f7f6 fd16 	bl	800b35a <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN USB_MspInit 1 */

  /* USER CODE END USB_MspInit 1 */
  }
}
 801492e:	46c0      	nop			; (mov r8, r8)
 8014930:	46bd      	mov	sp, r7
 8014932:	b004      	add	sp, #16
 8014934:	bd80      	pop	{r7, pc}
 8014936:	46c0      	nop			; (mov r8, r8)
 8014938:	40005c00 	.word	0x40005c00
 801493c:	40021000 	.word	0x40021000

08014940 <HAL_PCD_SetupStageCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_SetupStageCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_SetupStageCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 8014940:	b580      	push	{r7, lr}
 8014942:	b082      	sub	sp, #8
 8014944:	af00      	add	r7, sp, #0
 8014946:	6078      	str	r0, [r7, #4]
  USBD_LL_SetupStage((USBD_HandleTypeDef*)hpcd->pData, (uint8_t *)hpcd->Setup);
 8014948:	687a      	ldr	r2, [r7, #4]
 801494a:	23bc      	movs	r3, #188	; 0xbc
 801494c:	009b      	lsls	r3, r3, #2
 801494e:	58d2      	ldr	r2, [r2, r3]
 8014950:	687b      	ldr	r3, [r7, #4]
 8014952:	21ac      	movs	r1, #172	; 0xac
 8014954:	0089      	lsls	r1, r1, #2
 8014956:	468c      	mov	ip, r1
 8014958:	4463      	add	r3, ip
 801495a:	0019      	movs	r1, r3
 801495c:	0010      	movs	r0, r2
 801495e:	f7fd fbeb 	bl	8012138 <USBD_LL_SetupStage>
}
 8014962:	46c0      	nop			; (mov r8, r8)
 8014964:	46bd      	mov	sp, r7
 8014966:	b002      	add	sp, #8
 8014968:	bd80      	pop	{r7, pc}

0801496a <HAL_PCD_DataOutStageCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_DataOutStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#else
void HAL_PCD_DataOutStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 801496a:	b590      	push	{r4, r7, lr}
 801496c:	b083      	sub	sp, #12
 801496e:	af00      	add	r7, sp, #0
 8014970:	6078      	str	r0, [r7, #4]
 8014972:	000a      	movs	r2, r1
 8014974:	1cfb      	adds	r3, r7, #3
 8014976:	701a      	strb	r2, [r3, #0]
  USBD_LL_DataOutStage((USBD_HandleTypeDef*)hpcd->pData, epnum, hpcd->OUT_ep[epnum].xfer_buff);
 8014978:	687a      	ldr	r2, [r7, #4]
 801497a:	23bc      	movs	r3, #188	; 0xbc
 801497c:	009b      	lsls	r3, r3, #2
 801497e:	58d4      	ldr	r4, [r2, r3]
 8014980:	1cfb      	adds	r3, r7, #3
 8014982:	781a      	ldrb	r2, [r3, #0]
 8014984:	6878      	ldr	r0, [r7, #4]
 8014986:	23be      	movs	r3, #190	; 0xbe
 8014988:	0059      	lsls	r1, r3, #1
 801498a:	0013      	movs	r3, r2
 801498c:	009b      	lsls	r3, r3, #2
 801498e:	189b      	adds	r3, r3, r2
 8014990:	00db      	lsls	r3, r3, #3
 8014992:	18c3      	adds	r3, r0, r3
 8014994:	185b      	adds	r3, r3, r1
 8014996:	681a      	ldr	r2, [r3, #0]
 8014998:	1cfb      	adds	r3, r7, #3
 801499a:	781b      	ldrb	r3, [r3, #0]
 801499c:	0019      	movs	r1, r3
 801499e:	0020      	movs	r0, r4
 80149a0:	f7fd fc28 	bl	80121f4 <USBD_LL_DataOutStage>
}
 80149a4:	46c0      	nop			; (mov r8, r8)
 80149a6:	46bd      	mov	sp, r7
 80149a8:	b003      	add	sp, #12
 80149aa:	bd90      	pop	{r4, r7, pc}

080149ac <HAL_PCD_DataInStageCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_DataInStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#else
void HAL_PCD_DataInStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 80149ac:	b580      	push	{r7, lr}
 80149ae:	b082      	sub	sp, #8
 80149b0:	af00      	add	r7, sp, #0
 80149b2:	6078      	str	r0, [r7, #4]
 80149b4:	000a      	movs	r2, r1
 80149b6:	1cfb      	adds	r3, r7, #3
 80149b8:	701a      	strb	r2, [r3, #0]
  USBD_LL_DataInStage((USBD_HandleTypeDef*)hpcd->pData, epnum, hpcd->IN_ep[epnum].xfer_buff);
 80149ba:	687a      	ldr	r2, [r7, #4]
 80149bc:	23bc      	movs	r3, #188	; 0xbc
 80149be:	009b      	lsls	r3, r3, #2
 80149c0:	58d0      	ldr	r0, [r2, r3]
 80149c2:	1cfb      	adds	r3, r7, #3
 80149c4:	781a      	ldrb	r2, [r3, #0]
 80149c6:	6879      	ldr	r1, [r7, #4]
 80149c8:	0013      	movs	r3, r2
 80149ca:	009b      	lsls	r3, r3, #2
 80149cc:	189b      	adds	r3, r3, r2
 80149ce:	00db      	lsls	r3, r3, #3
 80149d0:	18cb      	adds	r3, r1, r3
 80149d2:	333c      	adds	r3, #60	; 0x3c
 80149d4:	681a      	ldr	r2, [r3, #0]
 80149d6:	1cfb      	adds	r3, r7, #3
 80149d8:	781b      	ldrb	r3, [r3, #0]
 80149da:	0019      	movs	r1, r3
 80149dc:	f7fd fc8c 	bl	80122f8 <USBD_LL_DataInStage>
}
 80149e0:	46c0      	nop			; (mov r8, r8)
 80149e2:	46bd      	mov	sp, r7
 80149e4:	b002      	add	sp, #8
 80149e6:	bd80      	pop	{r7, pc}

080149e8 <HAL_PCD_SOFCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_SOFCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_SOFCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 80149e8:	b580      	push	{r7, lr}
 80149ea:	b082      	sub	sp, #8
 80149ec:	af00      	add	r7, sp, #0
 80149ee:	6078      	str	r0, [r7, #4]
  USBD_LL_SOF((USBD_HandleTypeDef*)hpcd->pData);
 80149f0:	687a      	ldr	r2, [r7, #4]
 80149f2:	23bc      	movs	r3, #188	; 0xbc
 80149f4:	009b      	lsls	r3, r3, #2
 80149f6:	58d3      	ldr	r3, [r2, r3]
 80149f8:	0018      	movs	r0, r3
 80149fa:	f7fd fdc3 	bl	8012584 <USBD_LL_SOF>
}
 80149fe:	46c0      	nop			; (mov r8, r8)
 8014a00:	46bd      	mov	sp, r7
 8014a02:	b002      	add	sp, #8
 8014a04:	bd80      	pop	{r7, pc}

08014a06 <HAL_PCD_ResetCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_ResetCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_ResetCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 8014a06:	b580      	push	{r7, lr}
 8014a08:	b084      	sub	sp, #16
 8014a0a:	af00      	add	r7, sp, #0
 8014a0c:	6078      	str	r0, [r7, #4]
  USBD_SpeedTypeDef speed = USBD_SPEED_FULL;
 8014a0e:	230f      	movs	r3, #15
 8014a10:	18fb      	adds	r3, r7, r3
 8014a12:	2201      	movs	r2, #1
 8014a14:	701a      	strb	r2, [r3, #0]

  if ( hpcd->Init.speed != PCD_SPEED_FULL)
 8014a16:	687b      	ldr	r3, [r7, #4]
 8014a18:	689b      	ldr	r3, [r3, #8]
 8014a1a:	2b02      	cmp	r3, #2
 8014a1c:	d001      	beq.n	8014a22 <HAL_PCD_ResetCallback+0x1c>
  {
    Error_Handler();
 8014a1e:	f7f5 ff9d 	bl	800a95c <Error_Handler>
  }
    /* Set Speed. */
  USBD_LL_SetSpeed((USBD_HandleTypeDef*)hpcd->pData, speed);
 8014a22:	687a      	ldr	r2, [r7, #4]
 8014a24:	23bc      	movs	r3, #188	; 0xbc
 8014a26:	009b      	lsls	r3, r3, #2
 8014a28:	58d2      	ldr	r2, [r2, r3]
 8014a2a:	230f      	movs	r3, #15
 8014a2c:	18fb      	adds	r3, r7, r3
 8014a2e:	781b      	ldrb	r3, [r3, #0]
 8014a30:	0019      	movs	r1, r3
 8014a32:	0010      	movs	r0, r2
 8014a34:	f7fd fd65 	bl	8012502 <USBD_LL_SetSpeed>

  /* Reset Device. */
  USBD_LL_Reset((USBD_HandleTypeDef*)hpcd->pData);
 8014a38:	687a      	ldr	r2, [r7, #4]
 8014a3a:	23bc      	movs	r3, #188	; 0xbc
 8014a3c:	009b      	lsls	r3, r3, #2
 8014a3e:	58d3      	ldr	r3, [r2, r3]
 8014a40:	0018      	movs	r0, r3
 8014a42:	f7fd fd16 	bl	8012472 <USBD_LL_Reset>
}
 8014a46:	46c0      	nop			; (mov r8, r8)
 8014a48:	46bd      	mov	sp, r7
 8014a4a:	b004      	add	sp, #16
 8014a4c:	bd80      	pop	{r7, pc}
	...

08014a50 <HAL_PCD_SuspendCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_SuspendCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_SuspendCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 8014a50:	b580      	push	{r7, lr}
 8014a52:	b082      	sub	sp, #8
 8014a54:	af00      	add	r7, sp, #0
 8014a56:	6078      	str	r0, [r7, #4]
  /* Inform USB library that core enters in suspend Mode. */
  USBD_LL_Suspend((USBD_HandleTypeDef*)hpcd->pData);
 8014a58:	687a      	ldr	r2, [r7, #4]
 8014a5a:	23bc      	movs	r3, #188	; 0xbc
 8014a5c:	009b      	lsls	r3, r3, #2
 8014a5e:	58d3      	ldr	r3, [r2, r3]
 8014a60:	0018      	movs	r0, r3
 8014a62:	f7fd fd5f 	bl	8012524 <USBD_LL_Suspend>
  /* Enter in STOP mode. */
  /* USER CODE BEGIN 2 */
  if (hpcd->Init.low_power_enable)
 8014a66:	687b      	ldr	r3, [r7, #4]
 8014a68:	699b      	ldr	r3, [r3, #24]
 8014a6a:	2b00      	cmp	r3, #0
 8014a6c:	d005      	beq.n	8014a7a <HAL_PCD_SuspendCallback+0x2a>
  {
    /* Set SLEEPDEEP bit and SleepOnExit of Cortex System Control Register. */
    SCB->SCR |= (uint32_t)((uint32_t)(SCB_SCR_SLEEPDEEP_Msk | SCB_SCR_SLEEPONEXIT_Msk));
 8014a6e:	4b05      	ldr	r3, [pc, #20]	; (8014a84 <HAL_PCD_SuspendCallback+0x34>)
 8014a70:	691a      	ldr	r2, [r3, #16]
 8014a72:	4b04      	ldr	r3, [pc, #16]	; (8014a84 <HAL_PCD_SuspendCallback+0x34>)
 8014a74:	2106      	movs	r1, #6
 8014a76:	430a      	orrs	r2, r1
 8014a78:	611a      	str	r2, [r3, #16]
  }
  /* USER CODE END 2 */
}
 8014a7a:	46c0      	nop			; (mov r8, r8)
 8014a7c:	46bd      	mov	sp, r7
 8014a7e:	b002      	add	sp, #8
 8014a80:	bd80      	pop	{r7, pc}
 8014a82:	46c0      	nop			; (mov r8, r8)
 8014a84:	e000ed00 	.word	0xe000ed00

08014a88 <HAL_PCD_ResumeCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_ResumeCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_ResumeCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 8014a88:	b580      	push	{r7, lr}
 8014a8a:	b082      	sub	sp, #8
 8014a8c:	af00      	add	r7, sp, #0
 8014a8e:	6078      	str	r0, [r7, #4]
  /* USER CODE BEGIN 3 */
  if (hpcd->Init.low_power_enable)
 8014a90:	687b      	ldr	r3, [r7, #4]
 8014a92:	699b      	ldr	r3, [r3, #24]
 8014a94:	2b00      	cmp	r3, #0
 8014a96:	d007      	beq.n	8014aa8 <HAL_PCD_ResumeCallback+0x20>
  {
    /* Reset SLEEPDEEP bit of Cortex System Control Register. */
    SCB->SCR &= (uint32_t)~((uint32_t)(SCB_SCR_SLEEPDEEP_Msk | SCB_SCR_SLEEPONEXIT_Msk));
 8014a98:	4b09      	ldr	r3, [pc, #36]	; (8014ac0 <HAL_PCD_ResumeCallback+0x38>)
 8014a9a:	691a      	ldr	r2, [r3, #16]
 8014a9c:	4b08      	ldr	r3, [pc, #32]	; (8014ac0 <HAL_PCD_ResumeCallback+0x38>)
 8014a9e:	2106      	movs	r1, #6
 8014aa0:	438a      	bics	r2, r1
 8014aa2:	611a      	str	r2, [r3, #16]
    SystemClockConfig_Resume();
 8014aa4:	f000 fa44 	bl	8014f30 <SystemClockConfig_Resume>
  }
  /* USER CODE END 3 */
  USBD_LL_Resume((USBD_HandleTypeDef*)hpcd->pData);
 8014aa8:	687a      	ldr	r2, [r7, #4]
 8014aaa:	23bc      	movs	r3, #188	; 0xbc
 8014aac:	009b      	lsls	r3, r3, #2
 8014aae:	58d3      	ldr	r3, [r2, r3]
 8014ab0:	0018      	movs	r0, r3
 8014ab2:	f7fd fd4f 	bl	8012554 <USBD_LL_Resume>
}
 8014ab6:	46c0      	nop			; (mov r8, r8)
 8014ab8:	46bd      	mov	sp, r7
 8014aba:	b002      	add	sp, #8
 8014abc:	bd80      	pop	{r7, pc}
 8014abe:	46c0      	nop			; (mov r8, r8)
 8014ac0:	e000ed00 	.word	0xe000ed00

08014ac4 <USBD_LL_Init>:
  * @brief  Initializes the low level portion of the device driver.
  * @param  pdev: Device handle
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_Init(USBD_HandleTypeDef *pdev)
{
 8014ac4:	b580      	push	{r7, lr}
 8014ac6:	b082      	sub	sp, #8
 8014ac8:	af00      	add	r7, sp, #0
 8014aca:	6078      	str	r0, [r7, #4]
  /* Init USB Ip. */
  /* Link the driver to the stack. */
  hpcd_USB_FS.pData = pdev;
 8014acc:	4a2d      	ldr	r2, [pc, #180]	; (8014b84 <USBD_LL_Init+0xc0>)
 8014ace:	23bc      	movs	r3, #188	; 0xbc
 8014ad0:	009b      	lsls	r3, r3, #2
 8014ad2:	6879      	ldr	r1, [r7, #4]
 8014ad4:	50d1      	str	r1, [r2, r3]
  pdev->pData = &hpcd_USB_FS;
 8014ad6:	687a      	ldr	r2, [r7, #4]
 8014ad8:	23b0      	movs	r3, #176	; 0xb0
 8014ada:	009b      	lsls	r3, r3, #2
 8014adc:	4929      	ldr	r1, [pc, #164]	; (8014b84 <USBD_LL_Init+0xc0>)
 8014ade:	50d1      	str	r1, [r2, r3]

  hpcd_USB_FS.Instance = USB;
 8014ae0:	4b28      	ldr	r3, [pc, #160]	; (8014b84 <USBD_LL_Init+0xc0>)
 8014ae2:	4a29      	ldr	r2, [pc, #164]	; (8014b88 <USBD_LL_Init+0xc4>)
 8014ae4:	601a      	str	r2, [r3, #0]
  hpcd_USB_FS.Init.dev_endpoints = 8;
 8014ae6:	4b27      	ldr	r3, [pc, #156]	; (8014b84 <USBD_LL_Init+0xc0>)
 8014ae8:	2208      	movs	r2, #8
 8014aea:	605a      	str	r2, [r3, #4]
  hpcd_USB_FS.Init.speed = PCD_SPEED_FULL;
 8014aec:	4b25      	ldr	r3, [pc, #148]	; (8014b84 <USBD_LL_Init+0xc0>)
 8014aee:	2202      	movs	r2, #2
 8014af0:	609a      	str	r2, [r3, #8]
  hpcd_USB_FS.Init.phy_itface = PCD_PHY_EMBEDDED;
 8014af2:	4b24      	ldr	r3, [pc, #144]	; (8014b84 <USBD_LL_Init+0xc0>)
 8014af4:	2202      	movs	r2, #2
 8014af6:	611a      	str	r2, [r3, #16]
  hpcd_USB_FS.Init.low_power_enable = DISABLE;
 8014af8:	4b22      	ldr	r3, [pc, #136]	; (8014b84 <USBD_LL_Init+0xc0>)
 8014afa:	2200      	movs	r2, #0
 8014afc:	619a      	str	r2, [r3, #24]
  hpcd_USB_FS.Init.lpm_enable = DISABLE;
 8014afe:	4b21      	ldr	r3, [pc, #132]	; (8014b84 <USBD_LL_Init+0xc0>)
 8014b00:	2200      	movs	r2, #0
 8014b02:	61da      	str	r2, [r3, #28]
  hpcd_USB_FS.Init.battery_charging_enable = DISABLE;
 8014b04:	4b1f      	ldr	r3, [pc, #124]	; (8014b84 <USBD_LL_Init+0xc0>)
 8014b06:	2200      	movs	r2, #0
 8014b08:	621a      	str	r2, [r3, #32]
  if (HAL_PCD_Init(&hpcd_USB_FS) != HAL_OK)
 8014b0a:	4b1e      	ldr	r3, [pc, #120]	; (8014b84 <USBD_LL_Init+0xc0>)
 8014b0c:	0018      	movs	r0, r3
 8014b0e:	f7f6 fe6f 	bl	800b7f0 <HAL_PCD_Init>
 8014b12:	1e03      	subs	r3, r0, #0
 8014b14:	d001      	beq.n	8014b1a <USBD_LL_Init+0x56>
  {
    Error_Handler( );
 8014b16:	f7f5 ff21 	bl	800a95c <Error_Handler>
  HAL_PCD_RegisterDataInStageCallback(&hpcd_USB_FS, PCD_DataInStageCallback);
  HAL_PCD_RegisterIsoOutIncpltCallback(&hpcd_USB_FS, PCD_ISOOUTIncompleteCallback);
  HAL_PCD_RegisterIsoInIncpltCallback(&hpcd_USB_FS, PCD_ISOINIncompleteCallback);
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
  /* USER CODE BEGIN EndPoint_Configuration */
  HAL_PCDEx_PMAConfig((PCD_HandleTypeDef*)pdev->pData , 0x00 , PCD_SNG_BUF, 0x18);
 8014b1a:	687a      	ldr	r2, [r7, #4]
 8014b1c:	23b0      	movs	r3, #176	; 0xb0
 8014b1e:	009b      	lsls	r3, r3, #2
 8014b20:	58d0      	ldr	r0, [r2, r3]
 8014b22:	2318      	movs	r3, #24
 8014b24:	2200      	movs	r2, #0
 8014b26:	2100      	movs	r1, #0
 8014b28:	f7f8 fc50 	bl	800d3cc <HAL_PCDEx_PMAConfig>
  HAL_PCDEx_PMAConfig((PCD_HandleTypeDef*)pdev->pData , 0x80 , PCD_SNG_BUF, 0x58);
 8014b2c:	687a      	ldr	r2, [r7, #4]
 8014b2e:	23b0      	movs	r3, #176	; 0xb0
 8014b30:	009b      	lsls	r3, r3, #2
 8014b32:	58d0      	ldr	r0, [r2, r3]
 8014b34:	2358      	movs	r3, #88	; 0x58
 8014b36:	2200      	movs	r2, #0
 8014b38:	2180      	movs	r1, #128	; 0x80
 8014b3a:	f7f8 fc47 	bl	800d3cc <HAL_PCDEx_PMAConfig>
  /* USER CODE END EndPoint_Configuration */
  /* USER CODE BEGIN EndPoint_Configuration_CDC */
  HAL_PCDEx_PMAConfig((PCD_HandleTypeDef*)pdev->pData , 0x81 , PCD_SNG_BUF, 0xC0);
 8014b3e:	687a      	ldr	r2, [r7, #4]
 8014b40:	23b0      	movs	r3, #176	; 0xb0
 8014b42:	009b      	lsls	r3, r3, #2
 8014b44:	58d0      	ldr	r0, [r2, r3]
 8014b46:	23c0      	movs	r3, #192	; 0xc0
 8014b48:	2200      	movs	r2, #0
 8014b4a:	2181      	movs	r1, #129	; 0x81
 8014b4c:	f7f8 fc3e 	bl	800d3cc <HAL_PCDEx_PMAConfig>
  HAL_PCDEx_PMAConfig((PCD_HandleTypeDef*)pdev->pData , 0x01 , PCD_SNG_BUF, 0x110);
 8014b50:	687a      	ldr	r2, [r7, #4]
 8014b52:	23b0      	movs	r3, #176	; 0xb0
 8014b54:	009b      	lsls	r3, r3, #2
 8014b56:	58d0      	ldr	r0, [r2, r3]
 8014b58:	2388      	movs	r3, #136	; 0x88
 8014b5a:	005b      	lsls	r3, r3, #1
 8014b5c:	2200      	movs	r2, #0
 8014b5e:	2101      	movs	r1, #1
 8014b60:	f7f8 fc34 	bl	800d3cc <HAL_PCDEx_PMAConfig>
  HAL_PCDEx_PMAConfig((PCD_HandleTypeDef*)pdev->pData , 0x82 , PCD_SNG_BUF, 0x100);
 8014b64:	687a      	ldr	r2, [r7, #4]
 8014b66:	23b0      	movs	r3, #176	; 0xb0
 8014b68:	009b      	lsls	r3, r3, #2
 8014b6a:	58d0      	ldr	r0, [r2, r3]
 8014b6c:	2380      	movs	r3, #128	; 0x80
 8014b6e:	005b      	lsls	r3, r3, #1
 8014b70:	2200      	movs	r2, #0
 8014b72:	2182      	movs	r1, #130	; 0x82
 8014b74:	f7f8 fc2a 	bl	800d3cc <HAL_PCDEx_PMAConfig>
  /* USER CODE END EndPoint_Configuration_CDC */
  return USBD_OK;
 8014b78:	2300      	movs	r3, #0
}
 8014b7a:	0018      	movs	r0, r3
 8014b7c:	46bd      	mov	sp, r7
 8014b7e:	b002      	add	sp, #8
 8014b80:	bd80      	pop	{r7, pc}
 8014b82:	46c0      	nop			; (mov r8, r8)
 8014b84:	20003478 	.word	0x20003478
 8014b88:	40005c00 	.word	0x40005c00

08014b8c <USBD_LL_Start>:
  * @brief  Starts the low level portion of the device driver.
  * @param  pdev: Device handle
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_Start(USBD_HandleTypeDef *pdev)
{
 8014b8c:	b5f0      	push	{r4, r5, r6, r7, lr}
 8014b8e:	b085      	sub	sp, #20
 8014b90:	af00      	add	r7, sp, #0
 8014b92:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef hal_status = HAL_OK;
 8014b94:	210f      	movs	r1, #15
 8014b96:	187b      	adds	r3, r7, r1
 8014b98:	2200      	movs	r2, #0
 8014b9a:	701a      	strb	r2, [r3, #0]
  USBD_StatusTypeDef usb_status = USBD_OK;
 8014b9c:	260e      	movs	r6, #14
 8014b9e:	19bb      	adds	r3, r7, r6
 8014ba0:	2200      	movs	r2, #0
 8014ba2:	701a      	strb	r2, [r3, #0]

  hal_status = HAL_PCD_Start(pdev->pData);
 8014ba4:	687a      	ldr	r2, [r7, #4]
 8014ba6:	23b0      	movs	r3, #176	; 0xb0
 8014ba8:	009b      	lsls	r3, r3, #2
 8014baa:	58d3      	ldr	r3, [r2, r3]
 8014bac:	000d      	movs	r5, r1
 8014bae:	187c      	adds	r4, r7, r1
 8014bb0:	0018      	movs	r0, r3
 8014bb2:	f7f6 ff2d 	bl	800ba10 <HAL_PCD_Start>
 8014bb6:	0003      	movs	r3, r0
 8014bb8:	7023      	strb	r3, [r4, #0]

  usb_status =  USBD_Get_USB_Status(hal_status);
 8014bba:	19bc      	adds	r4, r7, r6
 8014bbc:	197b      	adds	r3, r7, r5
 8014bbe:	781b      	ldrb	r3, [r3, #0]
 8014bc0:	0018      	movs	r0, r3
 8014bc2:	f000 f9bc 	bl	8014f3e <USBD_Get_USB_Status>
 8014bc6:	0003      	movs	r3, r0
 8014bc8:	7023      	strb	r3, [r4, #0]

  return usb_status;
 8014bca:	19bb      	adds	r3, r7, r6
 8014bcc:	781b      	ldrb	r3, [r3, #0]
}
 8014bce:	0018      	movs	r0, r3
 8014bd0:	46bd      	mov	sp, r7
 8014bd2:	b005      	add	sp, #20
 8014bd4:	bdf0      	pop	{r4, r5, r6, r7, pc}

08014bd6 <USBD_LL_OpenEP>:
  * @param  ep_type: Endpoint type
  * @param  ep_mps: Endpoint max packet size
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_OpenEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr, uint8_t ep_type, uint16_t ep_mps)
{
 8014bd6:	b5f0      	push	{r4, r5, r6, r7, lr}
 8014bd8:	b085      	sub	sp, #20
 8014bda:	af00      	add	r7, sp, #0
 8014bdc:	6078      	str	r0, [r7, #4]
 8014bde:	000c      	movs	r4, r1
 8014be0:	0010      	movs	r0, r2
 8014be2:	0019      	movs	r1, r3
 8014be4:	1cfb      	adds	r3, r7, #3
 8014be6:	1c22      	adds	r2, r4, #0
 8014be8:	701a      	strb	r2, [r3, #0]
 8014bea:	1cbb      	adds	r3, r7, #2
 8014bec:	1c02      	adds	r2, r0, #0
 8014bee:	701a      	strb	r2, [r3, #0]
 8014bf0:	003b      	movs	r3, r7
 8014bf2:	1c0a      	adds	r2, r1, #0
 8014bf4:	801a      	strh	r2, [r3, #0]
  HAL_StatusTypeDef hal_status = HAL_OK;
 8014bf6:	260f      	movs	r6, #15
 8014bf8:	19bb      	adds	r3, r7, r6
 8014bfa:	2200      	movs	r2, #0
 8014bfc:	701a      	strb	r2, [r3, #0]
  USBD_StatusTypeDef usb_status = USBD_OK;
 8014bfe:	250e      	movs	r5, #14
 8014c00:	197b      	adds	r3, r7, r5
 8014c02:	2200      	movs	r2, #0
 8014c04:	701a      	strb	r2, [r3, #0]

  hal_status = HAL_PCD_EP_Open(pdev->pData, ep_addr, ep_mps, ep_type);
 8014c06:	687a      	ldr	r2, [r7, #4]
 8014c08:	23b0      	movs	r3, #176	; 0xb0
 8014c0a:	009b      	lsls	r3, r3, #2
 8014c0c:	58d0      	ldr	r0, [r2, r3]
 8014c0e:	19bc      	adds	r4, r7, r6
 8014c10:	1cbb      	adds	r3, r7, #2
 8014c12:	781d      	ldrb	r5, [r3, #0]
 8014c14:	003b      	movs	r3, r7
 8014c16:	881a      	ldrh	r2, [r3, #0]
 8014c18:	1cfb      	adds	r3, r7, #3
 8014c1a:	7819      	ldrb	r1, [r3, #0]
 8014c1c:	002b      	movs	r3, r5
 8014c1e:	f7f7 f8c4 	bl	800bdaa <HAL_PCD_EP_Open>
 8014c22:	0003      	movs	r3, r0
 8014c24:	7023      	strb	r3, [r4, #0]

  usb_status =  USBD_Get_USB_Status(hal_status);
 8014c26:	250e      	movs	r5, #14
 8014c28:	197c      	adds	r4, r7, r5
 8014c2a:	19bb      	adds	r3, r7, r6
 8014c2c:	781b      	ldrb	r3, [r3, #0]
 8014c2e:	0018      	movs	r0, r3
 8014c30:	f000 f985 	bl	8014f3e <USBD_Get_USB_Status>
 8014c34:	0003      	movs	r3, r0
 8014c36:	7023      	strb	r3, [r4, #0]

  return usb_status;
 8014c38:	197b      	adds	r3, r7, r5
 8014c3a:	781b      	ldrb	r3, [r3, #0]
}
 8014c3c:	0018      	movs	r0, r3
 8014c3e:	46bd      	mov	sp, r7
 8014c40:	b005      	add	sp, #20
 8014c42:	bdf0      	pop	{r4, r5, r6, r7, pc}

08014c44 <USBD_LL_CloseEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint number
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_CloseEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
 8014c44:	b5f0      	push	{r4, r5, r6, r7, lr}
 8014c46:	b085      	sub	sp, #20
 8014c48:	af00      	add	r7, sp, #0
 8014c4a:	6078      	str	r0, [r7, #4]
 8014c4c:	000a      	movs	r2, r1
 8014c4e:	1cfb      	adds	r3, r7, #3
 8014c50:	701a      	strb	r2, [r3, #0]
  HAL_StatusTypeDef hal_status = HAL_OK;
 8014c52:	210f      	movs	r1, #15
 8014c54:	187b      	adds	r3, r7, r1
 8014c56:	2200      	movs	r2, #0
 8014c58:	701a      	strb	r2, [r3, #0]
  USBD_StatusTypeDef usb_status = USBD_OK;
 8014c5a:	260e      	movs	r6, #14
 8014c5c:	19bb      	adds	r3, r7, r6
 8014c5e:	2200      	movs	r2, #0
 8014c60:	701a      	strb	r2, [r3, #0]

  hal_status = HAL_PCD_EP_Close(pdev->pData, ep_addr);
 8014c62:	687a      	ldr	r2, [r7, #4]
 8014c64:	23b0      	movs	r3, #176	; 0xb0
 8014c66:	009b      	lsls	r3, r3, #2
 8014c68:	58d2      	ldr	r2, [r2, r3]
 8014c6a:	000d      	movs	r5, r1
 8014c6c:	187c      	adds	r4, r7, r1
 8014c6e:	1cfb      	adds	r3, r7, #3
 8014c70:	781b      	ldrb	r3, [r3, #0]
 8014c72:	0019      	movs	r1, r3
 8014c74:	0010      	movs	r0, r2
 8014c76:	f7f7 f910 	bl	800be9a <HAL_PCD_EP_Close>
 8014c7a:	0003      	movs	r3, r0
 8014c7c:	7023      	strb	r3, [r4, #0]

  usb_status =  USBD_Get_USB_Status(hal_status);
 8014c7e:	19bc      	adds	r4, r7, r6
 8014c80:	197b      	adds	r3, r7, r5
 8014c82:	781b      	ldrb	r3, [r3, #0]
 8014c84:	0018      	movs	r0, r3
 8014c86:	f000 f95a 	bl	8014f3e <USBD_Get_USB_Status>
 8014c8a:	0003      	movs	r3, r0
 8014c8c:	7023      	strb	r3, [r4, #0]

  return usb_status;
 8014c8e:	19bb      	adds	r3, r7, r6
 8014c90:	781b      	ldrb	r3, [r3, #0]
}
 8014c92:	0018      	movs	r0, r3
 8014c94:	46bd      	mov	sp, r7
 8014c96:	b005      	add	sp, #20
 8014c98:	bdf0      	pop	{r4, r5, r6, r7, pc}

08014c9a <USBD_LL_StallEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint number
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_StallEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
 8014c9a:	b5f0      	push	{r4, r5, r6, r7, lr}
 8014c9c:	b085      	sub	sp, #20
 8014c9e:	af00      	add	r7, sp, #0
 8014ca0:	6078      	str	r0, [r7, #4]
 8014ca2:	000a      	movs	r2, r1
 8014ca4:	1cfb      	adds	r3, r7, #3
 8014ca6:	701a      	strb	r2, [r3, #0]
  HAL_StatusTypeDef hal_status = HAL_OK;
 8014ca8:	210f      	movs	r1, #15
 8014caa:	187b      	adds	r3, r7, r1
 8014cac:	2200      	movs	r2, #0
 8014cae:	701a      	strb	r2, [r3, #0]
  USBD_StatusTypeDef usb_status = USBD_OK;
 8014cb0:	260e      	movs	r6, #14
 8014cb2:	19bb      	adds	r3, r7, r6
 8014cb4:	2200      	movs	r2, #0
 8014cb6:	701a      	strb	r2, [r3, #0]

  hal_status = HAL_PCD_EP_SetStall(pdev->pData, ep_addr);
 8014cb8:	687a      	ldr	r2, [r7, #4]
 8014cba:	23b0      	movs	r3, #176	; 0xb0
 8014cbc:	009b      	lsls	r3, r3, #2
 8014cbe:	58d2      	ldr	r2, [r2, r3]
 8014cc0:	000d      	movs	r5, r1
 8014cc2:	187c      	adds	r4, r7, r1
 8014cc4:	1cfb      	adds	r3, r7, #3
 8014cc6:	781b      	ldrb	r3, [r3, #0]
 8014cc8:	0019      	movs	r1, r3
 8014cca:	0010      	movs	r0, r2
 8014ccc:	f7f7 f9dc 	bl	800c088 <HAL_PCD_EP_SetStall>
 8014cd0:	0003      	movs	r3, r0
 8014cd2:	7023      	strb	r3, [r4, #0]

  usb_status =  USBD_Get_USB_Status(hal_status);
 8014cd4:	19bc      	adds	r4, r7, r6
 8014cd6:	197b      	adds	r3, r7, r5
 8014cd8:	781b      	ldrb	r3, [r3, #0]
 8014cda:	0018      	movs	r0, r3
 8014cdc:	f000 f92f 	bl	8014f3e <USBD_Get_USB_Status>
 8014ce0:	0003      	movs	r3, r0
 8014ce2:	7023      	strb	r3, [r4, #0]

  return usb_status;
 8014ce4:	19bb      	adds	r3, r7, r6
 8014ce6:	781b      	ldrb	r3, [r3, #0]
}
 8014ce8:	0018      	movs	r0, r3
 8014cea:	46bd      	mov	sp, r7
 8014cec:	b005      	add	sp, #20
 8014cee:	bdf0      	pop	{r4, r5, r6, r7, pc}

08014cf0 <USBD_LL_ClearStallEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint number
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_ClearStallEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
 8014cf0:	b5f0      	push	{r4, r5, r6, r7, lr}
 8014cf2:	b085      	sub	sp, #20
 8014cf4:	af00      	add	r7, sp, #0
 8014cf6:	6078      	str	r0, [r7, #4]
 8014cf8:	000a      	movs	r2, r1
 8014cfa:	1cfb      	adds	r3, r7, #3
 8014cfc:	701a      	strb	r2, [r3, #0]
  HAL_StatusTypeDef hal_status = HAL_OK;
 8014cfe:	210f      	movs	r1, #15
 8014d00:	187b      	adds	r3, r7, r1
 8014d02:	2200      	movs	r2, #0
 8014d04:	701a      	strb	r2, [r3, #0]
  USBD_StatusTypeDef usb_status = USBD_OK;
 8014d06:	260e      	movs	r6, #14
 8014d08:	19bb      	adds	r3, r7, r6
 8014d0a:	2200      	movs	r2, #0
 8014d0c:	701a      	strb	r2, [r3, #0]

  hal_status = HAL_PCD_EP_ClrStall(pdev->pData, ep_addr);
 8014d0e:	687a      	ldr	r2, [r7, #4]
 8014d10:	23b0      	movs	r3, #176	; 0xb0
 8014d12:	009b      	lsls	r3, r3, #2
 8014d14:	58d2      	ldr	r2, [r2, r3]
 8014d16:	000d      	movs	r5, r1
 8014d18:	187c      	adds	r4, r7, r1
 8014d1a:	1cfb      	adds	r3, r7, #3
 8014d1c:	781b      	ldrb	r3, [r3, #0]
 8014d1e:	0019      	movs	r1, r3
 8014d20:	0010      	movs	r0, r2
 8014d22:	f7f7 fa0d 	bl	800c140 <HAL_PCD_EP_ClrStall>
 8014d26:	0003      	movs	r3, r0
 8014d28:	7023      	strb	r3, [r4, #0]

  usb_status =  USBD_Get_USB_Status(hal_status);
 8014d2a:	19bc      	adds	r4, r7, r6
 8014d2c:	197b      	adds	r3, r7, r5
 8014d2e:	781b      	ldrb	r3, [r3, #0]
 8014d30:	0018      	movs	r0, r3
 8014d32:	f000 f904 	bl	8014f3e <USBD_Get_USB_Status>
 8014d36:	0003      	movs	r3, r0
 8014d38:	7023      	strb	r3, [r4, #0]

  return usb_status;
 8014d3a:	19bb      	adds	r3, r7, r6
 8014d3c:	781b      	ldrb	r3, [r3, #0]
}
 8014d3e:	0018      	movs	r0, r3
 8014d40:	46bd      	mov	sp, r7
 8014d42:	b005      	add	sp, #20
 8014d44:	bdf0      	pop	{r4, r5, r6, r7, pc}

08014d46 <USBD_LL_IsStallEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint number
  * @retval Stall (1: Yes, 0: No)
  */
uint8_t USBD_LL_IsStallEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
 8014d46:	b580      	push	{r7, lr}
 8014d48:	b084      	sub	sp, #16
 8014d4a:	af00      	add	r7, sp, #0
 8014d4c:	6078      	str	r0, [r7, #4]
 8014d4e:	000a      	movs	r2, r1
 8014d50:	1cfb      	adds	r3, r7, #3
 8014d52:	701a      	strb	r2, [r3, #0]
  PCD_HandleTypeDef *hpcd = (PCD_HandleTypeDef*) pdev->pData;
 8014d54:	687a      	ldr	r2, [r7, #4]
 8014d56:	23b0      	movs	r3, #176	; 0xb0
 8014d58:	009b      	lsls	r3, r3, #2
 8014d5a:	58d3      	ldr	r3, [r2, r3]
 8014d5c:	60fb      	str	r3, [r7, #12]

  if((ep_addr & 0x80) == 0x80)
 8014d5e:	1cfb      	adds	r3, r7, #3
 8014d60:	781b      	ldrb	r3, [r3, #0]
 8014d62:	b25b      	sxtb	r3, r3
 8014d64:	2b00      	cmp	r3, #0
 8014d66:	da0d      	bge.n	8014d84 <USBD_LL_IsStallEP+0x3e>
  {
    return hpcd->IN_ep[ep_addr & 0x7F].is_stall;
 8014d68:	1cfb      	adds	r3, r7, #3
 8014d6a:	781b      	ldrb	r3, [r3, #0]
 8014d6c:	227f      	movs	r2, #127	; 0x7f
 8014d6e:	4013      	ands	r3, r2
 8014d70:	68f9      	ldr	r1, [r7, #12]
 8014d72:	1c5a      	adds	r2, r3, #1
 8014d74:	0013      	movs	r3, r2
 8014d76:	009b      	lsls	r3, r3, #2
 8014d78:	189b      	adds	r3, r3, r2
 8014d7a:	00db      	lsls	r3, r3, #3
 8014d7c:	18cb      	adds	r3, r1, r3
 8014d7e:	3302      	adds	r3, #2
 8014d80:	781b      	ldrb	r3, [r3, #0]
 8014d82:	e00d      	b.n	8014da0 <USBD_LL_IsStallEP+0x5a>
  }
  else
  {
    return hpcd->OUT_ep[ep_addr & 0x7F].is_stall;
 8014d84:	1cfb      	adds	r3, r7, #3
 8014d86:	781b      	ldrb	r3, [r3, #0]
 8014d88:	227f      	movs	r2, #127	; 0x7f
 8014d8a:	401a      	ands	r2, r3
 8014d8c:	68f8      	ldr	r0, [r7, #12]
 8014d8e:	23b5      	movs	r3, #181	; 0xb5
 8014d90:	0059      	lsls	r1, r3, #1
 8014d92:	0013      	movs	r3, r2
 8014d94:	009b      	lsls	r3, r3, #2
 8014d96:	189b      	adds	r3, r3, r2
 8014d98:	00db      	lsls	r3, r3, #3
 8014d9a:	18c3      	adds	r3, r0, r3
 8014d9c:	185b      	adds	r3, r3, r1
 8014d9e:	781b      	ldrb	r3, [r3, #0]
  }
}
 8014da0:	0018      	movs	r0, r3
 8014da2:	46bd      	mov	sp, r7
 8014da4:	b004      	add	sp, #16
 8014da6:	bd80      	pop	{r7, pc}

08014da8 <USBD_LL_SetUSBAddress>:
  * @param  pdev: Device handle
  * @param  dev_addr: Device address
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_SetUSBAddress(USBD_HandleTypeDef *pdev, uint8_t dev_addr)
{
 8014da8:	b5f0      	push	{r4, r5, r6, r7, lr}
 8014daa:	b085      	sub	sp, #20
 8014dac:	af00      	add	r7, sp, #0
 8014dae:	6078      	str	r0, [r7, #4]
 8014db0:	000a      	movs	r2, r1
 8014db2:	1cfb      	adds	r3, r7, #3
 8014db4:	701a      	strb	r2, [r3, #0]
  HAL_StatusTypeDef hal_status = HAL_OK;
 8014db6:	210f      	movs	r1, #15
 8014db8:	187b      	adds	r3, r7, r1
 8014dba:	2200      	movs	r2, #0
 8014dbc:	701a      	strb	r2, [r3, #0]
  USBD_StatusTypeDef usb_status = USBD_OK;
 8014dbe:	260e      	movs	r6, #14
 8014dc0:	19bb      	adds	r3, r7, r6
 8014dc2:	2200      	movs	r2, #0
 8014dc4:	701a      	strb	r2, [r3, #0]

  hal_status = HAL_PCD_SetAddress(pdev->pData, dev_addr);
 8014dc6:	687a      	ldr	r2, [r7, #4]
 8014dc8:	23b0      	movs	r3, #176	; 0xb0
 8014dca:	009b      	lsls	r3, r3, #2
 8014dcc:	58d2      	ldr	r2, [r2, r3]
 8014dce:	000d      	movs	r5, r1
 8014dd0:	187c      	adds	r4, r7, r1
 8014dd2:	1cfb      	adds	r3, r7, #3
 8014dd4:	781b      	ldrb	r3, [r3, #0]
 8014dd6:	0019      	movs	r1, r3
 8014dd8:	0010      	movs	r0, r2
 8014dda:	f7f6 ffbb 	bl	800bd54 <HAL_PCD_SetAddress>
 8014dde:	0003      	movs	r3, r0
 8014de0:	7023      	strb	r3, [r4, #0]

  usb_status =  USBD_Get_USB_Status(hal_status);
 8014de2:	19bc      	adds	r4, r7, r6
 8014de4:	197b      	adds	r3, r7, r5
 8014de6:	781b      	ldrb	r3, [r3, #0]
 8014de8:	0018      	movs	r0, r3
 8014dea:	f000 f8a8 	bl	8014f3e <USBD_Get_USB_Status>
 8014dee:	0003      	movs	r3, r0
 8014df0:	7023      	strb	r3, [r4, #0]

  return usb_status;
 8014df2:	19bb      	adds	r3, r7, r6
 8014df4:	781b      	ldrb	r3, [r3, #0]
}
 8014df6:	0018      	movs	r0, r3
 8014df8:	46bd      	mov	sp, r7
 8014dfa:	b005      	add	sp, #20
 8014dfc:	bdf0      	pop	{r4, r5, r6, r7, pc}

08014dfe <USBD_LL_Transmit>:
  * @param  pbuf: Pointer to data to be sent
  * @param  size: Data size
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_Transmit(USBD_HandleTypeDef *pdev, uint8_t ep_addr, uint8_t *pbuf, uint16_t size)
{
 8014dfe:	b5f0      	push	{r4, r5, r6, r7, lr}
 8014e00:	b087      	sub	sp, #28
 8014e02:	af00      	add	r7, sp, #0
 8014e04:	60f8      	str	r0, [r7, #12]
 8014e06:	0008      	movs	r0, r1
 8014e08:	607a      	str	r2, [r7, #4]
 8014e0a:	0019      	movs	r1, r3
 8014e0c:	230b      	movs	r3, #11
 8014e0e:	18fb      	adds	r3, r7, r3
 8014e10:	1c02      	adds	r2, r0, #0
 8014e12:	701a      	strb	r2, [r3, #0]
 8014e14:	2408      	movs	r4, #8
 8014e16:	193b      	adds	r3, r7, r4
 8014e18:	1c0a      	adds	r2, r1, #0
 8014e1a:	801a      	strh	r2, [r3, #0]
  HAL_StatusTypeDef hal_status = HAL_OK;
 8014e1c:	2117      	movs	r1, #23
 8014e1e:	187b      	adds	r3, r7, r1
 8014e20:	2200      	movs	r2, #0
 8014e22:	701a      	strb	r2, [r3, #0]
  USBD_StatusTypeDef usb_status = USBD_OK;
 8014e24:	2516      	movs	r5, #22
 8014e26:	197b      	adds	r3, r7, r5
 8014e28:	2200      	movs	r2, #0
 8014e2a:	701a      	strb	r2, [r3, #0]

  hal_status = HAL_PCD_EP_Transmit(pdev->pData, ep_addr, pbuf, size);
 8014e2c:	68fa      	ldr	r2, [r7, #12]
 8014e2e:	23b0      	movs	r3, #176	; 0xb0
 8014e30:	009b      	lsls	r3, r3, #2
 8014e32:	58d0      	ldr	r0, [r2, r3]
 8014e34:	193b      	adds	r3, r7, r4
 8014e36:	881d      	ldrh	r5, [r3, #0]
 8014e38:	000e      	movs	r6, r1
 8014e3a:	187c      	adds	r4, r7, r1
 8014e3c:	687a      	ldr	r2, [r7, #4]
 8014e3e:	230b      	movs	r3, #11
 8014e40:	18fb      	adds	r3, r7, r3
 8014e42:	7819      	ldrb	r1, [r3, #0]
 8014e44:	002b      	movs	r3, r5
 8014e46:	f7f7 f8d6 	bl	800bff6 <HAL_PCD_EP_Transmit>
 8014e4a:	0003      	movs	r3, r0
 8014e4c:	7023      	strb	r3, [r4, #0]

  usb_status =  USBD_Get_USB_Status(hal_status);
 8014e4e:	2516      	movs	r5, #22
 8014e50:	197c      	adds	r4, r7, r5
 8014e52:	19bb      	adds	r3, r7, r6
 8014e54:	781b      	ldrb	r3, [r3, #0]
 8014e56:	0018      	movs	r0, r3
 8014e58:	f000 f871 	bl	8014f3e <USBD_Get_USB_Status>
 8014e5c:	0003      	movs	r3, r0
 8014e5e:	7023      	strb	r3, [r4, #0]

  return usb_status;
 8014e60:	197b      	adds	r3, r7, r5
 8014e62:	781b      	ldrb	r3, [r3, #0]
}
 8014e64:	0018      	movs	r0, r3
 8014e66:	46bd      	mov	sp, r7
 8014e68:	b007      	add	sp, #28
 8014e6a:	bdf0      	pop	{r4, r5, r6, r7, pc}

08014e6c <USBD_LL_PrepareReceive>:
  * @param  pbuf: Pointer to data to be received
  * @param  size: Data size
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_PrepareReceive(USBD_HandleTypeDef *pdev, uint8_t ep_addr, uint8_t *pbuf, uint16_t size)
{
 8014e6c:	b5f0      	push	{r4, r5, r6, r7, lr}
 8014e6e:	b087      	sub	sp, #28
 8014e70:	af00      	add	r7, sp, #0
 8014e72:	60f8      	str	r0, [r7, #12]
 8014e74:	0008      	movs	r0, r1
 8014e76:	607a      	str	r2, [r7, #4]
 8014e78:	0019      	movs	r1, r3
 8014e7a:	230b      	movs	r3, #11
 8014e7c:	18fb      	adds	r3, r7, r3
 8014e7e:	1c02      	adds	r2, r0, #0
 8014e80:	701a      	strb	r2, [r3, #0]
 8014e82:	2408      	movs	r4, #8
 8014e84:	193b      	adds	r3, r7, r4
 8014e86:	1c0a      	adds	r2, r1, #0
 8014e88:	801a      	strh	r2, [r3, #0]
  HAL_StatusTypeDef hal_status = HAL_OK;
 8014e8a:	2117      	movs	r1, #23
 8014e8c:	187b      	adds	r3, r7, r1
 8014e8e:	2200      	movs	r2, #0
 8014e90:	701a      	strb	r2, [r3, #0]
  USBD_StatusTypeDef usb_status = USBD_OK;
 8014e92:	2516      	movs	r5, #22
 8014e94:	197b      	adds	r3, r7, r5
 8014e96:	2200      	movs	r2, #0
 8014e98:	701a      	strb	r2, [r3, #0]

  hal_status = HAL_PCD_EP_Receive(pdev->pData, ep_addr, pbuf, size);
 8014e9a:	68fa      	ldr	r2, [r7, #12]
 8014e9c:	23b0      	movs	r3, #176	; 0xb0
 8014e9e:	009b      	lsls	r3, r3, #2
 8014ea0:	58d0      	ldr	r0, [r2, r3]
 8014ea2:	193b      	adds	r3, r7, r4
 8014ea4:	881d      	ldrh	r5, [r3, #0]
 8014ea6:	000e      	movs	r6, r1
 8014ea8:	187c      	adds	r4, r7, r1
 8014eaa:	687a      	ldr	r2, [r7, #4]
 8014eac:	230b      	movs	r3, #11
 8014eae:	18fb      	adds	r3, r7, r3
 8014eb0:	7819      	ldrb	r1, [r3, #0]
 8014eb2:	002b      	movs	r3, r5
 8014eb4:	f7f7 f842 	bl	800bf3c <HAL_PCD_EP_Receive>
 8014eb8:	0003      	movs	r3, r0
 8014eba:	7023      	strb	r3, [r4, #0]

  usb_status =  USBD_Get_USB_Status(hal_status);
 8014ebc:	2516      	movs	r5, #22
 8014ebe:	197c      	adds	r4, r7, r5
 8014ec0:	19bb      	adds	r3, r7, r6
 8014ec2:	781b      	ldrb	r3, [r3, #0]
 8014ec4:	0018      	movs	r0, r3
 8014ec6:	f000 f83a 	bl	8014f3e <USBD_Get_USB_Status>
 8014eca:	0003      	movs	r3, r0
 8014ecc:	7023      	strb	r3, [r4, #0]

  return usb_status;
 8014ece:	197b      	adds	r3, r7, r5
 8014ed0:	781b      	ldrb	r3, [r3, #0]
}
 8014ed2:	0018      	movs	r0, r3
 8014ed4:	46bd      	mov	sp, r7
 8014ed6:	b007      	add	sp, #28
 8014ed8:	bdf0      	pop	{r4, r5, r6, r7, pc}

08014eda <USBD_LL_GetRxDataSize>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint number
  * @retval Received Data Size
  */
uint32_t USBD_LL_GetRxDataSize(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
 8014eda:	b580      	push	{r7, lr}
 8014edc:	b082      	sub	sp, #8
 8014ede:	af00      	add	r7, sp, #0
 8014ee0:	6078      	str	r0, [r7, #4]
 8014ee2:	000a      	movs	r2, r1
 8014ee4:	1cfb      	adds	r3, r7, #3
 8014ee6:	701a      	strb	r2, [r3, #0]
  return HAL_PCD_EP_GetRxCount((PCD_HandleTypeDef*) pdev->pData, ep_addr);
 8014ee8:	687a      	ldr	r2, [r7, #4]
 8014eea:	23b0      	movs	r3, #176	; 0xb0
 8014eec:	009b      	lsls	r3, r3, #2
 8014eee:	58d2      	ldr	r2, [r2, r3]
 8014ef0:	1cfb      	adds	r3, r7, #3
 8014ef2:	781b      	ldrb	r3, [r3, #0]
 8014ef4:	0019      	movs	r1, r3
 8014ef6:	0010      	movs	r0, r2
 8014ef8:	f7f7 f864 	bl	800bfc4 <HAL_PCD_EP_GetRxCount>
 8014efc:	0003      	movs	r3, r0
}
 8014efe:	0018      	movs	r0, r3
 8014f00:	46bd      	mov	sp, r7
 8014f02:	b002      	add	sp, #8
 8014f04:	bd80      	pop	{r7, pc}
	...

08014f08 <USBD_static_malloc>:
  * @brief  Static single allocation.
  * @param  size: Size of allocated memory
  * @retval None
  */
void *USBD_static_malloc(uint32_t size)
{
 8014f08:	b580      	push	{r7, lr}
 8014f0a:	b082      	sub	sp, #8
 8014f0c:	af00      	add	r7, sp, #0
 8014f0e:	6078      	str	r0, [r7, #4]
  static uint32_t mem[(sizeof(USBD_CDC_HandleTypeDef)/4)+1];/* On 32-bit boundary */
  return mem;
 8014f10:	4b02      	ldr	r3, [pc, #8]	; (8014f1c <USBD_static_malloc+0x14>)
}
 8014f12:	0018      	movs	r0, r3
 8014f14:	46bd      	mov	sp, r7
 8014f16:	b002      	add	sp, #8
 8014f18:	bd80      	pop	{r7, pc}
 8014f1a:	46c0      	nop			; (mov r8, r8)
 8014f1c:	20001314 	.word	0x20001314

08014f20 <USBD_static_free>:
  * @brief  Dummy memory free
  * @param  p: Pointer to allocated  memory address
  * @retval None
  */
void USBD_static_free(void *p)
{
 8014f20:	b580      	push	{r7, lr}
 8014f22:	b082      	sub	sp, #8
 8014f24:	af00      	add	r7, sp, #0
 8014f26:	6078      	str	r0, [r7, #4]

}
 8014f28:	46c0      	nop			; (mov r8, r8)
 8014f2a:	46bd      	mov	sp, r7
 8014f2c:	b002      	add	sp, #8
 8014f2e:	bd80      	pop	{r7, pc}

08014f30 <SystemClockConfig_Resume>:
  * @brief  Configures system clock after wake-up from USB Resume CallBack:
  *         enable HSI, PLL and select PLL as system clock source.
  * @retval None
  */
static void SystemClockConfig_Resume(void)
{
 8014f30:	b580      	push	{r7, lr}
 8014f32:	af00      	add	r7, sp, #0
  SystemClock_Config();
 8014f34:	f7f5 fb20 	bl	800a578 <SystemClock_Config>
}
 8014f38:	46c0      	nop			; (mov r8, r8)
 8014f3a:	46bd      	mov	sp, r7
 8014f3c:	bd80      	pop	{r7, pc}

08014f3e <USBD_Get_USB_Status>:
  * @brief  Returns the USB status depending on the HAL status:
  * @param  hal_status: HAL status
  * @retval USB status
  */
USBD_StatusTypeDef USBD_Get_USB_Status(HAL_StatusTypeDef hal_status)
{
 8014f3e:	b580      	push	{r7, lr}
 8014f40:	b084      	sub	sp, #16
 8014f42:	af00      	add	r7, sp, #0
 8014f44:	0002      	movs	r2, r0
 8014f46:	1dfb      	adds	r3, r7, #7
 8014f48:	701a      	strb	r2, [r3, #0]
  USBD_StatusTypeDef usb_status = USBD_OK;
 8014f4a:	230f      	movs	r3, #15
 8014f4c:	18fb      	adds	r3, r7, r3
 8014f4e:	2200      	movs	r2, #0
 8014f50:	701a      	strb	r2, [r3, #0]

  switch (hal_status)
 8014f52:	1dfb      	adds	r3, r7, #7
 8014f54:	781b      	ldrb	r3, [r3, #0]
 8014f56:	2b03      	cmp	r3, #3
 8014f58:	d017      	beq.n	8014f8a <USBD_Get_USB_Status+0x4c>
 8014f5a:	dc1b      	bgt.n	8014f94 <USBD_Get_USB_Status+0x56>
 8014f5c:	2b02      	cmp	r3, #2
 8014f5e:	d00f      	beq.n	8014f80 <USBD_Get_USB_Status+0x42>
 8014f60:	dc18      	bgt.n	8014f94 <USBD_Get_USB_Status+0x56>
 8014f62:	2b00      	cmp	r3, #0
 8014f64:	d002      	beq.n	8014f6c <USBD_Get_USB_Status+0x2e>
 8014f66:	2b01      	cmp	r3, #1
 8014f68:	d005      	beq.n	8014f76 <USBD_Get_USB_Status+0x38>
 8014f6a:	e013      	b.n	8014f94 <USBD_Get_USB_Status+0x56>
  {
    case HAL_OK :
      usb_status = USBD_OK;
 8014f6c:	230f      	movs	r3, #15
 8014f6e:	18fb      	adds	r3, r7, r3
 8014f70:	2200      	movs	r2, #0
 8014f72:	701a      	strb	r2, [r3, #0]
    break;
 8014f74:	e013      	b.n	8014f9e <USBD_Get_USB_Status+0x60>
    case HAL_ERROR :
      usb_status = USBD_FAIL;
 8014f76:	230f      	movs	r3, #15
 8014f78:	18fb      	adds	r3, r7, r3
 8014f7a:	2202      	movs	r2, #2
 8014f7c:	701a      	strb	r2, [r3, #0]
    break;
 8014f7e:	e00e      	b.n	8014f9e <USBD_Get_USB_Status+0x60>
    case HAL_BUSY :
      usb_status = USBD_BUSY;
 8014f80:	230f      	movs	r3, #15
 8014f82:	18fb      	adds	r3, r7, r3
 8014f84:	2201      	movs	r2, #1
 8014f86:	701a      	strb	r2, [r3, #0]
    break;
 8014f88:	e009      	b.n	8014f9e <USBD_Get_USB_Status+0x60>
    case HAL_TIMEOUT :
      usb_status = USBD_FAIL;
 8014f8a:	230f      	movs	r3, #15
 8014f8c:	18fb      	adds	r3, r7, r3
 8014f8e:	2202      	movs	r2, #2
 8014f90:	701a      	strb	r2, [r3, #0]
    break;
 8014f92:	e004      	b.n	8014f9e <USBD_Get_USB_Status+0x60>
    default :
      usb_status = USBD_FAIL;
 8014f94:	230f      	movs	r3, #15
 8014f96:	18fb      	adds	r3, r7, r3
 8014f98:	2202      	movs	r2, #2
 8014f9a:	701a      	strb	r2, [r3, #0]
    break;
 8014f9c:	46c0      	nop			; (mov r8, r8)
  }
  return usb_status;
 8014f9e:	230f      	movs	r3, #15
 8014fa0:	18fb      	adds	r3, r7, r3
 8014fa2:	781b      	ldrb	r3, [r3, #0]
}
 8014fa4:	0018      	movs	r0, r3
 8014fa6:	46bd      	mov	sp, r7
 8014fa8:	b004      	add	sp, #16
 8014faa:	bd80      	pop	{r7, pc}

08014fac <__errno>:
 8014fac:	4b01      	ldr	r3, [pc, #4]	; (8014fb4 <__errno+0x8>)
 8014fae:	6818      	ldr	r0, [r3, #0]
 8014fb0:	4770      	bx	lr
 8014fb2:	46c0      	nop			; (mov r8, r8)
 8014fb4:	200002dc 	.word	0x200002dc

08014fb8 <__libc_init_array>:
 8014fb8:	b570      	push	{r4, r5, r6, lr}
 8014fba:	2600      	movs	r6, #0
 8014fbc:	4d0c      	ldr	r5, [pc, #48]	; (8014ff0 <__libc_init_array+0x38>)
 8014fbe:	4c0d      	ldr	r4, [pc, #52]	; (8014ff4 <__libc_init_array+0x3c>)
 8014fc0:	1b64      	subs	r4, r4, r5
 8014fc2:	10a4      	asrs	r4, r4, #2
 8014fc4:	42a6      	cmp	r6, r4
 8014fc6:	d109      	bne.n	8014fdc <__libc_init_array+0x24>
 8014fc8:	2600      	movs	r6, #0
 8014fca:	f000 fc6d 	bl	80158a8 <_init>
 8014fce:	4d0a      	ldr	r5, [pc, #40]	; (8014ff8 <__libc_init_array+0x40>)
 8014fd0:	4c0a      	ldr	r4, [pc, #40]	; (8014ffc <__libc_init_array+0x44>)
 8014fd2:	1b64      	subs	r4, r4, r5
 8014fd4:	10a4      	asrs	r4, r4, #2
 8014fd6:	42a6      	cmp	r6, r4
 8014fd8:	d105      	bne.n	8014fe6 <__libc_init_array+0x2e>
 8014fda:	bd70      	pop	{r4, r5, r6, pc}
 8014fdc:	00b3      	lsls	r3, r6, #2
 8014fde:	58eb      	ldr	r3, [r5, r3]
 8014fe0:	4798      	blx	r3
 8014fe2:	3601      	adds	r6, #1
 8014fe4:	e7ee      	b.n	8014fc4 <__libc_init_array+0xc>
 8014fe6:	00b3      	lsls	r3, r6, #2
 8014fe8:	58eb      	ldr	r3, [r5, r3]
 8014fea:	4798      	blx	r3
 8014fec:	3601      	adds	r6, #1
 8014fee:	e7f2      	b.n	8014fd6 <__libc_init_array+0x1e>
 8014ff0:	08015e78 	.word	0x08015e78
 8014ff4:	08015e78 	.word	0x08015e78
 8014ff8:	08015e78 	.word	0x08015e78
 8014ffc:	08015e7c 	.word	0x08015e7c

08015000 <memcpy>:
 8015000:	2300      	movs	r3, #0
 8015002:	b510      	push	{r4, lr}
 8015004:	429a      	cmp	r2, r3
 8015006:	d100      	bne.n	801500a <memcpy+0xa>
 8015008:	bd10      	pop	{r4, pc}
 801500a:	5ccc      	ldrb	r4, [r1, r3]
 801500c:	54c4      	strb	r4, [r0, r3]
 801500e:	3301      	adds	r3, #1
 8015010:	e7f8      	b.n	8015004 <memcpy+0x4>

08015012 <memset>:
 8015012:	0003      	movs	r3, r0
 8015014:	1882      	adds	r2, r0, r2
 8015016:	4293      	cmp	r3, r2
 8015018:	d100      	bne.n	801501c <memset+0xa>
 801501a:	4770      	bx	lr
 801501c:	7019      	strb	r1, [r3, #0]
 801501e:	3301      	adds	r3, #1
 8015020:	e7f9      	b.n	8015016 <memset+0x4>
	...

08015024 <siprintf>:
 8015024:	b40e      	push	{r1, r2, r3}
 8015026:	b500      	push	{lr}
 8015028:	490b      	ldr	r1, [pc, #44]	; (8015058 <siprintf+0x34>)
 801502a:	b09c      	sub	sp, #112	; 0x70
 801502c:	ab1d      	add	r3, sp, #116	; 0x74
 801502e:	9002      	str	r0, [sp, #8]
 8015030:	9006      	str	r0, [sp, #24]
 8015032:	9107      	str	r1, [sp, #28]
 8015034:	9104      	str	r1, [sp, #16]
 8015036:	4809      	ldr	r0, [pc, #36]	; (801505c <siprintf+0x38>)
 8015038:	4909      	ldr	r1, [pc, #36]	; (8015060 <siprintf+0x3c>)
 801503a:	cb04      	ldmia	r3!, {r2}
 801503c:	9105      	str	r1, [sp, #20]
 801503e:	6800      	ldr	r0, [r0, #0]
 8015040:	a902      	add	r1, sp, #8
 8015042:	9301      	str	r3, [sp, #4]
 8015044:	f000 f896 	bl	8015174 <_svfiprintf_r>
 8015048:	2300      	movs	r3, #0
 801504a:	9a02      	ldr	r2, [sp, #8]
 801504c:	7013      	strb	r3, [r2, #0]
 801504e:	b01c      	add	sp, #112	; 0x70
 8015050:	bc08      	pop	{r3}
 8015052:	b003      	add	sp, #12
 8015054:	4718      	bx	r3
 8015056:	46c0      	nop			; (mov r8, r8)
 8015058:	7fffffff 	.word	0x7fffffff
 801505c:	200002dc 	.word	0x200002dc
 8015060:	ffff0208 	.word	0xffff0208

08015064 <strcat>:
 8015064:	0002      	movs	r2, r0
 8015066:	b510      	push	{r4, lr}
 8015068:	7813      	ldrb	r3, [r2, #0]
 801506a:	0014      	movs	r4, r2
 801506c:	3201      	adds	r2, #1
 801506e:	2b00      	cmp	r3, #0
 8015070:	d1fa      	bne.n	8015068 <strcat+0x4>
 8015072:	5cca      	ldrb	r2, [r1, r3]
 8015074:	54e2      	strb	r2, [r4, r3]
 8015076:	3301      	adds	r3, #1
 8015078:	2a00      	cmp	r2, #0
 801507a:	d1fa      	bne.n	8015072 <strcat+0xe>
 801507c:	bd10      	pop	{r4, pc}

0801507e <strcpy>:
 801507e:	0003      	movs	r3, r0
 8015080:	780a      	ldrb	r2, [r1, #0]
 8015082:	3101      	adds	r1, #1
 8015084:	701a      	strb	r2, [r3, #0]
 8015086:	3301      	adds	r3, #1
 8015088:	2a00      	cmp	r2, #0
 801508a:	d1f9      	bne.n	8015080 <strcpy+0x2>
 801508c:	4770      	bx	lr

0801508e <strncmp>:
 801508e:	b530      	push	{r4, r5, lr}
 8015090:	0005      	movs	r5, r0
 8015092:	1e10      	subs	r0, r2, #0
 8015094:	d00b      	beq.n	80150ae <strncmp+0x20>
 8015096:	2400      	movs	r4, #0
 8015098:	3a01      	subs	r2, #1
 801509a:	5d2b      	ldrb	r3, [r5, r4]
 801509c:	5d08      	ldrb	r0, [r1, r4]
 801509e:	4283      	cmp	r3, r0
 80150a0:	d104      	bne.n	80150ac <strncmp+0x1e>
 80150a2:	4294      	cmp	r4, r2
 80150a4:	d002      	beq.n	80150ac <strncmp+0x1e>
 80150a6:	3401      	adds	r4, #1
 80150a8:	2b00      	cmp	r3, #0
 80150aa:	d1f6      	bne.n	801509a <strncmp+0xc>
 80150ac:	1a18      	subs	r0, r3, r0
 80150ae:	bd30      	pop	{r4, r5, pc}

080150b0 <__ssputs_r>:
 80150b0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80150b2:	688e      	ldr	r6, [r1, #8]
 80150b4:	b085      	sub	sp, #20
 80150b6:	0007      	movs	r7, r0
 80150b8:	000c      	movs	r4, r1
 80150ba:	9203      	str	r2, [sp, #12]
 80150bc:	9301      	str	r3, [sp, #4]
 80150be:	429e      	cmp	r6, r3
 80150c0:	d83c      	bhi.n	801513c <__ssputs_r+0x8c>
 80150c2:	2390      	movs	r3, #144	; 0x90
 80150c4:	898a      	ldrh	r2, [r1, #12]
 80150c6:	00db      	lsls	r3, r3, #3
 80150c8:	421a      	tst	r2, r3
 80150ca:	d034      	beq.n	8015136 <__ssputs_r+0x86>
 80150cc:	2503      	movs	r5, #3
 80150ce:	6909      	ldr	r1, [r1, #16]
 80150d0:	6823      	ldr	r3, [r4, #0]
 80150d2:	1a5b      	subs	r3, r3, r1
 80150d4:	9302      	str	r3, [sp, #8]
 80150d6:	6963      	ldr	r3, [r4, #20]
 80150d8:	9802      	ldr	r0, [sp, #8]
 80150da:	435d      	muls	r5, r3
 80150dc:	0feb      	lsrs	r3, r5, #31
 80150de:	195d      	adds	r5, r3, r5
 80150e0:	9b01      	ldr	r3, [sp, #4]
 80150e2:	106d      	asrs	r5, r5, #1
 80150e4:	3301      	adds	r3, #1
 80150e6:	181b      	adds	r3, r3, r0
 80150e8:	42ab      	cmp	r3, r5
 80150ea:	d900      	bls.n	80150ee <__ssputs_r+0x3e>
 80150ec:	001d      	movs	r5, r3
 80150ee:	0553      	lsls	r3, r2, #21
 80150f0:	d532      	bpl.n	8015158 <__ssputs_r+0xa8>
 80150f2:	0029      	movs	r1, r5
 80150f4:	0038      	movs	r0, r7
 80150f6:	f000 fb27 	bl	8015748 <_malloc_r>
 80150fa:	1e06      	subs	r6, r0, #0
 80150fc:	d109      	bne.n	8015112 <__ssputs_r+0x62>
 80150fe:	230c      	movs	r3, #12
 8015100:	603b      	str	r3, [r7, #0]
 8015102:	2340      	movs	r3, #64	; 0x40
 8015104:	2001      	movs	r0, #1
 8015106:	89a2      	ldrh	r2, [r4, #12]
 8015108:	4240      	negs	r0, r0
 801510a:	4313      	orrs	r3, r2
 801510c:	81a3      	strh	r3, [r4, #12]
 801510e:	b005      	add	sp, #20
 8015110:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8015112:	9a02      	ldr	r2, [sp, #8]
 8015114:	6921      	ldr	r1, [r4, #16]
 8015116:	f7ff ff73 	bl	8015000 <memcpy>
 801511a:	89a3      	ldrh	r3, [r4, #12]
 801511c:	4a14      	ldr	r2, [pc, #80]	; (8015170 <__ssputs_r+0xc0>)
 801511e:	401a      	ands	r2, r3
 8015120:	2380      	movs	r3, #128	; 0x80
 8015122:	4313      	orrs	r3, r2
 8015124:	81a3      	strh	r3, [r4, #12]
 8015126:	9b02      	ldr	r3, [sp, #8]
 8015128:	6126      	str	r6, [r4, #16]
 801512a:	18f6      	adds	r6, r6, r3
 801512c:	6026      	str	r6, [r4, #0]
 801512e:	6165      	str	r5, [r4, #20]
 8015130:	9e01      	ldr	r6, [sp, #4]
 8015132:	1aed      	subs	r5, r5, r3
 8015134:	60a5      	str	r5, [r4, #8]
 8015136:	9b01      	ldr	r3, [sp, #4]
 8015138:	429e      	cmp	r6, r3
 801513a:	d900      	bls.n	801513e <__ssputs_r+0x8e>
 801513c:	9e01      	ldr	r6, [sp, #4]
 801513e:	0032      	movs	r2, r6
 8015140:	9903      	ldr	r1, [sp, #12]
 8015142:	6820      	ldr	r0, [r4, #0]
 8015144:	f000 faa3 	bl	801568e <memmove>
 8015148:	68a3      	ldr	r3, [r4, #8]
 801514a:	2000      	movs	r0, #0
 801514c:	1b9b      	subs	r3, r3, r6
 801514e:	60a3      	str	r3, [r4, #8]
 8015150:	6823      	ldr	r3, [r4, #0]
 8015152:	199e      	adds	r6, r3, r6
 8015154:	6026      	str	r6, [r4, #0]
 8015156:	e7da      	b.n	801510e <__ssputs_r+0x5e>
 8015158:	002a      	movs	r2, r5
 801515a:	0038      	movs	r0, r7
 801515c:	f000 fb52 	bl	8015804 <_realloc_r>
 8015160:	1e06      	subs	r6, r0, #0
 8015162:	d1e0      	bne.n	8015126 <__ssputs_r+0x76>
 8015164:	0038      	movs	r0, r7
 8015166:	6921      	ldr	r1, [r4, #16]
 8015168:	f000 faa4 	bl	80156b4 <_free_r>
 801516c:	e7c7      	b.n	80150fe <__ssputs_r+0x4e>
 801516e:	46c0      	nop			; (mov r8, r8)
 8015170:	fffffb7f 	.word	0xfffffb7f

08015174 <_svfiprintf_r>:
 8015174:	b5f0      	push	{r4, r5, r6, r7, lr}
 8015176:	b0a1      	sub	sp, #132	; 0x84
 8015178:	9003      	str	r0, [sp, #12]
 801517a:	001d      	movs	r5, r3
 801517c:	898b      	ldrh	r3, [r1, #12]
 801517e:	000f      	movs	r7, r1
 8015180:	0016      	movs	r6, r2
 8015182:	061b      	lsls	r3, r3, #24
 8015184:	d511      	bpl.n	80151aa <_svfiprintf_r+0x36>
 8015186:	690b      	ldr	r3, [r1, #16]
 8015188:	2b00      	cmp	r3, #0
 801518a:	d10e      	bne.n	80151aa <_svfiprintf_r+0x36>
 801518c:	2140      	movs	r1, #64	; 0x40
 801518e:	f000 fadb 	bl	8015748 <_malloc_r>
 8015192:	6038      	str	r0, [r7, #0]
 8015194:	6138      	str	r0, [r7, #16]
 8015196:	2800      	cmp	r0, #0
 8015198:	d105      	bne.n	80151a6 <_svfiprintf_r+0x32>
 801519a:	230c      	movs	r3, #12
 801519c:	9a03      	ldr	r2, [sp, #12]
 801519e:	3801      	subs	r0, #1
 80151a0:	6013      	str	r3, [r2, #0]
 80151a2:	b021      	add	sp, #132	; 0x84
 80151a4:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80151a6:	2340      	movs	r3, #64	; 0x40
 80151a8:	617b      	str	r3, [r7, #20]
 80151aa:	2300      	movs	r3, #0
 80151ac:	ac08      	add	r4, sp, #32
 80151ae:	6163      	str	r3, [r4, #20]
 80151b0:	3320      	adds	r3, #32
 80151b2:	7663      	strb	r3, [r4, #25]
 80151b4:	3310      	adds	r3, #16
 80151b6:	76a3      	strb	r3, [r4, #26]
 80151b8:	9507      	str	r5, [sp, #28]
 80151ba:	0035      	movs	r5, r6
 80151bc:	782b      	ldrb	r3, [r5, #0]
 80151be:	2b00      	cmp	r3, #0
 80151c0:	d001      	beq.n	80151c6 <_svfiprintf_r+0x52>
 80151c2:	2b25      	cmp	r3, #37	; 0x25
 80151c4:	d147      	bne.n	8015256 <_svfiprintf_r+0xe2>
 80151c6:	1bab      	subs	r3, r5, r6
 80151c8:	9305      	str	r3, [sp, #20]
 80151ca:	42b5      	cmp	r5, r6
 80151cc:	d00c      	beq.n	80151e8 <_svfiprintf_r+0x74>
 80151ce:	0032      	movs	r2, r6
 80151d0:	0039      	movs	r1, r7
 80151d2:	9803      	ldr	r0, [sp, #12]
 80151d4:	f7ff ff6c 	bl	80150b0 <__ssputs_r>
 80151d8:	1c43      	adds	r3, r0, #1
 80151da:	d100      	bne.n	80151de <_svfiprintf_r+0x6a>
 80151dc:	e0ae      	b.n	801533c <_svfiprintf_r+0x1c8>
 80151de:	6962      	ldr	r2, [r4, #20]
 80151e0:	9b05      	ldr	r3, [sp, #20]
 80151e2:	4694      	mov	ip, r2
 80151e4:	4463      	add	r3, ip
 80151e6:	6163      	str	r3, [r4, #20]
 80151e8:	782b      	ldrb	r3, [r5, #0]
 80151ea:	2b00      	cmp	r3, #0
 80151ec:	d100      	bne.n	80151f0 <_svfiprintf_r+0x7c>
 80151ee:	e0a5      	b.n	801533c <_svfiprintf_r+0x1c8>
 80151f0:	2201      	movs	r2, #1
 80151f2:	2300      	movs	r3, #0
 80151f4:	4252      	negs	r2, r2
 80151f6:	6062      	str	r2, [r4, #4]
 80151f8:	a904      	add	r1, sp, #16
 80151fa:	3254      	adds	r2, #84	; 0x54
 80151fc:	1852      	adds	r2, r2, r1
 80151fe:	1c6e      	adds	r6, r5, #1
 8015200:	6023      	str	r3, [r4, #0]
 8015202:	60e3      	str	r3, [r4, #12]
 8015204:	60a3      	str	r3, [r4, #8]
 8015206:	7013      	strb	r3, [r2, #0]
 8015208:	65a3      	str	r3, [r4, #88]	; 0x58
 801520a:	2205      	movs	r2, #5
 801520c:	7831      	ldrb	r1, [r6, #0]
 801520e:	4854      	ldr	r0, [pc, #336]	; (8015360 <_svfiprintf_r+0x1ec>)
 8015210:	f000 fa32 	bl	8015678 <memchr>
 8015214:	1c75      	adds	r5, r6, #1
 8015216:	2800      	cmp	r0, #0
 8015218:	d11f      	bne.n	801525a <_svfiprintf_r+0xe6>
 801521a:	6822      	ldr	r2, [r4, #0]
 801521c:	06d3      	lsls	r3, r2, #27
 801521e:	d504      	bpl.n	801522a <_svfiprintf_r+0xb6>
 8015220:	2353      	movs	r3, #83	; 0x53
 8015222:	a904      	add	r1, sp, #16
 8015224:	185b      	adds	r3, r3, r1
 8015226:	2120      	movs	r1, #32
 8015228:	7019      	strb	r1, [r3, #0]
 801522a:	0713      	lsls	r3, r2, #28
 801522c:	d504      	bpl.n	8015238 <_svfiprintf_r+0xc4>
 801522e:	2353      	movs	r3, #83	; 0x53
 8015230:	a904      	add	r1, sp, #16
 8015232:	185b      	adds	r3, r3, r1
 8015234:	212b      	movs	r1, #43	; 0x2b
 8015236:	7019      	strb	r1, [r3, #0]
 8015238:	7833      	ldrb	r3, [r6, #0]
 801523a:	2b2a      	cmp	r3, #42	; 0x2a
 801523c:	d016      	beq.n	801526c <_svfiprintf_r+0xf8>
 801523e:	0035      	movs	r5, r6
 8015240:	2100      	movs	r1, #0
 8015242:	200a      	movs	r0, #10
 8015244:	68e3      	ldr	r3, [r4, #12]
 8015246:	782a      	ldrb	r2, [r5, #0]
 8015248:	1c6e      	adds	r6, r5, #1
 801524a:	3a30      	subs	r2, #48	; 0x30
 801524c:	2a09      	cmp	r2, #9
 801524e:	d94e      	bls.n	80152ee <_svfiprintf_r+0x17a>
 8015250:	2900      	cmp	r1, #0
 8015252:	d111      	bne.n	8015278 <_svfiprintf_r+0x104>
 8015254:	e017      	b.n	8015286 <_svfiprintf_r+0x112>
 8015256:	3501      	adds	r5, #1
 8015258:	e7b0      	b.n	80151bc <_svfiprintf_r+0x48>
 801525a:	4b41      	ldr	r3, [pc, #260]	; (8015360 <_svfiprintf_r+0x1ec>)
 801525c:	6822      	ldr	r2, [r4, #0]
 801525e:	1ac0      	subs	r0, r0, r3
 8015260:	2301      	movs	r3, #1
 8015262:	4083      	lsls	r3, r0
 8015264:	4313      	orrs	r3, r2
 8015266:	002e      	movs	r6, r5
 8015268:	6023      	str	r3, [r4, #0]
 801526a:	e7ce      	b.n	801520a <_svfiprintf_r+0x96>
 801526c:	9b07      	ldr	r3, [sp, #28]
 801526e:	1d19      	adds	r1, r3, #4
 8015270:	681b      	ldr	r3, [r3, #0]
 8015272:	9107      	str	r1, [sp, #28]
 8015274:	2b00      	cmp	r3, #0
 8015276:	db01      	blt.n	801527c <_svfiprintf_r+0x108>
 8015278:	930b      	str	r3, [sp, #44]	; 0x2c
 801527a:	e004      	b.n	8015286 <_svfiprintf_r+0x112>
 801527c:	425b      	negs	r3, r3
 801527e:	60e3      	str	r3, [r4, #12]
 8015280:	2302      	movs	r3, #2
 8015282:	4313      	orrs	r3, r2
 8015284:	6023      	str	r3, [r4, #0]
 8015286:	782b      	ldrb	r3, [r5, #0]
 8015288:	2b2e      	cmp	r3, #46	; 0x2e
 801528a:	d10a      	bne.n	80152a2 <_svfiprintf_r+0x12e>
 801528c:	786b      	ldrb	r3, [r5, #1]
 801528e:	2b2a      	cmp	r3, #42	; 0x2a
 8015290:	d135      	bne.n	80152fe <_svfiprintf_r+0x18a>
 8015292:	9b07      	ldr	r3, [sp, #28]
 8015294:	3502      	adds	r5, #2
 8015296:	1d1a      	adds	r2, r3, #4
 8015298:	681b      	ldr	r3, [r3, #0]
 801529a:	9207      	str	r2, [sp, #28]
 801529c:	2b00      	cmp	r3, #0
 801529e:	db2b      	blt.n	80152f8 <_svfiprintf_r+0x184>
 80152a0:	9309      	str	r3, [sp, #36]	; 0x24
 80152a2:	4e30      	ldr	r6, [pc, #192]	; (8015364 <_svfiprintf_r+0x1f0>)
 80152a4:	2203      	movs	r2, #3
 80152a6:	0030      	movs	r0, r6
 80152a8:	7829      	ldrb	r1, [r5, #0]
 80152aa:	f000 f9e5 	bl	8015678 <memchr>
 80152ae:	2800      	cmp	r0, #0
 80152b0:	d006      	beq.n	80152c0 <_svfiprintf_r+0x14c>
 80152b2:	2340      	movs	r3, #64	; 0x40
 80152b4:	1b80      	subs	r0, r0, r6
 80152b6:	4083      	lsls	r3, r0
 80152b8:	6822      	ldr	r2, [r4, #0]
 80152ba:	3501      	adds	r5, #1
 80152bc:	4313      	orrs	r3, r2
 80152be:	6023      	str	r3, [r4, #0]
 80152c0:	7829      	ldrb	r1, [r5, #0]
 80152c2:	2206      	movs	r2, #6
 80152c4:	4828      	ldr	r0, [pc, #160]	; (8015368 <_svfiprintf_r+0x1f4>)
 80152c6:	1c6e      	adds	r6, r5, #1
 80152c8:	7621      	strb	r1, [r4, #24]
 80152ca:	f000 f9d5 	bl	8015678 <memchr>
 80152ce:	2800      	cmp	r0, #0
 80152d0:	d03c      	beq.n	801534c <_svfiprintf_r+0x1d8>
 80152d2:	4b26      	ldr	r3, [pc, #152]	; (801536c <_svfiprintf_r+0x1f8>)
 80152d4:	2b00      	cmp	r3, #0
 80152d6:	d125      	bne.n	8015324 <_svfiprintf_r+0x1b0>
 80152d8:	2207      	movs	r2, #7
 80152da:	9b07      	ldr	r3, [sp, #28]
 80152dc:	3307      	adds	r3, #7
 80152de:	4393      	bics	r3, r2
 80152e0:	3308      	adds	r3, #8
 80152e2:	9307      	str	r3, [sp, #28]
 80152e4:	6963      	ldr	r3, [r4, #20]
 80152e6:	9a04      	ldr	r2, [sp, #16]
 80152e8:	189b      	adds	r3, r3, r2
 80152ea:	6163      	str	r3, [r4, #20]
 80152ec:	e765      	b.n	80151ba <_svfiprintf_r+0x46>
 80152ee:	4343      	muls	r3, r0
 80152f0:	0035      	movs	r5, r6
 80152f2:	2101      	movs	r1, #1
 80152f4:	189b      	adds	r3, r3, r2
 80152f6:	e7a6      	b.n	8015246 <_svfiprintf_r+0xd2>
 80152f8:	2301      	movs	r3, #1
 80152fa:	425b      	negs	r3, r3
 80152fc:	e7d0      	b.n	80152a0 <_svfiprintf_r+0x12c>
 80152fe:	2300      	movs	r3, #0
 8015300:	200a      	movs	r0, #10
 8015302:	001a      	movs	r2, r3
 8015304:	3501      	adds	r5, #1
 8015306:	6063      	str	r3, [r4, #4]
 8015308:	7829      	ldrb	r1, [r5, #0]
 801530a:	1c6e      	adds	r6, r5, #1
 801530c:	3930      	subs	r1, #48	; 0x30
 801530e:	2909      	cmp	r1, #9
 8015310:	d903      	bls.n	801531a <_svfiprintf_r+0x1a6>
 8015312:	2b00      	cmp	r3, #0
 8015314:	d0c5      	beq.n	80152a2 <_svfiprintf_r+0x12e>
 8015316:	9209      	str	r2, [sp, #36]	; 0x24
 8015318:	e7c3      	b.n	80152a2 <_svfiprintf_r+0x12e>
 801531a:	4342      	muls	r2, r0
 801531c:	0035      	movs	r5, r6
 801531e:	2301      	movs	r3, #1
 8015320:	1852      	adds	r2, r2, r1
 8015322:	e7f1      	b.n	8015308 <_svfiprintf_r+0x194>
 8015324:	ab07      	add	r3, sp, #28
 8015326:	9300      	str	r3, [sp, #0]
 8015328:	003a      	movs	r2, r7
 801532a:	0021      	movs	r1, r4
 801532c:	4b10      	ldr	r3, [pc, #64]	; (8015370 <_svfiprintf_r+0x1fc>)
 801532e:	9803      	ldr	r0, [sp, #12]
 8015330:	e000      	b.n	8015334 <_svfiprintf_r+0x1c0>
 8015332:	bf00      	nop
 8015334:	9004      	str	r0, [sp, #16]
 8015336:	9b04      	ldr	r3, [sp, #16]
 8015338:	3301      	adds	r3, #1
 801533a:	d1d3      	bne.n	80152e4 <_svfiprintf_r+0x170>
 801533c:	89bb      	ldrh	r3, [r7, #12]
 801533e:	980d      	ldr	r0, [sp, #52]	; 0x34
 8015340:	065b      	lsls	r3, r3, #25
 8015342:	d400      	bmi.n	8015346 <_svfiprintf_r+0x1d2>
 8015344:	e72d      	b.n	80151a2 <_svfiprintf_r+0x2e>
 8015346:	2001      	movs	r0, #1
 8015348:	4240      	negs	r0, r0
 801534a:	e72a      	b.n	80151a2 <_svfiprintf_r+0x2e>
 801534c:	ab07      	add	r3, sp, #28
 801534e:	9300      	str	r3, [sp, #0]
 8015350:	003a      	movs	r2, r7
 8015352:	0021      	movs	r1, r4
 8015354:	4b06      	ldr	r3, [pc, #24]	; (8015370 <_svfiprintf_r+0x1fc>)
 8015356:	9803      	ldr	r0, [sp, #12]
 8015358:	f000 f87c 	bl	8015454 <_printf_i>
 801535c:	e7ea      	b.n	8015334 <_svfiprintf_r+0x1c0>
 801535e:	46c0      	nop			; (mov r8, r8)
 8015360:	08015e44 	.word	0x08015e44
 8015364:	08015e4a 	.word	0x08015e4a
 8015368:	08015e4e 	.word	0x08015e4e
 801536c:	00000000 	.word	0x00000000
 8015370:	080150b1 	.word	0x080150b1

08015374 <_printf_common>:
 8015374:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8015376:	0015      	movs	r5, r2
 8015378:	9301      	str	r3, [sp, #4]
 801537a:	688a      	ldr	r2, [r1, #8]
 801537c:	690b      	ldr	r3, [r1, #16]
 801537e:	000c      	movs	r4, r1
 8015380:	9000      	str	r0, [sp, #0]
 8015382:	4293      	cmp	r3, r2
 8015384:	da00      	bge.n	8015388 <_printf_common+0x14>
 8015386:	0013      	movs	r3, r2
 8015388:	0022      	movs	r2, r4
 801538a:	602b      	str	r3, [r5, #0]
 801538c:	3243      	adds	r2, #67	; 0x43
 801538e:	7812      	ldrb	r2, [r2, #0]
 8015390:	2a00      	cmp	r2, #0
 8015392:	d001      	beq.n	8015398 <_printf_common+0x24>
 8015394:	3301      	adds	r3, #1
 8015396:	602b      	str	r3, [r5, #0]
 8015398:	6823      	ldr	r3, [r4, #0]
 801539a:	069b      	lsls	r3, r3, #26
 801539c:	d502      	bpl.n	80153a4 <_printf_common+0x30>
 801539e:	682b      	ldr	r3, [r5, #0]
 80153a0:	3302      	adds	r3, #2
 80153a2:	602b      	str	r3, [r5, #0]
 80153a4:	6822      	ldr	r2, [r4, #0]
 80153a6:	2306      	movs	r3, #6
 80153a8:	0017      	movs	r7, r2
 80153aa:	401f      	ands	r7, r3
 80153ac:	421a      	tst	r2, r3
 80153ae:	d027      	beq.n	8015400 <_printf_common+0x8c>
 80153b0:	0023      	movs	r3, r4
 80153b2:	3343      	adds	r3, #67	; 0x43
 80153b4:	781b      	ldrb	r3, [r3, #0]
 80153b6:	1e5a      	subs	r2, r3, #1
 80153b8:	4193      	sbcs	r3, r2
 80153ba:	6822      	ldr	r2, [r4, #0]
 80153bc:	0692      	lsls	r2, r2, #26
 80153be:	d430      	bmi.n	8015422 <_printf_common+0xae>
 80153c0:	0022      	movs	r2, r4
 80153c2:	9901      	ldr	r1, [sp, #4]
 80153c4:	9800      	ldr	r0, [sp, #0]
 80153c6:	9e08      	ldr	r6, [sp, #32]
 80153c8:	3243      	adds	r2, #67	; 0x43
 80153ca:	47b0      	blx	r6
 80153cc:	1c43      	adds	r3, r0, #1
 80153ce:	d025      	beq.n	801541c <_printf_common+0xa8>
 80153d0:	2306      	movs	r3, #6
 80153d2:	6820      	ldr	r0, [r4, #0]
 80153d4:	682a      	ldr	r2, [r5, #0]
 80153d6:	68e1      	ldr	r1, [r4, #12]
 80153d8:	2500      	movs	r5, #0
 80153da:	4003      	ands	r3, r0
 80153dc:	2b04      	cmp	r3, #4
 80153de:	d103      	bne.n	80153e8 <_printf_common+0x74>
 80153e0:	1a8d      	subs	r5, r1, r2
 80153e2:	43eb      	mvns	r3, r5
 80153e4:	17db      	asrs	r3, r3, #31
 80153e6:	401d      	ands	r5, r3
 80153e8:	68a3      	ldr	r3, [r4, #8]
 80153ea:	6922      	ldr	r2, [r4, #16]
 80153ec:	4293      	cmp	r3, r2
 80153ee:	dd01      	ble.n	80153f4 <_printf_common+0x80>
 80153f0:	1a9b      	subs	r3, r3, r2
 80153f2:	18ed      	adds	r5, r5, r3
 80153f4:	2700      	movs	r7, #0
 80153f6:	42bd      	cmp	r5, r7
 80153f8:	d120      	bne.n	801543c <_printf_common+0xc8>
 80153fa:	2000      	movs	r0, #0
 80153fc:	e010      	b.n	8015420 <_printf_common+0xac>
 80153fe:	3701      	adds	r7, #1
 8015400:	68e3      	ldr	r3, [r4, #12]
 8015402:	682a      	ldr	r2, [r5, #0]
 8015404:	1a9b      	subs	r3, r3, r2
 8015406:	42bb      	cmp	r3, r7
 8015408:	ddd2      	ble.n	80153b0 <_printf_common+0x3c>
 801540a:	0022      	movs	r2, r4
 801540c:	2301      	movs	r3, #1
 801540e:	9901      	ldr	r1, [sp, #4]
 8015410:	9800      	ldr	r0, [sp, #0]
 8015412:	9e08      	ldr	r6, [sp, #32]
 8015414:	3219      	adds	r2, #25
 8015416:	47b0      	blx	r6
 8015418:	1c43      	adds	r3, r0, #1
 801541a:	d1f0      	bne.n	80153fe <_printf_common+0x8a>
 801541c:	2001      	movs	r0, #1
 801541e:	4240      	negs	r0, r0
 8015420:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 8015422:	2030      	movs	r0, #48	; 0x30
 8015424:	18e1      	adds	r1, r4, r3
 8015426:	3143      	adds	r1, #67	; 0x43
 8015428:	7008      	strb	r0, [r1, #0]
 801542a:	0021      	movs	r1, r4
 801542c:	1c5a      	adds	r2, r3, #1
 801542e:	3145      	adds	r1, #69	; 0x45
 8015430:	7809      	ldrb	r1, [r1, #0]
 8015432:	18a2      	adds	r2, r4, r2
 8015434:	3243      	adds	r2, #67	; 0x43
 8015436:	3302      	adds	r3, #2
 8015438:	7011      	strb	r1, [r2, #0]
 801543a:	e7c1      	b.n	80153c0 <_printf_common+0x4c>
 801543c:	0022      	movs	r2, r4
 801543e:	2301      	movs	r3, #1
 8015440:	9901      	ldr	r1, [sp, #4]
 8015442:	9800      	ldr	r0, [sp, #0]
 8015444:	9e08      	ldr	r6, [sp, #32]
 8015446:	321a      	adds	r2, #26
 8015448:	47b0      	blx	r6
 801544a:	1c43      	adds	r3, r0, #1
 801544c:	d0e6      	beq.n	801541c <_printf_common+0xa8>
 801544e:	3701      	adds	r7, #1
 8015450:	e7d1      	b.n	80153f6 <_printf_common+0x82>
	...

08015454 <_printf_i>:
 8015454:	b5f0      	push	{r4, r5, r6, r7, lr}
 8015456:	b08b      	sub	sp, #44	; 0x2c
 8015458:	9206      	str	r2, [sp, #24]
 801545a:	000a      	movs	r2, r1
 801545c:	3243      	adds	r2, #67	; 0x43
 801545e:	9307      	str	r3, [sp, #28]
 8015460:	9005      	str	r0, [sp, #20]
 8015462:	9204      	str	r2, [sp, #16]
 8015464:	7e0a      	ldrb	r2, [r1, #24]
 8015466:	000c      	movs	r4, r1
 8015468:	9b10      	ldr	r3, [sp, #64]	; 0x40
 801546a:	2a78      	cmp	r2, #120	; 0x78
 801546c:	d806      	bhi.n	801547c <_printf_i+0x28>
 801546e:	2a62      	cmp	r2, #98	; 0x62
 8015470:	d808      	bhi.n	8015484 <_printf_i+0x30>
 8015472:	2a00      	cmp	r2, #0
 8015474:	d100      	bne.n	8015478 <_printf_i+0x24>
 8015476:	e0c0      	b.n	80155fa <_printf_i+0x1a6>
 8015478:	2a58      	cmp	r2, #88	; 0x58
 801547a:	d052      	beq.n	8015522 <_printf_i+0xce>
 801547c:	0026      	movs	r6, r4
 801547e:	3642      	adds	r6, #66	; 0x42
 8015480:	7032      	strb	r2, [r6, #0]
 8015482:	e022      	b.n	80154ca <_printf_i+0x76>
 8015484:	0010      	movs	r0, r2
 8015486:	3863      	subs	r0, #99	; 0x63
 8015488:	2815      	cmp	r0, #21
 801548a:	d8f7      	bhi.n	801547c <_printf_i+0x28>
 801548c:	f7f3 fe44 	bl	8009118 <__gnu_thumb1_case_shi>
 8015490:	001f0016 	.word	0x001f0016
 8015494:	fff6fff6 	.word	0xfff6fff6
 8015498:	fff6fff6 	.word	0xfff6fff6
 801549c:	fff6001f 	.word	0xfff6001f
 80154a0:	fff6fff6 	.word	0xfff6fff6
 80154a4:	00a8fff6 	.word	0x00a8fff6
 80154a8:	009a0036 	.word	0x009a0036
 80154ac:	fff6fff6 	.word	0xfff6fff6
 80154b0:	fff600b9 	.word	0xfff600b9
 80154b4:	fff60036 	.word	0xfff60036
 80154b8:	009efff6 	.word	0x009efff6
 80154bc:	0026      	movs	r6, r4
 80154be:	681a      	ldr	r2, [r3, #0]
 80154c0:	3642      	adds	r6, #66	; 0x42
 80154c2:	1d11      	adds	r1, r2, #4
 80154c4:	6019      	str	r1, [r3, #0]
 80154c6:	6813      	ldr	r3, [r2, #0]
 80154c8:	7033      	strb	r3, [r6, #0]
 80154ca:	2301      	movs	r3, #1
 80154cc:	e0a7      	b.n	801561e <_printf_i+0x1ca>
 80154ce:	6808      	ldr	r0, [r1, #0]
 80154d0:	6819      	ldr	r1, [r3, #0]
 80154d2:	1d0a      	adds	r2, r1, #4
 80154d4:	0605      	lsls	r5, r0, #24
 80154d6:	d50b      	bpl.n	80154f0 <_printf_i+0x9c>
 80154d8:	680d      	ldr	r5, [r1, #0]
 80154da:	601a      	str	r2, [r3, #0]
 80154dc:	2d00      	cmp	r5, #0
 80154de:	da03      	bge.n	80154e8 <_printf_i+0x94>
 80154e0:	232d      	movs	r3, #45	; 0x2d
 80154e2:	9a04      	ldr	r2, [sp, #16]
 80154e4:	426d      	negs	r5, r5
 80154e6:	7013      	strb	r3, [r2, #0]
 80154e8:	4b61      	ldr	r3, [pc, #388]	; (8015670 <_printf_i+0x21c>)
 80154ea:	270a      	movs	r7, #10
 80154ec:	9303      	str	r3, [sp, #12]
 80154ee:	e032      	b.n	8015556 <_printf_i+0x102>
 80154f0:	680d      	ldr	r5, [r1, #0]
 80154f2:	601a      	str	r2, [r3, #0]
 80154f4:	0641      	lsls	r1, r0, #25
 80154f6:	d5f1      	bpl.n	80154dc <_printf_i+0x88>
 80154f8:	b22d      	sxth	r5, r5
 80154fa:	e7ef      	b.n	80154dc <_printf_i+0x88>
 80154fc:	680d      	ldr	r5, [r1, #0]
 80154fe:	6819      	ldr	r1, [r3, #0]
 8015500:	1d08      	adds	r0, r1, #4
 8015502:	6018      	str	r0, [r3, #0]
 8015504:	062e      	lsls	r6, r5, #24
 8015506:	d501      	bpl.n	801550c <_printf_i+0xb8>
 8015508:	680d      	ldr	r5, [r1, #0]
 801550a:	e003      	b.n	8015514 <_printf_i+0xc0>
 801550c:	066d      	lsls	r5, r5, #25
 801550e:	d5fb      	bpl.n	8015508 <_printf_i+0xb4>
 8015510:	680d      	ldr	r5, [r1, #0]
 8015512:	b2ad      	uxth	r5, r5
 8015514:	4b56      	ldr	r3, [pc, #344]	; (8015670 <_printf_i+0x21c>)
 8015516:	270a      	movs	r7, #10
 8015518:	9303      	str	r3, [sp, #12]
 801551a:	2a6f      	cmp	r2, #111	; 0x6f
 801551c:	d117      	bne.n	801554e <_printf_i+0xfa>
 801551e:	2708      	movs	r7, #8
 8015520:	e015      	b.n	801554e <_printf_i+0xfa>
 8015522:	3145      	adds	r1, #69	; 0x45
 8015524:	700a      	strb	r2, [r1, #0]
 8015526:	4a52      	ldr	r2, [pc, #328]	; (8015670 <_printf_i+0x21c>)
 8015528:	9203      	str	r2, [sp, #12]
 801552a:	681a      	ldr	r2, [r3, #0]
 801552c:	6821      	ldr	r1, [r4, #0]
 801552e:	ca20      	ldmia	r2!, {r5}
 8015530:	601a      	str	r2, [r3, #0]
 8015532:	0608      	lsls	r0, r1, #24
 8015534:	d550      	bpl.n	80155d8 <_printf_i+0x184>
 8015536:	07cb      	lsls	r3, r1, #31
 8015538:	d502      	bpl.n	8015540 <_printf_i+0xec>
 801553a:	2320      	movs	r3, #32
 801553c:	4319      	orrs	r1, r3
 801553e:	6021      	str	r1, [r4, #0]
 8015540:	2710      	movs	r7, #16
 8015542:	2d00      	cmp	r5, #0
 8015544:	d103      	bne.n	801554e <_printf_i+0xfa>
 8015546:	2320      	movs	r3, #32
 8015548:	6822      	ldr	r2, [r4, #0]
 801554a:	439a      	bics	r2, r3
 801554c:	6022      	str	r2, [r4, #0]
 801554e:	0023      	movs	r3, r4
 8015550:	2200      	movs	r2, #0
 8015552:	3343      	adds	r3, #67	; 0x43
 8015554:	701a      	strb	r2, [r3, #0]
 8015556:	6863      	ldr	r3, [r4, #4]
 8015558:	60a3      	str	r3, [r4, #8]
 801555a:	2b00      	cmp	r3, #0
 801555c:	db03      	blt.n	8015566 <_printf_i+0x112>
 801555e:	2204      	movs	r2, #4
 8015560:	6821      	ldr	r1, [r4, #0]
 8015562:	4391      	bics	r1, r2
 8015564:	6021      	str	r1, [r4, #0]
 8015566:	2d00      	cmp	r5, #0
 8015568:	d102      	bne.n	8015570 <_printf_i+0x11c>
 801556a:	9e04      	ldr	r6, [sp, #16]
 801556c:	2b00      	cmp	r3, #0
 801556e:	d00c      	beq.n	801558a <_printf_i+0x136>
 8015570:	9e04      	ldr	r6, [sp, #16]
 8015572:	0028      	movs	r0, r5
 8015574:	0039      	movs	r1, r7
 8015576:	f7f3 fe5f 	bl	8009238 <__aeabi_uidivmod>
 801557a:	9b03      	ldr	r3, [sp, #12]
 801557c:	3e01      	subs	r6, #1
 801557e:	5c5b      	ldrb	r3, [r3, r1]
 8015580:	7033      	strb	r3, [r6, #0]
 8015582:	002b      	movs	r3, r5
 8015584:	0005      	movs	r5, r0
 8015586:	429f      	cmp	r7, r3
 8015588:	d9f3      	bls.n	8015572 <_printf_i+0x11e>
 801558a:	2f08      	cmp	r7, #8
 801558c:	d109      	bne.n	80155a2 <_printf_i+0x14e>
 801558e:	6823      	ldr	r3, [r4, #0]
 8015590:	07db      	lsls	r3, r3, #31
 8015592:	d506      	bpl.n	80155a2 <_printf_i+0x14e>
 8015594:	6863      	ldr	r3, [r4, #4]
 8015596:	6922      	ldr	r2, [r4, #16]
 8015598:	4293      	cmp	r3, r2
 801559a:	dc02      	bgt.n	80155a2 <_printf_i+0x14e>
 801559c:	2330      	movs	r3, #48	; 0x30
 801559e:	3e01      	subs	r6, #1
 80155a0:	7033      	strb	r3, [r6, #0]
 80155a2:	9b04      	ldr	r3, [sp, #16]
 80155a4:	1b9b      	subs	r3, r3, r6
 80155a6:	6123      	str	r3, [r4, #16]
 80155a8:	9b07      	ldr	r3, [sp, #28]
 80155aa:	0021      	movs	r1, r4
 80155ac:	9300      	str	r3, [sp, #0]
 80155ae:	9805      	ldr	r0, [sp, #20]
 80155b0:	9b06      	ldr	r3, [sp, #24]
 80155b2:	aa09      	add	r2, sp, #36	; 0x24
 80155b4:	f7ff fede 	bl	8015374 <_printf_common>
 80155b8:	1c43      	adds	r3, r0, #1
 80155ba:	d135      	bne.n	8015628 <_printf_i+0x1d4>
 80155bc:	2001      	movs	r0, #1
 80155be:	4240      	negs	r0, r0
 80155c0:	b00b      	add	sp, #44	; 0x2c
 80155c2:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80155c4:	2220      	movs	r2, #32
 80155c6:	6809      	ldr	r1, [r1, #0]
 80155c8:	430a      	orrs	r2, r1
 80155ca:	6022      	str	r2, [r4, #0]
 80155cc:	0022      	movs	r2, r4
 80155ce:	2178      	movs	r1, #120	; 0x78
 80155d0:	3245      	adds	r2, #69	; 0x45
 80155d2:	7011      	strb	r1, [r2, #0]
 80155d4:	4a27      	ldr	r2, [pc, #156]	; (8015674 <_printf_i+0x220>)
 80155d6:	e7a7      	b.n	8015528 <_printf_i+0xd4>
 80155d8:	0648      	lsls	r0, r1, #25
 80155da:	d5ac      	bpl.n	8015536 <_printf_i+0xe2>
 80155dc:	b2ad      	uxth	r5, r5
 80155de:	e7aa      	b.n	8015536 <_printf_i+0xe2>
 80155e0:	681a      	ldr	r2, [r3, #0]
 80155e2:	680d      	ldr	r5, [r1, #0]
 80155e4:	1d10      	adds	r0, r2, #4
 80155e6:	6949      	ldr	r1, [r1, #20]
 80155e8:	6018      	str	r0, [r3, #0]
 80155ea:	6813      	ldr	r3, [r2, #0]
 80155ec:	062e      	lsls	r6, r5, #24
 80155ee:	d501      	bpl.n	80155f4 <_printf_i+0x1a0>
 80155f0:	6019      	str	r1, [r3, #0]
 80155f2:	e002      	b.n	80155fa <_printf_i+0x1a6>
 80155f4:	066d      	lsls	r5, r5, #25
 80155f6:	d5fb      	bpl.n	80155f0 <_printf_i+0x19c>
 80155f8:	8019      	strh	r1, [r3, #0]
 80155fa:	2300      	movs	r3, #0
 80155fc:	9e04      	ldr	r6, [sp, #16]
 80155fe:	6123      	str	r3, [r4, #16]
 8015600:	e7d2      	b.n	80155a8 <_printf_i+0x154>
 8015602:	681a      	ldr	r2, [r3, #0]
 8015604:	1d11      	adds	r1, r2, #4
 8015606:	6019      	str	r1, [r3, #0]
 8015608:	6816      	ldr	r6, [r2, #0]
 801560a:	2100      	movs	r1, #0
 801560c:	0030      	movs	r0, r6
 801560e:	6862      	ldr	r2, [r4, #4]
 8015610:	f000 f832 	bl	8015678 <memchr>
 8015614:	2800      	cmp	r0, #0
 8015616:	d001      	beq.n	801561c <_printf_i+0x1c8>
 8015618:	1b80      	subs	r0, r0, r6
 801561a:	6060      	str	r0, [r4, #4]
 801561c:	6863      	ldr	r3, [r4, #4]
 801561e:	6123      	str	r3, [r4, #16]
 8015620:	2300      	movs	r3, #0
 8015622:	9a04      	ldr	r2, [sp, #16]
 8015624:	7013      	strb	r3, [r2, #0]
 8015626:	e7bf      	b.n	80155a8 <_printf_i+0x154>
 8015628:	6923      	ldr	r3, [r4, #16]
 801562a:	0032      	movs	r2, r6
 801562c:	9906      	ldr	r1, [sp, #24]
 801562e:	9805      	ldr	r0, [sp, #20]
 8015630:	9d07      	ldr	r5, [sp, #28]
 8015632:	47a8      	blx	r5
 8015634:	1c43      	adds	r3, r0, #1
 8015636:	d0c1      	beq.n	80155bc <_printf_i+0x168>
 8015638:	6823      	ldr	r3, [r4, #0]
 801563a:	079b      	lsls	r3, r3, #30
 801563c:	d415      	bmi.n	801566a <_printf_i+0x216>
 801563e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8015640:	68e0      	ldr	r0, [r4, #12]
 8015642:	4298      	cmp	r0, r3
 8015644:	dabc      	bge.n	80155c0 <_printf_i+0x16c>
 8015646:	0018      	movs	r0, r3
 8015648:	e7ba      	b.n	80155c0 <_printf_i+0x16c>
 801564a:	0022      	movs	r2, r4
 801564c:	2301      	movs	r3, #1
 801564e:	9906      	ldr	r1, [sp, #24]
 8015650:	9805      	ldr	r0, [sp, #20]
 8015652:	9e07      	ldr	r6, [sp, #28]
 8015654:	3219      	adds	r2, #25
 8015656:	47b0      	blx	r6
 8015658:	1c43      	adds	r3, r0, #1
 801565a:	d0af      	beq.n	80155bc <_printf_i+0x168>
 801565c:	3501      	adds	r5, #1
 801565e:	68e3      	ldr	r3, [r4, #12]
 8015660:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8015662:	1a9b      	subs	r3, r3, r2
 8015664:	42ab      	cmp	r3, r5
 8015666:	dcf0      	bgt.n	801564a <_printf_i+0x1f6>
 8015668:	e7e9      	b.n	801563e <_printf_i+0x1ea>
 801566a:	2500      	movs	r5, #0
 801566c:	e7f7      	b.n	801565e <_printf_i+0x20a>
 801566e:	46c0      	nop			; (mov r8, r8)
 8015670:	08015e55 	.word	0x08015e55
 8015674:	08015e66 	.word	0x08015e66

08015678 <memchr>:
 8015678:	b2c9      	uxtb	r1, r1
 801567a:	1882      	adds	r2, r0, r2
 801567c:	4290      	cmp	r0, r2
 801567e:	d101      	bne.n	8015684 <memchr+0xc>
 8015680:	2000      	movs	r0, #0
 8015682:	4770      	bx	lr
 8015684:	7803      	ldrb	r3, [r0, #0]
 8015686:	428b      	cmp	r3, r1
 8015688:	d0fb      	beq.n	8015682 <memchr+0xa>
 801568a:	3001      	adds	r0, #1
 801568c:	e7f6      	b.n	801567c <memchr+0x4>

0801568e <memmove>:
 801568e:	b510      	push	{r4, lr}
 8015690:	4288      	cmp	r0, r1
 8015692:	d902      	bls.n	801569a <memmove+0xc>
 8015694:	188b      	adds	r3, r1, r2
 8015696:	4298      	cmp	r0, r3
 8015698:	d303      	bcc.n	80156a2 <memmove+0x14>
 801569a:	2300      	movs	r3, #0
 801569c:	e007      	b.n	80156ae <memmove+0x20>
 801569e:	5c8b      	ldrb	r3, [r1, r2]
 80156a0:	5483      	strb	r3, [r0, r2]
 80156a2:	3a01      	subs	r2, #1
 80156a4:	d2fb      	bcs.n	801569e <memmove+0x10>
 80156a6:	bd10      	pop	{r4, pc}
 80156a8:	5ccc      	ldrb	r4, [r1, r3]
 80156aa:	54c4      	strb	r4, [r0, r3]
 80156ac:	3301      	adds	r3, #1
 80156ae:	429a      	cmp	r2, r3
 80156b0:	d1fa      	bne.n	80156a8 <memmove+0x1a>
 80156b2:	e7f8      	b.n	80156a6 <memmove+0x18>

080156b4 <_free_r>:
 80156b4:	b570      	push	{r4, r5, r6, lr}
 80156b6:	0005      	movs	r5, r0
 80156b8:	2900      	cmp	r1, #0
 80156ba:	d010      	beq.n	80156de <_free_r+0x2a>
 80156bc:	1f0c      	subs	r4, r1, #4
 80156be:	6823      	ldr	r3, [r4, #0]
 80156c0:	2b00      	cmp	r3, #0
 80156c2:	da00      	bge.n	80156c6 <_free_r+0x12>
 80156c4:	18e4      	adds	r4, r4, r3
 80156c6:	0028      	movs	r0, r5
 80156c8:	f000 f8d4 	bl	8015874 <__malloc_lock>
 80156cc:	4a1d      	ldr	r2, [pc, #116]	; (8015744 <_free_r+0x90>)
 80156ce:	6813      	ldr	r3, [r2, #0]
 80156d0:	2b00      	cmp	r3, #0
 80156d2:	d105      	bne.n	80156e0 <_free_r+0x2c>
 80156d4:	6063      	str	r3, [r4, #4]
 80156d6:	6014      	str	r4, [r2, #0]
 80156d8:	0028      	movs	r0, r5
 80156da:	f000 f8d3 	bl	8015884 <__malloc_unlock>
 80156de:	bd70      	pop	{r4, r5, r6, pc}
 80156e0:	42a3      	cmp	r3, r4
 80156e2:	d908      	bls.n	80156f6 <_free_r+0x42>
 80156e4:	6821      	ldr	r1, [r4, #0]
 80156e6:	1860      	adds	r0, r4, r1
 80156e8:	4283      	cmp	r3, r0
 80156ea:	d1f3      	bne.n	80156d4 <_free_r+0x20>
 80156ec:	6818      	ldr	r0, [r3, #0]
 80156ee:	685b      	ldr	r3, [r3, #4]
 80156f0:	1841      	adds	r1, r0, r1
 80156f2:	6021      	str	r1, [r4, #0]
 80156f4:	e7ee      	b.n	80156d4 <_free_r+0x20>
 80156f6:	001a      	movs	r2, r3
 80156f8:	685b      	ldr	r3, [r3, #4]
 80156fa:	2b00      	cmp	r3, #0
 80156fc:	d001      	beq.n	8015702 <_free_r+0x4e>
 80156fe:	42a3      	cmp	r3, r4
 8015700:	d9f9      	bls.n	80156f6 <_free_r+0x42>
 8015702:	6811      	ldr	r1, [r2, #0]
 8015704:	1850      	adds	r0, r2, r1
 8015706:	42a0      	cmp	r0, r4
 8015708:	d10b      	bne.n	8015722 <_free_r+0x6e>
 801570a:	6820      	ldr	r0, [r4, #0]
 801570c:	1809      	adds	r1, r1, r0
 801570e:	1850      	adds	r0, r2, r1
 8015710:	6011      	str	r1, [r2, #0]
 8015712:	4283      	cmp	r3, r0
 8015714:	d1e0      	bne.n	80156d8 <_free_r+0x24>
 8015716:	6818      	ldr	r0, [r3, #0]
 8015718:	685b      	ldr	r3, [r3, #4]
 801571a:	1841      	adds	r1, r0, r1
 801571c:	6011      	str	r1, [r2, #0]
 801571e:	6053      	str	r3, [r2, #4]
 8015720:	e7da      	b.n	80156d8 <_free_r+0x24>
 8015722:	42a0      	cmp	r0, r4
 8015724:	d902      	bls.n	801572c <_free_r+0x78>
 8015726:	230c      	movs	r3, #12
 8015728:	602b      	str	r3, [r5, #0]
 801572a:	e7d5      	b.n	80156d8 <_free_r+0x24>
 801572c:	6821      	ldr	r1, [r4, #0]
 801572e:	1860      	adds	r0, r4, r1
 8015730:	4283      	cmp	r3, r0
 8015732:	d103      	bne.n	801573c <_free_r+0x88>
 8015734:	6818      	ldr	r0, [r3, #0]
 8015736:	685b      	ldr	r3, [r3, #4]
 8015738:	1841      	adds	r1, r0, r1
 801573a:	6021      	str	r1, [r4, #0]
 801573c:	6063      	str	r3, [r4, #4]
 801573e:	6054      	str	r4, [r2, #4]
 8015740:	e7ca      	b.n	80156d8 <_free_r+0x24>
 8015742:	46c0      	nop			; (mov r8, r8)
 8015744:	20001534 	.word	0x20001534

08015748 <_malloc_r>:
 8015748:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801574a:	2303      	movs	r3, #3
 801574c:	1ccd      	adds	r5, r1, #3
 801574e:	439d      	bics	r5, r3
 8015750:	3508      	adds	r5, #8
 8015752:	0006      	movs	r6, r0
 8015754:	2d0c      	cmp	r5, #12
 8015756:	d21f      	bcs.n	8015798 <_malloc_r+0x50>
 8015758:	250c      	movs	r5, #12
 801575a:	42a9      	cmp	r1, r5
 801575c:	d81e      	bhi.n	801579c <_malloc_r+0x54>
 801575e:	0030      	movs	r0, r6
 8015760:	f000 f888 	bl	8015874 <__malloc_lock>
 8015764:	4925      	ldr	r1, [pc, #148]	; (80157fc <_malloc_r+0xb4>)
 8015766:	680a      	ldr	r2, [r1, #0]
 8015768:	0014      	movs	r4, r2
 801576a:	2c00      	cmp	r4, #0
 801576c:	d11a      	bne.n	80157a4 <_malloc_r+0x5c>
 801576e:	4f24      	ldr	r7, [pc, #144]	; (8015800 <_malloc_r+0xb8>)
 8015770:	683b      	ldr	r3, [r7, #0]
 8015772:	2b00      	cmp	r3, #0
 8015774:	d104      	bne.n	8015780 <_malloc_r+0x38>
 8015776:	0021      	movs	r1, r4
 8015778:	0030      	movs	r0, r6
 801577a:	f000 f869 	bl	8015850 <_sbrk_r>
 801577e:	6038      	str	r0, [r7, #0]
 8015780:	0029      	movs	r1, r5
 8015782:	0030      	movs	r0, r6
 8015784:	f000 f864 	bl	8015850 <_sbrk_r>
 8015788:	1c43      	adds	r3, r0, #1
 801578a:	d12b      	bne.n	80157e4 <_malloc_r+0x9c>
 801578c:	230c      	movs	r3, #12
 801578e:	0030      	movs	r0, r6
 8015790:	6033      	str	r3, [r6, #0]
 8015792:	f000 f877 	bl	8015884 <__malloc_unlock>
 8015796:	e003      	b.n	80157a0 <_malloc_r+0x58>
 8015798:	2d00      	cmp	r5, #0
 801579a:	dade      	bge.n	801575a <_malloc_r+0x12>
 801579c:	230c      	movs	r3, #12
 801579e:	6033      	str	r3, [r6, #0]
 80157a0:	2000      	movs	r0, #0
 80157a2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80157a4:	6823      	ldr	r3, [r4, #0]
 80157a6:	1b5b      	subs	r3, r3, r5
 80157a8:	d419      	bmi.n	80157de <_malloc_r+0x96>
 80157aa:	2b0b      	cmp	r3, #11
 80157ac:	d903      	bls.n	80157b6 <_malloc_r+0x6e>
 80157ae:	6023      	str	r3, [r4, #0]
 80157b0:	18e4      	adds	r4, r4, r3
 80157b2:	6025      	str	r5, [r4, #0]
 80157b4:	e003      	b.n	80157be <_malloc_r+0x76>
 80157b6:	6863      	ldr	r3, [r4, #4]
 80157b8:	42a2      	cmp	r2, r4
 80157ba:	d10e      	bne.n	80157da <_malloc_r+0x92>
 80157bc:	600b      	str	r3, [r1, #0]
 80157be:	0030      	movs	r0, r6
 80157c0:	f000 f860 	bl	8015884 <__malloc_unlock>
 80157c4:	0020      	movs	r0, r4
 80157c6:	2207      	movs	r2, #7
 80157c8:	300b      	adds	r0, #11
 80157ca:	1d23      	adds	r3, r4, #4
 80157cc:	4390      	bics	r0, r2
 80157ce:	1ac2      	subs	r2, r0, r3
 80157d0:	4298      	cmp	r0, r3
 80157d2:	d0e6      	beq.n	80157a2 <_malloc_r+0x5a>
 80157d4:	1a1b      	subs	r3, r3, r0
 80157d6:	50a3      	str	r3, [r4, r2]
 80157d8:	e7e3      	b.n	80157a2 <_malloc_r+0x5a>
 80157da:	6053      	str	r3, [r2, #4]
 80157dc:	e7ef      	b.n	80157be <_malloc_r+0x76>
 80157de:	0022      	movs	r2, r4
 80157e0:	6864      	ldr	r4, [r4, #4]
 80157e2:	e7c2      	b.n	801576a <_malloc_r+0x22>
 80157e4:	2303      	movs	r3, #3
 80157e6:	1cc4      	adds	r4, r0, #3
 80157e8:	439c      	bics	r4, r3
 80157ea:	42a0      	cmp	r0, r4
 80157ec:	d0e1      	beq.n	80157b2 <_malloc_r+0x6a>
 80157ee:	1a21      	subs	r1, r4, r0
 80157f0:	0030      	movs	r0, r6
 80157f2:	f000 f82d 	bl	8015850 <_sbrk_r>
 80157f6:	1c43      	adds	r3, r0, #1
 80157f8:	d1db      	bne.n	80157b2 <_malloc_r+0x6a>
 80157fa:	e7c7      	b.n	801578c <_malloc_r+0x44>
 80157fc:	20001534 	.word	0x20001534
 8015800:	20001538 	.word	0x20001538

08015804 <_realloc_r>:
 8015804:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8015806:	0007      	movs	r7, r0
 8015808:	000d      	movs	r5, r1
 801580a:	0016      	movs	r6, r2
 801580c:	2900      	cmp	r1, #0
 801580e:	d105      	bne.n	801581c <_realloc_r+0x18>
 8015810:	0011      	movs	r1, r2
 8015812:	f7ff ff99 	bl	8015748 <_malloc_r>
 8015816:	0004      	movs	r4, r0
 8015818:	0020      	movs	r0, r4
 801581a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 801581c:	2a00      	cmp	r2, #0
 801581e:	d103      	bne.n	8015828 <_realloc_r+0x24>
 8015820:	f7ff ff48 	bl	80156b4 <_free_r>
 8015824:	0034      	movs	r4, r6
 8015826:	e7f7      	b.n	8015818 <_realloc_r+0x14>
 8015828:	f000 f834 	bl	8015894 <_malloc_usable_size_r>
 801582c:	002c      	movs	r4, r5
 801582e:	42b0      	cmp	r0, r6
 8015830:	d2f2      	bcs.n	8015818 <_realloc_r+0x14>
 8015832:	0031      	movs	r1, r6
 8015834:	0038      	movs	r0, r7
 8015836:	f7ff ff87 	bl	8015748 <_malloc_r>
 801583a:	1e04      	subs	r4, r0, #0
 801583c:	d0ec      	beq.n	8015818 <_realloc_r+0x14>
 801583e:	0029      	movs	r1, r5
 8015840:	0032      	movs	r2, r6
 8015842:	f7ff fbdd 	bl	8015000 <memcpy>
 8015846:	0029      	movs	r1, r5
 8015848:	0038      	movs	r0, r7
 801584a:	f7ff ff33 	bl	80156b4 <_free_r>
 801584e:	e7e3      	b.n	8015818 <_realloc_r+0x14>

08015850 <_sbrk_r>:
 8015850:	2300      	movs	r3, #0
 8015852:	b570      	push	{r4, r5, r6, lr}
 8015854:	4d06      	ldr	r5, [pc, #24]	; (8015870 <_sbrk_r+0x20>)
 8015856:	0004      	movs	r4, r0
 8015858:	0008      	movs	r0, r1
 801585a:	602b      	str	r3, [r5, #0]
 801585c:	f7f5 fbce 	bl	800affc <_sbrk>
 8015860:	1c43      	adds	r3, r0, #1
 8015862:	d103      	bne.n	801586c <_sbrk_r+0x1c>
 8015864:	682b      	ldr	r3, [r5, #0]
 8015866:	2b00      	cmp	r3, #0
 8015868:	d000      	beq.n	801586c <_sbrk_r+0x1c>
 801586a:	6023      	str	r3, [r4, #0]
 801586c:	bd70      	pop	{r4, r5, r6, pc}
 801586e:	46c0      	nop			; (mov r8, r8)
 8015870:	2000376c 	.word	0x2000376c

08015874 <__malloc_lock>:
 8015874:	b510      	push	{r4, lr}
 8015876:	4802      	ldr	r0, [pc, #8]	; (8015880 <__malloc_lock+0xc>)
 8015878:	f000 f814 	bl	80158a4 <__retarget_lock_acquire_recursive>
 801587c:	bd10      	pop	{r4, pc}
 801587e:	46c0      	nop			; (mov r8, r8)
 8015880:	20003774 	.word	0x20003774

08015884 <__malloc_unlock>:
 8015884:	b510      	push	{r4, lr}
 8015886:	4802      	ldr	r0, [pc, #8]	; (8015890 <__malloc_unlock+0xc>)
 8015888:	f000 f80d 	bl	80158a6 <__retarget_lock_release_recursive>
 801588c:	bd10      	pop	{r4, pc}
 801588e:	46c0      	nop			; (mov r8, r8)
 8015890:	20003774 	.word	0x20003774

08015894 <_malloc_usable_size_r>:
 8015894:	1f0b      	subs	r3, r1, #4
 8015896:	681b      	ldr	r3, [r3, #0]
 8015898:	1f18      	subs	r0, r3, #4
 801589a:	2b00      	cmp	r3, #0
 801589c:	da01      	bge.n	80158a2 <_malloc_usable_size_r+0xe>
 801589e:	580b      	ldr	r3, [r1, r0]
 80158a0:	18c0      	adds	r0, r0, r3
 80158a2:	4770      	bx	lr

080158a4 <__retarget_lock_acquire_recursive>:
 80158a4:	4770      	bx	lr

080158a6 <__retarget_lock_release_recursive>:
 80158a6:	4770      	bx	lr

080158a8 <_init>:
 80158a8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80158aa:	46c0      	nop			; (mov r8, r8)
 80158ac:	bcf8      	pop	{r3, r4, r5, r6, r7}
 80158ae:	bc08      	pop	{r3}
 80158b0:	469e      	mov	lr, r3
 80158b2:	4770      	bx	lr

080158b4 <_fini>:
 80158b4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80158b6:	46c0      	nop			; (mov r8, r8)
 80158b8:	bcf8      	pop	{r3, r4, r5, r6, r7}
 80158ba:	bc08      	pop	{r3}
 80158bc:	469e      	mov	lr, r3
 80158be:	4770      	bx	lr
